(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('dcmjs')) :
  typeof define === 'function' && define.amd ? define(['exports', 'dcmjs'], factory) :
  (factory((global.DICOMMicroscopyViewer = {}),global.dcmjs));
}(this, (function (exports,dcmjs) { 'use strict';

  dcmjs = dcmjs && dcmjs.hasOwnProperty('default') ? dcmjs['default'] : dcmjs;

  const PROJECT_NAME = 'dicommicroscopyviewer';

  /**
   *  Enumerates custom events for dicom-microscopy-viewer. Events are captured,
   *  normalized, and re-triggered with a `dicommicroscopyviewer` prefix.
   *  This allows handling of events consistently across different browsers.
   *
   *  @enum {String}
   *  @memberof dicom-microscopy-viewer
   *  @readonly
   */
  const EVENTS = {
    ROI_ADDED: `${PROJECT_NAME}_roi_added`,
    ROI_REMOVED: `${PROJECT_NAME}_roi_removed`,
    ROI_DRAWN: `${PROJECT_NAME}_roi_drawn`,
    ROI_SELECTED: `${PROJECT_NAME}_roi_selected`,
    ROI_MODIFIED: `${PROJECT_NAME}_roi_modified`,
    MOVE_STARTED: `${PROJECT_NAME}_move_started`,
    MOVE_ENDED: `${PROJECT_NAME}_move_ended`,
  };

  /** Maps DICOM Attribute Tag to Keyword.
   *
   * @constant {Object}
   * @private
   */
  const tagToKeyword = {
    '00000000': 'CommandGroupLength',
    '00000001': 'CommandLengthToEnd',
    '00000002': 'AffectedSOPClassUID',
    '00000003': 'RequestedSOPClassUID',
    '00000010': 'CommandRecognitionCode',
    '00000100': 'CommandField',
    '00000110': 'MessageID',
    '00000120': 'MessageIDBeingRespondedTo',
    '00000200': 'Initiator',
    '00000300': 'Receiver',
    '00000400': 'FindLocation',
    '00000600': 'MoveDestination',
    '00000700': 'Priority',
    '00000800': 'CommandDataSetType',
    '00000850': 'NumberOfMatches',
    '00000860': 'ResponseSequenceNumber',
    '00000900': 'Status',
    '00000901': 'OffendingElement',
    '00000902': 'ErrorComment',
    '00000903': 'ErrorID',
    '00001000': 'AffectedSOPInstanceUID',
    '00001001': 'RequestedSOPInstanceUID',
    '00001002': 'EventTypeID',
    '00001005': 'AttributeIdentifierList',
    '00001008': 'ActionTypeID',
    '00001020': 'NumberOfRemainingSuboperations',
    '00001021': 'NumberOfCompletedSuboperations',
    '00001022': 'NumberOfFailedSuboperations',
    '00001023': 'NumberOfWarningSuboperations',
    '00001030': 'MoveOriginatorApplicationEntityTitle',
    '00001031': 'MoveOriginatorMessageID',
    '00004000': 'DialogReceiver',
    '00004010': 'TerminalType',
    '00005010': 'MessageSetID',
    '00005020': 'EndMessageID',
    '00005110': 'DisplayFormat',
    '00005120': 'PagePositionID',
    '00005130': 'TextFormatID',
    '00005140': 'NormalReverse',
    '00005150': 'AddGrayScale',
    '00005160': 'Borders',
    '00005170': 'Copies',
    '00005180': 'CommandMagnificationType',
    '00005190': 'Erase',
    '000051A0': 'Print',
    '000051B0': 'Overlays',
    '00020000': 'FileMetaInformationGroupLength',
    '00020001': 'FileMetaInformationVersion',
    '00020002': 'MediaStorageSOPClassUID',
    '00020003': 'MediaStorageSOPInstanceUID',
    '00020010': 'TransferSyntaxUID',
    '00020012': 'ImplementationClassUID',
    '00020013': 'ImplementationVersionName',
    '00020016': 'SourceApplicationEntityTitle',
    '00020017': 'SendingApplicationEntityTitle',
    '00020018': 'ReceivingApplicationEntityTitle',
    '00020100': 'PrivateInformationCreatorUID',
    '00020102': 'PrivateInformation',
    '00041130': 'FileSetID',
    '00041141': 'FileSetDescriptorFileID',
    '00041142': 'SpecificCharacterSetOfFileSetDescriptorFile',
    '00041200': 'OffsetOfTheFirstDirectoryRecordOfTheRootDirectoryEntity',
    '00041202': 'OffsetOfTheLastDirectoryRecordOfTheRootDirectoryEntity',
    '00041212': 'FileSetConsistencyFlag',
    '00041220': 'DirectoryRecordSequence',
    '00041400': 'OffsetOfTheNextDirectoryRecord',
    '00041410': 'RecordInUseFlag',
    '00041420': 'OffsetOfReferencedLowerLevelDirectoryEntity',
    '00041430': 'DirectoryRecordType',
    '00041432': 'PrivateRecordUID',
    '00041500': 'ReferencedFileID',
    '00041504': 'MRDRDirectoryRecordOffset',
    '00041510': 'ReferencedSOPClassUIDInFile',
    '00041511': 'ReferencedSOPInstanceUIDInFile',
    '00041512': 'ReferencedTransferSyntaxUIDInFile',
    '0004151A': 'ReferencedRelatedGeneralSOPClassUIDInFile',
    '00041600': 'NumberOfReferences',
    '00080001': 'LengthToEnd',
    '00080005': 'SpecificCharacterSet',
    '00080006': 'LanguageCodeSequence',
    '00080008': 'ImageType',
    '00080010': 'RecognitionCode',
    '00080012': 'InstanceCreationDate',
    '00080013': 'InstanceCreationTime',
    '00080014': 'InstanceCreatorUID',
    '00080015': 'InstanceCoercionDateTime',
    '00080016': 'SOPClassUID',
    '00080018': 'SOPInstanceUID',
    '0008001A': 'RelatedGeneralSOPClassUID',
    '0008001B': 'OriginalSpecializedSOPClassUID',
    '00080020': 'StudyDate',
    '00080021': 'SeriesDate',
    '00080022': 'AcquisitionDate',
    '00080023': 'ContentDate',
    '00080024': 'OverlayDate',
    '00080025': 'CurveDate',
    '0008002A': 'AcquisitionDateTime',
    '00080030': 'StudyTime',
    '00080031': 'SeriesTime',
    '00080032': 'AcquisitionTime',
    '00080033': 'ContentTime',
    '00080034': 'OverlayTime',
    '00080035': 'CurveTime',
    '00080040': 'DataSetType',
    '00080041': 'DataSetSubtype',
    '00080042': 'NuclearMedicineSeriesType',
    '00080050': 'AccessionNumber',
    '00080051': 'IssuerOfAccessionNumberSequence',
    '00080052': 'QueryRetrieveLevel',
    '00080053': 'QueryRetrieveView',
    '00080054': 'RetrieveAETitle',
    '00080055': 'StationAETitle',
    '00080056': 'InstanceAvailability',
    '00080058': 'FailedSOPInstanceUIDList',
    '00080060': 'Modality',
    '00080061': 'ModalitiesInStudy',
    '00080062': 'SOPClassesInStudy',
    '00080063': 'AnatomicRegionsInStudyCodeSequence',
    '00080064': 'ConversionType',
    '00080068': 'PresentationIntentType',
    '00080070': 'Manufacturer',
    '00080080': 'InstitutionName',
    '00080081': 'InstitutionAddress',
    '00080082': 'InstitutionCodeSequence',
    '00080090': 'ReferringPhysicianName',
    '00080092': 'ReferringPhysicianAddress',
    '00080094': 'ReferringPhysicianTelephoneNumbers',
    '00080096': 'ReferringPhysicianIdentificationSequence',
    '0008009C': 'ConsultingPhysicianName',
    '0008009D': 'ConsultingPhysicianIdentificationSequence',
    '00080100': 'CodeValue',
    '00080101': 'ExtendedCodeValue',
    '00080102': 'CodingSchemeDesignator',
    '00080103': 'CodingSchemeVersion',
    '00080104': 'CodeMeaning',
    '00080105': 'MappingResource',
    '00080106': 'ContextGroupVersion',
    '00080107': 'ContextGroupLocalVersion',
    '00080108': 'ExtendedCodeMeaning',
    '00080109': 'CodingSchemeResourcesSequence',
    '0008010A': 'CodingSchemeURLType',
    '0008010B': 'ContextGroupExtensionFlag',
    '0008010C': 'CodingSchemeUID',
    '0008010D': 'ContextGroupExtensionCreatorUID',
    '0008010E': 'CodingSchemeURL',
    '0008010F': 'ContextIdentifier',
    '00080110': 'CodingSchemeIdentificationSequence',
    '00080112': 'CodingSchemeRegistry',
    '00080114': 'CodingSchemeExternalID',
    '00080115': 'CodingSchemeName',
    '00080116': 'CodingSchemeResponsibleOrganization',
    '00080117': 'ContextUID',
    '00080118': 'MappingResourceUID',
    '00080119': 'LongCodeValue',
    '00080120': 'URNCodeValue',
    '00080121': 'EquivalentCodeSequence',
    '00080122': 'MappingResourceName',
    '00080123': 'ContextGroupIdentificationSequence',
    '00080124': 'MappingResourceIdentificationSequence',
    '00080201': 'TimezoneOffsetFromUTC',
    '00080220': 'ResponsibleGroupCodeSequence',
    '00080221': 'EquipmentModality',
    '00080222': 'ManufacturerRelatedModelGroup',
    '00080300': 'PrivateDataElementCharacteristicsSequence',
    '00080301': 'PrivateGroupReference',
    '00080302': 'PrivateCreatorReference',
    '00080303': 'BlockIdentifyingInformationStatus',
    '00080304': 'NonidentifyingPrivateElements',
    '00080305': 'DeidentificationActionSequence',
    '00080306': 'IdentifyingPrivateElements',
    '00080307': 'DeidentificationAction',
    '00080308': 'PrivateDataElement',
    '00080309': 'PrivateDataElementValueMultiplicity',
    '0008030A': 'PrivateDataElementValueRepresentation',
    '0008030B': 'PrivateDataElementNumberOfItems',
    '0008030C': 'PrivateDataElementName',
    '0008030D': 'PrivateDataElementKeyword',
    '0008030E': 'PrivateDataElementDescription',
    '0008030F': 'PrivateDataElementEncoding',
    '00080310': 'PrivateDataElementDefinitionSequence',
    '00081000': 'NetworkID',
    '00081010': 'StationName',
    '00081030': 'StudyDescription',
    '00081032': 'ProcedureCodeSequence',
    '0008103E': 'SeriesDescription',
    '0008103F': 'SeriesDescriptionCodeSequence',
    '00081040': 'InstitutionalDepartmentName',
    '00081048': 'PhysiciansOfRecord',
    '00081049': 'PhysiciansOfRecordIdentificationSequence',
    '00081050': 'PerformingPhysicianName',
    '00081052': 'PerformingPhysicianIdentificationSequence',
    '00081060': 'NameOfPhysiciansReadingStudy',
    '00081062': 'PhysiciansReadingStudyIdentificationSequence',
    '00081070': 'OperatorsName',
    '00081072': 'OperatorIdentificationSequence',
    '00081080': 'AdmittingDiagnosesDescription',
    '00081084': 'AdmittingDiagnosesCodeSequence',
    '00081090': 'ManufacturerModelName',
    '00081100': 'ReferencedResultsSequence',
    '00081110': 'ReferencedStudySequence',
    '00081111': 'ReferencedPerformedProcedureStepSequence',
    '00081115': 'ReferencedSeriesSequence',
    '00081120': 'ReferencedPatientSequence',
    '00081125': 'ReferencedVisitSequence',
    '00081130': 'ReferencedOverlaySequence',
    '00081134': 'ReferencedStereometricInstanceSequence',
    '0008113A': 'ReferencedWaveformSequence',
    '00081140': 'ReferencedImageSequence',
    '00081145': 'ReferencedCurveSequence',
    '0008114A': 'ReferencedInstanceSequence',
    '0008114B': 'ReferencedRealWorldValueMappingInstanceSequence',
    '00081150': 'ReferencedSOPClassUID',
    '00081155': 'ReferencedSOPInstanceUID',
    '00081156': 'DefinitionSourceSequence',
    '0008115A': 'SOPClassesSupported',
    '00081160': 'ReferencedFrameNumber',
    '00081161': 'SimpleFrameList',
    '00081162': 'CalculatedFrameList',
    '00081163': 'TimeRange',
    '00081164': 'FrameExtractionSequence',
    '00081167': 'MultiFrameSourceSOPInstanceUID',
    '00081190': 'RetrieveURL',
    '00081195': 'TransactionUID',
    '00081196': 'WarningReason',
    '00081197': 'FailureReason',
    '00081198': 'FailedSOPSequence',
    '00081199': 'ReferencedSOPSequence',
    '0008119A': 'OtherFailuresSequence',
    '00081200': 'StudiesContainingOtherReferencedInstancesSequence',
    '00081250': 'RelatedSeriesSequence',
    '00082110': 'LossyImageCompressionRetired',
    '00082111': 'DerivationDescription',
    '00082112': 'SourceImageSequence',
    '00082120': 'StageName',
    '00082122': 'StageNumber',
    '00082124': 'NumberOfStages',
    '00082127': 'ViewName',
    '00082128': 'ViewNumber',
    '00082129': 'NumberOfEventTimers',
    '0008212A': 'NumberOfViewsInStage',
    '00082130': 'EventElapsedTimes',
    '00082132': 'EventTimerNames',
    '00082133': 'EventTimerSequence',
    '00082134': 'EventTimeOffset',
    '00082135': 'EventCodeSequence',
    '00082142': 'StartTrim',
    '00082143': 'StopTrim',
    '00082144': 'RecommendedDisplayFrameRate',
    '00082200': 'TransducerPosition',
    '00082204': 'TransducerOrientation',
    '00082208': 'AnatomicStructure',
    '00082218': 'AnatomicRegionSequence',
    '00082220': 'AnatomicRegionModifierSequence',
    '00082228': 'PrimaryAnatomicStructureSequence',
    '00082229': 'AnatomicStructureSpaceOrRegionSequence',
    '00082230': 'PrimaryAnatomicStructureModifierSequence',
    '00082240': 'TransducerPositionSequence',
    '00082242': 'TransducerPositionModifierSequence',
    '00082244': 'TransducerOrientationSequence',
    '00082246': 'TransducerOrientationModifierSequence',
    '00082251': 'AnatomicStructureSpaceOrRegionCodeSequenceTrial',
    '00082253': 'AnatomicPortalOfEntranceCodeSequenceTrial',
    '00082255': 'AnatomicApproachDirectionCodeSequenceTrial',
    '00082256': 'AnatomicPerspectiveDescriptionTrial',
    '00082257': 'AnatomicPerspectiveCodeSequenceTrial',
    '00082258': 'AnatomicLocationOfExaminingInstrumentDescriptionTrial',
    '00082259': 'AnatomicLocationOfExaminingInstrumentCodeSequenceTrial',
    '0008225A': 'AnatomicStructureSpaceOrRegionModifierCodeSequenceTrial',
    '0008225C': 'OnAxisBackgroundAnatomicStructureCodeSequenceTrial',
    '00083001': 'AlternateRepresentationSequence',
    '00083010': 'IrradiationEventUID',
    '00083011': 'SourceIrradiationEventSequence',
    '00083012': 'RadiopharmaceuticalAdministrationEventUID',
    '00084000': 'IdentifyingComments',
    '00089007': 'FrameType',
    '00089092': 'ReferencedImageEvidenceSequence',
    '00089121': 'ReferencedRawDataSequence',
    '00089123': 'CreatorVersionUID',
    '00089124': 'DerivationImageSequence',
    '00089154': 'SourceImageEvidenceSequence',
    '00089205': 'PixelPresentation',
    '00089206': 'VolumetricProperties',
    '00089207': 'VolumeBasedCalculationTechnique',
    '00089208': 'ComplexImageComponent',
    '00089209': 'AcquisitionContrast',
    '00089215': 'DerivationCodeSequence',
    '00089237': 'ReferencedPresentationStateSequence',
    '00089410': 'ReferencedOtherPlaneSequence',
    '00089458': 'FrameDisplaySequence',
    '00089459': 'RecommendedDisplayFrameRateInFloat',
    '00089460': 'SkipFrameRangeFlag',
    '00100010': 'PatientName',
    '00100020': 'PatientID',
    '00100021': 'IssuerOfPatientID',
    '00100022': 'TypeOfPatientID',
    '00100024': 'IssuerOfPatientIDQualifiersSequence',
    '00100026': 'SourcePatientGroupIdentificationSequence',
    '00100027': 'GroupOfPatientsIdentificationSequence',
    '00100028': 'SubjectRelativePositionInImage',
    '00100030': 'PatientBirthDate',
    '00100032': 'PatientBirthTime',
    '00100033': 'PatientBirthDateInAlternativeCalendar',
    '00100034': 'PatientDeathDateInAlternativeCalendar',
    '00100035': 'PatientAlternativeCalendar',
    '00100040': 'PatientSex',
    '00100050': 'PatientInsurancePlanCodeSequence',
    '00100101': 'PatientPrimaryLanguageCodeSequence',
    '00100102': 'PatientPrimaryLanguageModifierCodeSequence',
    '00100200': 'QualityControlSubject',
    '00100201': 'QualityControlSubjectTypeCodeSequence',
    '00100212': 'StrainDescription',
    '00100213': 'StrainNomenclature',
    '00100214': 'StrainStockNumber',
    '00100215': 'StrainSourceRegistryCodeSequence',
    '00100216': 'StrainStockSequence',
    '00100217': 'StrainSource',
    '00100218': 'StrainAdditionalInformation',
    '00100219': 'StrainCodeSequence',
    '00100221': 'GeneticModificationsSequence',
    '00100222': 'GeneticModificationsDescription',
    '00100223': 'GeneticModificationsNomenclature',
    '00100229': 'GeneticModificationsCodeSequence',
    '00101000': 'OtherPatientIDs',
    '00101001': 'OtherPatientNames',
    '00101002': 'OtherPatientIDsSequence',
    '00101005': 'PatientBirthName',
    '00101010': 'PatientAge',
    '00101020': 'PatientSize',
    '00101021': 'PatientSizeCodeSequence',
    '00101022': 'PatientBodyMassIndex',
    '00101023': 'MeasuredAPDimension',
    '00101024': 'MeasuredLateralDimension',
    '00101030': 'PatientWeight',
    '00101040': 'PatientAddress',
    '00101050': 'InsurancePlanIdentification',
    '00101060': 'PatientMotherBirthName',
    '00101080': 'MilitaryRank',
    '00101081': 'BranchOfService',
    '00101090': 'MedicalRecordLocator',
    '00101100': 'ReferencedPatientPhotoSequence',
    '00102000': 'MedicalAlerts',
    '00102110': 'Allergies',
    '00102150': 'CountryOfResidence',
    '00102152': 'RegionOfResidence',
    '00102154': 'PatientTelephoneNumbers',
    '00102155': 'PatientTelecomInformation',
    '00102160': 'EthnicGroup',
    '00102180': 'Occupation',
    '001021A0': 'SmokingStatus',
    '001021B0': 'AdditionalPatientHistory',
    '001021C0': 'PregnancyStatus',
    '001021D0': 'LastMenstrualDate',
    '001021F0': 'PatientReligiousPreference',
    '00102201': 'PatientSpeciesDescription',
    '00102202': 'PatientSpeciesCodeSequence',
    '00102203': 'PatientSexNeutered',
    '00102210': 'AnatomicalOrientationType',
    '00102292': 'PatientBreedDescription',
    '00102293': 'PatientBreedCodeSequence',
    '00102294': 'BreedRegistrationSequence',
    '00102295': 'BreedRegistrationNumber',
    '00102296': 'BreedRegistryCodeSequence',
    '00102297': 'ResponsiblePerson',
    '00102298': 'ResponsiblePersonRole',
    '00102299': 'ResponsibleOrganization',
    '00104000': 'PatientComments',
    '00109431': 'ExaminedBodyThickness',
    '00120010': 'ClinicalTrialSponsorName',
    '00120020': 'ClinicalTrialProtocolID',
    '00120021': 'ClinicalTrialProtocolName',
    '00120030': 'ClinicalTrialSiteID',
    '00120031': 'ClinicalTrialSiteName',
    '00120040': 'ClinicalTrialSubjectID',
    '00120042': 'ClinicalTrialSubjectReadingID',
    '00120050': 'ClinicalTrialTimePointID',
    '00120051': 'ClinicalTrialTimePointDescription',
    '00120052': 'LongitudinalTemporalOffsetFromEvent',
    '00120053': 'LongitudinalTemporalEventType',
    '00120060': 'ClinicalTrialCoordinatingCenterName',
    '00120062': 'PatientIdentityRemoved',
    '00120063': 'DeidentificationMethod',
    '00120064': 'DeidentificationMethodCodeSequence',
    '00120071': 'ClinicalTrialSeriesID',
    '00120072': 'ClinicalTrialSeriesDescription',
    '00120081': 'ClinicalTrialProtocolEthicsCommitteeName',
    '00120082': 'ClinicalTrialProtocolEthicsCommitteeApprovalNumber',
    '00120083': 'ConsentForClinicalTrialUseSequence',
    '00120084': 'DistributionType',
    '00120085': 'ConsentForDistributionFlag',
    '00120086': 'EthicsCommitteeApprovalEffectivenessStartDate',
    '00120087': 'EthicsCommitteeApprovalEffectivenessEndDate',
    '00140023': 'CADFileFormat',
    '00140024': 'ComponentReferenceSystem',
    '00140025': 'ComponentManufacturingProcedure',
    '00140028': 'ComponentManufacturer',
    '00140030': 'MaterialThickness',
    '00140032': 'MaterialPipeDiameter',
    '00140034': 'MaterialIsolationDiameter',
    '00140042': 'MaterialGrade',
    '00140044': 'MaterialPropertiesDescription',
    '00140045': 'MaterialPropertiesFileFormatRetired',
    '00140046': 'MaterialNotes',
    '00140050': 'ComponentShape',
    '00140052': 'CurvatureType',
    '00140054': 'OuterDiameter',
    '00140056': 'InnerDiameter',
    '00140100': 'ComponentWelderIDs',
    '00140101': 'SecondaryApprovalStatus',
    '00140102': 'SecondaryReviewDate',
    '00140103': 'SecondaryReviewTime',
    '00140104': 'SecondaryReviewerName',
    '00140105': 'RepairID',
    '00140106': 'MultipleComponentApprovalSequence',
    '00140107': 'OtherApprovalStatus',
    '00140108': 'OtherSecondaryApprovalStatus',
    '00141010': 'ActualEnvironmentalConditions',
    '00141020': 'ExpiryDate',
    '00141040': 'EnvironmentalConditions',
    '00142002': 'EvaluatorSequence',
    '00142004': 'EvaluatorNumber',
    '00142006': 'EvaluatorName',
    '00142008': 'EvaluationAttempt',
    '00142012': 'IndicationSequence',
    '00142014': 'IndicationNumber',
    '00142016': 'IndicationLabel',
    '00142018': 'IndicationDescription',
    '0014201A': 'IndicationType',
    '0014201C': 'IndicationDisposition',
    '0014201E': 'IndicationROISequence',
    '00142030': 'IndicationPhysicalPropertySequence',
    '00142032': 'PropertyLabel',
    '00142202': 'CoordinateSystemNumberOfAxes',
    '00142204': 'CoordinateSystemAxesSequence',
    '00142206': 'CoordinateSystemAxisDescription',
    '00142208': 'CoordinateSystemDataSetMapping',
    '0014220A': 'CoordinateSystemAxisNumber',
    '0014220C': 'CoordinateSystemAxisType',
    '0014220E': 'CoordinateSystemAxisUnits',
    '00142210': 'CoordinateSystemAxisValues',
    '00142220': 'CoordinateSystemTransformSequence',
    '00142222': 'TransformDescription',
    '00142224': 'TransformNumberOfAxes',
    '00142226': 'TransformOrderOfAxes',
    '00142228': 'TransformedAxisUnits',
    '0014222A': 'CoordinateSystemTransformRotationAndScaleMatrix',
    '0014222C': 'CoordinateSystemTransformTranslationMatrix',
    '00143011': 'InternalDetectorFrameTime',
    '00143012': 'NumberOfFramesIntegrated',
    '00143020': 'DetectorTemperatureSequence',
    '00143022': 'SensorName',
    '00143024': 'HorizontalOffsetOfSensor',
    '00143026': 'VerticalOffsetOfSensor',
    '00143028': 'SensorTemperature',
    '00143040': 'DarkCurrentSequence',
    '00143050': 'DarkCurrentCounts',
    '00143060': 'GainCorrectionReferenceSequence',
    '00143070': 'AirCounts',
    '00143071': 'KVUsedInGainCalibration',
    '00143072': 'MAUsedInGainCalibration',
    '00143073': 'NumberOfFramesUsedForIntegration',
    '00143074': 'FilterMaterialUsedInGainCalibration',
    '00143075': 'FilterThicknessUsedInGainCalibration',
    '00143076': 'DateOfGainCalibration',
    '00143077': 'TimeOfGainCalibration',
    '00143080': 'BadPixelImage',
    '00143099': 'CalibrationNotes',
    '00144002': 'PulserEquipmentSequence',
    '00144004': 'PulserType',
    '00144006': 'PulserNotes',
    '00144008': 'ReceiverEquipmentSequence',
    '0014400A': 'AmplifierType',
    '0014400C': 'ReceiverNotes',
    '0014400E': 'PreAmplifierEquipmentSequence',
    '0014400F': 'PreAmplifierNotes',
    '00144010': 'TransmitTransducerSequence',
    '00144011': 'ReceiveTransducerSequence',
    '00144012': 'NumberOfElements',
    '00144013': 'ElementShape',
    '00144014': 'ElementDimensionA',
    '00144015': 'ElementDimensionB',
    '00144016': 'ElementPitchA',
    '00144017': 'MeasuredBeamDimensionA',
    '00144018': 'MeasuredBeamDimensionB',
    '00144019': 'LocationOfMeasuredBeamDiameter',
    '0014401A': 'NominalFrequency',
    '0014401B': 'MeasuredCenterFrequency',
    '0014401C': 'MeasuredBandwidth',
    '0014401D': 'ElementPitchB',
    '00144020': 'PulserSettingsSequence',
    '00144022': 'PulseWidth',
    '00144024': 'ExcitationFrequency',
    '00144026': 'ModulationType',
    '00144028': 'Damping',
    '00144030': 'ReceiverSettingsSequence',
    '00144031': 'AcquiredSoundpathLength',
    '00144032': 'AcquisitionCompressionType',
    '00144033': 'AcquisitionSampleSize',
    '00144034': 'RectifierSmoothing',
    '00144035': 'DACSequence',
    '00144036': 'DACType',
    '00144038': 'DACGainPoints',
    '0014403A': 'DACTimePoints',
    '0014403C': 'DACAmplitude',
    '00144040': 'PreAmplifierSettingsSequence',
    '00144050': 'TransmitTransducerSettingsSequence',
    '00144051': 'ReceiveTransducerSettingsSequence',
    '00144052': 'IncidentAngle',
    '00144054': 'CouplingTechnique',
    '00144056': 'CouplingMedium',
    '00144057': 'CouplingVelocity',
    '00144058': 'ProbeCenterLocationX',
    '00144059': 'ProbeCenterLocationZ',
    '0014405A': 'SoundPathLength',
    '0014405C': 'DelayLawIdentifier',
    '00144060': 'GateSettingsSequence',
    '00144062': 'GateThreshold',
    '00144064': 'VelocityOfSound',
    '00144070': 'CalibrationSettingsSequence',
    '00144072': 'CalibrationProcedure',
    '00144074': 'ProcedureVersion',
    '00144076': 'ProcedureCreationDate',
    '00144078': 'ProcedureExpirationDate',
    '0014407A': 'ProcedureLastModifiedDate',
    '0014407C': 'CalibrationTime',
    '0014407E': 'CalibrationDate',
    '00144080': 'ProbeDriveEquipmentSequence',
    '00144081': 'DriveType',
    '00144082': 'ProbeDriveNotes',
    '00144083': 'DriveProbeSequence',
    '00144084': 'ProbeInductance',
    '00144085': 'ProbeResistance',
    '00144086': 'ReceiveProbeSequence',
    '00144087': 'ProbeDriveSettingsSequence',
    '00144088': 'BridgeResistors',
    '00144089': 'ProbeOrientationAngle',
    '0014408B': 'UserSelectedGainY',
    '0014408C': 'UserSelectedPhase',
    '0014408D': 'UserSelectedOffsetX',
    '0014408E': 'UserSelectedOffsetY',
    '00144091': 'ChannelSettingsSequence',
    '00144092': 'ChannelThreshold',
    '0014409A': 'ScannerSettingsSequence',
    '0014409B': 'ScanProcedure',
    '0014409C': 'TranslationRateX',
    '0014409D': 'TranslationRateY',
    '0014409F': 'ChannelOverlap',
    '001440A0': 'ImageQualityIndicatorType',
    '001440A1': 'ImageQualityIndicatorMaterial',
    '001440A2': 'ImageQualityIndicatorSize',
    '00145002': 'LINACEnergy',
    '00145004': 'LINACOutput',
    '00145100': 'ActiveAperture',
    '00145101': 'TotalAperture',
    '00145102': 'ApertureElevation',
    '00145103': 'MainLobeAngle',
    '00145104': 'MainRoofAngle',
    '00145105': 'ConnectorType',
    '00145106': 'WedgeModelNumber',
    '00145107': 'WedgeAngleFloat',
    '00145108': 'WedgeRoofAngle',
    '00145109': ('WedgeElement1Position'),
    '0014510A': 'WedgeMaterialVelocity',
    '0014510B': 'WedgeMaterial',
    '0014510C': 'WedgeOffsetZ',
    '0014510D': 'WedgeOriginOffsetX',
    '0014510E': 'WedgeTimeDelay',
    '0014510F': 'WedgeName',
    '00145110': 'WedgeManufacturerName',
    '00145111': 'WedgeDescription',
    '00145112': 'NominalBeamAngle',
    '00145113': 'WedgeOffsetX',
    '00145114': 'WedgeOffsetY',
    '00145115': 'WedgeTotalLength',
    '00145116': 'WedgeInContactLength',
    '00145117': 'WedgeFrontGap',
    '00145118': 'WedgeTotalHeight',
    '00145119': 'WedgeFrontHeight',
    '0014511A': 'WedgeRearHeight',
    '0014511B': 'WedgeTotalWidth',
    '0014511C': 'WedgeInContactWidth',
    '0014511D': 'WedgeChamferHeight',
    '0014511E': 'WedgeCurve',
    '0014511F': 'RadiusAlongWedge',
    '00180010': 'ContrastBolusAgent',
    '00180012': 'ContrastBolusAgentSequence',
    '00180013': ('ContrastBolusT1Relaxivity'),
    '00180014': 'ContrastBolusAdministrationRouteSequence',
    '00180015': 'BodyPartExamined',
    '00180020': 'ScanningSequence',
    '00180021': 'SequenceVariant',
    '00180022': 'ScanOptions',
    '00180023': 'MRAcquisitionType',
    '00180024': 'SequenceName',
    '00180025': 'AngioFlag',
    '00180026': 'InterventionDrugInformationSequence',
    '00180027': 'InterventionDrugStopTime',
    '00180028': 'InterventionDrugDose',
    '00180029': 'InterventionDrugCodeSequence',
    '0018002A': 'AdditionalDrugSequence',
    '00180030': 'Radionuclide',
    '00180031': 'Radiopharmaceutical',
    '00180032': 'EnergyWindowCenterline',
    '00180033': 'EnergyWindowTotalWidth',
    '00180034': 'InterventionDrugName',
    '00180035': 'InterventionDrugStartTime',
    '00180036': 'InterventionSequence',
    '00180037': 'TherapyType',
    '00180038': 'InterventionStatus',
    '00180039': 'TherapyDescription',
    '0018003A': 'InterventionDescription',
    '00180040': 'CineRate',
    '00180042': 'InitialCineRunState',
    '00180050': 'SliceThickness',
    '00180060': 'KVP',
    '00180061': '',
    '00180070': 'CountsAccumulated',
    '00180071': 'AcquisitionTerminationCondition',
    '00180072': 'EffectiveDuration',
    '00180073': 'AcquisitionStartCondition',
    '00180074': 'AcquisitionStartConditionData',
    '00180075': 'AcquisitionTerminationConditionData',
    '00180080': 'RepetitionTime',
    '00180081': 'EchoTime',
    '00180082': 'InversionTime',
    '00180083': 'NumberOfAverages',
    '00180084': 'ImagingFrequency',
    '00180085': 'ImagedNucleus',
    '00180086': 'EchoNumbers',
    '00180087': 'MagneticFieldStrength',
    '00180088': 'SpacingBetweenSlices',
    '00180089': 'NumberOfPhaseEncodingSteps',
    '00180090': 'DataCollectionDiameter',
    '00180091': 'EchoTrainLength',
    '00180093': 'PercentSampling',
    '00180094': 'PercentPhaseFieldOfView',
    '00180095': 'PixelBandwidth',
    '00181000': 'DeviceSerialNumber',
    '00181002': 'DeviceUID',
    '00181003': 'DeviceID',
    '00181004': 'PlateID',
    '00181005': 'GeneratorID',
    '00181006': 'GridID',
    '00181007': 'CassetteID',
    '00181008': 'GantryID',
    '00181009': 'UniqueDeviceIdentifier',
    '0018100A': 'UDISequence',
    '00181010': 'SecondaryCaptureDeviceID',
    '00181011': 'HardcopyCreationDeviceID',
    '00181012': 'DateOfSecondaryCapture',
    '00181014': 'TimeOfSecondaryCapture',
    '00181016': 'SecondaryCaptureDeviceManufacturer',
    '00181017': 'HardcopyDeviceManufacturer',
    '00181018': 'SecondaryCaptureDeviceManufacturerModelName',
    '00181019': 'SecondaryCaptureDeviceSoftwareVersions',
    '0018101A': 'HardcopyDeviceSoftwareVersion',
    '0018101B': 'HardcopyDeviceManufacturerModelName',
    '00181020': 'SoftwareVersions',
    '00181022': 'VideoImageFormatAcquired',
    '00181023': 'DigitalImageFormatAcquired',
    '00181030': 'ProtocolName',
    '00181040': 'ContrastBolusRoute',
    '00181041': 'ContrastBolusVolume',
    '00181042': 'ContrastBolusStartTime',
    '00181043': 'ContrastBolusStopTime',
    '00181044': 'ContrastBolusTotalDose',
    '00181045': 'SyringeCounts',
    '00181046': 'ContrastFlowRate',
    '00181047': 'ContrastFlowDuration',
    '00181048': 'ContrastBolusIngredient',
    '00181049': 'ContrastBolusIngredientConcentration',
    '00181050': 'SpatialResolution',
    '00181060': 'TriggerTime',
    '00181061': 'TriggerSourceOrType',
    '00181062': 'NominalInterval',
    '00181063': 'FrameTime',
    '00181064': 'CardiacFramingType',
    '00181065': 'FrameTimeVector',
    '00181066': 'FrameDelay',
    '00181067': 'ImageTriggerDelay',
    '00181068': 'MultiplexGroupTimeOffset',
    '00181069': 'TriggerTimeOffset',
    '0018106A': 'SynchronizationTrigger',
    '0018106C': 'SynchronizationChannel',
    '0018106E': 'TriggerSamplePosition',
    '00181070': 'RadiopharmaceuticalRoute',
    '00181071': 'RadiopharmaceuticalVolume',
    '00181072': 'RadiopharmaceuticalStartTime',
    '00181073': 'RadiopharmaceuticalStopTime',
    '00181074': 'RadionuclideTotalDose',
    '00181075': 'RadionuclideHalfLife',
    '00181076': 'RadionuclidePositronFraction',
    '00181077': 'RadiopharmaceuticalSpecificActivity',
    '00181078': 'RadiopharmaceuticalStartDateTime',
    '00181079': 'RadiopharmaceuticalStopDateTime',
    '00181080': 'BeatRejectionFlag',
    '00181081': 'LowRRValue',
    '00181082': 'HighRRValue',
    '00181083': 'IntervalsAcquired',
    '00181084': 'IntervalsRejected',
    '00181085': 'PVCRejection',
    '00181086': 'SkipBeats',
    '00181088': 'HeartRate',
    '00181090': 'CardiacNumberOfImages',
    '00181094': 'TriggerWindow',
    '00181100': 'ReconstructionDiameter',
    '00181110': 'DistanceSourceToDetector',
    '00181111': 'DistanceSourceToPatient',
    '00181114': 'EstimatedRadiographicMagnificationFactor',
    '00181120': 'GantryDetectorTilt',
    '00181121': 'GantryDetectorSlew',
    '00181130': 'TableHeight',
    '00181131': 'TableTraverse',
    '00181134': 'TableMotion',
    '00181135': 'TableVerticalIncrement',
    '00181136': 'TableLateralIncrement',
    '00181137': 'TableLongitudinalIncrement',
    '00181138': 'TableAngle',
    '0018113A': 'TableType',
    '00181140': 'RotationDirection',
    '00181141': 'AngularPosition',
    '00181142': 'RadialPosition',
    '00181143': 'ScanArc',
    '00181144': 'AngularStep',
    '00181145': 'CenterOfRotationOffset',
    '00181146': 'RotationOffset',
    '00181147': 'FieldOfViewShape',
    '00181149': 'FieldOfViewDimensions',
    '00181150': 'ExposureTime',
    '00181151': 'XRayTubeCurrent',
    '00181152': 'Exposure',
    '00181153': 'ExposureInuAs',
    '00181154': 'AveragePulseWidth',
    '00181155': 'RadiationSetting',
    '00181156': 'RectificationType',
    '0018115A': 'RadiationMode',
    '0018115E': 'ImageAndFluoroscopyAreaDoseProduct',
    '00181160': 'FilterType',
    '00181161': 'TypeOfFilters',
    '00181162': 'IntensifierSize',
    '00181164': 'ImagerPixelSpacing',
    '00181166': 'Grid',
    '00181170': 'GeneratorPower',
    '00181180': 'CollimatorGridName',
    '00181181': 'CollimatorType',
    '00181182': 'FocalDistance',
    '00181183': 'XFocusCenter',
    '00181184': 'YFocusCenter',
    '00181190': 'FocalSpots',
    '00181191': 'AnodeTargetMaterial',
    '001811A0': 'BodyPartThickness',
    '001811A2': 'CompressionForce',
    '001811A3': 'CompressionPressure',
    '001811A4': 'PaddleDescription',
    '001811A5': 'CompressionContactArea',
    '00181200': 'DateOfLastCalibration',
    '00181201': 'TimeOfLastCalibration',
    '00181202': 'DateTimeOfLastCalibration',
    '00181210': 'ConvolutionKernel',
    '00181240': 'UpperLowerPixelValues',
    '00181242': 'ActualFrameDuration',
    '00181243': 'CountRate',
    '00181244': 'PreferredPlaybackSequencing',
    '00181250': 'ReceiveCoilName',
    '00181251': 'TransmitCoilName',
    '00181260': 'PlateType',
    '00181261': 'PhosphorType',
    '00181271': 'WaterEquivalentDiameter',
    '00181272': 'WaterEquivalentDiameterCalculationMethodCodeSequence',
    '00181300': 'ScanVelocity',
    '00181301': 'WholeBodyTechnique',
    '00181302': 'ScanLength',
    '00181310': 'AcquisitionMatrix',
    '00181312': 'InPlanePhaseEncodingDirection',
    '00181314': 'FlipAngle',
    '00181315': 'VariableFlipAngleFlag',
    '00181316': 'SAR',
    '00181318': 'dBdt',
    '00181320': ('B1rms'),
    '00181400': 'AcquisitionDeviceProcessingDescription',
    '00181401': 'AcquisitionDeviceProcessingCode',
    '00181402': 'CassetteOrientation',
    '00181403': 'CassetteSize',
    '00181404': 'ExposuresOnPlate',
    '00181405': 'RelativeXRayExposure',
    '00181411': 'ExposureIndex',
    '00181412': 'TargetExposureIndex',
    '00181413': 'DeviationIndex',
    '00181450': 'ColumnAngulation',
    '00181460': 'TomoLayerHeight',
    '00181470': 'TomoAngle',
    '00181480': 'TomoTime',
    '00181490': 'TomoType',
    '00181491': 'TomoClass',
    '00181495': 'NumberOfTomosynthesisSourceImages',
    '00181500': 'PositionerMotion',
    '00181508': 'PositionerType',
    '00181510': 'PositionerPrimaryAngle',
    '00181511': 'PositionerSecondaryAngle',
    '00181520': 'PositionerPrimaryAngleIncrement',
    '00181521': 'PositionerSecondaryAngleIncrement',
    '00181530': 'DetectorPrimaryAngle',
    '00181531': 'DetectorSecondaryAngle',
    '00181600': 'ShutterShape',
    '00181602': 'ShutterLeftVerticalEdge',
    '00181604': 'ShutterRightVerticalEdge',
    '00181606': 'ShutterUpperHorizontalEdge',
    '00181608': 'ShutterLowerHorizontalEdge',
    '00181610': 'CenterOfCircularShutter',
    '00181612': 'RadiusOfCircularShutter',
    '00181620': 'VerticesOfThePolygonalShutter',
    '00181622': 'ShutterPresentationValue',
    '00181623': 'ShutterOverlayGroup',
    '00181624': 'ShutterPresentationColorCIELabValue',
    '00181700': 'CollimatorShape',
    '00181702': 'CollimatorLeftVerticalEdge',
    '00181704': 'CollimatorRightVerticalEdge',
    '00181706': 'CollimatorUpperHorizontalEdge',
    '00181708': 'CollimatorLowerHorizontalEdge',
    '00181710': 'CenterOfCircularCollimator',
    '00181712': 'RadiusOfCircularCollimator',
    '00181720': 'VerticesOfThePolygonalCollimator',
    '00181800': 'AcquisitionTimeSynchronized',
    '00181801': 'TimeSource',
    '00181802': 'TimeDistributionProtocol',
    '00181803': 'NTPSourceAddress',
    '00182001': 'PageNumberVector',
    '00182002': 'FrameLabelVector',
    '00182003': 'FramePrimaryAngleVector',
    '00182004': 'FrameSecondaryAngleVector',
    '00182005': 'SliceLocationVector',
    '00182006': 'DisplayWindowLabelVector',
    '00182010': 'NominalScannedPixelSpacing',
    '00182020': 'DigitizingDeviceTransportDirection',
    '00182030': 'RotationOfScannedFilm',
    '00182041': 'BiopsyTargetSequence',
    '00182042': 'TargetUID',
    '00182043': 'LocalizingCursorPosition',
    '00182044': 'CalculatedTargetPosition',
    '00182045': 'TargetLabel',
    '00182046': 'DisplayedZValue',
    '00183100': 'IVUSAcquisition',
    '00183101': 'IVUSPullbackRate',
    '00183102': 'IVUSGatedRate',
    '00183103': 'IVUSPullbackStartFrameNumber',
    '00183104': 'IVUSPullbackStopFrameNumber',
    '00183105': 'LesionNumber',
    '00184000': 'AcquisitionComments',
    '00185000': 'OutputPower',
    '00185010': 'TransducerData',
    '00185012': 'FocusDepth',
    '00185020': 'ProcessingFunction',
    '00185021': 'PostprocessingFunction',
    '00185022': 'MechanicalIndex',
    '00185024': 'BoneThermalIndex',
    '00185026': 'CranialThermalIndex',
    '00185027': 'SoftTissueThermalIndex',
    '00185028': 'SoftTissueFocusThermalIndex',
    '00185029': 'SoftTissueSurfaceThermalIndex',
    '00185030': 'DynamicRange',
    '00185040': 'TotalGain',
    '00185050': 'DepthOfScanField',
    '00185100': 'PatientPosition',
    '00185101': 'ViewPosition',
    '00185104': 'ProjectionEponymousNameCodeSequence',
    '00185210': 'ImageTransformationMatrix',
    '00185212': 'ImageTranslationVector',
    '00186000': 'Sensitivity',
    '00186011': 'SequenceOfUltrasoundRegions',
    '00186012': 'RegionSpatialFormat',
    '00186014': 'RegionDataType',
    '00186016': 'RegionFlags',
    '00186018': ('RegionLocationMinX0'),
    '0018601A': ('RegionLocationMinY0'),
    '0018601C': ('RegionLocationMaxX1'),
    '0018601E': ('RegionLocationMaxY1'),
    '00186020': ('ReferencePixelX0'),
    '00186022': ('ReferencePixelY0'),
    '00186024': 'PhysicalUnitsXDirection',
    '00186026': 'PhysicalUnitsYDirection',
    '00186028': 'ReferencePixelPhysicalValueX',
    '0018602A': 'ReferencePixelPhysicalValueY',
    '0018602C': 'PhysicalDeltaX',
    '0018602E': 'PhysicalDeltaY',
    '00186030': 'TransducerFrequency',
    '00186031': 'TransducerType',
    '00186032': 'PulseRepetitionFrequency',
    '00186034': 'DopplerCorrectionAngle',
    '00186036': 'SteeringAngle',
    '00186038': 'DopplerSampleVolumeXPositionRetired',
    '00186039': 'DopplerSampleVolumeXPosition',
    '0018603A': 'DopplerSampleVolumeYPositionRetired',
    '0018603B': 'DopplerSampleVolumeYPosition',
    '0018603C': ('TMLinePositionX0Retired'),
    '0018603D': ('TMLinePositionX0'),
    '0018603E': ('TMLinePositionY0Retired'),
    '0018603F': ('TMLinePositionY0'),
    '00186040': ('TMLinePositionX1Retired'),
    '00186041': ('TMLinePositionX1'),
    '00186042': ('TMLinePositionY1Retired'),
    '00186043': ('TMLinePositionY1'),
    '00186044': 'PixelComponentOrganization',
    '00186046': 'PixelComponentMask',
    '00186048': 'PixelComponentRangeStart',
    '0018604A': 'PixelComponentRangeStop',
    '0018604C': 'PixelComponentPhysicalUnits',
    '0018604E': 'PixelComponentDataType',
    '00186050': 'NumberOfTableBreakPoints',
    '00186052': 'TableOfXBreakPoints',
    '00186054': 'TableOfYBreakPoints',
    '00186056': 'NumberOfTableEntries',
    '00186058': 'TableOfPixelValues',
    '0018605A': 'TableOfParameterValues',
    '00186060': 'RWaveTimeVector',
    '00187000': 'DetectorConditionsNominalFlag',
    '00187001': 'DetectorTemperature',
    '00187004': 'DetectorType',
    '00187005': 'DetectorConfiguration',
    '00187006': 'DetectorDescription',
    '00187008': 'DetectorMode',
    '0018700A': 'DetectorID',
    '0018700C': 'DateOfLastDetectorCalibration',
    '0018700E': 'TimeOfLastDetectorCalibration',
    '00187010': 'ExposuresOnDetectorSinceLastCalibration',
    '00187011': 'ExposuresOnDetectorSinceManufactured',
    '00187012': 'DetectorTimeSinceLastExposure',
    '00187014': 'DetectorActiveTime',
    '00187016': 'DetectorActivationOffsetFromExposure',
    '0018701A': 'DetectorBinning',
    '00187020': 'DetectorElementPhysicalSize',
    '00187022': 'DetectorElementSpacing',
    '00187024': 'DetectorActiveShape',
    '00187026': 'DetectorActiveDimensions',
    '00187028': 'DetectorActiveOrigin',
    '0018702A': 'DetectorManufacturerName',
    '0018702B': 'DetectorManufacturerModelName',
    '00187030': 'FieldOfViewOrigin',
    '00187032': 'FieldOfViewRotation',
    '00187034': 'FieldOfViewHorizontalFlip',
    '00187036': 'PixelDataAreaOriginRelativeToFOV',
    '00187038': 'PixelDataAreaRotationAngleRelativeToFOV',
    '00187040': 'GridAbsorbingMaterial',
    '00187041': 'GridSpacingMaterial',
    '00187042': 'GridThickness',
    '00187044': 'GridPitch',
    '00187046': 'GridAspectRatio',
    '00187048': 'GridPeriod',
    '0018704C': 'GridFocalDistance',
    '00187050': 'FilterMaterial',
    '00187052': 'FilterThicknessMinimum',
    '00187054': 'FilterThicknessMaximum',
    '00187056': 'FilterBeamPathLengthMinimum',
    '00187058': 'FilterBeamPathLengthMaximum',
    '00187060': 'ExposureControlMode',
    '00187062': 'ExposureControlModeDescription',
    '00187064': 'ExposureStatus',
    '00187065': 'PhototimerSetting',
    '00188150': 'ExposureTimeInuS',
    '00188151': 'XRayTubeCurrentInuA',
    '00189004': 'ContentQualification',
    '00189005': 'PulseSequenceName',
    '00189006': 'MRImagingModifierSequence',
    '00189008': 'EchoPulseSequence',
    '00189009': 'InversionRecovery',
    '00189010': 'FlowCompensation',
    '00189011': 'MultipleSpinEcho',
    '00189012': 'MultiPlanarExcitation',
    '00189014': 'PhaseContrast',
    '00189015': 'TimeOfFlightContrast',
    '00189016': 'Spoiling',
    '00189017': 'SteadyStatePulseSequence',
    '00189018': 'EchoPlanarPulseSequence',
    '00189019': 'TagAngleFirstAxis',
    '00189020': 'MagnetizationTransfer',
    '00189021': ('T2Preparation'),
    '00189022': 'BloodSignalNulling',
    '00189024': 'SaturationRecovery',
    '00189025': 'SpectrallySelectedSuppression',
    '00189026': 'SpectrallySelectedExcitation',
    '00189027': 'SpatialPresaturation',
    '00189028': 'Tagging',
    '00189029': 'OversamplingPhase',
    '00189030': 'TagSpacingFirstDimension',
    '00189032': 'GeometryOfKSpaceTraversal',
    '00189033': 'SegmentedKSpaceTraversal',
    '00189034': 'RectilinearPhaseEncodeReordering',
    '00189035': 'TagThickness',
    '00189036': 'PartialFourierDirection',
    '00189037': 'CardiacSynchronizationTechnique',
    '00189041': 'ReceiveCoilManufacturerName',
    '00189042': 'MRReceiveCoilSequence',
    '00189043': 'ReceiveCoilType',
    '00189044': 'QuadratureReceiveCoil',
    '00189045': 'MultiCoilDefinitionSequence',
    '00189046': 'MultiCoilConfiguration',
    '00189047': 'MultiCoilElementName',
    '00189048': 'MultiCoilElementUsed',
    '00189049': 'MRTransmitCoilSequence',
    '00189050': 'TransmitCoilManufacturerName',
    '00189051': 'TransmitCoilType',
    '00189052': 'SpectralWidth',
    '00189053': 'ChemicalShiftReference',
    '00189054': 'VolumeLocalizationTechnique',
    '00189058': 'MRAcquisitionFrequencyEncodingSteps',
    '00189059': 'Decoupling',
    '00189060': 'DecoupledNucleus',
    '00189061': 'DecouplingFrequency',
    '00189062': 'DecouplingMethod',
    '00189063': 'DecouplingChemicalShiftReference',
    '00189064': 'KSpaceFiltering',
    '00189065': 'TimeDomainFiltering',
    '00189066': 'NumberOfZeroFills',
    '00189067': 'BaselineCorrection',
    '00189069': 'ParallelReductionFactorInPlane',
    '00189070': 'CardiacRRIntervalSpecified',
    '00189073': 'AcquisitionDuration',
    '00189074': 'FrameAcquisitionDateTime',
    '00189075': 'DiffusionDirectionality',
    '00189076': 'DiffusionGradientDirectionSequence',
    '00189077': 'ParallelAcquisition',
    '00189078': 'ParallelAcquisitionTechnique',
    '00189079': 'InversionTimes',
    '00189080': 'MetaboliteMapDescription',
    '00189081': 'PartialFourier',
    '00189082': 'EffectiveEchoTime',
    '00189083': 'MetaboliteMapCodeSequence',
    '00189084': 'ChemicalShiftSequence',
    '00189085': 'CardiacSignalSource',
    '00189087': 'DiffusionBValue',
    '00189089': 'DiffusionGradientOrientation',
    '00189090': 'VelocityEncodingDirection',
    '00189091': 'VelocityEncodingMinimumValue',
    '00189092': 'VelocityEncodingAcquisitionSequence',
    '00189093': 'NumberOfKSpaceTrajectories',
    '00189094': 'CoverageOfKSpace',
    '00189095': 'SpectroscopyAcquisitionPhaseRows',
    '00189096': 'ParallelReductionFactorInPlaneRetired',
    '00189098': 'TransmitterFrequency',
    '00189100': 'ResonantNucleus',
    '00189101': 'FrequencyCorrection',
    '00189103': 'MRSpectroscopyFOVGeometrySequence',
    '00189104': 'SlabThickness',
    '00189105': 'SlabOrientation',
    '00189106': 'MidSlabPosition',
    '00189107': 'MRSpatialSaturationSequence',
    '00189112': 'MRTimingAndRelatedParametersSequence',
    '00189114': 'MREchoSequence',
    '00189115': 'MRModifierSequence',
    '00189117': 'MRDiffusionSequence',
    '00189118': 'CardiacSynchronizationSequence',
    '00189119': 'MRAveragesSequence',
    '00189125': 'MRFOVGeometrySequence',
    '00189126': 'VolumeLocalizationSequence',
    '00189127': 'SpectroscopyAcquisitionDataColumns',
    '00189147': 'DiffusionAnisotropyType',
    '00189151': 'FrameReferenceDateTime',
    '00189152': 'MRMetaboliteMapSequence',
    '00189155': 'ParallelReductionFactorOutOfPlane',
    '00189159': 'SpectroscopyAcquisitionOutOfPlanePhaseSteps',
    '00189166': 'BulkMotionStatus',
    '00189168': 'ParallelReductionFactorSecondInPlane',
    '00189169': 'CardiacBeatRejectionTechnique',
    '00189170': 'RespiratoryMotionCompensationTechnique',
    '00189171': 'RespiratorySignalSource',
    '00189172': 'BulkMotionCompensationTechnique',
    '00189173': 'BulkMotionSignalSource',
    '00189174': 'ApplicableSafetyStandardAgency',
    '00189175': 'ApplicableSafetyStandardDescription',
    '00189176': 'OperatingModeSequence',
    '00189177': 'OperatingModeType',
    '00189178': 'OperatingMode',
    '00189179': 'SpecificAbsorptionRateDefinition',
    '00189180': 'GradientOutputType',
    '00189181': 'SpecificAbsorptionRateValue',
    '00189182': 'GradientOutput',
    '00189183': 'FlowCompensationDirection',
    '00189184': 'TaggingDelay',
    '00189185': 'RespiratoryMotionCompensationTechniqueDescription',
    '00189186': 'RespiratorySignalSourceID',
    '00189195': 'ChemicalShiftMinimumIntegrationLimitInHz',
    '00189196': 'ChemicalShiftMaximumIntegrationLimitInHz',
    '00189197': 'MRVelocityEncodingSequence',
    '00189198': 'FirstOrderPhaseCorrection',
    '00189199': 'WaterReferencedPhaseCorrection',
    '00189200': 'MRSpectroscopyAcquisitionType',
    '00189214': 'RespiratoryCyclePosition',
    '00189217': 'VelocityEncodingMaximumValue',
    '00189218': 'TagSpacingSecondDimension',
    '00189219': 'TagAngleSecondAxis',
    '00189220': 'FrameAcquisitionDuration',
    '00189226': 'MRImageFrameTypeSequence',
    '00189227': 'MRSpectroscopyFrameTypeSequence',
    '00189231': 'MRAcquisitionPhaseEncodingStepsInPlane',
    '00189232': 'MRAcquisitionPhaseEncodingStepsOutOfPlane',
    '00189234': 'SpectroscopyAcquisitionPhaseColumns',
    '00189236': 'CardiacCyclePosition',
    '00189239': 'SpecificAbsorptionRateSequence',
    '00189240': 'RFEchoTrainLength',
    '00189241': 'GradientEchoTrainLength',
    '00189250': 'ArterialSpinLabelingContrast',
    '00189251': 'MRArterialSpinLabelingSequence',
    '00189252': 'ASLTechniqueDescription',
    '00189253': 'ASLSlabNumber',
    '00189254': 'ASLSlabThickness',
    '00189255': 'ASLSlabOrientation',
    '00189256': 'ASLMidSlabPosition',
    '00189257': 'ASLContext',
    '00189258': 'ASLPulseTrainDuration',
    '00189259': 'ASLCrusherFlag',
    '0018925A': 'ASLCrusherFlowLimit',
    '0018925B': 'ASLCrusherDescription',
    '0018925C': 'ASLBolusCutoffFlag',
    '0018925D': 'ASLBolusCutoffTimingSequence',
    '0018925E': 'ASLBolusCutoffTechnique',
    '0018925F': 'ASLBolusCutoffDelayTime',
    '00189260': 'ASLSlabSequence',
    '00189295': 'ChemicalShiftMinimumIntegrationLimitInppm',
    '00189296': 'ChemicalShiftMaximumIntegrationLimitInppm',
    '00189297': 'WaterReferenceAcquisition',
    '00189298': 'EchoPeakPosition',
    '00189301': 'CTAcquisitionTypeSequence',
    '00189302': 'AcquisitionType',
    '00189303': 'TubeAngle',
    '00189304': 'CTAcquisitionDetailsSequence',
    '00189305': 'RevolutionTime',
    '00189306': 'SingleCollimationWidth',
    '00189307': 'TotalCollimationWidth',
    '00189308': 'CTTableDynamicsSequence',
    '00189309': 'TableSpeed',
    '00189310': 'TableFeedPerRotation',
    '00189311': 'SpiralPitchFactor',
    '00189312': 'CTGeometrySequence',
    '00189313': 'DataCollectionCenterPatient',
    '00189314': 'CTReconstructionSequence',
    '00189315': 'ReconstructionAlgorithm',
    '00189316': 'ConvolutionKernelGroup',
    '00189317': 'ReconstructionFieldOfView',
    '00189318': 'ReconstructionTargetCenterPatient',
    '00189319': 'ReconstructionAngle',
    '00189320': 'ImageFilter',
    '00189321': 'CTExposureSequence',
    '00189322': 'ReconstructionPixelSpacing',
    '00189323': 'ExposureModulationType',
    '00189324': 'EstimatedDoseSaving',
    '00189325': 'CTXRayDetailsSequence',
    '00189326': 'CTPositionSequence',
    '00189327': 'TablePosition',
    '00189328': 'ExposureTimeInms',
    '00189329': 'CTImageFrameTypeSequence',
    '00189330': 'XRayTubeCurrentInmA',
    '00189332': 'ExposureInmAs',
    '00189333': 'ConstantVolumeFlag',
    '00189334': 'FluoroscopyFlag',
    '00189335': 'DistanceSourceToDataCollectionCenter',
    '00189337': 'ContrastBolusAgentNumber',
    '00189338': 'ContrastBolusIngredientCodeSequence',
    '00189340': 'ContrastAdministrationProfileSequence',
    '00189341': 'ContrastBolusUsageSequence',
    '00189342': 'ContrastBolusAgentAdministered',
    '00189343': 'ContrastBolusAgentDetected',
    '00189344': 'ContrastBolusAgentPhase',
    '00189345': 'CTDIvol',
    '00189346': 'CTDIPhantomTypeCodeSequence',
    '00189351': 'CalciumScoringMassFactorPatient',
    '00189352': 'CalciumScoringMassFactorDevice',
    '00189353': 'EnergyWeightingFactor',
    '00189360': 'CTAdditionalXRaySourceSequence',
    '00189401': 'ProjectionPixelCalibrationSequence',
    '00189402': 'DistanceSourceToIsocenter',
    '00189403': 'DistanceObjectToTableTop',
    '00189404': 'ObjectPixelSpacingInCenterOfBeam',
    '00189405': 'PositionerPositionSequence',
    '00189406': 'TablePositionSequence',
    '00189407': 'CollimatorShapeSequence',
    '00189410': 'PlanesInAcquisition',
    '00189412': 'XAXRFFrameCharacteristicsSequence',
    '00189417': 'FrameAcquisitionSequence',
    '00189420': 'XRayReceptorType',
    '00189423': 'AcquisitionProtocolName',
    '00189424': 'AcquisitionProtocolDescription',
    '00189425': 'ContrastBolusIngredientOpaque',
    '00189426': 'DistanceReceptorPlaneToDetectorHousing',
    '00189427': 'IntensifierActiveShape',
    '00189428': 'IntensifierActiveDimensions',
    '00189429': 'PhysicalDetectorSize',
    '00189430': 'PositionOfIsocenterProjection',
    '00189432': 'FieldOfViewSequence',
    '00189433': 'FieldOfViewDescription',
    '00189434': 'ExposureControlSensingRegionsSequence',
    '00189435': 'ExposureControlSensingRegionShape',
    '00189436': 'ExposureControlSensingRegionLeftVerticalEdge',
    '00189437': 'ExposureControlSensingRegionRightVerticalEdge',
    '00189438': 'ExposureControlSensingRegionUpperHorizontalEdge',
    '00189439': 'ExposureControlSensingRegionLowerHorizontalEdge',
    '00189440': 'CenterOfCircularExposureControlSensingRegion',
    '00189441': 'RadiusOfCircularExposureControlSensingRegion',
    '00189442': 'VerticesOfThePolygonalExposureControlSensingRegion',
    '00189445': '',
    '00189447': 'ColumnAngulationPatient',
    '00189449': 'BeamAngle',
    '00189451': 'FrameDetectorParametersSequence',
    '00189452': 'CalculatedAnatomyThickness',
    '00189455': 'CalibrationSequence',
    '00189456': 'ObjectThicknessSequence',
    '00189457': 'PlaneIdentification',
    '00189461': 'FieldOfViewDimensionsInFloat',
    '00189462': 'IsocenterReferenceSystemSequence',
    '00189463': 'PositionerIsocenterPrimaryAngle',
    '00189464': 'PositionerIsocenterSecondaryAngle',
    '00189465': 'PositionerIsocenterDetectorRotationAngle',
    '00189466': 'TableXPositionToIsocenter',
    '00189467': 'TableYPositionToIsocenter',
    '00189468': 'TableZPositionToIsocenter',
    '00189469': 'TableHorizontalRotationAngle',
    '00189470': 'TableHeadTiltAngle',
    '00189471': 'TableCradleTiltAngle',
    '00189472': 'FrameDisplayShutterSequence',
    '00189473': 'AcquiredImageAreaDoseProduct',
    '00189474': 'CArmPositionerTabletopRelationship',
    '00189476': 'XRayGeometrySequence',
    '00189477': 'IrradiationEventIdentificationSequence',
    '00189504': ('XRay3DFrameTypeSequence'),
    '00189506': 'ContributingSourcesSequence',
    '00189507': ('XRay3DAcquisitionSequence'),
    '00189508': 'PrimaryPositionerScanArc',
    '00189509': 'SecondaryPositionerScanArc',
    '00189510': 'PrimaryPositionerScanStartAngle',
    '00189511': 'SecondaryPositionerScanStartAngle',
    '00189514': 'PrimaryPositionerIncrement',
    '00189515': 'SecondaryPositionerIncrement',
    '00189516': 'StartAcquisitionDateTime',
    '00189517': 'EndAcquisitionDateTime',
    '00189518': 'PrimaryPositionerIncrementSign',
    '00189519': 'SecondaryPositionerIncrementSign',
    '00189524': 'ApplicationName',
    '00189525': 'ApplicationVersion',
    '00189526': 'ApplicationManufacturer',
    '00189527': 'AlgorithmType',
    '00189528': 'AlgorithmDescription',
    '00189530': ('XRay3DReconstructionSequence'),
    '00189531': 'ReconstructionDescription',
    '00189538': 'PerProjectionAcquisitionSequence',
    '00189541': 'DetectorPositionSequence',
    '00189542': 'XRayAcquisitionDoseSequence',
    '00189543': 'XRaySourceIsocenterPrimaryAngle',
    '00189544': 'XRaySourceIsocenterSecondaryAngle',
    '00189545': 'BreastSupportIsocenterPrimaryAngle',
    '00189546': 'BreastSupportIsocenterSecondaryAngle',
    '00189547': 'BreastSupportXPositionToIsocenter',
    '00189548': 'BreastSupportYPositionToIsocenter',
    '00189549': 'BreastSupportZPositionToIsocenter',
    '00189550': 'DetectorIsocenterPrimaryAngle',
    '00189551': 'DetectorIsocenterSecondaryAngle',
    '00189552': 'DetectorXPositionToIsocenter',
    '00189553': 'DetectorYPositionToIsocenter',
    '00189554': 'DetectorZPositionToIsocenter',
    '00189555': 'XRayGridSequence',
    '00189556': 'XRayFilterSequence',
    '00189557': 'DetectorActiveAreaTLHCPosition',
    '00189558': 'DetectorActiveAreaOrientation',
    '00189559': 'PositionerPrimaryAngleDirection',
    '00189601': 'DiffusionBMatrixSequence',
    '00189602': 'DiffusionBValueXX',
    '00189603': 'DiffusionBValueXY',
    '00189604': 'DiffusionBValueXZ',
    '00189605': 'DiffusionBValueYY',
    '00189606': 'DiffusionBValueYZ',
    '00189607': 'DiffusionBValueZZ',
    '00189621': 'FunctionalMRSequence',
    '00189622': 'FunctionalSettlingPhaseFramesPresent',
    '00189623': 'FunctionalSyncPulse',
    '00189624': 'SettlingPhaseFrame',
    '00189701': 'DecayCorrectionDateTime',
    '00189715': 'StartDensityThreshold',
    '00189716': 'StartRelativeDensityDifferenceThreshold',
    '00189717': 'StartCardiacTriggerCountThreshold',
    '00189718': 'StartRespiratoryTriggerCountThreshold',
    '00189719': 'TerminationCountsThreshold',
    '00189720': 'TerminationDensityThreshold',
    '00189721': 'TerminationRelativeDensityThreshold',
    '00189722': 'TerminationTimeThreshold',
    '00189723': 'TerminationCardiacTriggerCountThreshold',
    '00189724': 'TerminationRespiratoryTriggerCountThreshold',
    '00189725': 'DetectorGeometry',
    '00189726': 'TransverseDetectorSeparation',
    '00189727': 'AxialDetectorDimension',
    '00189729': 'RadiopharmaceuticalAgentNumber',
    '00189732': 'PETFrameAcquisitionSequence',
    '00189733': 'PETDetectorMotionDetailsSequence',
    '00189734': 'PETTableDynamicsSequence',
    '00189735': 'PETPositionSequence',
    '00189736': 'PETFrameCorrectionFactorsSequence',
    '00189737': 'RadiopharmaceuticalUsageSequence',
    '00189738': 'AttenuationCorrectionSource',
    '00189739': 'NumberOfIterations',
    '00189740': 'NumberOfSubsets',
    '00189749': 'PETReconstructionSequence',
    '00189751': 'PETFrameTypeSequence',
    '00189755': 'TimeOfFlightInformationUsed',
    '00189756': 'ReconstructionType',
    '00189758': 'DecayCorrected',
    '00189759': 'AttenuationCorrected',
    '00189760': 'ScatterCorrected',
    '00189761': 'DeadTimeCorrected',
    '00189762': 'GantryMotionCorrected',
    '00189763': 'PatientMotionCorrected',
    '00189764': 'CountLossNormalizationCorrected',
    '00189765': 'RandomsCorrected',
    '00189766': 'NonUniformRadialSamplingCorrected',
    '00189767': 'SensitivityCalibrated',
    '00189768': 'DetectorNormalizationCorrection',
    '00189769': 'IterativeReconstructionMethod',
    '00189770': 'AttenuationCorrectionTemporalRelationship',
    '00189771': 'PatientPhysiologicalStateSequence',
    '00189772': 'PatientPhysiologicalStateCodeSequence',
    '00189801': 'DepthsOfFocus',
    '00189803': 'ExcludedIntervalsSequence',
    '00189804': 'ExclusionStartDateTime',
    '00189805': 'ExclusionDuration',
    '00189806': 'USImageDescriptionSequence',
    '00189807': 'ImageDataTypeSequence',
    '00189808': 'DataType',
    '00189809': 'TransducerScanPatternCodeSequence',
    '0018980B': 'AliasedDataType',
    '0018980C': 'PositionMeasuringDeviceUsed',
    '0018980D': 'TransducerGeometryCodeSequence',
    '0018980E': 'TransducerBeamSteeringCodeSequence',
    '0018980F': 'TransducerApplicationCodeSequence',
    '00189810': 'ZeroVelocityPixelValue',
    '00189900': 'ReferenceLocationLabel',
    '00189901': 'ReferenceLocationDescription',
    '00189902': 'ReferenceBasisCodeSequence',
    '00189903': 'ReferenceGeometryCodeSequence',
    '00189904': 'OffsetDistance',
    '00189905': 'OffsetDirection',
    '00189906': 'PotentialScheduledProtocolCodeSequence',
    '00189907': 'PotentialRequestedProcedureCodeSequence',
    '00189908': 'PotentialReasonsForProcedure',
    '00189909': 'PotentialReasonsForProcedureCodeSequence',
    '0018990A': 'PotentialDiagnosticTasks',
    '0018990B': 'ContraindicationsCodeSequence',
    '0018990C': 'ReferencedDefinedProtocolSequence',
    '0018990D': 'ReferencedPerformedProtocolSequence',
    '0018990E': 'PredecessorProtocolSequence',
    '0018990F': 'ProtocolPlanningInformation',
    '00189910': 'ProtocolDesignRationale',
    '00189911': 'PatientSpecificationSequence',
    '00189912': 'ModelSpecificationSequence',
    '00189913': 'ParametersSpecificationSequence',
    '00189914': 'InstructionSequence',
    '00189915': 'InstructionIndex',
    '00189916': 'InstructionText',
    '00189917': 'InstructionDescription',
    '00189918': 'InstructionPerformedFlag',
    '00189919': 'InstructionPerformedDateTime',
    '0018991A': 'InstructionPerformanceComment',
    '0018991B': 'PatientPositioningInstructionSequence',
    '0018991C': 'PositioningMethodCodeSequence',
    '0018991D': 'PositioningLandmarkSequence',
    '0018991E': 'TargetFrameOfReferenceUID',
    '0018991F': 'AcquisitionProtocolElementSpecificationSequence',
    '00189920': 'AcquisitionProtocolElementSequence',
    '00189921': 'ProtocolElementNumber',
    '00189922': 'ProtocolElementName',
    '00189923': 'ProtocolElementCharacteristicsSummary',
    '00189924': 'ProtocolElementPurpose',
    '00189930': 'AcquisitionMotion',
    '00189931': 'AcquisitionStartLocationSequence',
    '00189932': 'AcquisitionEndLocationSequence',
    '00189933': 'ReconstructionProtocolElementSpecificationSequence',
    '00189934': 'ReconstructionProtocolElementSequence',
    '00189935': 'StorageProtocolElementSpecificationSequence',
    '00189936': 'StorageProtocolElementSequence',
    '00189937': 'RequestedSeriesDescription',
    '00189938': 'SourceAcquisitionProtocolElementNumber',
    '00189939': 'SourceAcquisitionBeamNumber',
    '0018993A': 'SourceReconstructionProtocolElementNumber',
    '0018993B': 'ReconstructionStartLocationSequence',
    '0018993C': 'ReconstructionEndLocationSequence',
    '0018993D': 'ReconstructionAlgorithmSequence',
    '0018993E': 'ReconstructionTargetCenterLocationSequence',
    '00189941': 'ImageFilterDescription',
    '00189942': 'CTDIvolNotificationTrigger',
    '00189943': 'DLPNotificationTrigger',
    '00189944': 'AutoKVPSelectionType',
    '00189945': 'AutoKVPUpperBound',
    '00189946': 'AutoKVPLowerBound',
    '00189947': 'ProtocolDefinedPatientPosition',
    '0018A001': 'ContributingEquipmentSequence',
    '0018A002': 'ContributionDateTime',
    '0018A003': 'ContributionDescription',
    '0020000D': 'StudyInstanceUID',
    '0020000E': 'SeriesInstanceUID',
    '00200010': 'StudyID',
    '00200011': 'SeriesNumber',
    '00200012': 'AcquisitionNumber',
    '00200013': 'InstanceNumber',
    '00200014': 'IsotopeNumber',
    '00200015': 'PhaseNumber',
    '00200016': 'IntervalNumber',
    '00200017': 'TimeSlotNumber',
    '00200018': 'AngleNumber',
    '00200019': 'ItemNumber',
    '00200020': 'PatientOrientation',
    '00200022': 'OverlayNumber',
    '00200024': 'CurveNumber',
    '00200026': 'LUTNumber',
    '00200030': 'ImagePosition',
    '00200032': 'ImagePositionPatient',
    '00200035': 'ImageOrientation',
    '00200037': 'ImageOrientationPatient',
    '00200050': 'Location',
    '00200052': 'FrameOfReferenceUID',
    '00200060': 'Laterality',
    '00200062': 'ImageLaterality',
    '00200070': 'ImageGeometryType',
    '00200080': 'MaskingImage',
    '002000AA': 'ReportNumber',
    '00200100': 'TemporalPositionIdentifier',
    '00200105': 'NumberOfTemporalPositions',
    '00200110': 'TemporalResolution',
    '00200200': 'SynchronizationFrameOfReferenceUID',
    '00200242': 'SOPInstanceUIDOfConcatenationSource',
    '00201000': 'SeriesInStudy',
    '00201001': 'AcquisitionsInSeries',
    '00201002': 'ImagesInAcquisition',
    '00201003': 'ImagesInSeries',
    '00201004': 'AcquisitionsInStudy',
    '00201005': 'ImagesInStudy',
    '00201020': 'Reference',
    '0020103F': 'TargetPositionReferenceIndicator',
    '00201040': 'PositionReferenceIndicator',
    '00201041': 'SliceLocation',
    '00201070': 'OtherStudyNumbers',
    '00201200': 'NumberOfPatientRelatedStudies',
    '00201202': 'NumberOfPatientRelatedSeries',
    '00201204': 'NumberOfPatientRelatedInstances',
    '00201206': 'NumberOfStudyRelatedSeries',
    '00201208': 'NumberOfStudyRelatedInstances',
    '00201209': 'NumberOfSeriesRelatedInstances',
    '00203401': 'ModifyingDeviceID',
    '00203402': 'ModifiedImageID',
    '00203403': 'ModifiedImageDate',
    '00203404': 'ModifyingDeviceManufacturer',
    '00203405': 'ModifiedImageTime',
    '00203406': 'ModifiedImageDescription',
    '00204000': 'ImageComments',
    '00205000': 'OriginalImageIdentification',
    '00205002': 'OriginalImageIdentificationNomenclature',
    '00209056': 'StackID',
    '00209057': 'InStackPositionNumber',
    '00209071': 'FrameAnatomySequence',
    '00209072': 'FrameLaterality',
    '00209111': 'FrameContentSequence',
    '00209113': 'PlanePositionSequence',
    '00209116': 'PlaneOrientationSequence',
    '00209128': 'TemporalPositionIndex',
    '00209153': 'NominalCardiacTriggerDelayTime',
    '00209154': 'NominalCardiacTriggerTimePriorToRPeak',
    '00209155': 'ActualCardiacTriggerTimePriorToRPeak',
    '00209156': 'FrameAcquisitionNumber',
    '00209157': 'DimensionIndexValues',
    '00209158': 'FrameComments',
    '00209161': 'ConcatenationUID',
    '00209162': 'InConcatenationNumber',
    '00209163': 'InConcatenationTotalNumber',
    '00209164': 'DimensionOrganizationUID',
    '00209165': 'DimensionIndexPointer',
    '00209167': 'FunctionalGroupPointer',
    '00209170': 'UnassignedSharedConvertedAttributesSequence',
    '00209171': 'UnassignedPerFrameConvertedAttributesSequence',
    '00209172': 'ConversionSourceAttributesSequence',
    '00209213': 'DimensionIndexPrivateCreator',
    '00209221': 'DimensionOrganizationSequence',
    '00209222': 'DimensionIndexSequence',
    '00209228': 'ConcatenationFrameOffsetNumber',
    '00209238': 'FunctionalGroupPrivateCreator',
    '00209241': 'NominalPercentageOfCardiacPhase',
    '00209245': 'NominalPercentageOfRespiratoryPhase',
    '00209246': 'StartingRespiratoryAmplitude',
    '00209247': 'StartingRespiratoryPhase',
    '00209248': 'EndingRespiratoryAmplitude',
    '00209249': 'EndingRespiratoryPhase',
    '00209250': 'RespiratoryTriggerType',
    '00209251': 'RRIntervalTimeNominal',
    '00209252': 'ActualCardiacTriggerDelayTime',
    '00209253': 'RespiratorySynchronizationSequence',
    '00209254': 'RespiratoryIntervalTime',
    '00209255': 'NominalRespiratoryTriggerDelayTime',
    '00209256': 'RespiratoryTriggerDelayThreshold',
    '00209257': 'ActualRespiratoryTriggerDelayTime',
    '00209301': 'ImagePositionVolume',
    '00209302': 'ImageOrientationVolume',
    '00209307': 'UltrasoundAcquisitionGeometry',
    '00209308': 'ApexPosition',
    '00209309': 'VolumeToTransducerMappingMatrix',
    '0020930A': 'VolumeToTableMappingMatrix',
    '0020930B': 'VolumeToTransducerRelationship',
    '0020930C': 'PatientFrameOfReferenceSource',
    '0020930D': 'TemporalPositionTimeOffset',
    '0020930E': 'PlanePositionVolumeSequence',
    '0020930F': 'PlaneOrientationVolumeSequence',
    '00209310': 'TemporalPositionSequence',
    '00209311': 'DimensionOrganizationType',
    '00209312': 'VolumeFrameOfReferenceUID',
    '00209313': 'TableFrameOfReferenceUID',
    '00209421': 'DimensionDescriptionLabel',
    '00209450': 'PatientOrientationInFrameSequence',
    '00209453': 'FrameLabel',
    '00209518': 'AcquisitionIndex',
    '00209529': 'ContributingSOPInstancesReferenceSequence',
    '00209536': 'ReconstructionIndex',
    '00220001': 'LightPathFilterPassThroughWavelength',
    '00220002': 'LightPathFilterPassBand',
    '00220003': 'ImagePathFilterPassThroughWavelength',
    '00220004': 'ImagePathFilterPassBand',
    '00220005': 'PatientEyeMovementCommanded',
    '00220006': 'PatientEyeMovementCommandCodeSequence',
    '00220007': 'SphericalLensPower',
    '00220008': 'CylinderLensPower',
    '00220009': 'CylinderAxis',
    '0022000A': 'EmmetropicMagnification',
    '0022000B': 'IntraOcularPressure',
    '0022000C': 'HorizontalFieldOfView',
    '0022000D': 'PupilDilated',
    '0022000E': 'DegreeOfDilation',
    '00220010': 'StereoBaselineAngle',
    '00220011': 'StereoBaselineDisplacement',
    '00220012': 'StereoHorizontalPixelOffset',
    '00220013': 'StereoVerticalPixelOffset',
    '00220014': 'StereoRotation',
    '00220015': 'AcquisitionDeviceTypeCodeSequence',
    '00220016': 'IlluminationTypeCodeSequence',
    '00220017': 'LightPathFilterTypeStackCodeSequence',
    '00220018': 'ImagePathFilterTypeStackCodeSequence',
    '00220019': 'LensesCodeSequence',
    '0022001A': 'ChannelDescriptionCodeSequence',
    '0022001B': 'RefractiveStateSequence',
    '0022001C': 'MydriaticAgentCodeSequence',
    '0022001D': 'RelativeImagePositionCodeSequence',
    '0022001E': 'CameraAngleOfView',
    '00220020': 'StereoPairsSequence',
    '00220021': 'LeftImageSequence',
    '00220022': 'RightImageSequence',
    '00220028': 'StereoPairsPresent',
    '00220030': 'AxialLengthOfTheEye',
    '00220031': 'OphthalmicFrameLocationSequence',
    '00220032': 'ReferenceCoordinates',
    '00220035': 'DepthSpatialResolution',
    '00220036': 'MaximumDepthDistortion',
    '00220037': 'AlongScanSpatialResolution',
    '00220038': 'MaximumAlongScanDistortion',
    '00220039': 'OphthalmicImageOrientation',
    '00220041': 'DepthOfTransverseImage',
    '00220042': 'MydriaticAgentConcentrationUnitsSequence',
    '00220048': 'AcrossScanSpatialResolution',
    '00220049': 'MaximumAcrossScanDistortion',
    '0022004E': 'MydriaticAgentConcentration',
    '00220055': 'IlluminationWaveLength',
    '00220056': 'IlluminationPower',
    '00220057': 'IlluminationBandwidth',
    '00220058': 'MydriaticAgentSequence',
    '00221007': 'OphthalmicAxialMeasurementsRightEyeSequence',
    '00221008': 'OphthalmicAxialMeasurementsLeftEyeSequence',
    '00221009': 'OphthalmicAxialMeasurementsDeviceType',
    '00221010': 'OphthalmicAxialLengthMeasurementsType',
    '00221012': 'OphthalmicAxialLengthSequence',
    '00221019': 'OphthalmicAxialLength',
    '00221024': 'LensStatusCodeSequence',
    '00221025': 'VitreousStatusCodeSequence',
    '00221028': 'IOLFormulaCodeSequence',
    '00221029': 'IOLFormulaDetail',
    '00221033': 'KeratometerIndex',
    '00221035': 'SourceOfOphthalmicAxialLengthCodeSequence',
    '00221037': 'TargetRefraction',
    '00221039': 'RefractiveProcedureOccurred',
    '00221040': 'RefractiveSurgeryTypeCodeSequence',
    '00221044': 'OphthalmicUltrasoundMethodCodeSequence',
    '00221050': 'OphthalmicAxialLengthMeasurementsSequence',
    '00221053': 'IOLPower',
    '00221054': 'PredictedRefractiveError',
    '00221059': 'OphthalmicAxialLengthVelocity',
    '00221065': 'LensStatusDescription',
    '00221066': 'VitreousStatusDescription',
    '00221090': 'IOLPowerSequence',
    '00221092': 'LensConstantSequence',
    '00221093': 'IOLManufacturer',
    '00221094': 'LensConstantDescription',
    '00221095': 'ImplantName',
    '00221096': 'KeratometryMeasurementTypeCodeSequence',
    '00221097': 'ImplantPartNumber',
    '00221100': 'ReferencedOphthalmicAxialMeasurementsSequence',
    '00221101': 'OphthalmicAxialLengthMeasurementsSegmentNameCodeSequence',
    '00221103': 'RefractiveErrorBeforeRefractiveSurgeryCodeSequence',
    '00221121': 'IOLPowerForExactEmmetropia',
    '00221122': 'IOLPowerForExactTargetRefraction',
    '00221125': 'AnteriorChamberDepthDefinitionCodeSequence',
    '00221127': 'LensThicknessSequence',
    '00221128': 'AnteriorChamberDepthSequence',
    '00221130': 'LensThickness',
    '00221131': 'AnteriorChamberDepth',
    '00221132': 'SourceOfLensThicknessDataCodeSequence',
    '00221133': 'SourceOfAnteriorChamberDepthDataCodeSequence',
    '00221134': 'SourceOfRefractiveMeasurementsSequence',
    '00221135': 'SourceOfRefractiveMeasurementsCodeSequence',
    '00221140': 'OphthalmicAxialLengthMeasurementModified',
    '00221150': 'OphthalmicAxialLengthDataSourceCodeSequence',
    '00221153': 'OphthalmicAxialLengthAcquisitionMethodCodeSequence',
    '00221155': 'SignalToNoiseRatio',
    '00221159': 'OphthalmicAxialLengthDataSourceDescription',
    '00221210': 'OphthalmicAxialLengthMeasurementsTotalLengthSequence',
    '00221211': 'OphthalmicAxialLengthMeasurementsSegmentalLengthSequence',
    '00221212': 'OphthalmicAxialLengthMeasurementsLengthSummationSequence',
    '00221220': 'UltrasoundOphthalmicAxialLengthMeasurementsSequence',
    '00221225': 'OpticalOphthalmicAxialLengthMeasurementsSequence',
    '00221230': 'UltrasoundSelectedOphthalmicAxialLengthSequence',
    '00221250': 'OphthalmicAxialLengthSelectionMethodCodeSequence',
    '00221255': 'OpticalSelectedOphthalmicAxialLengthSequence',
    '00221257': 'SelectedSegmentalOphthalmicAxialLengthSequence',
    '00221260': 'SelectedTotalOphthalmicAxialLengthSequence',
    '00221262': 'OphthalmicAxialLengthQualityMetricSequence',
    '00221265': 'OphthalmicAxialLengthQualityMetricTypeCodeSequence',
    '00221273': 'OphthalmicAxialLengthQualityMetricTypeDescription',
    '00221300': 'IntraocularLensCalculationsRightEyeSequence',
    '00221310': 'IntraocularLensCalculationsLeftEyeSequence',
    '00221330': 'ReferencedOphthalmicAxialLengthMeasurementQCImageSequence',
    '00221415': 'OphthalmicMappingDeviceType',
    '00221420': 'AcquisitionMethodCodeSequence',
    '00221423': 'AcquisitionMethodAlgorithmSequence',
    '00221436': 'OphthalmicThicknessMapTypeCodeSequence',
    '00221443': 'OphthalmicThicknessMappingNormalsSequence',
    '00221445': 'RetinalThicknessDefinitionCodeSequence',
    '00221450': 'PixelValueMappingToCodedConceptSequence',
    '00221452': 'MappedPixelValue',
    '00221454': 'PixelValueMappingExplanation',
    '00221458': 'OphthalmicThicknessMapQualityThresholdSequence',
    '00221460': 'OphthalmicThicknessMapThresholdQualityRating',
    '00221463': 'AnatomicStructureReferencePoint',
    '00221465': 'RegistrationToLocalizerSequence',
    '00221466': 'RegisteredLocalizerUnits',
    '00221467': 'RegisteredLocalizerTopLeftHandCorner',
    '00221468': 'RegisteredLocalizerBottomRightHandCorner',
    '00221470': 'OphthalmicThicknessMapQualityRatingSequence',
    '00221472': 'RelevantOPTAttributesSequence',
    '00221512': 'TransformationMethodCodeSequence',
    '00221513': 'TransformationAlgorithmSequence',
    '00221515': 'OphthalmicAxialLengthMethod',
    '00221517': 'OphthalmicFOV',
    '00221518': 'TwoDimensionalToThreeDimensionalMapSequence',
    '00221525': 'WideFieldOphthalmicPhotographyQualityRatingSequence',
    '00221526': 'WideFieldOphthalmicPhotographyQualityThresholdSequence',
    '00221527': 'WideFieldOphthalmicPhotographyThresholdQualityRating',
    '00221528': 'XCoordinatesCenterPixelViewAngle',
    '00221529': 'YCoordinatesCenterPixelViewAngle',
    '00221530': 'NumberOfMapPoints',
    '00221531': 'TwoDimensionalToThreeDimensionalMapData',
    '00221612': 'DerivationAlgorithmSequence',
    '00221615': 'OphthalmicImageTypeCodeSequence',
    '00221616': 'OphthalmicImageTypeDescription',
    '00221618': 'ScanPatternTypeCodeSequence',
    '00221620': 'ReferencedSurfaceMeshIdentificationSequence',
    '00221622': 'OphthalmicVolumetricPropertiesFlag',
    '00221624': 'OphthalmicAnatomicReferencePointXCoordinate',
    '00221626': 'OphthalmicAnatomicReferencePointYCoordinate',
    '00221628': 'OphthalmicEnFaceImageQualityRatingSequence',
    '00221630': 'QualityThreshold',
    '00221640': 'OCTBscanAnalysisAcquisitionParametersSequence',
    '00221642': 'NumberofBscansPerFrame',
    '00221643': 'BscanSlabThickness',
    '00221644': 'DistanceBetweenBscanSlabs',
    '00221645': 'BscanCycleTime',
    '00221646': 'BscanCycleTimeVector',
    '00221649': 'AscanRate',
    '00221650': 'BscanRate',
    '00221658': 'SurfaceMeshZPixelOffset',
    '00240010': 'VisualFieldHorizontalExtent',
    '00240011': 'VisualFieldVerticalExtent',
    '00240012': 'VisualFieldShape',
    '00240016': 'ScreeningTestModeCodeSequence',
    '00240018': 'MaximumStimulusLuminance',
    '00240020': 'BackgroundLuminance',
    '00240021': 'StimulusColorCodeSequence',
    '00240024': 'BackgroundIlluminationColorCodeSequence',
    '00240025': 'StimulusArea',
    '00240028': 'StimulusPresentationTime',
    '00240032': 'FixationSequence',
    '00240033': 'FixationMonitoringCodeSequence',
    '00240034': 'VisualFieldCatchTrialSequence',
    '00240035': 'FixationCheckedQuantity',
    '00240036': 'PatientNotProperlyFixatedQuantity',
    '00240037': 'PresentedVisualStimuliDataFlag',
    '00240038': 'NumberOfVisualStimuli',
    '00240039': 'ExcessiveFixationLossesDataFlag',
    '00240040': 'ExcessiveFixationLosses',
    '00240042': 'StimuliRetestingQuantity',
    '00240044': 'CommentsOnPatientPerformanceOfVisualField',
    '00240045': 'FalseNegativesEstimateFlag',
    '00240046': 'FalseNegativesEstimate',
    '00240048': 'NegativeCatchTrialsQuantity',
    '00240050': 'FalseNegativesQuantity',
    '00240051': 'ExcessiveFalseNegativesDataFlag',
    '00240052': 'ExcessiveFalseNegatives',
    '00240053': 'FalsePositivesEstimateFlag',
    '00240054': 'FalsePositivesEstimate',
    '00240055': 'CatchTrialsDataFlag',
    '00240056': 'PositiveCatchTrialsQuantity',
    '00240057': 'TestPointNormalsDataFlag',
    '00240058': 'TestPointNormalsSequence',
    '00240059': 'GlobalDeviationProbabilityNormalsFlag',
    '00240060': 'FalsePositivesQuantity',
    '00240061': 'ExcessiveFalsePositivesDataFlag',
    '00240062': 'ExcessiveFalsePositives',
    '00240063': 'VisualFieldTestNormalsFlag',
    '00240064': 'ResultsNormalsSequence',
    '00240065': 'AgeCorrectedSensitivityDeviationAlgorithmSequence',
    '00240066': 'GlobalDeviationFromNormal',
    '00240067': 'GeneralizedDefectSensitivityDeviationAlgorithmSequence',
    '00240068': 'LocalizedDeviationFromNormal',
    '00240069': 'PatientReliabilityIndicator',
    '00240070': 'VisualFieldMeanSensitivity',
    '00240071': 'GlobalDeviationProbability',
    '00240072': 'LocalDeviationProbabilityNormalsFlag',
    '00240073': 'LocalizedDeviationProbability',
    '00240074': 'ShortTermFluctuationCalculated',
    '00240075': 'ShortTermFluctuation',
    '00240076': 'ShortTermFluctuationProbabilityCalculated',
    '00240077': 'ShortTermFluctuationProbability',
    '00240078': 'CorrectedLocalizedDeviationFromNormalCalculated',
    '00240079': 'CorrectedLocalizedDeviationFromNormal',
    '00240080': 'CorrectedLocalizedDeviationFromNormalProbabilityCalculated',
    '00240081': 'CorrectedLocalizedDeviationFromNormalProbability',
    '00240083': 'GlobalDeviationProbabilitySequence',
    '00240085': 'LocalizedDeviationProbabilitySequence',
    '00240086': 'FovealSensitivityMeasured',
    '00240087': 'FovealSensitivity',
    '00240088': 'VisualFieldTestDuration',
    '00240089': 'VisualFieldTestPointSequence',
    '00240090': 'VisualFieldTestPointXCoordinate',
    '00240091': 'VisualFieldTestPointYCoordinate',
    '00240092': 'AgeCorrectedSensitivityDeviationValue',
    '00240093': 'StimulusResults',
    '00240094': 'SensitivityValue',
    '00240095': 'RetestStimulusSeen',
    '00240096': 'RetestSensitivityValue',
    '00240097': 'VisualFieldTestPointNormalsSequence',
    '00240098': 'QuantifiedDefect',
    '00240100': 'AgeCorrectedSensitivityDeviationProbabilityValue',
    '00240102': 'GeneralizedDefectCorrectedSensitivityDeviationFlag',
    '00240103': 'GeneralizedDefectCorrectedSensitivityDeviationValue',
    '00240104': 'GeneralizedDefectCorrectedSensitivityDeviationProbabilityValue',
    '00240105': 'MinimumSensitivityValue',
    '00240106': 'BlindSpotLocalized',
    '00240107': 'BlindSpotXCoordinate',
    '00240108': 'BlindSpotYCoordinate',
    '00240110': 'VisualAcuityMeasurementSequence',
    '00240112': 'RefractiveParametersUsedOnPatientSequence',
    '00240113': 'MeasurementLaterality',
    '00240114': 'OphthalmicPatientClinicalInformationLeftEyeSequence',
    '00240115': 'OphthalmicPatientClinicalInformationRightEyeSequence',
    '00240117': 'FovealPointNormativeDataFlag',
    '00240118': 'FovealPointProbabilityValue',
    '00240120': 'ScreeningBaselineMeasured',
    '00240122': 'ScreeningBaselineMeasuredSequence',
    '00240124': 'ScreeningBaselineType',
    '00240126': 'ScreeningBaselineValue',
    '00240202': 'AlgorithmSource',
    '00240306': 'DataSetName',
    '00240307': 'DataSetVersion',
    '00240308': 'DataSetSource',
    '00240309': 'DataSetDescription',
    '00240317': 'VisualFieldTestReliabilityGlobalIndexSequence',
    '00240320': 'VisualFieldGlobalResultsIndexSequence',
    '00240325': 'DataObservationSequence',
    '00240338': 'IndexNormalsFlag',
    '00240341': 'IndexProbability',
    '00240344': 'IndexProbabilitySequence',
    '00280002': 'SamplesPerPixel',
    '00280003': 'SamplesPerPixelUsed',
    '00280004': 'PhotometricInterpretation',
    '00280005': 'ImageDimensions',
    '00280006': 'PlanarConfiguration',
    '00280008': 'NumberOfFrames',
    '00280009': 'FrameIncrementPointer',
    '0028000A': 'FrameDimensionPointer',
    '00280010': 'Rows',
    '00280011': 'Columns',
    '00280012': 'Planes',
    '00280014': 'UltrasoundColorDataPresent',
    '00280020': '',
    '00280030': 'PixelSpacing',
    '00280031': 'ZoomFactor',
    '00280032': 'ZoomCenter',
    '00280034': 'PixelAspectRatio',
    '00280040': 'ImageFormat',
    '00280050': 'ManipulatedImage',
    '00280051': 'CorrectedImage',
    '0028005F': 'CompressionRecognitionCode',
    '00280060': 'CompressionCode',
    '00280061': 'CompressionOriginator',
    '00280062': 'CompressionLabel',
    '00280063': 'CompressionDescription',
    '00280065': 'CompressionSequence',
    '00280066': 'CompressionStepPointers',
    '00280068': 'RepeatInterval',
    '00280069': 'BitsGrouped',
    '00280070': 'PerimeterTable',
    '00280071': 'PerimeterValue',
    '00280080': 'PredictorRows',
    '00280081': 'PredictorColumns',
    '00280082': 'PredictorConstants',
    '00280090': 'BlockedPixels',
    '00280091': 'BlockRows',
    '00280092': 'BlockColumns',
    '00280093': 'RowOverlap',
    '00280094': 'ColumnOverlap',
    '00280100': 'BitsAllocated',
    '00280101': 'BitsStored',
    '00280102': 'HighBit',
    '00280103': 'PixelRepresentation',
    '00280104': 'SmallestValidPixelValue',
    '00280105': 'LargestValidPixelValue',
    '00280106': 'SmallestImagePixelValue',
    '00280107': 'LargestImagePixelValue',
    '00280108': 'SmallestPixelValueInSeries',
    '00280109': 'LargestPixelValueInSeries',
    '00280110': 'SmallestImagePixelValueInPlane',
    '00280111': 'LargestImagePixelValueInPlane',
    '00280120': 'PixelPaddingValue',
    '00280121': 'PixelPaddingRangeLimit',
    '00280122': 'FloatPixelPaddingValue',
    '00280123': 'DoubleFloatPixelPaddingValue',
    '00280124': 'FloatPixelPaddingRangeLimit',
    '00280125': 'DoubleFloatPixelPaddingRangeLimit',
    '00280200': 'ImageLocation',
    '00280300': 'QualityControlImage',
    '00280301': 'BurnedInAnnotation',
    '00280302': 'RecognizableVisualFeatures',
    '00280303': 'LongitudinalTemporalInformationModified',
    '00280304': 'ReferencedColorPaletteInstanceUID',
    '00280400': 'TransformLabel',
    '00280401': 'TransformVersionNumber',
    '00280402': 'NumberOfTransformSteps',
    '00280403': 'SequenceOfCompressedData',
    '00280404': 'DetailsOfCoefficients',
    '00280700': 'DCTLabel',
    '00280701': 'DataBlockDescription',
    '00280702': 'DataBlock',
    '00280710': 'NormalizationFactorFormat',
    '00280720': 'ZonalMapNumberFormat',
    '00280721': 'ZonalMapLocation',
    '00280722': 'ZonalMapFormat',
    '00280730': 'AdaptiveMapFormat',
    '00280740': 'CodeNumberFormat',
    '00280A02': 'PixelSpacingCalibrationType',
    '00280A04': 'PixelSpacingCalibrationDescription',
    '00281040': 'PixelIntensityRelationship',
    '00281041': 'PixelIntensityRelationshipSign',
    '00281050': 'WindowCenter',
    '00281051': 'WindowWidth',
    '00281052': 'RescaleIntercept',
    '00281053': 'RescaleSlope',
    '00281054': 'RescaleType',
    '00281055': 'WindowCenterWidthExplanation',
    '00281056': 'VOILUTFunction',
    '00281080': 'GrayScale',
    '00281090': 'RecommendedViewingMode',
    '00281100': 'GrayLookupTableDescriptor',
    '00281101': 'RedPaletteColorLookupTableDescriptor',
    '00281102': 'GreenPaletteColorLookupTableDescriptor',
    '00281103': 'BluePaletteColorLookupTableDescriptor',
    '00281104': 'AlphaPaletteColorLookupTableDescriptor',
    '00281111': 'LargeRedPaletteColorLookupTableDescriptor',
    '00281112': 'LargeGreenPaletteColorLookupTableDescriptor',
    '00281113': 'LargeBluePaletteColorLookupTableDescriptor',
    '00281199': 'PaletteColorLookupTableUID',
    '00281200': 'GrayLookupTableData',
    '00281201': 'RedPaletteColorLookupTableData',
    '00281202': 'GreenPaletteColorLookupTableData',
    '00281203': 'BluePaletteColorLookupTableData',
    '00281204': 'AlphaPaletteColorLookupTableData',
    '00281211': 'LargeRedPaletteColorLookupTableData',
    '00281212': 'LargeGreenPaletteColorLookupTableData',
    '00281213': 'LargeBluePaletteColorLookupTableData',
    '00281214': 'LargePaletteColorLookupTableUID',
    '00281221': 'SegmentedRedPaletteColorLookupTableData',
    '00281222': 'SegmentedGreenPaletteColorLookupTableData',
    '00281223': 'SegmentedBluePaletteColorLookupTableData',
    '00281224': 'SegmentedAlphaPaletteColorLookupTableData',
    '00281230': 'StoredValueColorRangeSequence',
    '00281231': 'MinimumStoredValueMapped',
    '00281232': 'MaximumStoredValueMapped',
    '00281300': 'BreastImplantPresent',
    '00281350': 'PartialView',
    '00281351': 'PartialViewDescription',
    '00281352': 'PartialViewCodeSequence',
    '0028135A': 'SpatialLocationsPreserved',
    '00281401': 'DataFrameAssignmentSequence',
    '00281402': 'DataPathAssignment',
    '00281403': 'BitsMappedToColorLookupTable',
    '00281404': ('BlendingLUT1Sequence'),
    '00281405': ('BlendingLUT1TransferFunction'),
    '00281406': 'BlendingWeightConstant',
    '00281407': 'BlendingLookupTableDescriptor',
    '00281408': 'BlendingLookupTableData',
    '0028140B': 'EnhancedPaletteColorLookupTableSequence',
    '0028140C': ('BlendingLUT2Sequence'),
    '0028140D': ('BlendingLUT2TransferFunction'),
    '0028140E': 'DataPathID',
    '0028140F': 'RGBLUTTransferFunction',
    '00281410': 'AlphaLUTTransferFunction',
    '00282000': 'ICCProfile',
    '00282002': 'ColorSpace',
    '00282110': 'LossyImageCompression',
    '00282112': 'LossyImageCompressionRatio',
    '00282114': 'LossyImageCompressionMethod',
    '00283000': 'ModalityLUTSequence',
    '00283002': 'LUTDescriptor',
    '00283003': 'LUTExplanation',
    '00283004': 'ModalityLUTType',
    '00283006': 'LUTData',
    '00283010': 'VOILUTSequence',
    '00283110': 'SoftcopyVOILUTSequence',
    '00284000': 'ImagePresentationComments',
    '00285000': 'BiPlaneAcquisitionSequence',
    '00286010': 'RepresentativeFrameNumber',
    '00286020': 'FrameNumbersOfInterest',
    '00286022': 'FrameOfInterestDescription',
    '00286023': 'FrameOfInterestType',
    '00286030': 'MaskPointers',
    '00286040': 'RWavePointer',
    '00286100': 'MaskSubtractionSequence',
    '00286101': 'MaskOperation',
    '00286102': 'ApplicableFrameRange',
    '00286110': 'MaskFrameNumbers',
    '00286112': 'ContrastFrameAveraging',
    '00286114': 'MaskSubPixelShift',
    '00286120': 'TIDOffset',
    '00286190': 'MaskOperationExplanation',
    '00287000': 'EquipmentAdministratorSequence',
    '00287001': 'NumberOfDisplaySubsystems',
    '00287002': 'CurrentConfigurationID',
    '00287003': 'DisplaySubsystemID',
    '00287004': 'DisplaySubsystemName',
    '00287005': 'DisplaySubsystemDescription',
    '00287006': 'SystemStatus',
    '00287007': 'SystemStatusComment',
    '00287008': 'TargetLuminanceCharacteristicsSequence',
    '00287009': 'LuminanceCharacteristicsID',
    '0028700A': 'DisplaySubsystemConfigurationSequence',
    '0028700B': 'ConfigurationID',
    '0028700C': 'ConfigurationName',
    '0028700D': 'ConfigurationDescription',
    '0028700E': 'ReferencedTargetLuminanceCharacteristicsID',
    '0028700F': 'QAResultsSequence',
    '00287010': 'DisplaySubsystemQAResultsSequence',
    '00287011': 'ConfigurationQAResultsSequence',
    '00287012': 'MeasurementEquipmentSequence',
    '00287013': 'MeasurementFunctions',
    '00287014': 'MeasurementEquipmentType',
    '00287015': 'VisualEvaluationResultSequence',
    '00287016': 'DisplayCalibrationResultSequence',
    '00287017': 'DDLValue',
    '00287018': 'CIExyWhitePoint',
    '00287019': 'DisplayFunctionType',
    '0028701A': 'GammaValue',
    '0028701B': 'NumberOfLuminancePoints',
    '0028701C': 'LuminanceResponseSequence',
    '0028701D': 'TargetMinimumLuminance',
    '0028701E': 'TargetMaximumLuminance',
    '0028701F': 'LuminanceValue',
    '00287020': 'LuminanceResponseDescription',
    '00287021': 'WhitePointFlag',
    '00287022': 'DisplayDeviceTypeCodeSequence',
    '00287023': 'DisplaySubsystemSequence',
    '00287024': 'LuminanceResultSequence',
    '00287025': 'AmbientLightValueSource',
    '00287026': 'MeasuredCharacteristics',
    '00287027': 'LuminanceUniformityResultSequence',
    '00287028': 'VisualEvaluationTestSequence',
    '00287029': 'TestResult',
    '0028702A': 'TestResultComment',
    '0028702B': 'TestImageValidation',
    '0028702C': 'TestPatternCodeSequence',
    '0028702D': 'MeasurementPatternCodeSequence',
    '0028702E': 'VisualEvaluationMethodCodeSequence',
    '00287FE0': 'PixelDataProviderURL',
    '00289001': 'DataPointRows',
    '00289002': 'DataPointColumns',
    '00289003': 'SignalDomainColumns',
    '00289099': 'LargestMonochromePixelValue',
    '00289108': 'DataRepresentation',
    '00289110': 'PixelMeasuresSequence',
    '00289132': 'FrameVOILUTSequence',
    '00289145': 'PixelValueTransformationSequence',
    '00289235': 'SignalDomainRows',
    '00289411': 'DisplayFilterPercentage',
    '00289415': 'FramePixelShiftSequence',
    '00289416': 'SubtractionItemID',
    '00289422': 'PixelIntensityRelationshipLUTSequence',
    '00289443': 'FramePixelDataPropertiesSequence',
    '00289444': 'GeometricalProperties',
    '00289445': 'GeometricMaximumDistortion',
    '00289446': 'ImageProcessingApplied',
    '00289454': 'MaskSelectionMode',
    '00289474': 'LUTFunction',
    '00289478': 'MaskVisibilityPercentage',
    '00289501': 'PixelShiftSequence',
    '00289502': 'RegionPixelShiftSequence',
    '00289503': 'VerticesOfTheRegion',
    '00289505': 'MultiFramePresentationSequence',
    '00289506': 'PixelShiftFrameRange',
    '00289507': 'LUTFrameRange',
    '00289520': 'ImageToEquipmentMappingMatrix',
    '00289537': 'EquipmentCoordinateSystemIdentification',
    '0032000A': 'StudyStatusID',
    '0032000C': 'StudyPriorityID',
    '00320012': 'StudyIDIssuer',
    '00320032': 'StudyVerifiedDate',
    '00320033': 'StudyVerifiedTime',
    '00320034': 'StudyReadDate',
    '00320035': 'StudyReadTime',
    '00321000': 'ScheduledStudyStartDate',
    '00321001': 'ScheduledStudyStartTime',
    '00321010': 'ScheduledStudyStopDate',
    '00321011': 'ScheduledStudyStopTime',
    '00321020': 'ScheduledStudyLocation',
    '00321021': 'ScheduledStudyLocationAETitle',
    '00321030': 'ReasonForStudy',
    '00321031': 'RequestingPhysicianIdentificationSequence',
    '00321032': 'RequestingPhysician',
    '00321033': 'RequestingService',
    '00321034': 'RequestingServiceCodeSequence',
    '00321040': 'StudyArrivalDate',
    '00321041': 'StudyArrivalTime',
    '00321050': 'StudyCompletionDate',
    '00321051': 'StudyCompletionTime',
    '00321055': 'StudyComponentStatusID',
    '00321060': 'RequestedProcedureDescription',
    '00321064': 'RequestedProcedureCodeSequence',
    '00321070': 'RequestedContrastAgent',
    '00324000': 'StudyComments',
    '00380004': 'ReferencedPatientAliasSequence',
    '00380008': 'VisitStatusID',
    '00380010': 'AdmissionID',
    '00380011': 'IssuerOfAdmissionID',
    '00380014': 'IssuerOfAdmissionIDSequence',
    '00380016': 'RouteOfAdmissions',
    '0038001A': 'ScheduledAdmissionDate',
    '0038001B': 'ScheduledAdmissionTime',
    '0038001C': 'ScheduledDischargeDate',
    '0038001D': 'ScheduledDischargeTime',
    '0038001E': 'ScheduledPatientInstitutionResidence',
    '00380020': 'AdmittingDate',
    '00380021': 'AdmittingTime',
    '00380030': 'DischargeDate',
    '00380032': 'DischargeTime',
    '00380040': 'DischargeDiagnosisDescription',
    '00380044': 'DischargeDiagnosisCodeSequence',
    '00380050': 'SpecialNeeds',
    '00380060': 'ServiceEpisodeID',
    '00380061': 'IssuerOfServiceEpisodeID',
    '00380062': 'ServiceEpisodeDescription',
    '00380064': 'IssuerOfServiceEpisodeIDSequence',
    '00380100': 'PertinentDocumentsSequence',
    '00380101': 'PertinentResourcesSequence',
    '00380102': 'ResourceDescription',
    '00380300': 'CurrentPatientLocation',
    '00380400': 'PatientInstitutionResidence',
    '00380500': 'PatientState',
    '00380502': 'PatientClinicalTrialParticipationSequence',
    '00384000': 'VisitComments',
    '003A0004': 'WaveformOriginality',
    '003A0005': 'NumberOfWaveformChannels',
    '003A0010': 'NumberOfWaveformSamples',
    '003A001A': 'SamplingFrequency',
    '003A0020': 'MultiplexGroupLabel',
    '003A0200': 'ChannelDefinitionSequence',
    '003A0202': 'WaveformChannelNumber',
    '003A0203': 'ChannelLabel',
    '003A0205': 'ChannelStatus',
    '003A0208': 'ChannelSourceSequence',
    '003A0209': 'ChannelSourceModifiersSequence',
    '003A020A': 'SourceWaveformSequence',
    '003A020C': 'ChannelDerivationDescription',
    '003A0210': 'ChannelSensitivity',
    '003A0211': 'ChannelSensitivityUnitsSequence',
    '003A0212': 'ChannelSensitivityCorrectionFactor',
    '003A0213': 'ChannelBaseline',
    '003A0214': 'ChannelTimeSkew',
    '003A0215': 'ChannelSampleSkew',
    '003A0218': 'ChannelOffset',
    '003A021A': 'WaveformBitsStored',
    '003A0220': 'FilterLowFrequency',
    '003A0221': 'FilterHighFrequency',
    '003A0222': 'NotchFilterFrequency',
    '003A0223': 'NotchFilterBandwidth',
    '003A0230': 'WaveformDataDisplayScale',
    '003A0231': 'WaveformDisplayBackgroundCIELabValue',
    '003A0240': 'WaveformPresentationGroupSequence',
    '003A0241': 'PresentationGroupNumber',
    '003A0242': 'ChannelDisplaySequence',
    '003A0244': 'ChannelRecommendedDisplayCIELabValue',
    '003A0245': 'ChannelPosition',
    '003A0246': 'DisplayShadingFlag',
    '003A0247': 'FractionalChannelDisplayScale',
    '003A0248': 'AbsoluteChannelDisplayScale',
    '003A0300': 'MultiplexedAudioChannelsDescriptionCodeSequence',
    '003A0301': 'ChannelIdentificationCode',
    '003A0302': 'ChannelMode',
    '00400001': 'ScheduledStationAETitle',
    '00400002': 'ScheduledProcedureStepStartDate',
    '00400003': 'ScheduledProcedureStepStartTime',
    '00400004': 'ScheduledProcedureStepEndDate',
    '00400005': 'ScheduledProcedureStepEndTime',
    '00400006': 'ScheduledPerformingPhysicianName',
    '00400007': 'ScheduledProcedureStepDescription',
    '00400008': 'ScheduledProtocolCodeSequence',
    '00400009': 'ScheduledProcedureStepID',
    '0040000A': 'StageCodeSequence',
    '0040000B': 'ScheduledPerformingPhysicianIdentificationSequence',
    '00400010': 'ScheduledStationName',
    '00400011': 'ScheduledProcedureStepLocation',
    '00400012': 'PreMedication',
    '00400020': 'ScheduledProcedureStepStatus',
    '00400026': 'OrderPlacerIdentifierSequence',
    '00400027': 'OrderFillerIdentifierSequence',
    '00400031': 'LocalNamespaceEntityID',
    '00400032': 'UniversalEntityID',
    '00400033': 'UniversalEntityIDType',
    '00400035': 'IdentifierTypeCode',
    '00400036': 'AssigningFacilitySequence',
    '00400039': 'AssigningJurisdictionCodeSequence',
    '0040003A': 'AssigningAgencyOrDepartmentCodeSequence',
    '00400100': 'ScheduledProcedureStepSequence',
    '00400220': 'ReferencedNonImageCompositeSOPInstanceSequence',
    '00400241': 'PerformedStationAETitle',
    '00400242': 'PerformedStationName',
    '00400243': 'PerformedLocation',
    '00400244': 'PerformedProcedureStepStartDate',
    '00400245': 'PerformedProcedureStepStartTime',
    '00400250': 'PerformedProcedureStepEndDate',
    '00400251': 'PerformedProcedureStepEndTime',
    '00400252': 'PerformedProcedureStepStatus',
    '00400253': 'PerformedProcedureStepID',
    '00400254': 'PerformedProcedureStepDescription',
    '00400255': 'PerformedProcedureTypeDescription',
    '00400260': 'PerformedProtocolCodeSequence',
    '00400261': 'PerformedProtocolType',
    '00400270': 'ScheduledStepAttributesSequence',
    '00400275': 'RequestAttributesSequence',
    '00400280': 'CommentsOnThePerformedProcedureStep',
    '00400281': 'PerformedProcedureStepDiscontinuationReasonCodeSequence',
    '00400293': 'QuantitySequence',
    '00400294': 'Quantity',
    '00400295': 'MeasuringUnitsSequence',
    '00400296': 'BillingItemSequence',
    '00400300': 'TotalTimeOfFluoroscopy',
    '00400301': 'TotalNumberOfExposures',
    '00400302': 'EntranceDose',
    '00400303': 'ExposedArea',
    '00400306': 'DistanceSourceToEntrance',
    '00400307': 'DistanceSourceToSupport',
    '0040030E': 'ExposureDoseSequence',
    '00400310': 'CommentsOnRadiationDose',
    '00400312': 'XRayOutput',
    '00400314': 'HalfValueLayer',
    '00400316': 'OrganDose',
    '00400318': 'OrganExposed',
    '00400320': 'BillingProcedureStepSequence',
    '00400321': 'FilmConsumptionSequence',
    '00400324': 'BillingSuppliesAndDevicesSequence',
    '00400330': 'ReferencedProcedureStepSequence',
    '00400340': 'PerformedSeriesSequence',
    '00400400': 'CommentsOnTheScheduledProcedureStep',
    '00400440': 'ProtocolContextSequence',
    '00400441': 'ContentItemModifierSequence',
    '00400500': 'ScheduledSpecimenSequence',
    '0040050A': 'SpecimenAccessionNumber',
    '00400512': 'ContainerIdentifier',
    '00400513': 'IssuerOfTheContainerIdentifierSequence',
    '00400515': 'AlternateContainerIdentifierSequence',
    '00400518': 'ContainerTypeCodeSequence',
    '0040051A': 'ContainerDescription',
    '00400520': 'ContainerComponentSequence',
    '00400550': 'SpecimenSequence',
    '00400551': 'SpecimenIdentifier',
    '00400552': 'SpecimenDescriptionSequenceTrial',
    '00400553': 'SpecimenDescriptionTrial',
    '00400554': 'SpecimenUID',
    '00400555': 'AcquisitionContextSequence',
    '00400556': 'AcquisitionContextDescription',
    '00400560': 'SpecimenDescriptionSequence',
    '00400562': 'IssuerOfTheSpecimenIdentifierSequence',
    '0040059A': 'SpecimenTypeCodeSequence',
    '00400600': 'SpecimenShortDescription',
    '00400602': 'SpecimenDetailedDescription',
    '00400610': 'SpecimenPreparationSequence',
    '00400612': 'SpecimenPreparationStepContentItemSequence',
    '00400620': 'SpecimenLocalizationContentItemSequence',
    '004006FA': 'SlideIdentifier',
    '00400710': 'WholeSlideMicroscopyImageFrameTypeSequence',
    '0040071A': 'ImageCenterPointCoordinatesSequence',
    '0040072A': 'XOffsetInSlideCoordinateSystem',
    '0040073A': 'YOffsetInSlideCoordinateSystem',
    '0040074A': 'ZOffsetInSlideCoordinateSystem',
    '004008D8': 'PixelSpacingSequence',
    '004008DA': 'CoordinateSystemAxisCodeSequence',
    '004008EA': 'MeasurementUnitsCodeSequence',
    '004009F8': 'VitalStainCodeSequenceTrial',
    '00401001': 'RequestedProcedureID',
    '00401002': 'ReasonForTheRequestedProcedure',
    '00401003': 'RequestedProcedurePriority',
    '00401004': 'PatientTransportArrangements',
    '00401005': 'RequestedProcedureLocation',
    '00401006': 'PlacerOrderNumberProcedure',
    '00401007': 'FillerOrderNumberProcedure',
    '00401008': 'ConfidentialityCode',
    '00401009': 'ReportingPriority',
    '0040100A': 'ReasonForRequestedProcedureCodeSequence',
    '00401010': 'NamesOfIntendedRecipientsOfResults',
    '00401011': 'IntendedRecipientsOfResultsIdentificationSequence',
    '00401012': 'ReasonForPerformedProcedureCodeSequence',
    '00401060': 'RequestedProcedureDescriptionTrial',
    '00401101': 'PersonIdentificationCodeSequence',
    '00401102': 'PersonAddress',
    '00401103': 'PersonTelephoneNumbers',
    '00401104': 'PersonTelecomInformation',
    '00401400': 'RequestedProcedureComments',
    '00402001': 'ReasonForTheImagingServiceRequest',
    '00402004': 'IssueDateOfImagingServiceRequest',
    '00402005': 'IssueTimeOfImagingServiceRequest',
    '00402006': 'PlacerOrderNumberImagingServiceRequestRetired',
    '00402007': 'FillerOrderNumberImagingServiceRequestRetired',
    '00402008': 'OrderEnteredBy',
    '00402009': 'OrderEntererLocation',
    '00402010': 'OrderCallbackPhoneNumber',
    '00402011': 'OrderCallbackTelecomInformation',
    '00402016': 'PlacerOrderNumberImagingServiceRequest',
    '00402017': 'FillerOrderNumberImagingServiceRequest',
    '00402400': 'ImagingServiceRequestComments',
    '00403001': 'ConfidentialityConstraintOnPatientDataDescription',
    '00404001': 'GeneralPurposeScheduledProcedureStepStatus',
    '00404002': 'GeneralPurposePerformedProcedureStepStatus',
    '00404003': 'GeneralPurposeScheduledProcedureStepPriority',
    '00404004': 'ScheduledProcessingApplicationsCodeSequence',
    '00404005': 'ScheduledProcedureStepStartDateTime',
    '00404006': 'MultipleCopiesFlag',
    '00404007': 'PerformedProcessingApplicationsCodeSequence',
    '00404008': 'ScheduledProcedureStepExpirationDateTime',
    '00404009': 'HumanPerformerCodeSequence',
    '00404010': 'ScheduledProcedureStepModificationDateTime',
    '00404011': 'ExpectedCompletionDateTime',
    '00404015': 'ResultingGeneralPurposePerformedProcedureStepsSequence',
    '00404016': 'ReferencedGeneralPurposeScheduledProcedureStepSequence',
    '00404018': 'ScheduledWorkitemCodeSequence',
    '00404019': 'PerformedWorkitemCodeSequence',
    '00404020': 'InputAvailabilityFlag',
    '00404021': 'InputInformationSequence',
    '00404022': 'RelevantInformationSequence',
    '00404023': 'ReferencedGeneralPurposeScheduledProcedureStepTransactionUID',
    '00404025': 'ScheduledStationNameCodeSequence',
    '00404026': 'ScheduledStationClassCodeSequence',
    '00404027': 'ScheduledStationGeographicLocationCodeSequence',
    '00404028': 'PerformedStationNameCodeSequence',
    '00404029': 'PerformedStationClassCodeSequence',
    '00404030': 'PerformedStationGeographicLocationCodeSequence',
    '00404031': 'RequestedSubsequentWorkitemCodeSequence',
    '00404032': 'NonDICOMOutputCodeSequence',
    '00404033': 'OutputInformationSequence',
    '00404034': 'ScheduledHumanPerformersSequence',
    '00404035': 'ActualHumanPerformersSequence',
    '00404036': 'HumanPerformerOrganization',
    '00404037': 'HumanPerformerName',
    '00404040': 'RawDataHandling',
    '00404041': 'InputReadinessState',
    '00404050': 'PerformedProcedureStepStartDateTime',
    '00404051': 'PerformedProcedureStepEndDateTime',
    '00404052': 'ProcedureStepCancellationDateTime',
    '00404070': 'OutputDestinationSequence',
    '00404071': 'DICOMStorageSequence',
    '00404072': 'STOWRSStorageSequence',
    '00404073': 'StorageURL',
    '00404074': 'XDSStorageSequence',
    '00408302': 'EntranceDoseInmGy',
    '00408303': 'EntranceDoseDerivation',
    '00409092': 'ParametricMapFrameTypeSequence',
    '00409094': 'ReferencedImageRealWorldValueMappingSequence',
    '00409096': 'RealWorldValueMappingSequence',
    '00409098': 'PixelValueMappingCodeSequence',
    '00409210': 'LUTLabel',
    '00409211': 'RealWorldValueLastValueMapped',
    '00409212': 'RealWorldValueLUTData',
    '00409213': 'DoubleFloatRealWorldValueLastValueMapped',
    '00409214': 'DoubleFloatRealWorldValueFirstValueMapped',
    '00409216': 'RealWorldValueFirstValueMapped',
    '00409220': 'QuantityDefinitionSequence',
    '00409224': 'RealWorldValueIntercept',
    '00409225': 'RealWorldValueSlope',
    '0040A007': 'FindingsFlagTrial',
    '0040A010': 'RelationshipType',
    '0040A020': 'FindingsSequenceTrial',
    '0040A021': 'FindingsGroupUIDTrial',
    '0040A022': 'ReferencedFindingsGroupUIDTrial',
    '0040A023': 'FindingsGroupRecordingDateTrial',
    '0040A024': 'FindingsGroupRecordingTimeTrial',
    '0040A026': 'FindingsSourceCategoryCodeSequenceTrial',
    '0040A027': 'VerifyingOrganization',
    '0040A028': 'DocumentingOrganizationIdentifierCodeSequenceTrial',
    '0040A030': 'VerificationDateTime',
    '0040A032': 'ObservationDateTime',
    '0040A040': 'ValueType',
    '0040A043': 'ConceptNameCodeSequence',
    '0040A047': 'MeasurementPrecisionDescriptionTrial',
    '0040A050': 'ContinuityOfContent',
    '0040A057': 'UrgencyOrPriorityAlertsTrial',
    '0040A060': 'SequencingIndicatorTrial',
    '0040A066': 'DocumentIdentifierCodeSequenceTrial',
    '0040A067': 'DocumentAuthorTrial',
    '0040A068': 'DocumentAuthorIdentifierCodeSequenceTrial',
    '0040A070': 'IdentifierCodeSequenceTrial',
    '0040A073': 'VerifyingObserverSequence',
    '0040A074': 'ObjectBinaryIdentifierTrial',
    '0040A075': 'VerifyingObserverName',
    '0040A076': 'DocumentingObserverIdentifierCodeSequenceTrial',
    '0040A078': 'AuthorObserverSequence',
    '0040A07A': 'ParticipantSequence',
    '0040A07C': 'CustodialOrganizationSequence',
    '0040A080': 'ParticipationType',
    '0040A082': 'ParticipationDateTime',
    '0040A084': 'ObserverType',
    '0040A085': 'ProcedureIdentifierCodeSequenceTrial',
    '0040A088': 'VerifyingObserverIdentificationCodeSequence',
    '0040A089': 'ObjectDirectoryBinaryIdentifierTrial',
    '0040A090': 'EquivalentCDADocumentSequence',
    '0040A0B0': 'ReferencedWaveformChannels',
    '0040A110': 'DateOfDocumentOrVerbalTransactionTrial',
    '0040A112': 'TimeOfDocumentCreationOrVerbalTransactionTrial',
    '0040A120': 'DateTime',
    '0040A121': 'Date',
    '0040A122': 'Time',
    '0040A123': 'PersonName',
    '0040A124': 'UID',
    '0040A125': 'ReportStatusIDTrial',
    '0040A130': 'TemporalRangeType',
    '0040A132': 'ReferencedSamplePositions',
    '0040A136': 'ReferencedFrameNumbers',
    '0040A138': 'ReferencedTimeOffsets',
    '0040A13A': 'ReferencedDateTime',
    '0040A160': 'TextValue',
    '0040A161': 'FloatingPointValue',
    '0040A162': 'RationalNumeratorValue',
    '0040A163': 'RationalDenominatorValue',
    '0040A167': 'ObservationCategoryCodeSequenceTrial',
    '0040A168': 'ConceptCodeSequence',
    '0040A16A': 'BibliographicCitationTrial',
    '0040A170': 'PurposeOfReferenceCodeSequence',
    '0040A171': 'ObservationUID',
    '0040A172': 'ReferencedObservationUIDTrial',
    '0040A173': 'ReferencedObservationClassTrial',
    '0040A174': 'ReferencedObjectObservationClassTrial',
    '0040A180': 'AnnotationGroupNumber',
    '0040A192': 'ObservationDateTrial',
    '0040A193': 'ObservationTimeTrial',
    '0040A194': 'MeasurementAutomationTrial',
    '0040A195': 'ModifierCodeSequence',
    '0040A224': 'IdentificationDescriptionTrial',
    '0040A290': 'CoordinatesSetGeometricTypeTrial',
    '0040A296': 'AlgorithmCodeSequenceTrial',
    '0040A297': 'AlgorithmDescriptionTrial',
    '0040A29A': 'PixelCoordinatesSetTrial',
    '0040A300': 'MeasuredValueSequence',
    '0040A301': 'NumericValueQualifierCodeSequence',
    '0040A307': 'CurrentObserverTrial',
    '0040A30A': 'NumericValue',
    '0040A313': 'ReferencedAccessionSequenceTrial',
    '0040A33A': 'ReportStatusCommentTrial',
    '0040A340': 'ProcedureContextSequenceTrial',
    '0040A352': 'VerbalSourceTrial',
    '0040A353': 'AddressTrial',
    '0040A354': 'TelephoneNumberTrial',
    '0040A358': 'VerbalSourceIdentifierCodeSequenceTrial',
    '0040A360': 'PredecessorDocumentsSequence',
    '0040A370': 'ReferencedRequestSequence',
    '0040A372': 'PerformedProcedureCodeSequence',
    '0040A375': 'CurrentRequestedProcedureEvidenceSequence',
    '0040A380': 'ReportDetailSequenceTrial',
    '0040A385': 'PertinentOtherEvidenceSequence',
    '0040A390': ('HL7StructuredDocumentReferenceSequence'),
    '0040A402': 'ObservationSubjectUIDTrial',
    '0040A403': 'ObservationSubjectClassTrial',
    '0040A404': 'ObservationSubjectTypeCodeSequenceTrial',
    '0040A491': 'CompletionFlag',
    '0040A492': 'CompletionFlagDescription',
    '0040A493': 'VerificationFlag',
    '0040A494': 'ArchiveRequested',
    '0040A496': 'PreliminaryFlag',
    '0040A504': 'ContentTemplateSequence',
    '0040A525': 'IdenticalDocumentsSequence',
    '0040A600': 'ObservationSubjectContextFlagTrial',
    '0040A601': 'ObserverContextFlagTrial',
    '0040A603': 'ProcedureContextFlagTrial',
    '0040A730': 'ContentSequence',
    '0040A731': 'RelationshipSequenceTrial',
    '0040A732': 'RelationshipTypeCodeSequenceTrial',
    '0040A744': 'LanguageCodeSequenceTrial',
    '0040A992': 'UniformResourceLocatorTrial',
    '0040B020': 'WaveformAnnotationSequence',
    '0040DB00': 'TemplateIdentifier',
    '0040DB06': 'TemplateVersion',
    '0040DB07': 'TemplateLocalVersion',
    '0040DB0B': 'TemplateExtensionFlag',
    '0040DB0C': 'TemplateExtensionOrganizationUID',
    '0040DB0D': 'TemplateExtensionCreatorUID',
    '0040DB73': 'ReferencedContentItemIdentifier',
    '0040E001': ('HL7InstanceIdentifier'),
    '0040E004': ('HL7DocumentEffectiveTime'),
    '0040E006': ('HL7DocumentTypeCodeSequence'),
    '0040E008': 'DocumentClassCodeSequence',
    '0040E010': 'RetrieveURI',
    '0040E011': 'RetrieveLocationUID',
    '0040E020': 'TypeOfInstances',
    '0040E021': 'DICOMRetrievalSequence',
    '0040E022': 'DICOMMediaRetrievalSequence',
    '0040E023': 'WADORetrievalSequence',
    '0040E024': 'XDSRetrievalSequence',
    '0040E025': 'WADORSRetrievalSequence',
    '0040E030': 'RepositoryUniqueID',
    '0040E031': 'HomeCommunityID',
    '00420010': 'DocumentTitle',
    '00420011': 'EncapsulatedDocument',
    '00420012': 'MIMETypeOfEncapsulatedDocument',
    '00420013': 'SourceInstanceSequence',
    '00420014': 'ListOfMIMETypes',
    '00440001': 'ProductPackageIdentifier',
    '00440002': 'SubstanceAdministrationApproval',
    '00440003': 'ApprovalStatusFurtherDescription',
    '00440004': 'ApprovalStatusDateTime',
    '00440007': 'ProductTypeCodeSequence',
    '00440008': 'ProductName',
    '00440009': 'ProductDescription',
    '0044000A': 'ProductLotIdentifier',
    '0044000B': 'ProductExpirationDateTime',
    '00440010': 'SubstanceAdministrationDateTime',
    '00440011': 'SubstanceAdministrationNotes',
    '00440012': 'SubstanceAdministrationDeviceID',
    '00440013': 'ProductParameterSequence',
    '00440019': 'SubstanceAdministrationParameterSequence',
    '00440100': 'ApprovalSequence',
    '00440101': 'AssertionCodeSequence',
    '00440102': 'AssertionUID',
    '00440103': 'AsserterIdentificationSequence',
    '00440104': 'AssertionDateTime',
    '00440105': 'AssertionExpirationDateTime',
    '00440106': 'AssertionComments',
    '00440107': 'RelatedAssertionSequence',
    '00440108': 'ReferencedAssertionUID',
    '00440109': 'ApprovalSubjectSequence',
    '0044010A': 'OrganizationalRoleCodeSequence',
    '00460012': 'LensDescription',
    '00460014': 'RightLensSequence',
    '00460015': 'LeftLensSequence',
    '00460016': 'UnspecifiedLateralityLensSequence',
    '00460018': 'CylinderSequence',
    '00460028': 'PrismSequence',
    '00460030': 'HorizontalPrismPower',
    '00460032': 'HorizontalPrismBase',
    '00460034': 'VerticalPrismPower',
    '00460036': 'VerticalPrismBase',
    '00460038': 'LensSegmentType',
    '00460040': 'OpticalTransmittance',
    '00460042': 'ChannelWidth',
    '00460044': 'PupilSize',
    '00460046': 'CornealSize',
    '00460050': 'AutorefractionRightEyeSequence',
    '00460052': 'AutorefractionLeftEyeSequence',
    '00460060': 'DistancePupillaryDistance',
    '00460062': 'NearPupillaryDistance',
    '00460063': 'IntermediatePupillaryDistance',
    '00460064': 'OtherPupillaryDistance',
    '00460070': 'KeratometryRightEyeSequence',
    '00460071': 'KeratometryLeftEyeSequence',
    '00460074': 'SteepKeratometricAxisSequence',
    '00460075': 'RadiusOfCurvature',
    '00460076': 'KeratometricPower',
    '00460077': 'KeratometricAxis',
    '00460080': 'FlatKeratometricAxisSequence',
    '00460092': 'BackgroundColor',
    '00460094': 'Optotype',
    '00460095': 'OptotypePresentation',
    '00460097': 'SubjectiveRefractionRightEyeSequence',
    '00460098': 'SubjectiveRefractionLeftEyeSequence',
    '00460100': 'AddNearSequence',
    '00460101': 'AddIntermediateSequence',
    '00460102': 'AddOtherSequence',
    '00460104': 'AddPower',
    '00460106': 'ViewingDistance',
    '00460121': 'VisualAcuityTypeCodeSequence',
    '00460122': 'VisualAcuityRightEyeSequence',
    '00460123': 'VisualAcuityLeftEyeSequence',
    '00460124': 'VisualAcuityBothEyesOpenSequence',
    '00460125': 'ViewingDistanceType',
    '00460135': 'VisualAcuityModifiers',
    '00460137': 'DecimalVisualAcuity',
    '00460139': 'OptotypeDetailedDefinition',
    '00460145': 'ReferencedRefractiveMeasurementsSequence',
    '00460146': 'SpherePower',
    '00460147': 'CylinderPower',
    '00460201': 'CornealTopographySurface',
    '00460202': 'CornealVertexLocation',
    '00460203': 'PupilCentroidXCoordinate',
    '00460204': 'PupilCentroidYCoordinate',
    '00460205': 'EquivalentPupilRadius',
    '00460207': 'CornealTopographyMapTypeCodeSequence',
    '00460208': 'VerticesOfTheOutlineOfPupil',
    '00460210': 'CornealTopographyMappingNormalsSequence',
    '00460211': 'MaximumCornealCurvatureSequence',
    '00460212': 'MaximumCornealCurvature',
    '00460213': 'MaximumCornealCurvatureLocation',
    '00460215': 'MinimumKeratometricSequence',
    '00460218': 'SimulatedKeratometricCylinderSequence',
    '00460220': 'AverageCornealPower',
    '00460224': 'CornealISValue',
    '00460227': 'AnalyzedArea',
    '00460230': 'SurfaceRegularityIndex',
    '00460232': 'SurfaceAsymmetryIndex',
    '00460234': 'CornealEccentricityIndex',
    '00460236': 'KeratoconusPredictionIndex',
    '00460238': 'DecimalPotentialVisualAcuity',
    '00460242': 'CornealTopographyMapQualityEvaluation',
    '00460244': 'SourceImageCornealProcessedDataSequence',
    '00460247': 'CornealPointLocation',
    '00460248': 'CornealPointEstimated',
    '00460249': 'AxialPower',
    '00460250': 'TangentialPower',
    '00460251': 'RefractivePower',
    '00460252': 'RelativeElevation',
    '00460253': 'CornealWavefront',
    '00480001': 'ImagedVolumeWidth',
    '00480002': 'ImagedVolumeHeight',
    '00480003': 'ImagedVolumeDepth',
    '00480006': 'TotalPixelMatrixColumns',
    '00480007': 'TotalPixelMatrixRows',
    '00480008': 'TotalPixelMatrixOriginSequence',
    '00480010': 'SpecimenLabelInImage',
    '00480011': 'FocusMethod',
    '00480012': 'ExtendedDepthOfField',
    '00480013': 'NumberOfFocalPlanes',
    '00480014': 'DistanceBetweenFocalPlanes',
    '00480015': 'RecommendedAbsentPixelCIELabValue',
    '00480100': 'IlluminatorTypeCodeSequence',
    '00480102': 'ImageOrientationSlide',
    '00480105': 'OpticalPathSequence',
    '00480106': 'OpticalPathIdentifier',
    '00480107': 'OpticalPathDescription',
    '00480108': 'IlluminationColorCodeSequence',
    '00480110': 'SpecimenReferenceSequence',
    '00480111': 'CondenserLensPower',
    '00480112': 'ObjectiveLensPower',
    '00480113': 'ObjectiveLensNumericalAperture',
    '00480120': 'PaletteColorLookupTableSequence',
    '00480200': 'ReferencedImageNavigationSequence',
    '00480201': 'TopLeftHandCornerOfLocalizerArea',
    '00480202': 'BottomRightHandCornerOfLocalizerArea',
    '00480207': 'OpticalPathIdentificationSequence',
    '0048021A': 'PlanePositionSlideSequence',
    '0048021E': 'ColumnPositionInTotalImagePixelMatrix',
    '0048021F': 'RowPositionInTotalImagePixelMatrix',
    '00480301': 'PixelOriginInterpretation',
    '00480302': 'NumberOfOpticalPaths',
    '00480303': 'TotalPixelMatrixFocalPlanes',
    '00500004': 'CalibrationImage',
    '00500010': 'DeviceSequence',
    '00500012': 'ContainerComponentTypeCodeSequence',
    '00500013': 'ContainerComponentThickness',
    '00500014': 'DeviceLength',
    '00500015': 'ContainerComponentWidth',
    '00500016': 'DeviceDiameter',
    '00500017': 'DeviceDiameterUnits',
    '00500018': 'DeviceVolume',
    '00500019': 'InterMarkerDistance',
    '0050001A': 'ContainerComponentMaterial',
    '0050001B': 'ContainerComponentID',
    '0050001C': 'ContainerComponentLength',
    '0050001D': 'ContainerComponentDiameter',
    '0050001E': 'ContainerComponentDescription',
    '00500020': 'DeviceDescription',
    '00520001': 'ContrastBolusIngredientPercentByVolume',
    '00520002': 'OCTFocalDistance',
    '00520003': 'BeamSpotSize',
    '00520004': 'EffectiveRefractiveIndex',
    '00520006': 'OCTAcquisitionDomain',
    '00520007': 'OCTOpticalCenterWavelength',
    '00520008': 'AxialResolution',
    '00520009': 'RangingDepth',
    '00520011': 'ALineRate',
    '00520012': 'ALinesPerFrame',
    '00520013': 'CatheterRotationalRate',
    '00520014': 'ALinePixelSpacing',
    '00520016': 'ModeOfPercutaneousAccessSequence',
    '00520025': 'IntravascularOCTFrameTypeSequence',
    '00520026': 'OCTZOffsetApplied',
    '00520027': 'IntravascularFrameContentSequence',
    '00520028': 'IntravascularLongitudinalDistance',
    '00520029': 'IntravascularOCTFrameContentSequence',
    '00520030': 'OCTZOffsetCorrection',
    '00520031': 'CatheterDirectionOfRotation',
    '00520033': 'SeamLineLocation',
    '00520034': 'FirstALineLocation',
    '00520036': 'SeamLineIndex',
    '00520038': 'NumberOfPaddedALines',
    '00520039': 'InterpolationType',
    '0052003A': 'RefractiveIndexApplied',
    '00540010': 'EnergyWindowVector',
    '00540011': 'NumberOfEnergyWindows',
    '00540012': 'EnergyWindowInformationSequence',
    '00540013': 'EnergyWindowRangeSequence',
    '00540014': 'EnergyWindowLowerLimit',
    '00540015': 'EnergyWindowUpperLimit',
    '00540016': 'RadiopharmaceuticalInformationSequence',
    '00540017': 'ResidualSyringeCounts',
    '00540018': 'EnergyWindowName',
    '00540020': 'DetectorVector',
    '00540021': 'NumberOfDetectors',
    '00540022': 'DetectorInformationSequence',
    '00540030': 'PhaseVector',
    '00540031': 'NumberOfPhases',
    '00540032': 'PhaseInformationSequence',
    '00540033': 'NumberOfFramesInPhase',
    '00540036': 'PhaseDelay',
    '00540038': 'PauseBetweenFrames',
    '00540039': 'PhaseDescription',
    '00540050': 'RotationVector',
    '00540051': 'NumberOfRotations',
    '00540052': 'RotationInformationSequence',
    '00540053': 'NumberOfFramesInRotation',
    '00540060': 'RRIntervalVector',
    '00540061': 'NumberOfRRIntervals',
    '00540062': 'GatedInformationSequence',
    '00540063': 'DataInformationSequence',
    '00540070': 'TimeSlotVector',
    '00540071': 'NumberOfTimeSlots',
    '00540072': 'TimeSlotInformationSequence',
    '00540073': 'TimeSlotTime',
    '00540080': 'SliceVector',
    '00540081': 'NumberOfSlices',
    '00540090': 'AngularViewVector',
    '00540100': 'TimeSliceVector',
    '00540101': 'NumberOfTimeSlices',
    '00540200': 'StartAngle',
    '00540202': 'TypeOfDetectorMotion',
    '00540210': 'TriggerVector',
    '00540211': 'NumberOfTriggersInPhase',
    '00540220': 'ViewCodeSequence',
    '00540222': 'ViewModifierCodeSequence',
    '00540300': 'RadionuclideCodeSequence',
    '00540302': 'AdministrationRouteCodeSequence',
    '00540304': 'RadiopharmaceuticalCodeSequence',
    '00540306': 'CalibrationDataSequence',
    '00540308': 'EnergyWindowNumber',
    '00540400': 'ImageID',
    '00540410': 'PatientOrientationCodeSequence',
    '00540412': 'PatientOrientationModifierCodeSequence',
    '00540414': 'PatientGantryRelationshipCodeSequence',
    '00540500': 'SliceProgressionDirection',
    '00540501': 'ScanProgressionDirection',
    '00541000': 'SeriesType',
    '00541001': 'Units',
    '00541002': 'CountsSource',
    '00541004': 'ReprojectionMethod',
    '00541006': 'SUVType',
    '00541100': 'RandomsCorrectionMethod',
    '00541101': 'AttenuationCorrectionMethod',
    '00541102': 'DecayCorrection',
    '00541103': 'ReconstructionMethod',
    '00541104': 'DetectorLinesOfResponseUsed',
    '00541105': 'ScatterCorrectionMethod',
    '00541200': 'AxialAcceptance',
    '00541201': 'AxialMash',
    '00541202': 'TransverseMash',
    '00541203': 'DetectorElementSize',
    '00541210': 'CoincidenceWindowWidth',
    '00541220': 'SecondaryCountsType',
    '00541300': 'FrameReferenceTime',
    '00541310': 'PrimaryPromptsCountsAccumulated',
    '00541311': 'SecondaryCountsAccumulated',
    '00541320': 'SliceSensitivityFactor',
    '00541321': 'DecayFactor',
    '00541322': 'DoseCalibrationFactor',
    '00541323': 'ScatterFractionFactor',
    '00541324': 'DeadTimeFactor',
    '00541330': 'ImageIndex',
    '00541400': 'CountsIncluded',
    '00541401': 'DeadTimeCorrectionFlag',
    '00603000': 'HistogramSequence',
    '00603002': 'HistogramNumberOfBins',
    '00603004': 'HistogramFirstBinValue',
    '00603006': 'HistogramLastBinValue',
    '00603008': 'HistogramBinWidth',
    '00603010': 'HistogramExplanation',
    '00603020': 'HistogramData',
    '00620001': 'SegmentationType',
    '00620002': 'SegmentSequence',
    '00620003': 'SegmentedPropertyCategoryCodeSequence',
    '00620004': 'SegmentNumber',
    '00620005': 'SegmentLabel',
    '00620006': 'SegmentDescription',
    '00620007': 'SegmentationAlgorithmIdentificationSequence',
    '00620008': 'SegmentAlgorithmType',
    '00620009': 'SegmentAlgorithmName',
    '0062000A': 'SegmentIdentificationSequence',
    '0062000B': 'ReferencedSegmentNumber',
    '0062000C': 'RecommendedDisplayGrayscaleValue',
    '0062000D': 'RecommendedDisplayCIELabValue',
    '0062000E': 'MaximumFractionalValue',
    '0062000F': 'SegmentedPropertyTypeCodeSequence',
    '00620010': 'SegmentationFractionalType',
    '00620011': 'SegmentedPropertyTypeModifierCodeSequence',
    '00620012': 'UsedSegmentsSequence',
    '00620020': 'TrackingID',
    '00620021': 'TrackingUID',
    '00640002': 'DeformableRegistrationSequence',
    '00640003': 'SourceFrameOfReferenceUID',
    '00640005': 'DeformableRegistrationGridSequence',
    '00640007': 'GridDimensions',
    '00640008': 'GridResolution',
    '00640009': 'VectorGridData',
    '0064000F': 'PreDeformationMatrixRegistrationSequence',
    '00640010': 'PostDeformationMatrixRegistrationSequence',
    '00660001': 'NumberOfSurfaces',
    '00660002': 'SurfaceSequence',
    '00660003': 'SurfaceNumber',
    '00660004': 'SurfaceComments',
    '00660009': 'SurfaceProcessing',
    '0066000A': 'SurfaceProcessingRatio',
    '0066000B': 'SurfaceProcessingDescription',
    '0066000C': 'RecommendedPresentationOpacity',
    '0066000D': 'RecommendedPresentationType',
    '0066000E': 'FiniteVolume',
    '00660010': 'Manifold',
    '00660011': 'SurfacePointsSequence',
    '00660012': 'SurfacePointsNormalsSequence',
    '00660013': 'SurfaceMeshPrimitivesSequence',
    '00660015': 'NumberOfSurfacePoints',
    '00660016': 'PointCoordinatesData',
    '00660017': 'PointPositionAccuracy',
    '00660018': 'MeanPointDistance',
    '00660019': 'MaximumPointDistance',
    '0066001A': 'PointsBoundingBoxCoordinates',
    '0066001B': 'AxisOfRotation',
    '0066001C': 'CenterOfRotation',
    '0066001E': 'NumberOfVectors',
    '0066001F': 'VectorDimensionality',
    '00660020': 'VectorAccuracy',
    '00660021': 'VectorCoordinateData',
    '00660023': 'TrianglePointIndexList',
    '00660024': 'EdgePointIndexList',
    '00660025': 'VertexPointIndexList',
    '00660026': 'TriangleStripSequence',
    '00660027': 'TriangleFanSequence',
    '00660028': 'LineSequence',
    '00660029': 'PrimitivePointIndexList',
    '0066002A': 'SurfaceCount',
    '0066002B': 'ReferencedSurfaceSequence',
    '0066002C': 'ReferencedSurfaceNumber',
    '0066002D': 'SegmentSurfaceGenerationAlgorithmIdentificationSequence',
    '0066002E': 'SegmentSurfaceSourceInstanceSequence',
    '0066002F': 'AlgorithmFamilyCodeSequence',
    '00660030': 'AlgorithmNameCodeSequence',
    '00660031': 'AlgorithmVersion',
    '00660032': 'AlgorithmParameters',
    '00660034': 'FacetSequence',
    '00660035': 'SurfaceProcessingAlgorithmIdentificationSequence',
    '00660036': 'AlgorithmName',
    '00660037': 'RecommendedPointRadius',
    '00660038': 'RecommendedLineThickness',
    '00660040': 'LongPrimitivePointIndexList',
    '00660041': 'LongTrianglePointIndexList',
    '00660042': 'LongEdgePointIndexList',
    '00660043': 'LongVertexPointIndexList',
    '00660101': 'TrackSetSequence',
    '00660102': 'TrackSequence',
    '00660103': 'RecommendedDisplayCIELabValueList',
    '00660104': 'TrackingAlgorithmIdentificationSequence',
    '00660105': 'TrackSetNumber',
    '00660106': 'TrackSetLabel',
    '00660107': 'TrackSetDescription',
    '00660108': 'TrackSetAnatomicalTypeCodeSequence',
    '00660121': 'MeasurementsSequence',
    '00660124': 'TrackSetStatisticsSequence',
    '00660125': 'FloatingPointValues',
    '00660129': 'TrackPointIndexList',
    '00660130': 'TrackStatisticsSequence',
    '00660132': 'MeasurementValuesSequence',
    '00660133': 'DiffusionAcquisitionCodeSequence',
    '00660134': 'DiffusionModelCodeSequence',
    '00686210': 'ImplantSize',
    '00686221': 'ImplantTemplateVersion',
    '00686222': 'ReplacedImplantTemplateSequence',
    '00686223': 'ImplantType',
    '00686224': 'DerivationImplantTemplateSequence',
    '00686225': 'OriginalImplantTemplateSequence',
    '00686226': 'EffectiveDateTime',
    '00686230': 'ImplantTargetAnatomySequence',
    '00686260': 'InformationFromManufacturerSequence',
    '00686265': 'NotificationFromManufacturerSequence',
    '00686270': 'InformationIssueDateTime',
    '00686280': 'InformationSummary',
    '006862A0': 'ImplantRegulatoryDisapprovalCodeSequence',
    '006862A5': 'OverallTemplateSpatialTolerance',
    '006862C0': 'HPGLDocumentSequence',
    '006862D0': 'HPGLDocumentID',
    '006862D5': 'HPGLDocumentLabel',
    '006862E0': 'ViewOrientationCodeSequence',
    '006862F0': 'ViewOrientationModifierCodeSequence',
    '006862F2': 'HPGLDocumentScaling',
    '00686300': 'HPGLDocument',
    '00686310': 'HPGLContourPenNumber',
    '00686320': 'HPGLPenSequence',
    '00686330': 'HPGLPenNumber',
    '00686340': 'HPGLPenLabel',
    '00686345': 'HPGLPenDescription',
    '00686346': 'RecommendedRotationPoint',
    '00686347': 'BoundingRectangle',
    '00686350': ('ImplantTemplate3DModelSurfaceNumber'),
    '00686360': 'SurfaceModelDescriptionSequence',
    '00686380': 'SurfaceModelLabel',
    '00686390': 'SurfaceModelScalingFactor',
    '006863A0': 'MaterialsCodeSequence',
    '006863A4': 'CoatingMaterialsCodeSequence',
    '006863A8': 'ImplantTypeCodeSequence',
    '006863AC': 'FixationMethodCodeSequence',
    '006863B0': 'MatingFeatureSetsSequence',
    '006863C0': 'MatingFeatureSetID',
    '006863D0': 'MatingFeatureSetLabel',
    '006863E0': 'MatingFeatureSequence',
    '006863F0': 'MatingFeatureID',
    '00686400': 'MatingFeatureDegreeOfFreedomSequence',
    '00686410': 'DegreeOfFreedomID',
    '00686420': 'DegreeOfFreedomType',
    '00686430': 'TwoDMatingFeatureCoordinatesSequence',
    '00686440': 'ReferencedHPGLDocumentID',
    '00686450': 'TwoDMatingPoint',
    '00686460': 'TwoDMatingAxes',
    '00686470': 'TwoDDegreeOfFreedomSequence',
    '00686490': 'ThreeDDegreeOfFreedomAxis',
    '006864A0': 'RangeOfFreedom',
    '006864C0': 'ThreeDMatingPoint',
    '006864D0': 'ThreeDMatingAxes',
    '006864F0': 'TwoDDegreeOfFreedomAxis',
    '00686500': 'PlanningLandmarkPointSequence',
    '00686510': 'PlanningLandmarkLineSequence',
    '00686520': 'PlanningLandmarkPlaneSequence',
    '00686530': 'PlanningLandmarkID',
    '00686540': 'PlanningLandmarkDescription',
    '00686545': 'PlanningLandmarkIdentificationCodeSequence',
    '00686550': 'TwoDPointCoordinatesSequence',
    '00686560': 'TwoDPointCoordinates',
    '00686590': 'ThreeDPointCoordinates',
    '006865A0': 'TwoDLineCoordinatesSequence',
    '006865B0': 'TwoDLineCoordinates',
    '006865D0': 'ThreeDLineCoordinates',
    '006865E0': 'TwoDPlaneCoordinatesSequence',
    '006865F0': 'TwoDPlaneIntersection',
    '00686610': 'ThreeDPlaneOrigin',
    '00686620': 'ThreeDPlaneNormal',
    '00687001': 'ModelModification',
    '00687002': 'ModelMirroring',
    '00687003': 'ModelUsageCodeSequence',
    '00700001': 'GraphicAnnotationSequence',
    '00700002': 'GraphicLayer',
    '00700003': 'BoundingBoxAnnotationUnits',
    '00700004': 'AnchorPointAnnotationUnits',
    '00700005': 'GraphicAnnotationUnits',
    '00700006': 'UnformattedTextValue',
    '00700008': 'TextObjectSequence',
    '00700009': 'GraphicObjectSequence',
    '00700010': 'BoundingBoxTopLeftHandCorner',
    '00700011': 'BoundingBoxBottomRightHandCorner',
    '00700012': 'BoundingBoxTextHorizontalJustification',
    '00700014': 'AnchorPoint',
    '00700015': 'AnchorPointVisibility',
    '00700020': 'GraphicDimensions',
    '00700021': 'NumberOfGraphicPoints',
    '00700022': 'GraphicData',
    '00700023': 'GraphicType',
    '00700024': 'GraphicFilled',
    '00700040': 'ImageRotationRetired',
    '00700041': 'ImageHorizontalFlip',
    '00700042': 'ImageRotation',
    '00700050': 'DisplayedAreaTopLeftHandCornerTrial',
    '00700051': 'DisplayedAreaBottomRightHandCornerTrial',
    '00700052': 'DisplayedAreaTopLeftHandCorner',
    '00700053': 'DisplayedAreaBottomRightHandCorner',
    '0070005A': 'DisplayedAreaSelectionSequence',
    '00700060': 'GraphicLayerSequence',
    '00700062': 'GraphicLayerOrder',
    '00700066': 'GraphicLayerRecommendedDisplayGrayscaleValue',
    '00700067': 'GraphicLayerRecommendedDisplayRGBValue',
    '00700068': 'GraphicLayerDescription',
    '00700080': 'ContentLabel',
    '00700081': 'ContentDescription',
    '00700082': 'PresentationCreationDate',
    '00700083': 'PresentationCreationTime',
    '00700084': 'ContentCreatorName',
    '00700086': 'ContentCreatorIdentificationCodeSequence',
    '00700087': 'AlternateContentDescriptionSequence',
    '00700100': 'PresentationSizeMode',
    '00700101': 'PresentationPixelSpacing',
    '00700102': 'PresentationPixelAspectRatio',
    '00700103': 'PresentationPixelMagnificationRatio',
    '00700207': 'GraphicGroupLabel',
    '00700208': 'GraphicGroupDescription',
    '00700209': 'CompoundGraphicSequence',
    '00700226': 'CompoundGraphicInstanceID',
    '00700227': 'FontName',
    '00700228': 'FontNameType',
    '00700229': 'CSSFontName',
    '00700230': 'RotationAngle',
    '00700231': 'TextStyleSequence',
    '00700232': 'LineStyleSequence',
    '00700233': 'FillStyleSequence',
    '00700234': 'GraphicGroupSequence',
    '00700241': 'TextColorCIELabValue',
    '00700242': 'HorizontalAlignment',
    '00700243': 'VerticalAlignment',
    '00700244': 'ShadowStyle',
    '00700245': 'ShadowOffsetX',
    '00700246': 'ShadowOffsetY',
    '00700247': 'ShadowColorCIELabValue',
    '00700248': 'Underlined',
    '00700249': 'Bold',
    '00700250': 'Italic',
    '00700251': 'PatternOnColorCIELabValue',
    '00700252': 'PatternOffColorCIELabValue',
    '00700253': 'LineThickness',
    '00700254': 'LineDashingStyle',
    '00700255': 'LinePattern',
    '00700256': 'FillPattern',
    '00700257': 'FillMode',
    '00700258': 'ShadowOpacity',
    '00700261': 'GapLength',
    '00700262': 'DiameterOfVisibility',
    '00700273': 'RotationPoint',
    '00700274': 'TickAlignment',
    '00700278': 'ShowTickLabel',
    '00700279': 'TickLabelAlignment',
    '00700282': 'CompoundGraphicUnits',
    '00700284': 'PatternOnOpacity',
    '00700285': 'PatternOffOpacity',
    '00700287': 'MajorTicksSequence',
    '00700288': 'TickPosition',
    '00700289': 'TickLabel',
    '00700294': 'CompoundGraphicType',
    '00700295': 'GraphicGroupID',
    '00700306': 'ShapeType',
    '00700308': 'RegistrationSequence',
    '00700309': 'MatrixRegistrationSequence',
    '0070030A': 'MatrixSequence',
    '0070030B': 'FrameOfReferenceToDisplayedCoordinateSystemTransformationMatrix',
    '0070030C': 'FrameOfReferenceTransformationMatrixType',
    '0070030D': 'RegistrationTypeCodeSequence',
    '0070030F': 'FiducialDescription',
    '00700310': 'FiducialIdentifier',
    '00700311': 'FiducialIdentifierCodeSequence',
    '00700312': 'ContourUncertaintyRadius',
    '00700314': 'UsedFiducialsSequence',
    '00700318': 'GraphicCoordinatesDataSequence',
    '0070031A': 'FiducialUID',
    '0070031B': 'ReferencedFiducialUID',
    '0070031C': 'FiducialSetSequence',
    '0070031E': 'FiducialSequence',
    '0070031F': 'FiducialsPropertyCategoryCodeSequence',
    '00700401': 'GraphicLayerRecommendedDisplayCIELabValue',
    '00700402': 'BlendingSequence',
    '00700403': 'RelativeOpacity',
    '00700404': 'ReferencedSpatialRegistrationSequence',
    '00700405': 'BlendingPosition',
    '00701101': 'PresentationDisplayCollectionUID',
    '00701102': 'PresentationSequenceCollectionUID',
    '00701103': 'PresentationSequencePositionIndex',
    '00701104': 'RenderedImageReferenceSequence',
    '00701201': 'VolumetricPresentationStateInputSequence',
    '00701202': 'PresentationInputType',
    '00701203': 'InputSequencePositionIndex',
    '00701204': 'Crop',
    '00701205': 'CroppingSpecificationIndex',
    '00701206': 'CompositingMethod',
    '00701207': 'VolumetricPresentationInputNumber',
    '00701208': 'ImageVolumeGeometry',
    '00701209': 'VolumetricPresentationInputSetUID',
    '0070120A': 'VolumetricPresentationInputSetSequence',
    '0070120B': 'GlobalCrop',
    '0070120C': 'GlobalCroppingSpecificationIndex',
    '0070120D': 'RenderingMethod',
    '00701301': 'VolumeCroppingSequence',
    '00701302': 'VolumeCroppingMethod',
    '00701303': 'BoundingBoxCrop',
    '00701304': 'ObliqueCroppingPlaneSequence',
    '00701305': 'Plane',
    '00701306': 'PlaneNormal',
    '00701309': 'CroppingSpecificationNumber',
    '00701501': 'MultiPlanarReconstructionStyle',
    '00701502': 'MPRThicknessType',
    '00701503': 'MPRSlabThickness',
    '00701505': 'MPRTopLeftHandCorner',
    '00701507': 'MPRViewWidthDirection',
    '00701508': 'MPRViewWidth',
    '0070150C': 'NumberOfVolumetricCurvePoints',
    '0070150D': 'VolumetricCurvePoints',
    '00701511': 'MPRViewHeightDirection',
    '00701512': 'MPRViewHeight',
    '00701602': 'RenderProjection',
    '00701603': 'ViewpointPosition',
    '00701604': 'ViewpointLookAtPoint',
    '00701605': 'ViewpointUpDirection',
    '00701606': 'RenderFieldOfView',
    '00701607': 'SamplingStepSize',
    '00701701': 'ShadingStyle',
    '00701702': 'AmbientReflectionIntensity',
    '00701703': 'LightDirection',
    '00701704': 'DiffuseReflectionIntensity',
    '00701705': 'SpecularReflectionIntensity',
    '00701706': 'Shininess',
    '00701801': 'PresentationStateClassificationComponentSequence',
    '00701802': 'ComponentType',
    '00701803': 'ComponentInputSequence',
    '00701804': 'VolumetricPresentationInputIndex',
    '00701805': 'PresentationStateCompositorComponentSequence',
    '00701806': 'WeightingTransferFunctionSequence',
    '00701807': 'WeightingLookupTableDescriptor',
    '00701808': 'WeightingLookupTableData',
    '00701901': 'VolumetricAnnotationSequence',
    '00701903': 'ReferencedStructuredContextSequence',
    '00701904': 'ReferencedContentItem',
    '00701905': 'VolumetricPresentationInputAnnotationSequence',
    '00701907': 'AnnotationClipping',
    '00701A01': 'PresentationAnimationStyle',
    '00701A03': 'RecommendedAnimationRate',
    '00701A04': 'AnimationCurveSequence',
    '00701A05': 'AnimationStepSize',
    '00701A06': 'SwivelRange',
    '00701A07': 'VolumetricCurveUpDirections',
    '00701A08': 'VolumeStreamSequence',
    '00701A09': 'RGBATransferFunctionDescription',
    '00701B01': 'AdvancedBlendingSequence',
    '00701B02': 'BlendingInputNumber',
    '00701B03': 'BlendingDisplayInputSequence',
    '00701B04': 'BlendingDisplaySequence',
    '00701B06': 'BlendingMode',
    '00701B07': 'TimeSeriesBlending',
    '00701B08': 'GeometryForDisplay',
    '00701B11': 'ThresholdSequence',
    '00701B12': 'ThresholdValueSequence',
    '00701B13': 'ThresholdType',
    '00701B14': 'ThresholdValue',
    '00720002': 'HangingProtocolName',
    '00720004': 'HangingProtocolDescription',
    '00720006': 'HangingProtocolLevel',
    '00720008': 'HangingProtocolCreator',
    '0072000A': 'HangingProtocolCreationDateTime',
    '0072000C': 'HangingProtocolDefinitionSequence',
    '0072000E': 'HangingProtocolUserIdentificationCodeSequence',
    '00720010': 'HangingProtocolUserGroupName',
    '00720012': 'SourceHangingProtocolSequence',
    '00720014': 'NumberOfPriorsReferenced',
    '00720020': 'ImageSetsSequence',
    '00720022': 'ImageSetSelectorSequence',
    '00720024': 'ImageSetSelectorUsageFlag',
    '00720026': 'SelectorAttribute',
    '00720028': 'SelectorValueNumber',
    '00720030': 'TimeBasedImageSetsSequence',
    '00720032': 'ImageSetNumber',
    '00720034': 'ImageSetSelectorCategory',
    '00720038': 'RelativeTime',
    '0072003A': 'RelativeTimeUnits',
    '0072003C': 'AbstractPriorValue',
    '0072003E': 'AbstractPriorCodeSequence',
    '00720040': 'ImageSetLabel',
    '00720050': 'SelectorAttributeVR',
    '00720052': 'SelectorSequencePointer',
    '00720054': 'SelectorSequencePointerPrivateCreator',
    '00720056': 'SelectorAttributePrivateCreator',
    '0072005E': 'SelectorAEValue',
    '0072005F': 'SelectorASValue',
    '00720060': 'SelectorATValue',
    '00720061': 'SelectorDAValue',
    '00720062': 'SelectorCSValue',
    '00720063': 'SelectorDTValue',
    '00720064': 'SelectorISValue',
    '00720065': 'SelectorOBValue',
    '00720066': 'SelectorLOValue',
    '00720067': 'SelectorOFValue',
    '00720068': 'SelectorLTValue',
    '00720069': 'SelectorOWValue',
    '0072006A': 'SelectorPNValue',
    '0072006B': 'SelectorTMValue',
    '0072006C': 'SelectorSHValue',
    '0072006D': 'SelectorUNValue',
    '0072006E': 'SelectorSTValue',
    '0072006F': 'SelectorUCValue',
    '00720070': 'SelectorUTValue',
    '00720071': 'SelectorURValue',
    '00720072': 'SelectorDSValue',
    '00720073': 'SelectorODValue',
    '00720074': 'SelectorFDValue',
    '00720075': 'SelectorOLValue',
    '00720076': 'SelectorFLValue',
    '00720078': 'SelectorULValue',
    '0072007A': 'SelectorUSValue',
    '0072007C': 'SelectorSLValue',
    '0072007E': 'SelectorSSValue',
    '0072007F': 'SelectorUIValue',
    '00720080': 'SelectorCodeSequenceValue',
    '00720100': 'NumberOfScreens',
    '00720102': 'NominalScreenDefinitionSequence',
    '00720104': 'NumberOfVerticalPixels',
    '00720106': 'NumberOfHorizontalPixels',
    '00720108': 'DisplayEnvironmentSpatialPosition',
    '0072010A': 'ScreenMinimumGrayscaleBitDepth',
    '0072010C': 'ScreenMinimumColorBitDepth',
    '0072010E': 'ApplicationMaximumRepaintTime',
    '00720200': 'DisplaySetsSequence',
    '00720202': 'DisplaySetNumber',
    '00720203': 'DisplaySetLabel',
    '00720204': 'DisplaySetPresentationGroup',
    '00720206': 'DisplaySetPresentationGroupDescription',
    '00720208': 'PartialDataDisplayHandling',
    '00720210': 'SynchronizedScrollingSequence',
    '00720212': 'DisplaySetScrollingGroup',
    '00720214': 'NavigationIndicatorSequence',
    '00720216': 'NavigationDisplaySet',
    '00720218': 'ReferenceDisplaySets',
    '00720300': 'ImageBoxesSequence',
    '00720302': 'ImageBoxNumber',
    '00720304': 'ImageBoxLayoutType',
    '00720306': 'ImageBoxTileHorizontalDimension',
    '00720308': 'ImageBoxTileVerticalDimension',
    '00720310': 'ImageBoxScrollDirection',
    '00720312': 'ImageBoxSmallScrollType',
    '00720314': 'ImageBoxSmallScrollAmount',
    '00720316': 'ImageBoxLargeScrollType',
    '00720318': 'ImageBoxLargeScrollAmount',
    '00720320': 'ImageBoxOverlapPriority',
    '00720330': 'CineRelativeToRealTime',
    '00720400': 'FilterOperationsSequence',
    '00720402': 'FilterByCategory',
    '00720404': 'FilterByAttributePresence',
    '00720406': 'FilterByOperator',
    '00720420': 'StructuredDisplayBackgroundCIELabValue',
    '00720421': 'EmptyImageBoxCIELabValue',
    '00720422': 'StructuredDisplayImageBoxSequence',
    '00720424': 'StructuredDisplayTextBoxSequence',
    '00720427': 'ReferencedFirstFrameSequence',
    '00720430': 'ImageBoxSynchronizationSequence',
    '00720432': 'SynchronizedImageBoxList',
    '00720434': 'TypeOfSynchronization',
    '00720500': 'BlendingOperationType',
    '00720510': 'ReformattingOperationType',
    '00720512': 'ReformattingThickness',
    '00720514': 'ReformattingInterval',
    '00720516': 'ReformattingOperationInitialViewDirection',
    '00720520': 'ThreeDRenderingType',
    '00720600': 'SortingOperationsSequence',
    '00720602': 'SortByCategory',
    '00720604': 'SortingDirection',
    '00720700': 'DisplaySetPatientOrientation',
    '00720702': 'VOIType',
    '00720704': 'PseudoColorType',
    '00720705': 'PseudoColorPaletteInstanceReferenceSequence',
    '00720706': 'ShowGrayscaleInverted',
    '00720710': 'ShowImageTrueSizeFlag',
    '00720712': 'ShowGraphicAnnotationFlag',
    '00720714': 'ShowPatientDemographicsFlag',
    '00720716': 'ShowAcquisitionTechniquesFlag',
    '00720717': 'DisplaySetHorizontalJustification',
    '00720718': 'DisplaySetVerticalJustification',
    '00740120': 'ContinuationStartMeterset',
    '00740121': 'ContinuationEndMeterset',
    '00741000': 'ProcedureStepState',
    '00741002': 'ProcedureStepProgressInformationSequence',
    '00741004': 'ProcedureStepProgress',
    '00741006': 'ProcedureStepProgressDescription',
    '00741007': 'ProcedureStepProgressParametersSequence',
    '00741008': 'ProcedureStepCommunicationsURISequence',
    '0074100A': 'ContactURI',
    '0074100C': 'ContactDisplayName',
    '0074100E': 'ProcedureStepDiscontinuationReasonCodeSequence',
    '00741020': 'BeamTaskSequence',
    '00741022': 'BeamTaskType',
    '00741024': 'BeamOrderIndexTrial',
    '00741025': 'AutosequenceFlag',
    '00741026': 'TableTopVerticalAdjustedPosition',
    '00741027': 'TableTopLongitudinalAdjustedPosition',
    '00741028': 'TableTopLateralAdjustedPosition',
    '0074102A': 'PatientSupportAdjustedAngle',
    '0074102B': 'TableTopEccentricAdjustedAngle',
    '0074102C': 'TableTopPitchAdjustedAngle',
    '0074102D': 'TableTopRollAdjustedAngle',
    '00741030': 'DeliveryVerificationImageSequence',
    '00741032': 'VerificationImageTiming',
    '00741034': 'DoubleExposureFlag',
    '00741036': 'DoubleExposureOrdering',
    '00741038': 'DoubleExposureMetersetTrial',
    '0074103A': 'DoubleExposureFieldDeltaTrial',
    '00741040': 'RelatedReferenceRTImageSequence',
    '00741042': 'GeneralMachineVerificationSequence',
    '00741044': 'ConventionalMachineVerificationSequence',
    '00741046': 'IonMachineVerificationSequence',
    '00741048': 'FailedAttributesSequence',
    '0074104A': 'OverriddenAttributesSequence',
    '0074104C': 'ConventionalControlPointVerificationSequence',
    '0074104E': 'IonControlPointVerificationSequence',
    '00741050': 'AttributeOccurrenceSequence',
    '00741052': 'AttributeOccurrencePointer',
    '00741054': 'AttributeItemSelector',
    '00741056': 'AttributeOccurrencePrivateCreator',
    '00741057': 'SelectorSequencePointerItems',
    '00741200': 'ScheduledProcedureStepPriority',
    '00741202': 'WorklistLabel',
    '00741204': 'ProcedureStepLabel',
    '00741210': 'ScheduledProcessingParametersSequence',
    '00741212': 'PerformedProcessingParametersSequence',
    '00741216': 'UnifiedProcedureStepPerformedProcedureSequence',
    '00741220': 'RelatedProcedureStepSequence',
    '00741222': 'ProcedureStepRelationshipType',
    '00741224': 'ReplacedProcedureStepSequence',
    '00741230': 'DeletionLock',
    '00741234': 'ReceivingAE',
    '00741236': 'RequestingAE',
    '00741238': 'ReasonForCancellation',
    '00741242': 'SCPStatus',
    '00741244': 'SubscriptionListStatus',
    '00741246': 'UnifiedProcedureStepListStatus',
    '00741324': 'BeamOrderIndex',
    '00741338': 'DoubleExposureMeterset',
    '0074133A': 'DoubleExposureFieldDelta',
    '00741401': 'BrachyTaskSequence',
    '00741402': 'ContinuationStartTotalReferenceAirKerma',
    '00741403': 'ContinuationEndTotalReferenceAirKerma',
    '00741404': 'ContinuationPulseNumber',
    '00741405': 'ChannelDeliveryOrderSequence',
    '00741406': 'ReferencedChannelNumber',
    '00741407': 'StartCumulativeTimeWeight',
    '00741408': 'EndCumulativeTimeWeight',
    '00741409': 'OmittedChannelSequence',
    '0074140A': 'ReasonForChannelOmission',
    '0074140B': 'ReasonForChannelOmissionDescription',
    '0074140C': 'ChannelDeliveryOrderIndex',
    '0074140D': 'ChannelDeliveryContinuationSequence',
    '0074140E': 'OmittedApplicationSetupSequence',
    '00760001': 'ImplantAssemblyTemplateName',
    '00760003': 'ImplantAssemblyTemplateIssuer',
    '00760006': 'ImplantAssemblyTemplateVersion',
    '00760008': 'ReplacedImplantAssemblyTemplateSequence',
    '0076000A': 'ImplantAssemblyTemplateType',
    '0076000C': 'OriginalImplantAssemblyTemplateSequence',
    '0076000E': 'DerivationImplantAssemblyTemplateSequence',
    '00760010': 'ImplantAssemblyTemplateTargetAnatomySequence',
    '00760020': 'ProcedureTypeCodeSequence',
    '00760030': 'SurgicalTechnique',
    '00760032': 'ComponentTypesSequence',
    '00760034': 'ComponentTypeCodeSequence',
    '00760036': 'ExclusiveComponentType',
    '00760038': 'MandatoryComponentType',
    '00760040': 'ComponentSequence',
    '00760055': 'ComponentID',
    '00760060': 'ComponentAssemblySequence',
    '00760070': ('Component1ReferencedID'),
    '00760080': ('Component1ReferencedMatingFeatureSetID'),
    '00760090': ('Component1ReferencedMatingFeatureID'),
    '007600A0': ('Component2ReferencedID'),
    '007600B0': ('Component2ReferencedMatingFeatureSetID'),
    '007600C0': ('Component2ReferencedMatingFeatureID'),
    '00780001': 'ImplantTemplateGroupName',
    '00780010': 'ImplantTemplateGroupDescription',
    '00780020': 'ImplantTemplateGroupIssuer',
    '00780024': 'ImplantTemplateGroupVersion',
    '00780026': 'ReplacedImplantTemplateGroupSequence',
    '00780028': 'ImplantTemplateGroupTargetAnatomySequence',
    '0078002A': 'ImplantTemplateGroupMembersSequence',
    '0078002E': 'ImplantTemplateGroupMemberID',
    '00780050': 'ThreeDImplantTemplateGroupMemberMatchingPoint',
    '00780060': 'ThreeDImplantTemplateGroupMemberMatchingAxes',
    '00780070': ('ImplantTemplateGroupMemberMatching2DCoordinatesSequence'),
    '00780090': 'TwoDImplantTemplateGroupMemberMatchingPoint',
    '007800A0': 'TwoDImplantTemplateGroupMemberMatchingAxes',
    '007800B0': 'ImplantTemplateGroupVariationDimensionSequence',
    '007800B2': 'ImplantTemplateGroupVariationDimensionName',
    '007800B4': 'ImplantTemplateGroupVariationDimensionRankSequence',
    '007800B6': 'ReferencedImplantTemplateGroupMemberID',
    '007800B8': 'ImplantTemplateGroupVariationDimensionRank',
    '00800001': 'SurfaceScanAcquisitionTypeCodeSequence',
    '00800002': 'SurfaceScanModeCodeSequence',
    '00800003': 'RegistrationMethodCodeSequence',
    '00800004': 'ShotDurationTime',
    '00800005': 'ShotOffsetTime',
    '00800006': 'SurfacePointPresentationValueData',
    '00800007': 'SurfacePointColorCIELabValueData',
    '00800008': 'UVMappingSequence',
    '00800009': 'TextureLabel',
    '00800010': 'UValueData',
    '00800011': 'VValueData',
    '00800012': 'ReferencedTextureSequence',
    '00800013': 'ReferencedSurfaceDataSequence',
    '00820001': 'AssessmentSummary',
    '00820003': 'AssessmentSummaryDescription',
    '00820004': 'AssessedSOPInstanceSequence',
    '00820005': 'ReferencedComparisonSOPInstanceSequence',
    '00820006': 'NumberOfAssessmentObservations',
    '00820007': 'AssessmentObservationsSequence',
    '00820008': 'ObservationSignificance',
    '0082000A': 'ObservationDescription',
    '0082000C': 'StructuredConstraintObservationSequence',
    '00820010': 'AssessedAttributeValueSequence',
    '00820016': 'AssessmentSetID',
    '00820017': 'AssessmentRequesterSequence',
    '00820018': 'SelectorAttributeName',
    '00820019': 'SelectorAttributeKeyword',
    '00820021': 'AssessmentTypeCodeSequence',
    '00820022': 'ObservationBasisCodeSequence',
    '00820023': 'AssessmentLabel',
    '00820032': 'ConstraintType',
    '00820033': 'SpecificationSelectionGuidance',
    '00820034': 'ConstraintValueSequence',
    '00820035': 'RecommendedDefaultValueSequence',
    '00820036': 'ConstraintViolationSignificance',
    '00820037': 'ConstraintViolationCondition',
    '00820038': 'ModifiableConstraintFlag',
    '00880130': 'StorageMediaFileSetID',
    '00880140': 'StorageMediaFileSetUID',
    '00880200': 'IconImageSequence',
    '00880904': 'TopicTitle',
    '00880906': 'TopicSubject',
    '00880910': 'TopicAuthor',
    '00880912': 'TopicKeywords',
    '01000410': 'SOPInstanceStatus',
    '01000420': 'SOPAuthorizationDateTime',
    '01000424': 'SOPAuthorizationComment',
    '01000426': 'AuthorizationEquipmentCertificationNumber',
    '04000005': 'MACIDNumber',
    '04000010': 'MACCalculationTransferSyntaxUID',
    '04000015': 'MACAlgorithm',
    '04000020': 'DataElementsSigned',
    '04000100': 'DigitalSignatureUID',
    '04000105': 'DigitalSignatureDateTime',
    '04000110': 'CertificateType',
    '04000115': 'CertificateOfSigner',
    '04000120': 'Signature',
    '04000305': 'CertifiedTimestampType',
    '04000310': 'CertifiedTimestamp',
    '04000315': '',
    '04000401': 'DigitalSignaturePurposeCodeSequence',
    '04000402': 'ReferencedDigitalSignatureSequence',
    '04000403': 'ReferencedSOPInstanceMACSequence',
    '04000404': 'MAC',
    '04000500': 'EncryptedAttributesSequence',
    '04000510': 'EncryptedContentTransferSyntaxUID',
    '04000520': 'EncryptedContent',
    '04000550': 'ModifiedAttributesSequence',
    '04000561': 'OriginalAttributesSequence',
    '04000562': 'AttributeModificationDateTime',
    '04000563': 'ModifyingSystem',
    '04000564': 'SourceOfPreviousValues',
    '04000565': 'ReasonForTheAttributeModification',
    '04000600': 'InstanceOriginStatus',
    '20000010': 'NumberOfCopies',
    '2000001E': 'PrinterConfigurationSequence',
    '20000020': 'PrintPriority',
    '20000030': 'MediumType',
    '20000040': 'FilmDestination',
    '20000050': 'FilmSessionLabel',
    '20000060': 'MemoryAllocation',
    '20000061': 'MaximumMemoryAllocation',
    '20000062': 'ColorImagePrintingFlag',
    '20000063': 'CollationFlag',
    '20000065': 'AnnotationFlag',
    '20000067': 'ImageOverlayFlag',
    '20000069': 'PresentationLUTFlag',
    '2000006A': 'ImageBoxPresentationLUTFlag',
    '200000A0': 'MemoryBitDepth',
    '200000A1': 'PrintingBitDepth',
    '200000A2': 'MediaInstalledSequence',
    '200000A4': 'OtherMediaAvailableSequence',
    '200000A8': 'SupportedImageDisplayFormatsSequence',
    '20000500': 'ReferencedFilmBoxSequence',
    '20000510': 'ReferencedStoredPrintSequence',
    '20100010': 'ImageDisplayFormat',
    '20100030': 'AnnotationDisplayFormatID',
    '20100040': 'FilmOrientation',
    '20100050': 'FilmSizeID',
    '20100052': 'PrinterResolutionID',
    '20100054': 'DefaultPrinterResolutionID',
    '20100060': 'MagnificationType',
    '20100080': 'SmoothingType',
    '201000A6': 'DefaultMagnificationType',
    '201000A7': 'OtherMagnificationTypesAvailable',
    '201000A8': 'DefaultSmoothingType',
    '201000A9': 'OtherSmoothingTypesAvailable',
    '20100100': 'BorderDensity',
    '20100110': 'EmptyImageDensity',
    '20100120': 'MinDensity',
    '20100130': 'MaxDensity',
    '20100140': 'Trim',
    '20100150': 'ConfigurationInformation',
    '20100152': 'ConfigurationInformationDescription',
    '20100154': 'MaximumCollatedFilms',
    '2010015E': 'Illumination',
    '20100160': 'ReflectedAmbientLight',
    '20100376': 'PrinterPixelSpacing',
    '20100500': 'ReferencedFilmSessionSequence',
    '20100510': 'ReferencedImageBoxSequence',
    '20100520': 'ReferencedBasicAnnotationBoxSequence',
    '20200010': 'ImageBoxPosition',
    '20200020': 'Polarity',
    '20200030': 'RequestedImageSize',
    '20200040': 'RequestedDecimateCropBehavior',
    '20200050': 'RequestedResolutionID',
    '202000A0': 'RequestedImageSizeFlag',
    '202000A2': 'DecimateCropResult',
    '20200110': 'BasicGrayscaleImageSequence',
    '20200111': 'BasicColorImageSequence',
    '20200130': 'ReferencedImageOverlayBoxSequence',
    '20200140': 'ReferencedVOILUTBoxSequence',
    '20300010': 'AnnotationPosition',
    '20300020': 'TextString',
    '20400010': 'ReferencedOverlayPlaneSequence',
    '20400011': 'ReferencedOverlayPlaneGroups',
    '20400020': 'OverlayPixelDataSequence',
    '20400060': 'OverlayMagnificationType',
    '20400070': 'OverlaySmoothingType',
    '20400072': 'OverlayOrImageMagnification',
    '20400074': 'MagnifyToNumberOfColumns',
    '20400080': 'OverlayForegroundDensity',
    '20400082': 'OverlayBackgroundDensity',
    '20400090': 'OverlayMode',
    '20400100': 'ThresholdDensity',
    '20400500': 'ReferencedImageBoxSequenceRetired',
    '20500010': 'PresentationLUTSequence',
    '20500020': 'PresentationLUTShape',
    '20500500': 'ReferencedPresentationLUTSequence',
    '21000010': 'PrintJobID',
    '21000020': 'ExecutionStatus',
    '21000030': 'ExecutionStatusInfo',
    '21000040': 'CreationDate',
    '21000050': 'CreationTime',
    '21000070': 'Originator',
    '21000140': 'DestinationAE',
    '21000160': 'OwnerID',
    '21000170': 'NumberOfFilms',
    '21000500': 'ReferencedPrintJobSequencePullStoredPrint',
    '21100010': 'PrinterStatus',
    '21100020': 'PrinterStatusInfo',
    '21100030': 'PrinterName',
    '21100099': 'PrintQueueID',
    '21200010': 'QueueStatus',
    '21200050': 'PrintJobDescriptionSequence',
    '21200070': 'ReferencedPrintJobSequence',
    '21300010': 'PrintManagementCapabilitiesSequence',
    '21300015': 'PrinterCharacteristicsSequence',
    '21300030': 'FilmBoxContentSequence',
    '21300040': 'ImageBoxContentSequence',
    '21300050': 'AnnotationContentSequence',
    '21300060': 'ImageOverlayBoxContentSequence',
    '21300080': 'PresentationLUTContentSequence',
    '213000A0': 'ProposedStudySequence',
    '213000C0': 'OriginalImageSequence',
    '22000001': 'LabelUsingInformationExtractedFromInstances',
    '22000002': 'LabelText',
    '22000003': 'LabelStyleSelection',
    '22000004': 'MediaDisposition',
    '22000005': 'BarcodeValue',
    '22000006': 'BarcodeSymbology',
    '22000007': 'AllowMediaSplitting',
    '22000008': 'IncludeNonDICOMObjects',
    '22000009': 'IncludeDisplayApplication',
    '2200000A': 'PreserveCompositeInstancesAfterMediaCreation',
    '2200000B': 'TotalNumberOfPiecesOfMediaCreated',
    '2200000C': 'RequestedMediaApplicationProfile',
    '2200000D': 'ReferencedStorageMediaSequence',
    '2200000E': 'FailureAttributes',
    '2200000F': 'AllowLossyCompression',
    '22000020': 'RequestPriority',
    '30020002': 'RTImageLabel',
    '30020003': 'RTImageName',
    '30020004': 'RTImageDescription',
    '3002000A': 'ReportedValuesOrigin',
    '3002000C': 'RTImagePlane',
    '3002000D': 'XRayImageReceptorTranslation',
    '3002000E': 'XRayImageReceptorAngle',
    '30020010': 'RTImageOrientation',
    '30020011': 'ImagePlanePixelSpacing',
    '30020012': 'RTImagePosition',
    '30020020': 'RadiationMachineName',
    '30020022': 'RadiationMachineSAD',
    '30020024': 'RadiationMachineSSD',
    '30020026': 'RTImageSID',
    '30020028': 'SourceToReferenceObjectDistance',
    '30020029': 'FractionNumber',
    '30020030': 'ExposureSequence',
    '30020032': 'MetersetExposure',
    '30020034': 'DiaphragmPosition',
    '30020040': 'FluenceMapSequence',
    '30020041': 'FluenceDataSource',
    '30020042': 'FluenceDataScale',
    '30020050': 'PrimaryFluenceModeSequence',
    '30020051': 'FluenceMode',
    '30020052': 'FluenceModeID',
    '30040001': 'DVHType',
    '30040002': 'DoseUnits',
    '30040004': 'DoseType',
    '30040005': 'SpatialTransformOfDose',
    '30040006': 'DoseComment',
    '30040008': 'NormalizationPoint',
    '3004000A': 'DoseSummationType',
    '3004000C': 'GridFrameOffsetVector',
    '3004000E': 'DoseGridScaling',
    '30040010': 'RTDoseROISequence',
    '30040012': 'DoseValue',
    '30040014': 'TissueHeterogeneityCorrection',
    '30040040': 'DVHNormalizationPoint',
    '30040042': 'DVHNormalizationDoseValue',
    '30040050': 'DVHSequence',
    '30040052': 'DVHDoseScaling',
    '30040054': 'DVHVolumeUnits',
    '30040056': 'DVHNumberOfBins',
    '30040058': 'DVHData',
    '30040060': 'DVHReferencedROISequence',
    '30040062': 'DVHROIContributionType',
    '30040070': 'DVHMinimumDose',
    '30040072': 'DVHMaximumDose',
    '30040074': 'DVHMeanDose',
    '30060002': 'StructureSetLabel',
    '30060004': 'StructureSetName',
    '30060006': 'StructureSetDescription',
    '30060008': 'StructureSetDate',
    '30060009': 'StructureSetTime',
    '30060010': 'ReferencedFrameOfReferenceSequence',
    '30060012': 'RTReferencedStudySequence',
    '30060014': 'RTReferencedSeriesSequence',
    '30060016': 'ContourImageSequence',
    '30060018': 'PredecessorStructureSetSequence',
    '30060020': 'StructureSetROISequence',
    '30060022': 'ROINumber',
    '30060024': 'ReferencedFrameOfReferenceUID',
    '30060026': 'ROIName',
    '30060028': 'ROIDescription',
    '3006002A': 'ROIDisplayColor',
    '3006002C': 'ROIVolume',
    '30060030': 'RTRelatedROISequence',
    '30060033': 'RTROIRelationship',
    '30060036': 'ROIGenerationAlgorithm',
    '30060038': 'ROIGenerationDescription',
    '30060039': 'ROIContourSequence',
    '30060040': 'ContourSequence',
    '30060042': 'ContourGeometricType',
    '30060044': 'ContourSlabThickness',
    '30060045': 'ContourOffsetVector',
    '30060046': 'NumberOfContourPoints',
    '30060048': 'ContourNumber',
    '30060049': 'AttachedContours',
    '30060050': 'ContourData',
    '30060080': 'RTROIObservationsSequence',
    '30060082': 'ObservationNumber',
    '30060084': 'ReferencedROINumber',
    '30060085': 'ROIObservationLabel',
    '30060086': 'RTROIIdentificationCodeSequence',
    '30060088': 'ROIObservationDescription',
    '300600A0': 'RelatedRTROIObservationsSequence',
    '300600A4': 'RTROIInterpretedType',
    '300600A6': 'ROIInterpreter',
    '300600B0': 'ROIPhysicalPropertiesSequence',
    '300600B2': 'ROIPhysicalProperty',
    '300600B4': 'ROIPhysicalPropertyValue',
    '300600B6': 'ROIElementalCompositionSequence',
    '300600B7': 'ROIElementalCompositionAtomicNumber',
    '300600B8': 'ROIElementalCompositionAtomicMassFraction',
    '300600B9': 'AdditionalRTROIIdentificationCodeSequence',
    '300600C0': 'FrameOfReferenceRelationshipSequence',
    '300600C2': 'RelatedFrameOfReferenceUID',
    '300600C4': 'FrameOfReferenceTransformationType',
    '300600C6': 'FrameOfReferenceTransformationMatrix',
    '300600C8': 'FrameOfReferenceTransformationComment',
    '30080010': 'MeasuredDoseReferenceSequence',
    '30080012': 'MeasuredDoseDescription',
    '30080014': 'MeasuredDoseType',
    '30080016': 'MeasuredDoseValue',
    '30080020': 'TreatmentSessionBeamSequence',
    '30080021': 'TreatmentSessionIonBeamSequence',
    '30080022': 'CurrentFractionNumber',
    '30080024': 'TreatmentControlPointDate',
    '30080025': 'TreatmentControlPointTime',
    '3008002A': 'TreatmentTerminationStatus',
    '3008002B': 'TreatmentTerminationCode',
    '3008002C': 'TreatmentVerificationStatus',
    '30080030': 'ReferencedTreatmentRecordSequence',
    '30080032': 'SpecifiedPrimaryMeterset',
    '30080033': 'SpecifiedSecondaryMeterset',
    '30080036': 'DeliveredPrimaryMeterset',
    '30080037': 'DeliveredSecondaryMeterset',
    '3008003A': 'SpecifiedTreatmentTime',
    '3008003B': 'DeliveredTreatmentTime',
    '30080040': 'ControlPointDeliverySequence',
    '30080041': 'IonControlPointDeliverySequence',
    '30080042': 'SpecifiedMeterset',
    '30080044': 'DeliveredMeterset',
    '30080045': 'MetersetRateSet',
    '30080046': 'MetersetRateDelivered',
    '30080047': 'ScanSpotMetersetsDelivered',
    '30080048': 'DoseRateDelivered',
    '30080050': 'TreatmentSummaryCalculatedDoseReferenceSequence',
    '30080052': 'CumulativeDoseToDoseReference',
    '30080054': 'FirstTreatmentDate',
    '30080056': 'MostRecentTreatmentDate',
    '3008005A': 'NumberOfFractionsDelivered',
    '30080060': 'OverrideSequence',
    '30080061': 'ParameterSequencePointer',
    '30080062': 'OverrideParameterPointer',
    '30080063': 'ParameterItemIndex',
    '30080064': 'MeasuredDoseReferenceNumber',
    '30080065': 'ParameterPointer',
    '30080066': 'OverrideReason',
    '30080067': 'ParameterValueNumber',
    '30080068': 'CorrectedParameterSequence',
    '3008006A': 'CorrectionValue',
    '30080070': 'CalculatedDoseReferenceSequence',
    '30080072': 'CalculatedDoseReferenceNumber',
    '30080074': 'CalculatedDoseReferenceDescription',
    '30080076': 'CalculatedDoseReferenceDoseValue',
    '30080078': 'StartMeterset',
    '3008007A': 'EndMeterset',
    '30080080': 'ReferencedMeasuredDoseReferenceSequence',
    '30080082': 'ReferencedMeasuredDoseReferenceNumber',
    '30080090': 'ReferencedCalculatedDoseReferenceSequence',
    '30080092': 'ReferencedCalculatedDoseReferenceNumber',
    '300800A0': 'BeamLimitingDeviceLeafPairsSequence',
    '300800B0': 'RecordedWedgeSequence',
    '300800C0': 'RecordedCompensatorSequence',
    '300800D0': 'RecordedBlockSequence',
    '300800E0': 'TreatmentSummaryMeasuredDoseReferenceSequence',
    '300800F0': 'RecordedSnoutSequence',
    '300800F2': 'RecordedRangeShifterSequence',
    '300800F4': 'RecordedLateralSpreadingDeviceSequence',
    '300800F6': 'RecordedRangeModulatorSequence',
    '30080100': 'RecordedSourceSequence',
    '30080105': 'SourceSerialNumber',
    '30080110': 'TreatmentSessionApplicationSetupSequence',
    '30080116': 'ApplicationSetupCheck',
    '30080120': 'RecordedBrachyAccessoryDeviceSequence',
    '30080122': 'ReferencedBrachyAccessoryDeviceNumber',
    '30080130': 'RecordedChannelSequence',
    '30080132': 'SpecifiedChannelTotalTime',
    '30080134': 'DeliveredChannelTotalTime',
    '30080136': 'SpecifiedNumberOfPulses',
    '30080138': 'DeliveredNumberOfPulses',
    '3008013A': 'SpecifiedPulseRepetitionInterval',
    '3008013C': 'DeliveredPulseRepetitionInterval',
    '30080140': 'RecordedSourceApplicatorSequence',
    '30080142': 'ReferencedSourceApplicatorNumber',
    '30080150': 'RecordedChannelShieldSequence',
    '30080152': 'ReferencedChannelShieldNumber',
    '30080160': 'BrachyControlPointDeliveredSequence',
    '30080162': 'SafePositionExitDate',
    '30080164': 'SafePositionExitTime',
    '30080166': 'SafePositionReturnDate',
    '30080168': 'SafePositionReturnTime',
    '30080171': 'PulseSpecificBrachyControlPointDeliveredSequence',
    '30080172': 'PulseNumber',
    '30080173': 'BrachyPulseControlPointDeliveredSequence',
    '30080200': 'CurrentTreatmentStatus',
    '30080202': 'TreatmentStatusComment',
    '30080220': 'FractionGroupSummarySequence',
    '30080223': 'ReferencedFractionNumber',
    '30080224': 'FractionGroupType',
    '30080230': 'BeamStopperPosition',
    '30080240': 'FractionStatusSummarySequence',
    '30080250': 'TreatmentDate',
    '30080251': 'TreatmentTime',
    '300A0002': 'RTPlanLabel',
    '300A0003': 'RTPlanName',
    '300A0004': 'RTPlanDescription',
    '300A0006': 'RTPlanDate',
    '300A0007': 'RTPlanTime',
    '300A0009': 'TreatmentProtocols',
    '300A000A': 'PlanIntent',
    '300A000B': 'TreatmentSites',
    '300A000C': 'RTPlanGeometry',
    '300A000E': 'PrescriptionDescription',
    '300A0010': 'DoseReferenceSequence',
    '300A0012': 'DoseReferenceNumber',
    '300A0013': 'DoseReferenceUID',
    '300A0014': 'DoseReferenceStructureType',
    '300A0015': 'NominalBeamEnergyUnit',
    '300A0016': 'DoseReferenceDescription',
    '300A0018': 'DoseReferencePointCoordinates',
    '300A001A': 'NominalPriorDose',
    '300A0020': 'DoseReferenceType',
    '300A0021': 'ConstraintWeight',
    '300A0022': 'DeliveryWarningDose',
    '300A0023': 'DeliveryMaximumDose',
    '300A0025': 'TargetMinimumDose',
    '300A0026': 'TargetPrescriptionDose',
    '300A0027': 'TargetMaximumDose',
    '300A0028': 'TargetUnderdoseVolumeFraction',
    '300A002A': 'OrganAtRiskFullVolumeDose',
    '300A002B': 'OrganAtRiskLimitDose',
    '300A002C': 'OrganAtRiskMaximumDose',
    '300A002D': 'OrganAtRiskOverdoseVolumeFraction',
    '300A0040': 'ToleranceTableSequence',
    '300A0042': 'ToleranceTableNumber',
    '300A0043': 'ToleranceTableLabel',
    '300A0044': 'GantryAngleTolerance',
    '300A0046': 'BeamLimitingDeviceAngleTolerance',
    '300A0048': 'BeamLimitingDeviceToleranceSequence',
    '300A004A': 'BeamLimitingDevicePositionTolerance',
    '300A004B': 'SnoutPositionTolerance',
    '300A004C': 'PatientSupportAngleTolerance',
    '300A004E': 'TableTopEccentricAngleTolerance',
    '300A004F': 'TableTopPitchAngleTolerance',
    '300A0050': 'TableTopRollAngleTolerance',
    '300A0051': 'TableTopVerticalPositionTolerance',
    '300A0052': 'TableTopLongitudinalPositionTolerance',
    '300A0053': 'TableTopLateralPositionTolerance',
    '300A0055': 'RTPlanRelationship',
    '300A0070': 'FractionGroupSequence',
    '300A0071': 'FractionGroupNumber',
    '300A0072': 'FractionGroupDescription',
    '300A0078': 'NumberOfFractionsPlanned',
    '300A0079': 'NumberOfFractionPatternDigitsPerDay',
    '300A007A': 'RepeatFractionCycleLength',
    '300A007B': 'FractionPattern',
    '300A0080': 'NumberOfBeams',
    '300A0082': 'BeamDoseSpecificationPoint',
    '300A0083': 'ReferencedDoseReferenceUID',
    '300A0084': 'BeamDose',
    '300A0086': 'BeamMeterset',
    '300A0088': 'BeamDosePointDepth',
    '300A0089': 'BeamDosePointEquivalentDepth',
    '300A008A': 'BeamDosePointSSD',
    '300A008B': 'BeamDoseMeaning',
    '300A008C': 'BeamDoseVerificationControlPointSequence',
    '300A008D': 'AverageBeamDosePointDepth',
    '300A008E': 'AverageBeamDosePointEquivalentDepth',
    '300A008F': 'AverageBeamDosePointSSD',
    '300A0090': 'BeamDoseType',
    '300A0091': 'AlternateBeamDose',
    '300A0092': 'AlternateBeamDoseType',
    '300A0093': 'DepthValueAveragingFlag',
    '300A0094': 'BeamDosePointSourceToExternalContourDistance',
    '300A00A0': 'NumberOfBrachyApplicationSetups',
    '300A00A2': 'BrachyApplicationSetupDoseSpecificationPoint',
    '300A00A4': 'BrachyApplicationSetupDose',
    '300A00B0': 'BeamSequence',
    '300A00B2': 'TreatmentMachineName',
    '300A00B3': 'PrimaryDosimeterUnit',
    '300A00B4': 'SourceAxisDistance',
    '300A00B6': 'BeamLimitingDeviceSequence',
    '300A00B8': 'RTBeamLimitingDeviceType',
    '300A00BA': 'SourceToBeamLimitingDeviceDistance',
    '300A00BB': 'IsocenterToBeamLimitingDeviceDistance',
    '300A00BC': 'NumberOfLeafJawPairs',
    '300A00BE': 'LeafPositionBoundaries',
    '300A00C0': 'BeamNumber',
    '300A00C2': 'BeamName',
    '300A00C3': 'BeamDescription',
    '300A00C4': 'BeamType',
    '300A00C5': 'BeamDeliveryDurationLimit',
    '300A00C6': 'RadiationType',
    '300A00C7': 'HighDoseTechniqueType',
    '300A00C8': 'ReferenceImageNumber',
    '300A00CA': 'PlannedVerificationImageSequence',
    '300A00CC': 'ImagingDeviceSpecificAcquisitionParameters',
    '300A00CE': 'TreatmentDeliveryType',
    '300A00D0': 'NumberOfWedges',
    '300A00D1': 'WedgeSequence',
    '300A00D2': 'WedgeNumber',
    '300A00D3': 'WedgeType',
    '300A00D4': 'WedgeID',
    '300A00D5': 'WedgeAngle',
    '300A00D6': 'WedgeFactor',
    '300A00D7': 'TotalWedgeTrayWaterEquivalentThickness',
    '300A00D8': 'WedgeOrientation',
    '300A00D9': 'IsocenterToWedgeTrayDistance',
    '300A00DA': 'SourceToWedgeTrayDistance',
    '300A00DB': 'WedgeThinEdgePosition',
    '300A00DC': 'BolusID',
    '300A00DD': 'BolusDescription',
    '300A00DE': 'EffectiveWedgeAngle',
    '300A00E0': 'NumberOfCompensators',
    '300A00E1': 'MaterialID',
    '300A00E2': 'TotalCompensatorTrayFactor',
    '300A00E3': 'CompensatorSequence',
    '300A00E4': 'CompensatorNumber',
    '300A00E5': 'CompensatorID',
    '300A00E6': 'SourceToCompensatorTrayDistance',
    '300A00E7': 'CompensatorRows',
    '300A00E8': 'CompensatorColumns',
    '300A00E9': 'CompensatorPixelSpacing',
    '300A00EA': 'CompensatorPosition',
    '300A00EB': 'CompensatorTransmissionData',
    '300A00EC': 'CompensatorThicknessData',
    '300A00ED': 'NumberOfBoli',
    '300A00EE': 'CompensatorType',
    '300A00EF': 'CompensatorTrayID',
    '300A00F0': 'NumberOfBlocks',
    '300A00F2': 'TotalBlockTrayFactor',
    '300A00F3': 'TotalBlockTrayWaterEquivalentThickness',
    '300A00F4': 'BlockSequence',
    '300A00F5': 'BlockTrayID',
    '300A00F6': 'SourceToBlockTrayDistance',
    '300A00F7': 'IsocenterToBlockTrayDistance',
    '300A00F8': 'BlockType',
    '300A00F9': 'AccessoryCode',
    '300A00FA': 'BlockDivergence',
    '300A00FB': 'BlockMountingPosition',
    '300A00FC': 'BlockNumber',
    '300A00FE': 'BlockName',
    '300A0100': 'BlockThickness',
    '300A0102': 'BlockTransmission',
    '300A0104': 'BlockNumberOfPoints',
    '300A0106': 'BlockData',
    '300A0107': 'ApplicatorSequence',
    '300A0108': 'ApplicatorID',
    '300A0109': 'ApplicatorType',
    '300A010A': 'ApplicatorDescription',
    '300A010C': 'CumulativeDoseReferenceCoefficient',
    '300A010E': 'FinalCumulativeMetersetWeight',
    '300A0110': 'NumberOfControlPoints',
    '300A0111': 'ControlPointSequence',
    '300A0112': 'ControlPointIndex',
    '300A0114': 'NominalBeamEnergy',
    '300A0115': 'DoseRateSet',
    '300A0116': 'WedgePositionSequence',
    '300A0118': 'WedgePosition',
    '300A011A': 'BeamLimitingDevicePositionSequence',
    '300A011C': 'LeafJawPositions',
    '300A011E': 'GantryAngle',
    '300A011F': 'GantryRotationDirection',
    '300A0120': 'BeamLimitingDeviceAngle',
    '300A0121': 'BeamLimitingDeviceRotationDirection',
    '300A0122': 'PatientSupportAngle',
    '300A0123': 'PatientSupportRotationDirection',
    '300A0124': 'TableTopEccentricAxisDistance',
    '300A0125': 'TableTopEccentricAngle',
    '300A0126': 'TableTopEccentricRotationDirection',
    '300A0128': 'TableTopVerticalPosition',
    '300A0129': 'TableTopLongitudinalPosition',
    '300A012A': 'TableTopLateralPosition',
    '300A012C': 'IsocenterPosition',
    '300A012E': 'SurfaceEntryPoint',
    '300A0130': 'SourceToSurfaceDistance',
    '300A0131': 'AverageBeamDosePointSourceToExternalContourDistance',
    '300A0132': 'SourceToExternalContourDistance',
    '300A0133': 'ExternalContourEntryPoint',
    '300A0134': 'CumulativeMetersetWeight',
    '300A0140': 'TableTopPitchAngle',
    '300A0142': 'TableTopPitchRotationDirection',
    '300A0144': 'TableTopRollAngle',
    '300A0146': 'TableTopRollRotationDirection',
    '300A0148': 'HeadFixationAngle',
    '300A014A': 'GantryPitchAngle',
    '300A014C': 'GantryPitchRotationDirection',
    '300A014E': 'GantryPitchAngleTolerance',
    '300A0150': 'FixationEye',
    '300A0151': 'ChairHeadFramePosition',
    '300A0152': 'HeadFixationAngleTolerance',
    '300A0153': 'ChairHeadFramePositionTolerance',
    '300A0154': 'FixationLightAzimuthalAngleTolerance',
    '300A0155': 'FixationLightPolarAngleTolerance',
    '300A0180': 'PatientSetupSequence',
    '300A0182': 'PatientSetupNumber',
    '300A0183': 'PatientSetupLabel',
    '300A0184': 'PatientAdditionalPosition',
    '300A0190': 'FixationDeviceSequence',
    '300A0192': 'FixationDeviceType',
    '300A0194': 'FixationDeviceLabel',
    '300A0196': 'FixationDeviceDescription',
    '300A0198': 'FixationDevicePosition',
    '300A0199': 'FixationDevicePitchAngle',
    '300A019A': 'FixationDeviceRollAngle',
    '300A01A0': 'ShieldingDeviceSequence',
    '300A01A2': 'ShieldingDeviceType',
    '300A01A4': 'ShieldingDeviceLabel',
    '300A01A6': 'ShieldingDeviceDescription',
    '300A01A8': 'ShieldingDevicePosition',
    '300A01B0': 'SetupTechnique',
    '300A01B2': 'SetupTechniqueDescription',
    '300A01B4': 'SetupDeviceSequence',
    '300A01B6': 'SetupDeviceType',
    '300A01B8': 'SetupDeviceLabel',
    '300A01BA': 'SetupDeviceDescription',
    '300A01BC': 'SetupDeviceParameter',
    '300A01D0': 'SetupReferenceDescription',
    '300A01D2': 'TableTopVerticalSetupDisplacement',
    '300A01D4': 'TableTopLongitudinalSetupDisplacement',
    '300A01D6': 'TableTopLateralSetupDisplacement',
    '300A0200': 'BrachyTreatmentTechnique',
    '300A0202': 'BrachyTreatmentType',
    '300A0206': 'TreatmentMachineSequence',
    '300A0210': 'SourceSequence',
    '300A0212': 'SourceNumber',
    '300A0214': 'SourceType',
    '300A0216': 'SourceManufacturer',
    '300A0218': 'ActiveSourceDiameter',
    '300A021A': 'ActiveSourceLength',
    '300A021B': 'SourceModelID',
    '300A021C': 'SourceDescription',
    '300A0222': 'SourceEncapsulationNominalThickness',
    '300A0224': 'SourceEncapsulationNominalTransmission',
    '300A0226': 'SourceIsotopeName',
    '300A0228': 'SourceIsotopeHalfLife',
    '300A0229': 'SourceStrengthUnits',
    '300A022A': 'ReferenceAirKermaRate',
    '300A022B': 'SourceStrength',
    '300A022C': 'SourceStrengthReferenceDate',
    '300A022E': 'SourceStrengthReferenceTime',
    '300A0230': 'ApplicationSetupSequence',
    '300A0232': 'ApplicationSetupType',
    '300A0234': 'ApplicationSetupNumber',
    '300A0236': 'ApplicationSetupName',
    '300A0238': 'ApplicationSetupManufacturer',
    '300A0240': 'TemplateNumber',
    '300A0242': 'TemplateType',
    '300A0244': 'TemplateName',
    '300A0250': 'TotalReferenceAirKerma',
    '300A0260': 'BrachyAccessoryDeviceSequence',
    '300A0262': 'BrachyAccessoryDeviceNumber',
    '300A0263': 'BrachyAccessoryDeviceID',
    '300A0264': 'BrachyAccessoryDeviceType',
    '300A0266': 'BrachyAccessoryDeviceName',
    '300A026A': 'BrachyAccessoryDeviceNominalThickness',
    '300A026C': 'BrachyAccessoryDeviceNominalTransmission',
    '300A0271': 'ChannelEffectiveLength',
    '300A0272': 'ChannelInnerLength',
    '300A0273': 'AfterloaderChannelID',
    '300A0274': 'SourceApplicatorTipLength',
    '300A0280': 'ChannelSequence',
    '300A0282': 'ChannelNumber',
    '300A0284': 'ChannelLength',
    '300A0286': 'ChannelTotalTime',
    '300A0288': 'SourceMovementType',
    '300A028A': 'NumberOfPulses',
    '300A028C': 'PulseRepetitionInterval',
    '300A0290': 'SourceApplicatorNumber',
    '300A0291': 'SourceApplicatorID',
    '300A0292': 'SourceApplicatorType',
    '300A0294': 'SourceApplicatorName',
    '300A0296': 'SourceApplicatorLength',
    '300A0298': 'SourceApplicatorManufacturer',
    '300A029C': 'SourceApplicatorWallNominalThickness',
    '300A029E': 'SourceApplicatorWallNominalTransmission',
    '300A02A0': 'SourceApplicatorStepSize',
    '300A02A2': 'TransferTubeNumber',
    '300A02A4': 'TransferTubeLength',
    '300A02B0': 'ChannelShieldSequence',
    '300A02B2': 'ChannelShieldNumber',
    '300A02B3': 'ChannelShieldID',
    '300A02B4': 'ChannelShieldName',
    '300A02B8': 'ChannelShieldNominalThickness',
    '300A02BA': 'ChannelShieldNominalTransmission',
    '300A02C8': 'FinalCumulativeTimeWeight',
    '300A02D0': 'BrachyControlPointSequence',
    '300A02D2': 'ControlPointRelativePosition',
    '300A02D4': ('ControlPoint3DPosition'),
    '300A02D6': 'CumulativeTimeWeight',
    '300A02E0': 'CompensatorDivergence',
    '300A02E1': 'CompensatorMountingPosition',
    '300A02E2': 'SourceToCompensatorDistance',
    '300A02E3': 'TotalCompensatorTrayWaterEquivalentThickness',
    '300A02E4': 'IsocenterToCompensatorTrayDistance',
    '300A02E5': 'CompensatorColumnOffset',
    '300A02E6': 'IsocenterToCompensatorDistances',
    '300A02E7': 'CompensatorRelativeStoppingPowerRatio',
    '300A02E8': 'CompensatorMillingToolDiameter',
    '300A02EA': 'IonRangeCompensatorSequence',
    '300A02EB': 'CompensatorDescription',
    '300A0302': 'RadiationMassNumber',
    '300A0304': 'RadiationAtomicNumber',
    '300A0306': 'RadiationChargeState',
    '300A0308': 'ScanMode',
    '300A0309': 'ModulatedScanModeType',
    '300A030A': 'VirtualSourceAxisDistances',
    '300A030C': 'SnoutSequence',
    '300A030D': 'SnoutPosition',
    '300A030F': 'SnoutID',
    '300A0312': 'NumberOfRangeShifters',
    '300A0314': 'RangeShifterSequence',
    '300A0316': 'RangeShifterNumber',
    '300A0318': 'RangeShifterID',
    '300A0320': 'RangeShifterType',
    '300A0322': 'RangeShifterDescription',
    '300A0330': 'NumberOfLateralSpreadingDevices',
    '300A0332': 'LateralSpreadingDeviceSequence',
    '300A0334': 'LateralSpreadingDeviceNumber',
    '300A0336': 'LateralSpreadingDeviceID',
    '300A0338': 'LateralSpreadingDeviceType',
    '300A033A': 'LateralSpreadingDeviceDescription',
    '300A033C': 'LateralSpreadingDeviceWaterEquivalentThickness',
    '300A0340': 'NumberOfRangeModulators',
    '300A0342': 'RangeModulatorSequence',
    '300A0344': 'RangeModulatorNumber',
    '300A0346': 'RangeModulatorID',
    '300A0348': 'RangeModulatorType',
    '300A034A': 'RangeModulatorDescription',
    '300A034C': 'BeamCurrentModulationID',
    '300A0350': 'PatientSupportType',
    '300A0352': 'PatientSupportID',
    '300A0354': 'PatientSupportAccessoryCode',
    '300A0355': 'TrayAccessoryCode',
    '300A0356': 'FixationLightAzimuthalAngle',
    '300A0358': 'FixationLightPolarAngle',
    '300A035A': 'MetersetRate',
    '300A0360': 'RangeShifterSettingsSequence',
    '300A0362': 'RangeShifterSetting',
    '300A0364': 'IsocenterToRangeShifterDistance',
    '300A0366': 'RangeShifterWaterEquivalentThickness',
    '300A0370': 'LateralSpreadingDeviceSettingsSequence',
    '300A0372': 'LateralSpreadingDeviceSetting',
    '300A0374': 'IsocenterToLateralSpreadingDeviceDistance',
    '300A0380': 'RangeModulatorSettingsSequence',
    '300A0382': 'RangeModulatorGatingStartValue',
    '300A0384': 'RangeModulatorGatingStopValue',
    '300A0386': 'RangeModulatorGatingStartWaterEquivalentThickness',
    '300A0388': 'RangeModulatorGatingStopWaterEquivalentThickness',
    '300A038A': 'IsocenterToRangeModulatorDistance',
    '300A038F': 'ScanSpotTimeOffset',
    '300A0390': 'ScanSpotTuneID',
    '300A0391': 'ScanSpotPrescribedIndices',
    '300A0392': 'NumberOfScanSpotPositions',
    '300A0393': 'ScanSpotReordered',
    '300A0394': 'ScanSpotPositionMap',
    '300A0395': 'ScanSpotReorderingAllowed',
    '300A0396': 'ScanSpotMetersetWeights',
    '300A0398': 'ScanningSpotSize',
    '300A039A': 'NumberOfPaintings',
    '300A03A0': 'IonToleranceTableSequence',
    '300A03A2': 'IonBeamSequence',
    '300A03A4': 'IonBeamLimitingDeviceSequence',
    '300A03A6': 'IonBlockSequence',
    '300A03A8': 'IonControlPointSequence',
    '300A03AA': 'IonWedgeSequence',
    '300A03AC': 'IonWedgePositionSequence',
    '300A0401': 'ReferencedSetupImageSequence',
    '300A0402': 'SetupImageComment',
    '300A0410': 'MotionSynchronizationSequence',
    '300A0412': 'ControlPointOrientation',
    '300A0420': 'GeneralAccessorySequence',
    '300A0421': 'GeneralAccessoryID',
    '300A0422': 'GeneralAccessoryDescription',
    '300A0423': 'GeneralAccessoryType',
    '300A0424': 'GeneralAccessoryNumber',
    '300A0425': 'SourceToGeneralAccessoryDistance',
    '300A0431': 'ApplicatorGeometrySequence',
    '300A0432': 'ApplicatorApertureShape',
    '300A0433': 'ApplicatorOpening',
    '300A0434': 'ApplicatorOpeningX',
    '300A0435': 'ApplicatorOpeningY',
    '300A0436': 'SourceToApplicatorMountingPositionDistance',
    '300A0440': 'NumberOfBlockSlabItems',
    '300A0441': 'BlockSlabSequence',
    '300A0442': 'BlockSlabThickness',
    '300A0443': 'BlockSlabNumber',
    '300A0450': 'DeviceMotionControlSequence',
    '300A0451': 'DeviceMotionExecutionMode',
    '300A0452': 'DeviceMotionObservationMode',
    '300A0453': 'DeviceMotionParameterCodeSequence',
    '300A0501': 'DistalDepthFraction',
    '300A0502': 'DistalDepth',
    '300A0503': 'NominalRangeModulationFractions',
    '300A0504': 'NominalRangeModulatedRegionDepths',
    '300A0505': 'DepthDoseParametersSequence',
    '300A0506': 'DeliveredDepthDoseParametersSequence',
    '300A0507': 'DeliveredDistalDepthFraction',
    '300A0508': 'DeliveredDistalDepth',
    '300A0509': 'DeliveredNominalRangeModulationFractions',
    '300A0510': 'DeliveredNominalRangeModulatedRegionDepths',
    '300A0511': 'DeliveredReferenceDoseDefinition',
    '300A0512': 'ReferenceDoseDefinition',
    '300C0002': 'ReferencedRTPlanSequence',
    '300C0004': 'ReferencedBeamSequence',
    '300C0006': 'ReferencedBeamNumber',
    '300C0007': 'ReferencedReferenceImageNumber',
    '300C0008': 'StartCumulativeMetersetWeight',
    '300C0009': 'EndCumulativeMetersetWeight',
    '300C000A': 'ReferencedBrachyApplicationSetupSequence',
    '300C000C': 'ReferencedBrachyApplicationSetupNumber',
    '300C000E': 'ReferencedSourceNumber',
    '300C0020': 'ReferencedFractionGroupSequence',
    '300C0022': 'ReferencedFractionGroupNumber',
    '300C0040': 'ReferencedVerificationImageSequence',
    '300C0042': 'ReferencedReferenceImageSequence',
    '300C0050': 'ReferencedDoseReferenceSequence',
    '300C0051': 'ReferencedDoseReferenceNumber',
    '300C0055': 'BrachyReferencedDoseReferenceSequence',
    '300C0060': 'ReferencedStructureSetSequence',
    '300C006A': 'ReferencedPatientSetupNumber',
    '300C0080': 'ReferencedDoseSequence',
    '300C00A0': 'ReferencedToleranceTableNumber',
    '300C00B0': 'ReferencedBolusSequence',
    '300C00C0': 'ReferencedWedgeNumber',
    '300C00D0': 'ReferencedCompensatorNumber',
    '300C00E0': 'ReferencedBlockNumber',
    '300C00F0': 'ReferencedControlPointIndex',
    '300C00F2': 'ReferencedControlPointSequence',
    '300C00F4': 'ReferencedStartControlPointIndex',
    '300C00F6': 'ReferencedStopControlPointIndex',
    '300C0100': 'ReferencedRangeShifterNumber',
    '300C0102': 'ReferencedLateralSpreadingDeviceNumber',
    '300C0104': 'ReferencedRangeModulatorNumber',
    '300C0111': 'OmittedBeamTaskSequence',
    '300C0112': 'ReasonForOmission',
    '300C0113': 'ReasonForOmissionDescription',
    '300E0002': 'ApprovalStatus',
    '300E0004': 'ReviewDate',
    '300E0005': 'ReviewTime',
    '300E0008': 'ReviewerName',
    '40000010': 'Arbitrary',
    '40004000': 'TextComments',
    '40080040': 'ResultsID',
    '40080042': 'ResultsIDIssuer',
    '40080050': 'ReferencedInterpretationSequence',
    '400800FF': 'ReportProductionStatusTrial',
    '40080100': 'InterpretationRecordedDate',
    '40080101': 'InterpretationRecordedTime',
    '40080102': 'InterpretationRecorder',
    '40080103': 'ReferenceToRecordedSound',
    '40080108': 'InterpretationTranscriptionDate',
    '40080109': 'InterpretationTranscriptionTime',
    '4008010A': 'InterpretationTranscriber',
    '4008010B': 'InterpretationText',
    '4008010C': 'InterpretationAuthor',
    '40080111': 'InterpretationApproverSequence',
    '40080112': 'InterpretationApprovalDate',
    '40080113': 'InterpretationApprovalTime',
    '40080114': 'PhysicianApprovingInterpretation',
    '40080115': 'InterpretationDiagnosisDescription',
    '40080117': 'InterpretationDiagnosisCodeSequence',
    '40080118': 'ResultsDistributionListSequence',
    '40080119': 'DistributionName',
    '4008011A': 'DistributionAddress',
    '40080200': 'InterpretationID',
    '40080202': 'InterpretationIDIssuer',
    '40080210': 'InterpretationTypeID',
    '40080212': 'InterpretationStatusID',
    '40080300': 'Impressions',
    '40084000': 'ResultsComments',
    '40100001': 'LowEnergyDetectors',
    '40100002': 'HighEnergyDetectors',
    '40100004': 'DetectorGeometrySequence',
    '40101001': 'ThreatROIVoxelSequence',
    '40101004': 'ThreatROIBase',
    '40101005': 'ThreatROIExtents',
    '40101006': 'ThreatROIBitmap',
    '40101007': 'RouteSegmentID',
    '40101008': 'GantryType',
    '40101009': 'OOIOwnerType',
    '4010100A': 'RouteSegmentSequence',
    '40101010': 'PotentialThreatObjectID',
    '40101011': 'ThreatSequence',
    '40101012': 'ThreatCategory',
    '40101013': 'ThreatCategoryDescription',
    '40101014': 'ATDAbilityAssessment',
    '40101015': 'ATDAssessmentFlag',
    '40101016': 'ATDAssessmentProbability',
    '40101017': 'Mass',
    '40101018': 'Density',
    '40101019': 'ZEffective',
    '4010101A': 'BoardingPassID',
    '4010101B': 'CenterOfMass',
    '4010101C': 'CenterOfPTO',
    '4010101D': 'BoundingPolygon',
    '4010101E': 'RouteSegmentStartLocationID',
    '4010101F': 'RouteSegmentEndLocationID',
    '40101020': 'RouteSegmentLocationIDType',
    '40101021': 'AbortReason',
    '40101023': 'VolumeOfPTO',
    '40101024': 'AbortFlag',
    '40101025': 'RouteSegmentStartTime',
    '40101026': 'RouteSegmentEndTime',
    '40101027': 'TDRType',
    '40101028': 'InternationalRouteSegment',
    '40101029': 'ThreatDetectionAlgorithmandVersion',
    '4010102A': 'AssignedLocation',
    '4010102B': 'AlarmDecisionTime',
    '40101031': 'AlarmDecision',
    '40101033': 'NumberOfTotalObjects',
    '40101034': 'NumberOfAlarmObjects',
    '40101037': 'PTORepresentationSequence',
    '40101038': 'ATDAssessmentSequence',
    '40101039': 'TIPType',
    '4010103A': 'DICOSVersion',
    '40101041': 'OOIOwnerCreationTime',
    '40101042': 'OOIType',
    '40101043': 'OOISize',
    '40101044': 'AcquisitionStatus',
    '40101045': 'BasisMaterialsCodeSequence',
    '40101046': 'PhantomType',
    '40101047': 'OOIOwnerSequence',
    '40101048': 'ScanType',
    '40101051': 'ItineraryID',
    '40101052': 'ItineraryIDType',
    '40101053': 'ItineraryIDAssigningAuthority',
    '40101054': 'RouteID',
    '40101055': 'RouteIDAssigningAuthority',
    '40101056': 'InboundArrivalType',
    '40101058': 'CarrierID',
    '40101059': 'CarrierIDAssigningAuthority',
    '40101060': 'SourceOrientation',
    '40101061': 'SourcePosition',
    '40101062': 'BeltHeight',
    '40101064': 'AlgorithmRoutingCodeSequence',
    '40101067': 'TransportClassification',
    '40101068': 'OOITypeDescriptor',
    '40101069': 'TotalProcessingTime',
    '4010106C': 'DetectorCalibrationData',
    '4010106D': 'AdditionalScreeningPerformed',
    '4010106E': 'AdditionalInspectionSelectionCriteria',
    '4010106F': 'AdditionalInspectionMethodSequence',
    '40101070': 'AITDeviceType',
    '40101071': 'QRMeasurementsSequence',
    '40101072': 'TargetMaterialSequence',
    '40101073': 'SNRThreshold',
    '40101075': 'ImageScaleRepresentation',
    '40101076': 'ReferencedPTOSequence',
    '40101077': 'ReferencedTDRInstanceSequence',
    '40101078': 'PTOLocationDescription',
    '40101079': 'AnomalyLocatorIndicatorSequence',
    '4010107A': 'AnomalyLocatorIndicator',
    '4010107B': 'PTORegionSequence',
    '4010107C': 'InspectionSelectionCriteria',
    '4010107D': 'SecondaryInspectionMethodSequence',
    '4010107E': 'PRCSToRCSOrientation',
    '4FFE0001': 'MACParametersSequence',
    '52009229': 'SharedFunctionalGroupsSequence',
    '52009230': 'PerFrameFunctionalGroupsSequence',
    '54000100': 'WaveformSequence',
    '54000110': 'ChannelMinimumValue',
    '54000112': 'ChannelMaximumValue',
    '54001004': 'WaveformBitsAllocated',
    '54001006': 'WaveformSampleInterpretation',
    '5400100A': 'WaveformPaddingValue',
    '54001010': 'WaveformData',
    '56000010': 'FirstOrderPhaseCorrectionAngle',
    '56000020': 'SpectroscopyData',
    '7FE00008': 'FloatPixelData',
    '7FE00009': 'DoubleFloatPixelData',
    '7FE00010': 'PixelData',
    '7FE00020': 'CoefficientsSDVN',
    '7FE00030': 'CoefficientsSDHN',
    '7FE00040': 'CoefficientsSDDN',
    'FFFAFFFA': 'DigitalSignaturesSequence',
    'FFFCFFFC': 'DataSetTrailingPadding',
    'FFFEE000': 'Item',
    'FFFEE00D': 'ItemDelimitationItem',
    'FFFEE0DD': 'SequenceDelimitationItem',
  };
  Object.freeze(tagToKeyword);

  /** Maps DICOM Attribute Keyword to Tag.
   *
   * @constant {Object}
   * @private
   */
  const keywordToTag = {
    'CommandGroupLength': '00000000',
    'CommandLengthToEnd': '00000001',
    'AffectedSOPClassUID': '00000002',
    'RequestedSOPClassUID': '00000003',
    'CommandRecognitionCode': '00000010',
    'CommandField': '00000100',
    'MessageID': '00000110',
    'MessageIDBeingRespondedTo': '00000120',
    'Initiator': '00000200',
    'Receiver': '00000300',
    'FindLocation': '00000400',
    'MoveDestination': '00000600',
    'Priority': '00000700',
    'CommandDataSetType': '00000800',
    'NumberOfMatches': '00000850',
    'ResponseSequenceNumber': '00000860',
    'Status': '00000900',
    'OffendingElement': '00000901',
    'ErrorComment': '00000902',
    'ErrorID': '00000903',
    'AffectedSOPInstanceUID': '00001000',
    'RequestedSOPInstanceUID': '00001001',
    'EventTypeID': '00001002',
    'AttributeIdentifierList': '00001005',
    'ActionTypeID': '00001008',
    'NumberOfRemainingSuboperations': '00001020',
    'NumberOfCompletedSuboperations': '00001021',
    'NumberOfFailedSuboperations': '00001022',
    'NumberOfWarningSuboperations': '00001023',
    'MoveOriginatorApplicationEntityTitle': '00001030',
    'MoveOriginatorMessageID': '00001031',
    'DialogReceiver': '00004000',
    'TerminalType': '00004010',
    'MessageSetID': '00005010',
    'EndMessageID': '00005020',
    'DisplayFormat': '00005110',
    'PagePositionID': '00005120',
    'TextFormatID': '00005130',
    'NormalReverse': '00005140',
    'AddGrayScale': '00005150',
    'Borders': '00005160',
    'Copies': '00005170',
    'CommandMagnificationType': '00005180',
    'Erase': '00005190',
    'Print': '000051A0',
    'Overlays': '000051B0',
    'FileMetaInformationGroupLength': '00020000',
    'FileMetaInformationVersion': '00020001',
    'MediaStorageSOPClassUID': '00020002',
    'MediaStorageSOPInstanceUID': '00020003',
    'TransferSyntaxUID': '00020010',
    'ImplementationClassUID': '00020012',
    'ImplementationVersionName': '00020013',
    'SourceApplicationEntityTitle': '00020016',
    'SendingApplicationEntityTitle': '00020017',
    'ReceivingApplicationEntityTitle': '00020018',
    'PrivateInformationCreatorUID': '00020100',
    'PrivateInformation': '00020102',
    'FileSetID': '00041130',
    'FileSetDescriptorFileID': '00041141',
    'SpecificCharacterSetOfFileSetDescriptorFile': '00041142',
    'OffsetOfTheFirstDirectoryRecordOfTheRootDirectoryEntity': '00041200',
    'OffsetOfTheLastDirectoryRecordOfTheRootDirectoryEntity': '00041202',
    'FileSetConsistencyFlag': '00041212',
    'DirectoryRecordSequence': '00041220',
    'OffsetOfTheNextDirectoryRecord': '00041400',
    'RecordInUseFlag': '00041410',
    'OffsetOfReferencedLowerLevelDirectoryEntity': '00041420',
    'DirectoryRecordType': '00041430',
    'PrivateRecordUID': '00041432',
    'ReferencedFileID': '00041500',
    'MRDRDirectoryRecordOffset': '00041504',
    'ReferencedSOPClassUIDInFile': '00041510',
    'ReferencedSOPInstanceUIDInFile': '00041511',
    'ReferencedTransferSyntaxUIDInFile': '00041512',
    'ReferencedRelatedGeneralSOPClassUIDInFile': '0004151A',
    'NumberOfReferences': '00041600',
    'LengthToEnd': '00080001',
    'SpecificCharacterSet': '00080005',
    'LanguageCodeSequence': '00080006',
    'ImageType': '00080008',
    'RecognitionCode': '00080010',
    'InstanceCreationDate': '00080012',
    'InstanceCreationTime': '00080013',
    'InstanceCreatorUID': '00080014',
    'InstanceCoercionDateTime': '00080015',
    'SOPClassUID': '00080016',
    'SOPInstanceUID': '00080018',
    'RelatedGeneralSOPClassUID': '0008001A',
    'OriginalSpecializedSOPClassUID': '0008001B',
    'StudyDate': '00080020',
    'SeriesDate': '00080021',
    'AcquisitionDate': '00080022',
    'ContentDate': '00080023',
    'OverlayDate': '00080024',
    'CurveDate': '00080025',
    'AcquisitionDateTime': '0008002A',
    'StudyTime': '00080030',
    'SeriesTime': '00080031',
    'AcquisitionTime': '00080032',
    'ContentTime': '00080033',
    'OverlayTime': '00080034',
    'CurveTime': '00080035',
    'DataSetType': '00080040',
    'DataSetSubtype': '00080041',
    'NuclearMedicineSeriesType': '00080042',
    'AccessionNumber': '00080050',
    'IssuerOfAccessionNumberSequence': '00080051',
    'QueryRetrieveLevel': '00080052',
    'QueryRetrieveView': '00080053',
    'RetrieveAETitle': '00080054',
    'StationAETitle': '00080055',
    'InstanceAvailability': '00080056',
    'FailedSOPInstanceUIDList': '00080058',
    'Modality': '00080060',
    'ModalitiesInStudy': '00080061',
    'SOPClassesInStudy': '00080062',
    'AnatomicRegionsInStudyCodeSequence': '00080063',
    'ConversionType': '00080064',
    'PresentationIntentType': '00080068',
    'Manufacturer': '00080070',
    'InstitutionName': '00080080',
    'InstitutionAddress': '00080081',
    'InstitutionCodeSequence': '00080082',
    'ReferringPhysicianName': '00080090',
    'ReferringPhysicianAddress': '00080092',
    'ReferringPhysicianTelephoneNumbers': '00080094',
    'ReferringPhysicianIdentificationSequence': '00080096',
    'ConsultingPhysicianName': '0008009C',
    'ConsultingPhysicianIdentificationSequence': '0008009D',
    'CodeValue': '00080100',
    'ExtendedCodeValue': '00080101',
    'CodingSchemeDesignator': '00080102',
    'CodingSchemeVersion': '00080103',
    'CodeMeaning': '00080104',
    'MappingResource': '00080105',
    'ContextGroupVersion': '00080106',
    'ContextGroupLocalVersion': '00080107',
    'ExtendedCodeMeaning': '00080108',
    'CodingSchemeResourcesSequence': '00080109',
    'CodingSchemeURLType': '0008010A',
    'ContextGroupExtensionFlag': '0008010B',
    'CodingSchemeUID': '0008010C',
    'ContextGroupExtensionCreatorUID': '0008010D',
    'CodingSchemeURL': '0008010E',
    'ContextIdentifier': '0008010F',
    'CodingSchemeIdentificationSequence': '00080110',
    'CodingSchemeRegistry': '00080112',
    'CodingSchemeExternalID': '00080114',
    'CodingSchemeName': '00080115',
    'CodingSchemeResponsibleOrganization': '00080116',
    'ContextUID': '00080117',
    'MappingResourceUID': '00080118',
    'LongCodeValue': '00080119',
    'URNCodeValue': '00080120',
    'EquivalentCodeSequence': '00080121',
    'MappingResourceName': '00080122',
    'ContextGroupIdentificationSequence': '00080123',
    'MappingResourceIdentificationSequence': '00080124',
    'TimezoneOffsetFromUTC': '00080201',
    'ResponsibleGroupCodeSequence': '00080220',
    'EquipmentModality': '00080221',
    'ManufacturerRelatedModelGroup': '00080222',
    'PrivateDataElementCharacteristicsSequence': '00080300',
    'PrivateGroupReference': '00080301',
    'PrivateCreatorReference': '00080302',
    'BlockIdentifyingInformationStatus': '00080303',
    'NonidentifyingPrivateElements': '00080304',
    'DeidentificationActionSequence': '00080305',
    'IdentifyingPrivateElements': '00080306',
    'DeidentificationAction': '00080307',
    'PrivateDataElement': '00080308',
    'PrivateDataElementValueMultiplicity': '00080309',
    'PrivateDataElementValueRepresentation': '0008030A',
    'PrivateDataElementNumberOfItems': '0008030B',
    'PrivateDataElementName': '0008030C',
    'PrivateDataElementKeyword': '0008030D',
    'PrivateDataElementDescription': '0008030E',
    'PrivateDataElementEncoding': '0008030F',
    'PrivateDataElementDefinitionSequence': '00080310',
    'NetworkID': '00081000',
    'StationName': '00081010',
    'StudyDescription': '00081030',
    'ProcedureCodeSequence': '00081032',
    'SeriesDescription': '0008103E',
    'SeriesDescriptionCodeSequence': '0008103F',
    'InstitutionalDepartmentName': '00081040',
    'PhysiciansOfRecord': '00081048',
    'PhysiciansOfRecordIdentificationSequence': '00081049',
    'PerformingPhysicianName': '00081050',
    'PerformingPhysicianIdentificationSequence': '00081052',
    'NameOfPhysiciansReadingStudy': '00081060',
    'PhysiciansReadingStudyIdentificationSequence': '00081062',
    'OperatorsName': '00081070',
    'OperatorIdentificationSequence': '00081072',
    'AdmittingDiagnosesDescription': '00081080',
    'AdmittingDiagnosesCodeSequence': '00081084',
    'ManufacturerModelName': '00081090',
    'ReferencedResultsSequence': '00081100',
    'ReferencedStudySequence': '00081110',
    'ReferencedPerformedProcedureStepSequence': '00081111',
    'ReferencedSeriesSequence': '00081115',
    'ReferencedPatientSequence': '00081120',
    'ReferencedVisitSequence': '00081125',
    'ReferencedOverlaySequence': '00081130',
    'ReferencedStereometricInstanceSequence': '00081134',
    'ReferencedWaveformSequence': '0008113A',
    'ReferencedImageSequence': '00081140',
    'ReferencedCurveSequence': '00081145',
    'ReferencedInstanceSequence': '0008114A',
    'ReferencedRealWorldValueMappingInstanceSequence': '0008114B',
    'ReferencedSOPClassUID': '00081150',
    'ReferencedSOPInstanceUID': '00081155',
    'DefinitionSourceSequence': '00081156',
    'SOPClassesSupported': '0008115A',
    'ReferencedFrameNumber': '00081160',
    'SimpleFrameList': '00081161',
    'CalculatedFrameList': '00081162',
    'TimeRange': '00081163',
    'FrameExtractionSequence': '00081164',
    'MultiFrameSourceSOPInstanceUID': '00081167',
    'RetrieveURL': '00081190',
    'TransactionUID': '00081195',
    'WarningReason': '00081196',
    'FailureReason': '00081197',
    'FailedSOPSequence': '00081198',
    'ReferencedSOPSequence': '00081199',
    'OtherFailuresSequence': '0008119A',
    'StudiesContainingOtherReferencedInstancesSequence': '00081200',
    'RelatedSeriesSequence': '00081250',
    'LossyImageCompressionRetired': '00082110',
    'DerivationDescription': '00082111',
    'SourceImageSequence': '00082112',
    'StageName': '00082120',
    'StageNumber': '00082122',
    'NumberOfStages': '00082124',
    'ViewName': '00082127',
    'ViewNumber': '00082128',
    'NumberOfEventTimers': '00082129',
    'NumberOfViewsInStage': '0008212A',
    'EventElapsedTimes': '00082130',
    'EventTimerNames': '00082132',
    'EventTimerSequence': '00082133',
    'EventTimeOffset': '00082134',
    'EventCodeSequence': '00082135',
    'StartTrim': '00082142',
    'StopTrim': '00082143',
    'RecommendedDisplayFrameRate': '00082144',
    'TransducerPosition': '00082200',
    'TransducerOrientation': '00082204',
    'AnatomicStructure': '00082208',
    'AnatomicRegionSequence': '00082218',
    'AnatomicRegionModifierSequence': '00082220',
    'PrimaryAnatomicStructureSequence': '00082228',
    'AnatomicStructureSpaceOrRegionSequence': '00082229',
    'PrimaryAnatomicStructureModifierSequence': '00082230',
    'TransducerPositionSequence': '00082240',
    'TransducerPositionModifierSequence': '00082242',
    'TransducerOrientationSequence': '00082244',
    'TransducerOrientationModifierSequence': '00082246',
    'AnatomicStructureSpaceOrRegionCodeSequenceTrial': '00082251',
    'AnatomicPortalOfEntranceCodeSequenceTrial': '00082253',
    'AnatomicApproachDirectionCodeSequenceTrial': '00082255',
    'AnatomicPerspectiveDescriptionTrial': '00082256',
    'AnatomicPerspectiveCodeSequenceTrial': '00082257',
    'AnatomicLocationOfExaminingInstrumentDescriptionTrial': '00082258',
    'AnatomicLocationOfExaminingInstrumentCodeSequenceTrial': '00082259',
    'AnatomicStructureSpaceOrRegionModifierCodeSequenceTrial': '0008225A',
    'OnAxisBackgroundAnatomicStructureCodeSequenceTrial': '0008225C',
    'AlternateRepresentationSequence': '00083001',
    'IrradiationEventUID': '00083010',
    'SourceIrradiationEventSequence': '00083011',
    'RadiopharmaceuticalAdministrationEventUID': '00083012',
    'IdentifyingComments': '00084000',
    'FrameType': '00089007',
    'ReferencedImageEvidenceSequence': '00089092',
    'ReferencedRawDataSequence': '00089121',
    'CreatorVersionUID': '00089123',
    'DerivationImageSequence': '00089124',
    'SourceImageEvidenceSequence': '00089154',
    'PixelPresentation': '00089205',
    'VolumetricProperties': '00089206',
    'VolumeBasedCalculationTechnique': '00089207',
    'ComplexImageComponent': '00089208',
    'AcquisitionContrast': '00089209',
    'DerivationCodeSequence': '00089215',
    'ReferencedPresentationStateSequence': '00089237',
    'ReferencedOtherPlaneSequence': '00089410',
    'FrameDisplaySequence': '00089458',
    'RecommendedDisplayFrameRateInFloat': '00089459',
    'SkipFrameRangeFlag': '00089460',
    'PatientName': '00100010',
    'PatientID': '00100020',
    'IssuerOfPatientID': '00100021',
    'TypeOfPatientID': '00100022',
    'IssuerOfPatientIDQualifiersSequence': '00100024',
    'SourcePatientGroupIdentificationSequence': '00100026',
    'GroupOfPatientsIdentificationSequence': '00100027',
    'SubjectRelativePositionInImage': '00100028',
    'PatientBirthDate': '00100030',
    'PatientBirthTime': '00100032',
    'PatientBirthDateInAlternativeCalendar': '00100033',
    'PatientDeathDateInAlternativeCalendar': '00100034',
    'PatientAlternativeCalendar': '00100035',
    'PatientSex': '00100040',
    'PatientInsurancePlanCodeSequence': '00100050',
    'PatientPrimaryLanguageCodeSequence': '00100101',
    'PatientPrimaryLanguageModifierCodeSequence': '00100102',
    'QualityControlSubject': '00100200',
    'QualityControlSubjectTypeCodeSequence': '00100201',
    'StrainDescription': '00100212',
    'StrainNomenclature': '00100213',
    'StrainStockNumber': '00100214',
    'StrainSourceRegistryCodeSequence': '00100215',
    'StrainStockSequence': '00100216',
    'StrainSource': '00100217',
    'StrainAdditionalInformation': '00100218',
    'StrainCodeSequence': '00100219',
    'GeneticModificationsSequence': '00100221',
    'GeneticModificationsDescription': '00100222',
    'GeneticModificationsNomenclature': '00100223',
    'GeneticModificationsCodeSequence': '00100229',
    'OtherPatientIDs': '00101000',
    'OtherPatientNames': '00101001',
    'OtherPatientIDsSequence': '00101002',
    'PatientBirthName': '00101005',
    'PatientAge': '00101010',
    'PatientSize': '00101020',
    'PatientSizeCodeSequence': '00101021',
    'PatientBodyMassIndex': '00101022',
    'MeasuredAPDimension': '00101023',
    'MeasuredLateralDimension': '00101024',
    'PatientWeight': '00101030',
    'PatientAddress': '00101040',
    'InsurancePlanIdentification': '00101050',
    'PatientMotherBirthName': '00101060',
    'MilitaryRank': '00101080',
    'BranchOfService': '00101081',
    'MedicalRecordLocator': '00101090',
    'ReferencedPatientPhotoSequence': '00101100',
    'MedicalAlerts': '00102000',
    'Allergies': '00102110',
    'CountryOfResidence': '00102150',
    'RegionOfResidence': '00102152',
    'PatientTelephoneNumbers': '00102154',
    'PatientTelecomInformation': '00102155',
    'EthnicGroup': '00102160',
    'Occupation': '00102180',
    'SmokingStatus': '001021A0',
    'AdditionalPatientHistory': '001021B0',
    'PregnancyStatus': '001021C0',
    'LastMenstrualDate': '001021D0',
    'PatientReligiousPreference': '001021F0',
    'PatientSpeciesDescription': '00102201',
    'PatientSpeciesCodeSequence': '00102202',
    'PatientSexNeutered': '00102203',
    'AnatomicalOrientationType': '00102210',
    'PatientBreedDescription': '00102292',
    'PatientBreedCodeSequence': '00102293',
    'BreedRegistrationSequence': '00102294',
    'BreedRegistrationNumber': '00102295',
    'BreedRegistryCodeSequence': '00102296',
    'ResponsiblePerson': '00102297',
    'ResponsiblePersonRole': '00102298',
    'ResponsibleOrganization': '00102299',
    'PatientComments': '00104000',
    'ExaminedBodyThickness': '00109431',
    'ClinicalTrialSponsorName': '00120010',
    'ClinicalTrialProtocolID': '00120020',
    'ClinicalTrialProtocolName': '00120021',
    'ClinicalTrialSiteID': '00120030',
    'ClinicalTrialSiteName': '00120031',
    'ClinicalTrialSubjectID': '00120040',
    'ClinicalTrialSubjectReadingID': '00120042',
    'ClinicalTrialTimePointID': '00120050',
    'ClinicalTrialTimePointDescription': '00120051',
    'LongitudinalTemporalOffsetFromEvent': '00120052',
    'LongitudinalTemporalEventType': '00120053',
    'ClinicalTrialCoordinatingCenterName': '00120060',
    'PatientIdentityRemoved': '00120062',
    'DeidentificationMethod': '00120063',
    'DeidentificationMethodCodeSequence': '00120064',
    'ClinicalTrialSeriesID': '00120071',
    'ClinicalTrialSeriesDescription': '00120072',
    'ClinicalTrialProtocolEthicsCommitteeName': '00120081',
    'ClinicalTrialProtocolEthicsCommitteeApprovalNumber': '00120082',
    'ConsentForClinicalTrialUseSequence': '00120083',
    'DistributionType': '00120084',
    'ConsentForDistributionFlag': '00120085',
    'EthicsCommitteeApprovalEffectivenessStartDate': '00120086',
    'EthicsCommitteeApprovalEffectivenessEndDate': '00120087',
    'CADFileFormat': '00140023',
    'ComponentReferenceSystem': '00140024',
    'ComponentManufacturingProcedure': '00140025',
    'ComponentManufacturer': '00140028',
    'MaterialThickness': '00140030',
    'MaterialPipeDiameter': '00140032',
    'MaterialIsolationDiameter': '00140034',
    'MaterialGrade': '00140042',
    'MaterialPropertiesDescription': '00140044',
    'MaterialPropertiesFileFormatRetired': '00140045',
    'MaterialNotes': '00140046',
    'ComponentShape': '00140050',
    'CurvatureType': '00140052',
    'OuterDiameter': '00140054',
    'InnerDiameter': '00140056',
    'ComponentWelderIDs': '00140100',
    'SecondaryApprovalStatus': '00140101',
    'SecondaryReviewDate': '00140102',
    'SecondaryReviewTime': '00140103',
    'SecondaryReviewerName': '00140104',
    'RepairID': '00140105',
    'MultipleComponentApprovalSequence': '00140106',
    'OtherApprovalStatus': '00140107',
    'OtherSecondaryApprovalStatus': '00140108',
    'ActualEnvironmentalConditions': '00141010',
    'ExpiryDate': '00141020',
    'EnvironmentalConditions': '00141040',
    'EvaluatorSequence': '00142002',
    'EvaluatorNumber': '00142004',
    'EvaluatorName': '00142006',
    'EvaluationAttempt': '00142008',
    'IndicationSequence': '00142012',
    'IndicationNumber': '00142014',
    'IndicationLabel': '00142016',
    'IndicationDescription': '00142018',
    'IndicationType': '0014201A',
    'IndicationDisposition': '0014201C',
    'IndicationROISequence': '0014201E',
    'IndicationPhysicalPropertySequence': '00142030',
    'PropertyLabel': '00142032',
    'CoordinateSystemNumberOfAxes': '00142202',
    'CoordinateSystemAxesSequence': '00142204',
    'CoordinateSystemAxisDescription': '00142206',
    'CoordinateSystemDataSetMapping': '00142208',
    'CoordinateSystemAxisNumber': '0014220A',
    'CoordinateSystemAxisType': '0014220C',
    'CoordinateSystemAxisUnits': '0014220E',
    'CoordinateSystemAxisValues': '00142210',
    'CoordinateSystemTransformSequence': '00142220',
    'TransformDescription': '00142222',
    'TransformNumberOfAxes': '00142224',
    'TransformOrderOfAxes': '00142226',
    'TransformedAxisUnits': '00142228',
    'CoordinateSystemTransformRotationAndScaleMatrix': '0014222A',
    'CoordinateSystemTransformTranslationMatrix': '0014222C',
    'InternalDetectorFrameTime': '00143011',
    'NumberOfFramesIntegrated': '00143012',
    'DetectorTemperatureSequence': '00143020',
    'SensorName': '00143022',
    'HorizontalOffsetOfSensor': '00143024',
    'VerticalOffsetOfSensor': '00143026',
    'SensorTemperature': '00143028',
    'DarkCurrentSequence': '00143040',
    'DarkCurrentCounts': '00143050',
    'GainCorrectionReferenceSequence': '00143060',
    'AirCounts': '00143070',
    'KVUsedInGainCalibration': '00143071',
    'MAUsedInGainCalibration': '00143072',
    'NumberOfFramesUsedForIntegration': '00143073',
    'FilterMaterialUsedInGainCalibration': '00143074',
    'FilterThicknessUsedInGainCalibration': '00143075',
    'DateOfGainCalibration': '00143076',
    'TimeOfGainCalibration': '00143077',
    'BadPixelImage': '00143080',
    'CalibrationNotes': '00143099',
    'PulserEquipmentSequence': '00144002',
    'PulserType': '00144004',
    'PulserNotes': '00144006',
    'ReceiverEquipmentSequence': '00144008',
    'AmplifierType': '0014400A',
    'ReceiverNotes': '0014400C',
    'PreAmplifierEquipmentSequence': '0014400E',
    'PreAmplifierNotes': '0014400F',
    'TransmitTransducerSequence': '00144010',
    'ReceiveTransducerSequence': '00144011',
    'NumberOfElements': '00144012',
    'ElementShape': '00144013',
    'ElementDimensionA': '00144014',
    'ElementDimensionB': '00144015',
    'ElementPitchA': '00144016',
    'MeasuredBeamDimensionA': '00144017',
    'MeasuredBeamDimensionB': '00144018',
    'LocationOfMeasuredBeamDiameter': '00144019',
    'NominalFrequency': '0014401A',
    'MeasuredCenterFrequency': '0014401B',
    'MeasuredBandwidth': '0014401C',
    'ElementPitchB': '0014401D',
    'PulserSettingsSequence': '00144020',
    'PulseWidth': '00144022',
    'ExcitationFrequency': '00144024',
    'ModulationType': '00144026',
    'Damping': '00144028',
    'ReceiverSettingsSequence': '00144030',
    'AcquiredSoundpathLength': '00144031',
    'AcquisitionCompressionType': '00144032',
    'AcquisitionSampleSize': '00144033',
    'RectifierSmoothing': '00144034',
    'DACSequence': '00144035',
    'DACType': '00144036',
    'DACGainPoints': '00144038',
    'DACTimePoints': '0014403A',
    'DACAmplitude': '0014403C',
    'PreAmplifierSettingsSequence': '00144040',
    'TransmitTransducerSettingsSequence': '00144050',
    'ReceiveTransducerSettingsSequence': '00144051',
    'IncidentAngle': '00144052',
    'CouplingTechnique': '00144054',
    'CouplingMedium': '00144056',
    'CouplingVelocity': '00144057',
    'ProbeCenterLocationX': '00144058',
    'ProbeCenterLocationZ': '00144059',
    'SoundPathLength': '0014405A',
    'DelayLawIdentifier': '0014405C',
    'GateSettingsSequence': '00144060',
    'GateThreshold': '00144062',
    'VelocityOfSound': '00144064',
    'CalibrationSettingsSequence': '00144070',
    'CalibrationProcedure': '00144072',
    'ProcedureVersion': '00144074',
    'ProcedureCreationDate': '00144076',
    'ProcedureExpirationDate': '00144078',
    'ProcedureLastModifiedDate': '0014407A',
    'CalibrationTime': '0014407C',
    'CalibrationDate': '0014407E',
    'ProbeDriveEquipmentSequence': '00144080',
    'DriveType': '00144081',
    'ProbeDriveNotes': '00144082',
    'DriveProbeSequence': '00144083',
    'ProbeInductance': '00144084',
    'ProbeResistance': '00144085',
    'ReceiveProbeSequence': '00144086',
    'ProbeDriveSettingsSequence': '00144087',
    'BridgeResistors': '00144088',
    'ProbeOrientationAngle': '00144089',
    'UserSelectedGainY': '0014408B',
    'UserSelectedPhase': '0014408C',
    'UserSelectedOffsetX': '0014408D',
    'UserSelectedOffsetY': '0014408E',
    'ChannelSettingsSequence': '00144091',
    'ChannelThreshold': '00144092',
    'ScannerSettingsSequence': '0014409A',
    'ScanProcedure': '0014409B',
    'TranslationRateX': '0014409C',
    'TranslationRateY': '0014409D',
    'ChannelOverlap': '0014409F',
    'ImageQualityIndicatorType': '001440A0',
    'ImageQualityIndicatorMaterial': '001440A1',
    'ImageQualityIndicatorSize': '001440A2',
    'LINACEnergy': '00145002',
    'LINACOutput': '00145004',
    'ActiveAperture': '00145100',
    'TotalAperture': '00145101',
    'ApertureElevation': '00145102',
    'MainLobeAngle': '00145103',
    'MainRoofAngle': '00145104',
    'ConnectorType': '00145105',
    'WedgeModelNumber': '00145106',
    'WedgeAngleFloat': '00145107',
    'WedgeRoofAngle': '00145108',
    '00145109': ('WedgeElement1Position'),
    'WedgeMaterialVelocity': '0014510A',
    'WedgeMaterial': '0014510B',
    'WedgeOffsetZ': '0014510C',
    'WedgeOriginOffsetX': '0014510D',
    'WedgeTimeDelay': '0014510E',
    'WedgeName': '0014510F',
    'WedgeManufacturerName': '00145110',
    'WedgeDescription': '00145111',
    'NominalBeamAngle': '00145112',
    'WedgeOffsetX': '00145113',
    'WedgeOffsetY': '00145114',
    'WedgeTotalLength': '00145115',
    'WedgeInContactLength': '00145116',
    'WedgeFrontGap': '00145117',
    'WedgeTotalHeight': '00145118',
    'WedgeFrontHeight': '00145119',
    'WedgeRearHeight': '0014511A',
    'WedgeTotalWidth': '0014511B',
    'WedgeInContactWidth': '0014511C',
    'WedgeChamferHeight': '0014511D',
    'WedgeCurve': '0014511E',
    'RadiusAlongWedge': '0014511F',
    'ContrastBolusAgent': '00180010',
    'ContrastBolusAgentSequence': '00180012',
    '00180013': ('ContrastBolusT1Relaxivity'),
    'ContrastBolusAdministrationRouteSequence': '00180014',
    'BodyPartExamined': '00180015',
    'ScanningSequence': '00180020',
    'SequenceVariant': '00180021',
    'ScanOptions': '00180022',
    'MRAcquisitionType': '00180023',
    'SequenceName': '00180024',
    'AngioFlag': '00180025',
    'InterventionDrugInformationSequence': '00180026',
    'InterventionDrugStopTime': '00180027',
    'InterventionDrugDose': '00180028',
    'InterventionDrugCodeSequence': '00180029',
    'AdditionalDrugSequence': '0018002A',
    'Radionuclide': '00180030',
    'Radiopharmaceutical': '00180031',
    'EnergyWindowCenterline': '00180032',
    'EnergyWindowTotalWidth': '00180033',
    'InterventionDrugName': '00180034',
    'InterventionDrugStartTime': '00180035',
    'InterventionSequence': '00180036',
    'TherapyType': '00180037',
    'InterventionStatus': '00180038',
    'TherapyDescription': '00180039',
    'InterventionDescription': '0018003A',
    'CineRate': '00180040',
    'InitialCineRunState': '00180042',
    'SliceThickness': '00180050',
    'KVP': '00180060',
    '': '00180061',
    'CountsAccumulated': '00180070',
    'AcquisitionTerminationCondition': '00180071',
    'EffectiveDuration': '00180072',
    'AcquisitionStartCondition': '00180073',
    'AcquisitionStartConditionData': '00180074',
    'AcquisitionTerminationConditionData': '00180075',
    'RepetitionTime': '00180080',
    'EchoTime': '00180081',
    'InversionTime': '00180082',
    'NumberOfAverages': '00180083',
    'ImagingFrequency': '00180084',
    'ImagedNucleus': '00180085',
    'EchoNumbers': '00180086',
    'MagneticFieldStrength': '00180087',
    'SpacingBetweenSlices': '00180088',
    'NumberOfPhaseEncodingSteps': '00180089',
    'DataCollectionDiameter': '00180090',
    'EchoTrainLength': '00180091',
    'PercentSampling': '00180093',
    'PercentPhaseFieldOfView': '00180094',
    'PixelBandwidth': '00180095',
    'DeviceSerialNumber': '00181000',
    'DeviceUID': '00181002',
    'DeviceID': '00181003',
    'PlateID': '00181004',
    'GeneratorID': '00181005',
    'GridID': '00181006',
    'CassetteID': '00181007',
    'GantryID': '00181008',
    'UniqueDeviceIdentifier': '00181009',
    'UDISequence': '0018100A',
    'SecondaryCaptureDeviceID': '00181010',
    'HardcopyCreationDeviceID': '00181011',
    'DateOfSecondaryCapture': '00181012',
    'TimeOfSecondaryCapture': '00181014',
    'SecondaryCaptureDeviceManufacturer': '00181016',
    'HardcopyDeviceManufacturer': '00181017',
    'SecondaryCaptureDeviceManufacturerModelName': '00181018',
    'SecondaryCaptureDeviceSoftwareVersions': '00181019',
    'HardcopyDeviceSoftwareVersion': '0018101A',
    'HardcopyDeviceManufacturerModelName': '0018101B',
    'SoftwareVersions': '00181020',
    'VideoImageFormatAcquired': '00181022',
    'DigitalImageFormatAcquired': '00181023',
    'ProtocolName': '00181030',
    'ContrastBolusRoute': '00181040',
    'ContrastBolusVolume': '00181041',
    'ContrastBolusStartTime': '00181042',
    'ContrastBolusStopTime': '00181043',
    'ContrastBolusTotalDose': '00181044',
    'SyringeCounts': '00181045',
    'ContrastFlowRate': '00181046',
    'ContrastFlowDuration': '00181047',
    'ContrastBolusIngredient': '00181048',
    'ContrastBolusIngredientConcentration': '00181049',
    'SpatialResolution': '00181050',
    'TriggerTime': '00181060',
    'TriggerSourceOrType': '00181061',
    'NominalInterval': '00181062',
    'FrameTime': '00181063',
    'CardiacFramingType': '00181064',
    'FrameTimeVector': '00181065',
    'FrameDelay': '00181066',
    'ImageTriggerDelay': '00181067',
    'MultiplexGroupTimeOffset': '00181068',
    'TriggerTimeOffset': '00181069',
    'SynchronizationTrigger': '0018106A',
    'SynchronizationChannel': '0018106C',
    'TriggerSamplePosition': '0018106E',
    'RadiopharmaceuticalRoute': '00181070',
    'RadiopharmaceuticalVolume': '00181071',
    'RadiopharmaceuticalStartTime': '00181072',
    'RadiopharmaceuticalStopTime': '00181073',
    'RadionuclideTotalDose': '00181074',
    'RadionuclideHalfLife': '00181075',
    'RadionuclidePositronFraction': '00181076',
    'RadiopharmaceuticalSpecificActivity': '00181077',
    'RadiopharmaceuticalStartDateTime': '00181078',
    'RadiopharmaceuticalStopDateTime': '00181079',
    'BeatRejectionFlag': '00181080',
    'LowRRValue': '00181081',
    'HighRRValue': '00181082',
    'IntervalsAcquired': '00181083',
    'IntervalsRejected': '00181084',
    'PVCRejection': '00181085',
    'SkipBeats': '00181086',
    'HeartRate': '00181088',
    'CardiacNumberOfImages': '00181090',
    'TriggerWindow': '00181094',
    'ReconstructionDiameter': '00181100',
    'DistanceSourceToDetector': '00181110',
    'DistanceSourceToPatient': '00181111',
    'EstimatedRadiographicMagnificationFactor': '00181114',
    'GantryDetectorTilt': '00181120',
    'GantryDetectorSlew': '00181121',
    'TableHeight': '00181130',
    'TableTraverse': '00181131',
    'TableMotion': '00181134',
    'TableVerticalIncrement': '00181135',
    'TableLateralIncrement': '00181136',
    'TableLongitudinalIncrement': '00181137',
    'TableAngle': '00181138',
    'TableType': '0018113A',
    'RotationDirection': '00181140',
    'AngularPosition': '00181141',
    'RadialPosition': '00181142',
    'ScanArc': '00181143',
    'AngularStep': '00181144',
    'CenterOfRotationOffset': '00181145',
    'RotationOffset': '00181146',
    'FieldOfViewShape': '00181147',
    'FieldOfViewDimensions': '00181149',
    'ExposureTime': '00181150',
    'XRayTubeCurrent': '00181151',
    'Exposure': '00181152',
    'ExposureInuAs': '00181153',
    'AveragePulseWidth': '00181154',
    'RadiationSetting': '00181155',
    'RectificationType': '00181156',
    'RadiationMode': '0018115A',
    'ImageAndFluoroscopyAreaDoseProduct': '0018115E',
    'FilterType': '00181160',
    'TypeOfFilters': '00181161',
    'IntensifierSize': '00181162',
    'ImagerPixelSpacing': '00181164',
    'Grid': '00181166',
    'GeneratorPower': '00181170',
    'CollimatorGridName': '00181180',
    'CollimatorType': '00181181',
    'FocalDistance': '00181182',
    'XFocusCenter': '00181183',
    'YFocusCenter': '00181184',
    'FocalSpots': '00181190',
    'AnodeTargetMaterial': '00181191',
    'BodyPartThickness': '001811A0',
    'CompressionForce': '001811A2',
    'CompressionPressure': '001811A3',
    'PaddleDescription': '001811A4',
    'CompressionContactArea': '001811A5',
    'DateOfLastCalibration': '00181200',
    'TimeOfLastCalibration': '00181201',
    'DateTimeOfLastCalibration': '00181202',
    'ConvolutionKernel': '00181210',
    'UpperLowerPixelValues': '00181240',
    'ActualFrameDuration': '00181242',
    'CountRate': '00181243',
    'PreferredPlaybackSequencing': '00181244',
    'ReceiveCoilName': '00181250',
    'TransmitCoilName': '00181251',
    'PlateType': '00181260',
    'PhosphorType': '00181261',
    'WaterEquivalentDiameter': '00181271',
    'WaterEquivalentDiameterCalculationMethodCodeSequence': '00181272',
    'ScanVelocity': '00181300',
    'WholeBodyTechnique': '00181301',
    'ScanLength': '00181302',
    'AcquisitionMatrix': '00181310',
    'InPlanePhaseEncodingDirection': '00181312',
    'FlipAngle': '00181314',
    'VariableFlipAngleFlag': '00181315',
    'SAR': '00181316',
    'dBdt': '00181318',
    '00181320': ('B1rms'),
    'AcquisitionDeviceProcessingDescription': '00181400',
    'AcquisitionDeviceProcessingCode': '00181401',
    'CassetteOrientation': '00181402',
    'CassetteSize': '00181403',
    'ExposuresOnPlate': '00181404',
    'RelativeXRayExposure': '00181405',
    'ExposureIndex': '00181411',
    'TargetExposureIndex': '00181412',
    'DeviationIndex': '00181413',
    'ColumnAngulation': '00181450',
    'TomoLayerHeight': '00181460',
    'TomoAngle': '00181470',
    'TomoTime': '00181480',
    'TomoType': '00181490',
    'TomoClass': '00181491',
    'NumberOfTomosynthesisSourceImages': '00181495',
    'PositionerMotion': '00181500',
    'PositionerType': '00181508',
    'PositionerPrimaryAngle': '00181510',
    'PositionerSecondaryAngle': '00181511',
    'PositionerPrimaryAngleIncrement': '00181520',
    'PositionerSecondaryAngleIncrement': '00181521',
    'DetectorPrimaryAngle': '00181530',
    'DetectorSecondaryAngle': '00181531',
    'ShutterShape': '00181600',
    'ShutterLeftVerticalEdge': '00181602',
    'ShutterRightVerticalEdge': '00181604',
    'ShutterUpperHorizontalEdge': '00181606',
    'ShutterLowerHorizontalEdge': '00181608',
    'CenterOfCircularShutter': '00181610',
    'RadiusOfCircularShutter': '00181612',
    'VerticesOfThePolygonalShutter': '00181620',
    'ShutterPresentationValue': '00181622',
    'ShutterOverlayGroup': '00181623',
    'ShutterPresentationColorCIELabValue': '00181624',
    'CollimatorShape': '00181700',
    'CollimatorLeftVerticalEdge': '00181702',
    'CollimatorRightVerticalEdge': '00181704',
    'CollimatorUpperHorizontalEdge': '00181706',
    'CollimatorLowerHorizontalEdge': '00181708',
    'CenterOfCircularCollimator': '00181710',
    'RadiusOfCircularCollimator': '00181712',
    'VerticesOfThePolygonalCollimator': '00181720',
    'AcquisitionTimeSynchronized': '00181800',
    'TimeSource': '00181801',
    'TimeDistributionProtocol': '00181802',
    'NTPSourceAddress': '00181803',
    'PageNumberVector': '00182001',
    'FrameLabelVector': '00182002',
    'FramePrimaryAngleVector': '00182003',
    'FrameSecondaryAngleVector': '00182004',
    'SliceLocationVector': '00182005',
    'DisplayWindowLabelVector': '00182006',
    'NominalScannedPixelSpacing': '00182010',
    'DigitizingDeviceTransportDirection': '00182020',
    'RotationOfScannedFilm': '00182030',
    'BiopsyTargetSequence': '00182041',
    'TargetUID': '00182042',
    'LocalizingCursorPosition': '00182043',
    'CalculatedTargetPosition': '00182044',
    'TargetLabel': '00182045',
    'DisplayedZValue': '00182046',
    'IVUSAcquisition': '00183100',
    'IVUSPullbackRate': '00183101',
    'IVUSGatedRate': '00183102',
    'IVUSPullbackStartFrameNumber': '00183103',
    'IVUSPullbackStopFrameNumber': '00183104',
    'LesionNumber': '00183105',
    'AcquisitionComments': '00184000',
    'OutputPower': '00185000',
    'TransducerData': '00185010',
    'FocusDepth': '00185012',
    'ProcessingFunction': '00185020',
    'PostprocessingFunction': '00185021',
    'MechanicalIndex': '00185022',
    'BoneThermalIndex': '00185024',
    'CranialThermalIndex': '00185026',
    'SoftTissueThermalIndex': '00185027',
    'SoftTissueFocusThermalIndex': '00185028',
    'SoftTissueSurfaceThermalIndex': '00185029',
    'DynamicRange': '00185030',
    'TotalGain': '00185040',
    'DepthOfScanField': '00185050',
    'PatientPosition': '00185100',
    'ViewPosition': '00185101',
    'ProjectionEponymousNameCodeSequence': '00185104',
    'ImageTransformationMatrix': '00185210',
    'ImageTranslationVector': '00185212',
    'Sensitivity': '00186000',
    'SequenceOfUltrasoundRegions': '00186011',
    'RegionSpatialFormat': '00186012',
    'RegionDataType': '00186014',
    'RegionFlags': '00186016',
    '00186018': ('RegionLocationMinX0'),
    '0018601A': ('RegionLocationMinY0'),
    '0018601C': ('RegionLocationMaxX1'),
    '0018601E': ('RegionLocationMaxY1'),
    '00186020': ('ReferencePixelX0'),
    '00186022': ('ReferencePixelY0'),
    'PhysicalUnitsXDirection': '00186024',
    'PhysicalUnitsYDirection': '00186026',
    'ReferencePixelPhysicalValueX': '00186028',
    'ReferencePixelPhysicalValueY': '0018602A',
    'PhysicalDeltaX': '0018602C',
    'PhysicalDeltaY': '0018602E',
    'TransducerFrequency': '00186030',
    'TransducerType': '00186031',
    'PulseRepetitionFrequency': '00186032',
    'DopplerCorrectionAngle': '00186034',
    'SteeringAngle': '00186036',
    'DopplerSampleVolumeXPositionRetired': '00186038',
    'DopplerSampleVolumeXPosition': '00186039',
    'DopplerSampleVolumeYPositionRetired': '0018603A',
    'DopplerSampleVolumeYPosition': '0018603B',
    '0018603C': ('TMLinePositionX0Retired'),
    '0018603D': ('TMLinePositionX0'),
    '0018603E': ('TMLinePositionY0Retired'),
    '0018603F': ('TMLinePositionY0'),
    '00186040': ('TMLinePositionX1Retired'),
    '00186041': ('TMLinePositionX1'),
    '00186042': ('TMLinePositionY1Retired'),
    '00186043': ('TMLinePositionY1'),
    'PixelComponentOrganization': '00186044',
    'PixelComponentMask': '00186046',
    'PixelComponentRangeStart': '00186048',
    'PixelComponentRangeStop': '0018604A',
    'PixelComponentPhysicalUnits': '0018604C',
    'PixelComponentDataType': '0018604E',
    'NumberOfTableBreakPoints': '00186050',
    'TableOfXBreakPoints': '00186052',
    'TableOfYBreakPoints': '00186054',
    'NumberOfTableEntries': '00186056',
    'TableOfPixelValues': '00186058',
    'TableOfParameterValues': '0018605A',
    'RWaveTimeVector': '00186060',
    'DetectorConditionsNominalFlag': '00187000',
    'DetectorTemperature': '00187001',
    'DetectorType': '00187004',
    'DetectorConfiguration': '00187005',
    'DetectorDescription': '00187006',
    'DetectorMode': '00187008',
    'DetectorID': '0018700A',
    'DateOfLastDetectorCalibration': '0018700C',
    'TimeOfLastDetectorCalibration': '0018700E',
    'ExposuresOnDetectorSinceLastCalibration': '00187010',
    'ExposuresOnDetectorSinceManufactured': '00187011',
    'DetectorTimeSinceLastExposure': '00187012',
    'DetectorActiveTime': '00187014',
    'DetectorActivationOffsetFromExposure': '00187016',
    'DetectorBinning': '0018701A',
    'DetectorElementPhysicalSize': '00187020',
    'DetectorElementSpacing': '00187022',
    'DetectorActiveShape': '00187024',
    'DetectorActiveDimensions': '00187026',
    'DetectorActiveOrigin': '00187028',
    'DetectorManufacturerName': '0018702A',
    'DetectorManufacturerModelName': '0018702B',
    'FieldOfViewOrigin': '00187030',
    'FieldOfViewRotation': '00187032',
    'FieldOfViewHorizontalFlip': '00187034',
    'PixelDataAreaOriginRelativeToFOV': '00187036',
    'PixelDataAreaRotationAngleRelativeToFOV': '00187038',
    'GridAbsorbingMaterial': '00187040',
    'GridSpacingMaterial': '00187041',
    'GridThickness': '00187042',
    'GridPitch': '00187044',
    'GridAspectRatio': '00187046',
    'GridPeriod': '00187048',
    'GridFocalDistance': '0018704C',
    'FilterMaterial': '00187050',
    'FilterThicknessMinimum': '00187052',
    'FilterThicknessMaximum': '00187054',
    'FilterBeamPathLengthMinimum': '00187056',
    'FilterBeamPathLengthMaximum': '00187058',
    'ExposureControlMode': '00187060',
    'ExposureControlModeDescription': '00187062',
    'ExposureStatus': '00187064',
    'PhototimerSetting': '00187065',
    'ExposureTimeInuS': '00188150',
    'XRayTubeCurrentInuA': '00188151',
    'ContentQualification': '00189004',
    'PulseSequenceName': '00189005',
    'MRImagingModifierSequence': '00189006',
    'EchoPulseSequence': '00189008',
    'InversionRecovery': '00189009',
    'FlowCompensation': '00189010',
    'MultipleSpinEcho': '00189011',
    'MultiPlanarExcitation': '00189012',
    'PhaseContrast': '00189014',
    'TimeOfFlightContrast': '00189015',
    'Spoiling': '00189016',
    'SteadyStatePulseSequence': '00189017',
    'EchoPlanarPulseSequence': '00189018',
    'TagAngleFirstAxis': '00189019',
    'MagnetizationTransfer': '00189020',
    '00189021': ('T2Preparation'),
    'BloodSignalNulling': '00189022',
    'SaturationRecovery': '00189024',
    'SpectrallySelectedSuppression': '00189025',
    'SpectrallySelectedExcitation': '00189026',
    'SpatialPresaturation': '00189027',
    'Tagging': '00189028',
    'OversamplingPhase': '00189029',
    'TagSpacingFirstDimension': '00189030',
    'GeometryOfKSpaceTraversal': '00189032',
    'SegmentedKSpaceTraversal': '00189033',
    'RectilinearPhaseEncodeReordering': '00189034',
    'TagThickness': '00189035',
    'PartialFourierDirection': '00189036',
    'CardiacSynchronizationTechnique': '00189037',
    'ReceiveCoilManufacturerName': '00189041',
    'MRReceiveCoilSequence': '00189042',
    'ReceiveCoilType': '00189043',
    'QuadratureReceiveCoil': '00189044',
    'MultiCoilDefinitionSequence': '00189045',
    'MultiCoilConfiguration': '00189046',
    'MultiCoilElementName': '00189047',
    'MultiCoilElementUsed': '00189048',
    'MRTransmitCoilSequence': '00189049',
    'TransmitCoilManufacturerName': '00189050',
    'TransmitCoilType': '00189051',
    'SpectralWidth': '00189052',
    'ChemicalShiftReference': '00189053',
    'VolumeLocalizationTechnique': '00189054',
    'MRAcquisitionFrequencyEncodingSteps': '00189058',
    'Decoupling': '00189059',
    'DecoupledNucleus': '00189060',
    'DecouplingFrequency': '00189061',
    'DecouplingMethod': '00189062',
    'DecouplingChemicalShiftReference': '00189063',
    'KSpaceFiltering': '00189064',
    'TimeDomainFiltering': '00189065',
    'NumberOfZeroFills': '00189066',
    'BaselineCorrection': '00189067',
    'ParallelReductionFactorInPlane': '00189069',
    'CardiacRRIntervalSpecified': '00189070',
    'AcquisitionDuration': '00189073',
    'FrameAcquisitionDateTime': '00189074',
    'DiffusionDirectionality': '00189075',
    'DiffusionGradientDirectionSequence': '00189076',
    'ParallelAcquisition': '00189077',
    'ParallelAcquisitionTechnique': '00189078',
    'InversionTimes': '00189079',
    'MetaboliteMapDescription': '00189080',
    'PartialFourier': '00189081',
    'EffectiveEchoTime': '00189082',
    'MetaboliteMapCodeSequence': '00189083',
    'ChemicalShiftSequence': '00189084',
    'CardiacSignalSource': '00189085',
    'DiffusionBValue': '00189087',
    'DiffusionGradientOrientation': '00189089',
    'VelocityEncodingDirection': '00189090',
    'VelocityEncodingMinimumValue': '00189091',
    'VelocityEncodingAcquisitionSequence': '00189092',
    'NumberOfKSpaceTrajectories': '00189093',
    'CoverageOfKSpace': '00189094',
    'SpectroscopyAcquisitionPhaseRows': '00189095',
    'ParallelReductionFactorInPlaneRetired': '00189096',
    'TransmitterFrequency': '00189098',
    'ResonantNucleus': '00189100',
    'FrequencyCorrection': '00189101',
    'MRSpectroscopyFOVGeometrySequence': '00189103',
    'SlabThickness': '00189104',
    'SlabOrientation': '00189105',
    'MidSlabPosition': '00189106',
    'MRSpatialSaturationSequence': '00189107',
    'MRTimingAndRelatedParametersSequence': '00189112',
    'MREchoSequence': '00189114',
    'MRModifierSequence': '00189115',
    'MRDiffusionSequence': '00189117',
    'CardiacSynchronizationSequence': '00189118',
    'MRAveragesSequence': '00189119',
    'MRFOVGeometrySequence': '00189125',
    'VolumeLocalizationSequence': '00189126',
    'SpectroscopyAcquisitionDataColumns': '00189127',
    'DiffusionAnisotropyType': '00189147',
    'FrameReferenceDateTime': '00189151',
    'MRMetaboliteMapSequence': '00189152',
    'ParallelReductionFactorOutOfPlane': '00189155',
    'SpectroscopyAcquisitionOutOfPlanePhaseSteps': '00189159',
    'BulkMotionStatus': '00189166',
    'ParallelReductionFactorSecondInPlane': '00189168',
    'CardiacBeatRejectionTechnique': '00189169',
    'RespiratoryMotionCompensationTechnique': '00189170',
    'RespiratorySignalSource': '00189171',
    'BulkMotionCompensationTechnique': '00189172',
    'BulkMotionSignalSource': '00189173',
    'ApplicableSafetyStandardAgency': '00189174',
    'ApplicableSafetyStandardDescription': '00189175',
    'OperatingModeSequence': '00189176',
    'OperatingModeType': '00189177',
    'OperatingMode': '00189178',
    'SpecificAbsorptionRateDefinition': '00189179',
    'GradientOutputType': '00189180',
    'SpecificAbsorptionRateValue': '00189181',
    'GradientOutput': '00189182',
    'FlowCompensationDirection': '00189183',
    'TaggingDelay': '00189184',
    'RespiratoryMotionCompensationTechniqueDescription': '00189185',
    'RespiratorySignalSourceID': '00189186',
    'ChemicalShiftMinimumIntegrationLimitInHz': '00189195',
    'ChemicalShiftMaximumIntegrationLimitInHz': '00189196',
    'MRVelocityEncodingSequence': '00189197',
    'FirstOrderPhaseCorrection': '00189198',
    'WaterReferencedPhaseCorrection': '00189199',
    'MRSpectroscopyAcquisitionType': '00189200',
    'RespiratoryCyclePosition': '00189214',
    'VelocityEncodingMaximumValue': '00189217',
    'TagSpacingSecondDimension': '00189218',
    'TagAngleSecondAxis': '00189219',
    'FrameAcquisitionDuration': '00189220',
    'MRImageFrameTypeSequence': '00189226',
    'MRSpectroscopyFrameTypeSequence': '00189227',
    'MRAcquisitionPhaseEncodingStepsInPlane': '00189231',
    'MRAcquisitionPhaseEncodingStepsOutOfPlane': '00189232',
    'SpectroscopyAcquisitionPhaseColumns': '00189234',
    'CardiacCyclePosition': '00189236',
    'SpecificAbsorptionRateSequence': '00189239',
    'RFEchoTrainLength': '00189240',
    'GradientEchoTrainLength': '00189241',
    'ArterialSpinLabelingContrast': '00189250',
    'MRArterialSpinLabelingSequence': '00189251',
    'ASLTechniqueDescription': '00189252',
    'ASLSlabNumber': '00189253',
    'ASLSlabThickness': '00189254',
    'ASLSlabOrientation': '00189255',
    'ASLMidSlabPosition': '00189256',
    'ASLContext': '00189257',
    'ASLPulseTrainDuration': '00189258',
    'ASLCrusherFlag': '00189259',
    'ASLCrusherFlowLimit': '0018925A',
    'ASLCrusherDescription': '0018925B',
    'ASLBolusCutoffFlag': '0018925C',
    'ASLBolusCutoffTimingSequence': '0018925D',
    'ASLBolusCutoffTechnique': '0018925E',
    'ASLBolusCutoffDelayTime': '0018925F',
    'ASLSlabSequence': '00189260',
    'ChemicalShiftMinimumIntegrationLimitInppm': '00189295',
    'ChemicalShiftMaximumIntegrationLimitInppm': '00189296',
    'WaterReferenceAcquisition': '00189297',
    'EchoPeakPosition': '00189298',
    'CTAcquisitionTypeSequence': '00189301',
    'AcquisitionType': '00189302',
    'TubeAngle': '00189303',
    'CTAcquisitionDetailsSequence': '00189304',
    'RevolutionTime': '00189305',
    'SingleCollimationWidth': '00189306',
    'TotalCollimationWidth': '00189307',
    'CTTableDynamicsSequence': '00189308',
    'TableSpeed': '00189309',
    'TableFeedPerRotation': '00189310',
    'SpiralPitchFactor': '00189311',
    'CTGeometrySequence': '00189312',
    'DataCollectionCenterPatient': '00189313',
    'CTReconstructionSequence': '00189314',
    'ReconstructionAlgorithm': '00189315',
    'ConvolutionKernelGroup': '00189316',
    'ReconstructionFieldOfView': '00189317',
    'ReconstructionTargetCenterPatient': '00189318',
    'ReconstructionAngle': '00189319',
    'ImageFilter': '00189320',
    'CTExposureSequence': '00189321',
    'ReconstructionPixelSpacing': '00189322',
    'ExposureModulationType': '00189323',
    'EstimatedDoseSaving': '00189324',
    'CTXRayDetailsSequence': '00189325',
    'CTPositionSequence': '00189326',
    'TablePosition': '00189327',
    'ExposureTimeInms': '00189328',
    'CTImageFrameTypeSequence': '00189329',
    'XRayTubeCurrentInmA': '00189330',
    'ExposureInmAs': '00189332',
    'ConstantVolumeFlag': '00189333',
    'FluoroscopyFlag': '00189334',
    'DistanceSourceToDataCollectionCenter': '00189335',
    'ContrastBolusAgentNumber': '00189337',
    'ContrastBolusIngredientCodeSequence': '00189338',
    'ContrastAdministrationProfileSequence': '00189340',
    'ContrastBolusUsageSequence': '00189341',
    'ContrastBolusAgentAdministered': '00189342',
    'ContrastBolusAgentDetected': '00189343',
    'ContrastBolusAgentPhase': '00189344',
    'CTDIvol': '00189345',
    'CTDIPhantomTypeCodeSequence': '00189346',
    'CalciumScoringMassFactorPatient': '00189351',
    'CalciumScoringMassFactorDevice': '00189352',
    'EnergyWeightingFactor': '00189353',
    'CTAdditionalXRaySourceSequence': '00189360',
    'ProjectionPixelCalibrationSequence': '00189401',
    'DistanceSourceToIsocenter': '00189402',
    'DistanceObjectToTableTop': '00189403',
    'ObjectPixelSpacingInCenterOfBeam': '00189404',
    'PositionerPositionSequence': '00189405',
    'TablePositionSequence': '00189406',
    'CollimatorShapeSequence': '00189407',
    'PlanesInAcquisition': '00189410',
    'XAXRFFrameCharacteristicsSequence': '00189412',
    'FrameAcquisitionSequence': '00189417',
    'XRayReceptorType': '00189420',
    'AcquisitionProtocolName': '00189423',
    'AcquisitionProtocolDescription': '00189424',
    'ContrastBolusIngredientOpaque': '00189425',
    'DistanceReceptorPlaneToDetectorHousing': '00189426',
    'IntensifierActiveShape': '00189427',
    'IntensifierActiveDimensions': '00189428',
    'PhysicalDetectorSize': '00189429',
    'PositionOfIsocenterProjection': '00189430',
    'FieldOfViewSequence': '00189432',
    'FieldOfViewDescription': '00189433',
    'ExposureControlSensingRegionsSequence': '00189434',
    'ExposureControlSensingRegionShape': '00189435',
    'ExposureControlSensingRegionLeftVerticalEdge': '00189436',
    'ExposureControlSensingRegionRightVerticalEdge': '00189437',
    'ExposureControlSensingRegionUpperHorizontalEdge': '00189438',
    'ExposureControlSensingRegionLowerHorizontalEdge': '00189439',
    'CenterOfCircularExposureControlSensingRegion': '00189440',
    'RadiusOfCircularExposureControlSensingRegion': '00189441',
    'VerticesOfThePolygonalExposureControlSensingRegion': '00189442',
    '': '00189445',
    'ColumnAngulationPatient': '00189447',
    'BeamAngle': '00189449',
    'FrameDetectorParametersSequence': '00189451',
    'CalculatedAnatomyThickness': '00189452',
    'CalibrationSequence': '00189455',
    'ObjectThicknessSequence': '00189456',
    'PlaneIdentification': '00189457',
    'FieldOfViewDimensionsInFloat': '00189461',
    'IsocenterReferenceSystemSequence': '00189462',
    'PositionerIsocenterPrimaryAngle': '00189463',
    'PositionerIsocenterSecondaryAngle': '00189464',
    'PositionerIsocenterDetectorRotationAngle': '00189465',
    'TableXPositionToIsocenter': '00189466',
    'TableYPositionToIsocenter': '00189467',
    'TableZPositionToIsocenter': '00189468',
    'TableHorizontalRotationAngle': '00189469',
    'TableHeadTiltAngle': '00189470',
    'TableCradleTiltAngle': '00189471',
    'FrameDisplayShutterSequence': '00189472',
    'AcquiredImageAreaDoseProduct': '00189473',
    'CArmPositionerTabletopRelationship': '00189474',
    'XRayGeometrySequence': '00189476',
    'IrradiationEventIdentificationSequence': '00189477',
    '00189504': ('XRay3DFrameTypeSequence'),
    'ContributingSourcesSequence': '00189506',
    '00189507': ('XRay3DAcquisitionSequence'),
    'PrimaryPositionerScanArc': '00189508',
    'SecondaryPositionerScanArc': '00189509',
    'PrimaryPositionerScanStartAngle': '00189510',
    'SecondaryPositionerScanStartAngle': '00189511',
    'PrimaryPositionerIncrement': '00189514',
    'SecondaryPositionerIncrement': '00189515',
    'StartAcquisitionDateTime': '00189516',
    'EndAcquisitionDateTime': '00189517',
    'PrimaryPositionerIncrementSign': '00189518',
    'SecondaryPositionerIncrementSign': '00189519',
    'ApplicationName': '00189524',
    'ApplicationVersion': '00189525',
    'ApplicationManufacturer': '00189526',
    'AlgorithmType': '00189527',
    'AlgorithmDescription': '00189528',
    '00189530': ('XRay3DReconstructionSequence'),
    'ReconstructionDescription': '00189531',
    'PerProjectionAcquisitionSequence': '00189538',
    'DetectorPositionSequence': '00189541',
    'XRayAcquisitionDoseSequence': '00189542',
    'XRaySourceIsocenterPrimaryAngle': '00189543',
    'XRaySourceIsocenterSecondaryAngle': '00189544',
    'BreastSupportIsocenterPrimaryAngle': '00189545',
    'BreastSupportIsocenterSecondaryAngle': '00189546',
    'BreastSupportXPositionToIsocenter': '00189547',
    'BreastSupportYPositionToIsocenter': '00189548',
    'BreastSupportZPositionToIsocenter': '00189549',
    'DetectorIsocenterPrimaryAngle': '00189550',
    'DetectorIsocenterSecondaryAngle': '00189551',
    'DetectorXPositionToIsocenter': '00189552',
    'DetectorYPositionToIsocenter': '00189553',
    'DetectorZPositionToIsocenter': '00189554',
    'XRayGridSequence': '00189555',
    'XRayFilterSequence': '00189556',
    'DetectorActiveAreaTLHCPosition': '00189557',
    'DetectorActiveAreaOrientation': '00189558',
    'PositionerPrimaryAngleDirection': '00189559',
    'DiffusionBMatrixSequence': '00189601',
    'DiffusionBValueXX': '00189602',
    'DiffusionBValueXY': '00189603',
    'DiffusionBValueXZ': '00189604',
    'DiffusionBValueYY': '00189605',
    'DiffusionBValueYZ': '00189606',
    'DiffusionBValueZZ': '00189607',
    'FunctionalMRSequence': '00189621',
    'FunctionalSettlingPhaseFramesPresent': '00189622',
    'FunctionalSyncPulse': '00189623',
    'SettlingPhaseFrame': '00189624',
    'DecayCorrectionDateTime': '00189701',
    'StartDensityThreshold': '00189715',
    'StartRelativeDensityDifferenceThreshold': '00189716',
    'StartCardiacTriggerCountThreshold': '00189717',
    'StartRespiratoryTriggerCountThreshold': '00189718',
    'TerminationCountsThreshold': '00189719',
    'TerminationDensityThreshold': '00189720',
    'TerminationRelativeDensityThreshold': '00189721',
    'TerminationTimeThreshold': '00189722',
    'TerminationCardiacTriggerCountThreshold': '00189723',
    'TerminationRespiratoryTriggerCountThreshold': '00189724',
    'DetectorGeometry': '00189725',
    'TransverseDetectorSeparation': '00189726',
    'AxialDetectorDimension': '00189727',
    'RadiopharmaceuticalAgentNumber': '00189729',
    'PETFrameAcquisitionSequence': '00189732',
    'PETDetectorMotionDetailsSequence': '00189733',
    'PETTableDynamicsSequence': '00189734',
    'PETPositionSequence': '00189735',
    'PETFrameCorrectionFactorsSequence': '00189736',
    'RadiopharmaceuticalUsageSequence': '00189737',
    'AttenuationCorrectionSource': '00189738',
    'NumberOfIterations': '00189739',
    'NumberOfSubsets': '00189740',
    'PETReconstructionSequence': '00189749',
    'PETFrameTypeSequence': '00189751',
    'TimeOfFlightInformationUsed': '00189755',
    'ReconstructionType': '00189756',
    'DecayCorrected': '00189758',
    'AttenuationCorrected': '00189759',
    'ScatterCorrected': '00189760',
    'DeadTimeCorrected': '00189761',
    'GantryMotionCorrected': '00189762',
    'PatientMotionCorrected': '00189763',
    'CountLossNormalizationCorrected': '00189764',
    'RandomsCorrected': '00189765',
    'NonUniformRadialSamplingCorrected': '00189766',
    'SensitivityCalibrated': '00189767',
    'DetectorNormalizationCorrection': '00189768',
    'IterativeReconstructionMethod': '00189769',
    'AttenuationCorrectionTemporalRelationship': '00189770',
    'PatientPhysiologicalStateSequence': '00189771',
    'PatientPhysiologicalStateCodeSequence': '00189772',
    'DepthsOfFocus': '00189801',
    'ExcludedIntervalsSequence': '00189803',
    'ExclusionStartDateTime': '00189804',
    'ExclusionDuration': '00189805',
    'USImageDescriptionSequence': '00189806',
    'ImageDataTypeSequence': '00189807',
    'DataType': '00189808',
    'TransducerScanPatternCodeSequence': '00189809',
    'AliasedDataType': '0018980B',
    'PositionMeasuringDeviceUsed': '0018980C',
    'TransducerGeometryCodeSequence': '0018980D',
    'TransducerBeamSteeringCodeSequence': '0018980E',
    'TransducerApplicationCodeSequence': '0018980F',
    'ZeroVelocityPixelValue': '00189810',
    'ReferenceLocationLabel': '00189900',
    'ReferenceLocationDescription': '00189901',
    'ReferenceBasisCodeSequence': '00189902',
    'ReferenceGeometryCodeSequence': '00189903',
    'OffsetDistance': '00189904',
    'OffsetDirection': '00189905',
    'PotentialScheduledProtocolCodeSequence': '00189906',
    'PotentialRequestedProcedureCodeSequence': '00189907',
    'PotentialReasonsForProcedure': '00189908',
    'PotentialReasonsForProcedureCodeSequence': '00189909',
    'PotentialDiagnosticTasks': '0018990A',
    'ContraindicationsCodeSequence': '0018990B',
    'ReferencedDefinedProtocolSequence': '0018990C',
    'ReferencedPerformedProtocolSequence': '0018990D',
    'PredecessorProtocolSequence': '0018990E',
    'ProtocolPlanningInformation': '0018990F',
    'ProtocolDesignRationale': '00189910',
    'PatientSpecificationSequence': '00189911',
    'ModelSpecificationSequence': '00189912',
    'ParametersSpecificationSequence': '00189913',
    'InstructionSequence': '00189914',
    'InstructionIndex': '00189915',
    'InstructionText': '00189916',
    'InstructionDescription': '00189917',
    'InstructionPerformedFlag': '00189918',
    'InstructionPerformedDateTime': '00189919',
    'InstructionPerformanceComment': '0018991A',
    'PatientPositioningInstructionSequence': '0018991B',
    'PositioningMethodCodeSequence': '0018991C',
    'PositioningLandmarkSequence': '0018991D',
    'TargetFrameOfReferenceUID': '0018991E',
    'AcquisitionProtocolElementSpecificationSequence': '0018991F',
    'AcquisitionProtocolElementSequence': '00189920',
    'ProtocolElementNumber': '00189921',
    'ProtocolElementName': '00189922',
    'ProtocolElementCharacteristicsSummary': '00189923',
    'ProtocolElementPurpose': '00189924',
    'AcquisitionMotion': '00189930',
    'AcquisitionStartLocationSequence': '00189931',
    'AcquisitionEndLocationSequence': '00189932',
    'ReconstructionProtocolElementSpecificationSequence': '00189933',
    'ReconstructionProtocolElementSequence': '00189934',
    'StorageProtocolElementSpecificationSequence': '00189935',
    'StorageProtocolElementSequence': '00189936',
    'RequestedSeriesDescription': '00189937',
    'SourceAcquisitionProtocolElementNumber': '00189938',
    'SourceAcquisitionBeamNumber': '00189939',
    'SourceReconstructionProtocolElementNumber': '0018993A',
    'ReconstructionStartLocationSequence': '0018993B',
    'ReconstructionEndLocationSequence': '0018993C',
    'ReconstructionAlgorithmSequence': '0018993D',
    'ReconstructionTargetCenterLocationSequence': '0018993E',
    'ImageFilterDescription': '00189941',
    'CTDIvolNotificationTrigger': '00189942',
    'DLPNotificationTrigger': '00189943',
    'AutoKVPSelectionType': '00189944',
    'AutoKVPUpperBound': '00189945',
    'AutoKVPLowerBound': '00189946',
    'ProtocolDefinedPatientPosition': '00189947',
    'ContributingEquipmentSequence': '0018A001',
    'ContributionDateTime': '0018A002',
    'ContributionDescription': '0018A003',
    'StudyInstanceUID': '0020000D',
    'SeriesInstanceUID': '0020000E',
    'StudyID': '00200010',
    'SeriesNumber': '00200011',
    'AcquisitionNumber': '00200012',
    'InstanceNumber': '00200013',
    'IsotopeNumber': '00200014',
    'PhaseNumber': '00200015',
    'IntervalNumber': '00200016',
    'TimeSlotNumber': '00200017',
    'AngleNumber': '00200018',
    'ItemNumber': '00200019',
    'PatientOrientation': '00200020',
    'OverlayNumber': '00200022',
    'CurveNumber': '00200024',
    'LUTNumber': '00200026',
    'ImagePosition': '00200030',
    'ImagePositionPatient': '00200032',
    'ImageOrientation': '00200035',
    'ImageOrientationPatient': '00200037',
    'Location': '00200050',
    'FrameOfReferenceUID': '00200052',
    'Laterality': '00200060',
    'ImageLaterality': '00200062',
    'ImageGeometryType': '00200070',
    'MaskingImage': '00200080',
    'ReportNumber': '002000AA',
    'TemporalPositionIdentifier': '00200100',
    'NumberOfTemporalPositions': '00200105',
    'TemporalResolution': '00200110',
    'SynchronizationFrameOfReferenceUID': '00200200',
    'SOPInstanceUIDOfConcatenationSource': '00200242',
    'SeriesInStudy': '00201000',
    'AcquisitionsInSeries': '00201001',
    'ImagesInAcquisition': '00201002',
    'ImagesInSeries': '00201003',
    'AcquisitionsInStudy': '00201004',
    'ImagesInStudy': '00201005',
    'Reference': '00201020',
    'TargetPositionReferenceIndicator': '0020103F',
    'PositionReferenceIndicator': '00201040',
    'SliceLocation': '00201041',
    'OtherStudyNumbers': '00201070',
    'NumberOfPatientRelatedStudies': '00201200',
    'NumberOfPatientRelatedSeries': '00201202',
    'NumberOfPatientRelatedInstances': '00201204',
    'NumberOfStudyRelatedSeries': '00201206',
    'NumberOfStudyRelatedInstances': '00201208',
    'NumberOfSeriesRelatedInstances': '00201209',
    'ModifyingDeviceID': '00203401',
    'ModifiedImageID': '00203402',
    'ModifiedImageDate': '00203403',
    'ModifyingDeviceManufacturer': '00203404',
    'ModifiedImageTime': '00203405',
    'ModifiedImageDescription': '00203406',
    'ImageComments': '00204000',
    'OriginalImageIdentification': '00205000',
    'OriginalImageIdentificationNomenclature': '00205002',
    'StackID': '00209056',
    'InStackPositionNumber': '00209057',
    'FrameAnatomySequence': '00209071',
    'FrameLaterality': '00209072',
    'FrameContentSequence': '00209111',
    'PlanePositionSequence': '00209113',
    'PlaneOrientationSequence': '00209116',
    'TemporalPositionIndex': '00209128',
    'NominalCardiacTriggerDelayTime': '00209153',
    'NominalCardiacTriggerTimePriorToRPeak': '00209154',
    'ActualCardiacTriggerTimePriorToRPeak': '00209155',
    'FrameAcquisitionNumber': '00209156',
    'DimensionIndexValues': '00209157',
    'FrameComments': '00209158',
    'ConcatenationUID': '00209161',
    'InConcatenationNumber': '00209162',
    'InConcatenationTotalNumber': '00209163',
    'DimensionOrganizationUID': '00209164',
    'DimensionIndexPointer': '00209165',
    'FunctionalGroupPointer': '00209167',
    'UnassignedSharedConvertedAttributesSequence': '00209170',
    'UnassignedPerFrameConvertedAttributesSequence': '00209171',
    'ConversionSourceAttributesSequence': '00209172',
    'DimensionIndexPrivateCreator': '00209213',
    'DimensionOrganizationSequence': '00209221',
    'DimensionIndexSequence': '00209222',
    'ConcatenationFrameOffsetNumber': '00209228',
    'FunctionalGroupPrivateCreator': '00209238',
    'NominalPercentageOfCardiacPhase': '00209241',
    'NominalPercentageOfRespiratoryPhase': '00209245',
    'StartingRespiratoryAmplitude': '00209246',
    'StartingRespiratoryPhase': '00209247',
    'EndingRespiratoryAmplitude': '00209248',
    'EndingRespiratoryPhase': '00209249',
    'RespiratoryTriggerType': '00209250',
    'RRIntervalTimeNominal': '00209251',
    'ActualCardiacTriggerDelayTime': '00209252',
    'RespiratorySynchronizationSequence': '00209253',
    'RespiratoryIntervalTime': '00209254',
    'NominalRespiratoryTriggerDelayTime': '00209255',
    'RespiratoryTriggerDelayThreshold': '00209256',
    'ActualRespiratoryTriggerDelayTime': '00209257',
    'ImagePositionVolume': '00209301',
    'ImageOrientationVolume': '00209302',
    'UltrasoundAcquisitionGeometry': '00209307',
    'ApexPosition': '00209308',
    'VolumeToTransducerMappingMatrix': '00209309',
    'VolumeToTableMappingMatrix': '0020930A',
    'VolumeToTransducerRelationship': '0020930B',
    'PatientFrameOfReferenceSource': '0020930C',
    'TemporalPositionTimeOffset': '0020930D',
    'PlanePositionVolumeSequence': '0020930E',
    'PlaneOrientationVolumeSequence': '0020930F',
    'TemporalPositionSequence': '00209310',
    'DimensionOrganizationType': '00209311',
    'VolumeFrameOfReferenceUID': '00209312',
    'TableFrameOfReferenceUID': '00209313',
    'DimensionDescriptionLabel': '00209421',
    'PatientOrientationInFrameSequence': '00209450',
    'FrameLabel': '00209453',
    'AcquisitionIndex': '00209518',
    'ContributingSOPInstancesReferenceSequence': '00209529',
    'ReconstructionIndex': '00209536',
    'LightPathFilterPassThroughWavelength': '00220001',
    'LightPathFilterPassBand': '00220002',
    'ImagePathFilterPassThroughWavelength': '00220003',
    'ImagePathFilterPassBand': '00220004',
    'PatientEyeMovementCommanded': '00220005',
    'PatientEyeMovementCommandCodeSequence': '00220006',
    'SphericalLensPower': '00220007',
    'CylinderLensPower': '00220008',
    'CylinderAxis': '00220009',
    'EmmetropicMagnification': '0022000A',
    'IntraOcularPressure': '0022000B',
    'HorizontalFieldOfView': '0022000C',
    'PupilDilated': '0022000D',
    'DegreeOfDilation': '0022000E',
    'StereoBaselineAngle': '00220010',
    'StereoBaselineDisplacement': '00220011',
    'StereoHorizontalPixelOffset': '00220012',
    'StereoVerticalPixelOffset': '00220013',
    'StereoRotation': '00220014',
    'AcquisitionDeviceTypeCodeSequence': '00220015',
    'IlluminationTypeCodeSequence': '00220016',
    'LightPathFilterTypeStackCodeSequence': '00220017',
    'ImagePathFilterTypeStackCodeSequence': '00220018',
    'LensesCodeSequence': '00220019',
    'ChannelDescriptionCodeSequence': '0022001A',
    'RefractiveStateSequence': '0022001B',
    'MydriaticAgentCodeSequence': '0022001C',
    'RelativeImagePositionCodeSequence': '0022001D',
    'CameraAngleOfView': '0022001E',
    'StereoPairsSequence': '00220020',
    'LeftImageSequence': '00220021',
    'RightImageSequence': '00220022',
    'StereoPairsPresent': '00220028',
    'AxialLengthOfTheEye': '00220030',
    'OphthalmicFrameLocationSequence': '00220031',
    'ReferenceCoordinates': '00220032',
    'DepthSpatialResolution': '00220035',
    'MaximumDepthDistortion': '00220036',
    'AlongScanSpatialResolution': '00220037',
    'MaximumAlongScanDistortion': '00220038',
    'OphthalmicImageOrientation': '00220039',
    'DepthOfTransverseImage': '00220041',
    'MydriaticAgentConcentrationUnitsSequence': '00220042',
    'AcrossScanSpatialResolution': '00220048',
    'MaximumAcrossScanDistortion': '00220049',
    'MydriaticAgentConcentration': '0022004E',
    'IlluminationWaveLength': '00220055',
    'IlluminationPower': '00220056',
    'IlluminationBandwidth': '00220057',
    'MydriaticAgentSequence': '00220058',
    'OphthalmicAxialMeasurementsRightEyeSequence': '00221007',
    'OphthalmicAxialMeasurementsLeftEyeSequence': '00221008',
    'OphthalmicAxialMeasurementsDeviceType': '00221009',
    'OphthalmicAxialLengthMeasurementsType': '00221010',
    'OphthalmicAxialLengthSequence': '00221012',
    'OphthalmicAxialLength': '00221019',
    'LensStatusCodeSequence': '00221024',
    'VitreousStatusCodeSequence': '00221025',
    'IOLFormulaCodeSequence': '00221028',
    'IOLFormulaDetail': '00221029',
    'KeratometerIndex': '00221033',
    'SourceOfOphthalmicAxialLengthCodeSequence': '00221035',
    'TargetRefraction': '00221037',
    'RefractiveProcedureOccurred': '00221039',
    'RefractiveSurgeryTypeCodeSequence': '00221040',
    'OphthalmicUltrasoundMethodCodeSequence': '00221044',
    'OphthalmicAxialLengthMeasurementsSequence': '00221050',
    'IOLPower': '00221053',
    'PredictedRefractiveError': '00221054',
    'OphthalmicAxialLengthVelocity': '00221059',
    'LensStatusDescription': '00221065',
    'VitreousStatusDescription': '00221066',
    'IOLPowerSequence': '00221090',
    'LensConstantSequence': '00221092',
    'IOLManufacturer': '00221093',
    'LensConstantDescription': '00221094',
    'ImplantName': '00221095',
    'KeratometryMeasurementTypeCodeSequence': '00221096',
    'ImplantPartNumber': '00221097',
    'ReferencedOphthalmicAxialMeasurementsSequence': '00221100',
    'OphthalmicAxialLengthMeasurementsSegmentNameCodeSequence': '00221101',
    'RefractiveErrorBeforeRefractiveSurgeryCodeSequence': '00221103',
    'IOLPowerForExactEmmetropia': '00221121',
    'IOLPowerForExactTargetRefraction': '00221122',
    'AnteriorChamberDepthDefinitionCodeSequence': '00221125',
    'LensThicknessSequence': '00221127',
    'AnteriorChamberDepthSequence': '00221128',
    'LensThickness': '00221130',
    'AnteriorChamberDepth': '00221131',
    'SourceOfLensThicknessDataCodeSequence': '00221132',
    'SourceOfAnteriorChamberDepthDataCodeSequence': '00221133',
    'SourceOfRefractiveMeasurementsSequence': '00221134',
    'SourceOfRefractiveMeasurementsCodeSequence': '00221135',
    'OphthalmicAxialLengthMeasurementModified': '00221140',
    'OphthalmicAxialLengthDataSourceCodeSequence': '00221150',
    'OphthalmicAxialLengthAcquisitionMethodCodeSequence': '00221153',
    'SignalToNoiseRatio': '00221155',
    'OphthalmicAxialLengthDataSourceDescription': '00221159',
    'OphthalmicAxialLengthMeasurementsTotalLengthSequence': '00221210',
    'OphthalmicAxialLengthMeasurementsSegmentalLengthSequence': '00221211',
    'OphthalmicAxialLengthMeasurementsLengthSummationSequence': '00221212',
    'UltrasoundOphthalmicAxialLengthMeasurementsSequence': '00221220',
    'OpticalOphthalmicAxialLengthMeasurementsSequence': '00221225',
    'UltrasoundSelectedOphthalmicAxialLengthSequence': '00221230',
    'OphthalmicAxialLengthSelectionMethodCodeSequence': '00221250',
    'OpticalSelectedOphthalmicAxialLengthSequence': '00221255',
    'SelectedSegmentalOphthalmicAxialLengthSequence': '00221257',
    'SelectedTotalOphthalmicAxialLengthSequence': '00221260',
    'OphthalmicAxialLengthQualityMetricSequence': '00221262',
    'OphthalmicAxialLengthQualityMetricTypeCodeSequence': '00221265',
    'OphthalmicAxialLengthQualityMetricTypeDescription': '00221273',
    'IntraocularLensCalculationsRightEyeSequence': '00221300',
    'IntraocularLensCalculationsLeftEyeSequence': '00221310',
    'ReferencedOphthalmicAxialLengthMeasurementQCImageSequence': '00221330',
    'OphthalmicMappingDeviceType': '00221415',
    'AcquisitionMethodCodeSequence': '00221420',
    'AcquisitionMethodAlgorithmSequence': '00221423',
    'OphthalmicThicknessMapTypeCodeSequence': '00221436',
    'OphthalmicThicknessMappingNormalsSequence': '00221443',
    'RetinalThicknessDefinitionCodeSequence': '00221445',
    'PixelValueMappingToCodedConceptSequence': '00221450',
    'MappedPixelValue': '00221452',
    'PixelValueMappingExplanation': '00221454',
    'OphthalmicThicknessMapQualityThresholdSequence': '00221458',
    'OphthalmicThicknessMapThresholdQualityRating': '00221460',
    'AnatomicStructureReferencePoint': '00221463',
    'RegistrationToLocalizerSequence': '00221465',
    'RegisteredLocalizerUnits': '00221466',
    'RegisteredLocalizerTopLeftHandCorner': '00221467',
    'RegisteredLocalizerBottomRightHandCorner': '00221468',
    'OphthalmicThicknessMapQualityRatingSequence': '00221470',
    'RelevantOPTAttributesSequence': '00221472',
    'TransformationMethodCodeSequence': '00221512',
    'TransformationAlgorithmSequence': '00221513',
    'OphthalmicAxialLengthMethod': '00221515',
    'OphthalmicFOV': '00221517',
    'TwoDimensionalToThreeDimensionalMapSequence': '00221518',
    'WideFieldOphthalmicPhotographyQualityRatingSequence': '00221525',
    'WideFieldOphthalmicPhotographyQualityThresholdSequence': '00221526',
    'WideFieldOphthalmicPhotographyThresholdQualityRating': '00221527',
    'XCoordinatesCenterPixelViewAngle': '00221528',
    'YCoordinatesCenterPixelViewAngle': '00221529',
    'NumberOfMapPoints': '00221530',
    'TwoDimensionalToThreeDimensionalMapData': '00221531',
    'DerivationAlgorithmSequence': '00221612',
    'OphthalmicImageTypeCodeSequence': '00221615',
    'OphthalmicImageTypeDescription': '00221616',
    'ScanPatternTypeCodeSequence': '00221618',
    'ReferencedSurfaceMeshIdentificationSequence': '00221620',
    'OphthalmicVolumetricPropertiesFlag': '00221622',
    'OphthalmicAnatomicReferencePointXCoordinate': '00221624',
    'OphthalmicAnatomicReferencePointYCoordinate': '00221626',
    'OphthalmicEnFaceImageQualityRatingSequence': '00221628',
    'QualityThreshold': '00221630',
    'OCTBscanAnalysisAcquisitionParametersSequence': '00221640',
    'NumberofBscansPerFrame': '00221642',
    'BscanSlabThickness': '00221643',
    'DistanceBetweenBscanSlabs': '00221644',
    'BscanCycleTime': '00221645',
    'BscanCycleTimeVector': '00221646',
    'AscanRate': '00221649',
    'BscanRate': '00221650',
    'SurfaceMeshZPixelOffset': '00221658',
    'VisualFieldHorizontalExtent': '00240010',
    'VisualFieldVerticalExtent': '00240011',
    'VisualFieldShape': '00240012',
    'ScreeningTestModeCodeSequence': '00240016',
    'MaximumStimulusLuminance': '00240018',
    'BackgroundLuminance': '00240020',
    'StimulusColorCodeSequence': '00240021',
    'BackgroundIlluminationColorCodeSequence': '00240024',
    'StimulusArea': '00240025',
    'StimulusPresentationTime': '00240028',
    'FixationSequence': '00240032',
    'FixationMonitoringCodeSequence': '00240033',
    'VisualFieldCatchTrialSequence': '00240034',
    'FixationCheckedQuantity': '00240035',
    'PatientNotProperlyFixatedQuantity': '00240036',
    'PresentedVisualStimuliDataFlag': '00240037',
    'NumberOfVisualStimuli': '00240038',
    'ExcessiveFixationLossesDataFlag': '00240039',
    'ExcessiveFixationLosses': '00240040',
    'StimuliRetestingQuantity': '00240042',
    'CommentsOnPatientPerformanceOfVisualField': '00240044',
    'FalseNegativesEstimateFlag': '00240045',
    'FalseNegativesEstimate': '00240046',
    'NegativeCatchTrialsQuantity': '00240048',
    'FalseNegativesQuantity': '00240050',
    'ExcessiveFalseNegativesDataFlag': '00240051',
    'ExcessiveFalseNegatives': '00240052',
    'FalsePositivesEstimateFlag': '00240053',
    'FalsePositivesEstimate': '00240054',
    'CatchTrialsDataFlag': '00240055',
    'PositiveCatchTrialsQuantity': '00240056',
    'TestPointNormalsDataFlag': '00240057',
    'TestPointNormalsSequence': '00240058',
    'GlobalDeviationProbabilityNormalsFlag': '00240059',
    'FalsePositivesQuantity': '00240060',
    'ExcessiveFalsePositivesDataFlag': '00240061',
    'ExcessiveFalsePositives': '00240062',
    'VisualFieldTestNormalsFlag': '00240063',
    'ResultsNormalsSequence': '00240064',
    'AgeCorrectedSensitivityDeviationAlgorithmSequence': '00240065',
    'GlobalDeviationFromNormal': '00240066',
    'GeneralizedDefectSensitivityDeviationAlgorithmSequence': '00240067',
    'LocalizedDeviationFromNormal': '00240068',
    'PatientReliabilityIndicator': '00240069',
    'VisualFieldMeanSensitivity': '00240070',
    'GlobalDeviationProbability': '00240071',
    'LocalDeviationProbabilityNormalsFlag': '00240072',
    'LocalizedDeviationProbability': '00240073',
    'ShortTermFluctuationCalculated': '00240074',
    'ShortTermFluctuation': '00240075',
    'ShortTermFluctuationProbabilityCalculated': '00240076',
    'ShortTermFluctuationProbability': '00240077',
    'CorrectedLocalizedDeviationFromNormalCalculated': '00240078',
    'CorrectedLocalizedDeviationFromNormal': '00240079',
    'CorrectedLocalizedDeviationFromNormalProbabilityCalculated': '00240080',
    'CorrectedLocalizedDeviationFromNormalProbability': '00240081',
    'GlobalDeviationProbabilitySequence': '00240083',
    'LocalizedDeviationProbabilitySequence': '00240085',
    'FovealSensitivityMeasured': '00240086',
    'FovealSensitivity': '00240087',
    'VisualFieldTestDuration': '00240088',
    'VisualFieldTestPointSequence': '00240089',
    'VisualFieldTestPointXCoordinate': '00240090',
    'VisualFieldTestPointYCoordinate': '00240091',
    'AgeCorrectedSensitivityDeviationValue': '00240092',
    'StimulusResults': '00240093',
    'SensitivityValue': '00240094',
    'RetestStimulusSeen': '00240095',
    'RetestSensitivityValue': '00240096',
    'VisualFieldTestPointNormalsSequence': '00240097',
    'QuantifiedDefect': '00240098',
    'AgeCorrectedSensitivityDeviationProbabilityValue': '00240100',
    'GeneralizedDefectCorrectedSensitivityDeviationFlag': '00240102',
    'GeneralizedDefectCorrectedSensitivityDeviationValue': '00240103',
    'GeneralizedDefectCorrectedSensitivityDeviationProbabilityValue': '00240104',
    'MinimumSensitivityValue': '00240105',
    'BlindSpotLocalized': '00240106',
    'BlindSpotXCoordinate': '00240107',
    'BlindSpotYCoordinate': '00240108',
    'VisualAcuityMeasurementSequence': '00240110',
    'RefractiveParametersUsedOnPatientSequence': '00240112',
    'MeasurementLaterality': '00240113',
    'OphthalmicPatientClinicalInformationLeftEyeSequence': '00240114',
    'OphthalmicPatientClinicalInformationRightEyeSequence': '00240115',
    'FovealPointNormativeDataFlag': '00240117',
    'FovealPointProbabilityValue': '00240118',
    'ScreeningBaselineMeasured': '00240120',
    'ScreeningBaselineMeasuredSequence': '00240122',
    'ScreeningBaselineType': '00240124',
    'ScreeningBaselineValue': '00240126',
    'AlgorithmSource': '00240202',
    'DataSetName': '00240306',
    'DataSetVersion': '00240307',
    'DataSetSource': '00240308',
    'DataSetDescription': '00240309',
    'VisualFieldTestReliabilityGlobalIndexSequence': '00240317',
    'VisualFieldGlobalResultsIndexSequence': '00240320',
    'DataObservationSequence': '00240325',
    'IndexNormalsFlag': '00240338',
    'IndexProbability': '00240341',
    'IndexProbabilitySequence': '00240344',
    'SamplesPerPixel': '00280002',
    'SamplesPerPixelUsed': '00280003',
    'PhotometricInterpretation': '00280004',
    'ImageDimensions': '00280005',
    'PlanarConfiguration': '00280006',
    'NumberOfFrames': '00280008',
    'FrameIncrementPointer': '00280009',
    'FrameDimensionPointer': '0028000A',
    'Rows': '00280010',
    'Columns': '00280011',
    'Planes': '00280012',
    'UltrasoundColorDataPresent': '00280014',
    '': '00280020',
    'PixelSpacing': '00280030',
    'ZoomFactor': '00280031',
    'ZoomCenter': '00280032',
    'PixelAspectRatio': '00280034',
    'ImageFormat': '00280040',
    'ManipulatedImage': '00280050',
    'CorrectedImage': '00280051',
    'CompressionRecognitionCode': '0028005F',
    'CompressionCode': '00280060',
    'CompressionOriginator': '00280061',
    'CompressionLabel': '00280062',
    'CompressionDescription': '00280063',
    'CompressionSequence': '00280065',
    'CompressionStepPointers': '00280066',
    'RepeatInterval': '00280068',
    'BitsGrouped': '00280069',
    'PerimeterTable': '00280070',
    'PerimeterValue': '00280071',
    'PredictorRows': '00280080',
    'PredictorColumns': '00280081',
    'PredictorConstants': '00280082',
    'BlockedPixels': '00280090',
    'BlockRows': '00280091',
    'BlockColumns': '00280092',
    'RowOverlap': '00280093',
    'ColumnOverlap': '00280094',
    'BitsAllocated': '00280100',
    'BitsStored': '00280101',
    'HighBit': '00280102',
    'PixelRepresentation': '00280103',
    'SmallestValidPixelValue': '00280104',
    'LargestValidPixelValue': '00280105',
    'SmallestImagePixelValue': '00280106',
    'LargestImagePixelValue': '00280107',
    'SmallestPixelValueInSeries': '00280108',
    'LargestPixelValueInSeries': '00280109',
    'SmallestImagePixelValueInPlane': '00280110',
    'LargestImagePixelValueInPlane': '00280111',
    'PixelPaddingValue': '00280120',
    'PixelPaddingRangeLimit': '00280121',
    'FloatPixelPaddingValue': '00280122',
    'DoubleFloatPixelPaddingValue': '00280123',
    'FloatPixelPaddingRangeLimit': '00280124',
    'DoubleFloatPixelPaddingRangeLimit': '00280125',
    'ImageLocation': '00280200',
    'QualityControlImage': '00280300',
    'BurnedInAnnotation': '00280301',
    'RecognizableVisualFeatures': '00280302',
    'LongitudinalTemporalInformationModified': '00280303',
    'ReferencedColorPaletteInstanceUID': '00280304',
    'TransformLabel': '00280400',
    'TransformVersionNumber': '00280401',
    'NumberOfTransformSteps': '00280402',
    'SequenceOfCompressedData': '00280403',
    'DetailsOfCoefficients': '00280404',
    'DCTLabel': '00280700',
    'DataBlockDescription': '00280701',
    'DataBlock': '00280702',
    'NormalizationFactorFormat': '00280710',
    'ZonalMapNumberFormat': '00280720',
    'ZonalMapLocation': '00280721',
    'ZonalMapFormat': '00280722',
    'AdaptiveMapFormat': '00280730',
    'CodeNumberFormat': '00280740',
    'PixelSpacingCalibrationType': '00280A02',
    'PixelSpacingCalibrationDescription': '00280A04',
    'PixelIntensityRelationship': '00281040',
    'PixelIntensityRelationshipSign': '00281041',
    'WindowCenter': '00281050',
    'WindowWidth': '00281051',
    'RescaleIntercept': '00281052',
    'RescaleSlope': '00281053',
    'RescaleType': '00281054',
    'WindowCenterWidthExplanation': '00281055',
    'VOILUTFunction': '00281056',
    'GrayScale': '00281080',
    'RecommendedViewingMode': '00281090',
    'GrayLookupTableDescriptor': '00281100',
    'RedPaletteColorLookupTableDescriptor': '00281101',
    'GreenPaletteColorLookupTableDescriptor': '00281102',
    'BluePaletteColorLookupTableDescriptor': '00281103',
    'AlphaPaletteColorLookupTableDescriptor': '00281104',
    'LargeRedPaletteColorLookupTableDescriptor': '00281111',
    'LargeGreenPaletteColorLookupTableDescriptor': '00281112',
    'LargeBluePaletteColorLookupTableDescriptor': '00281113',
    'PaletteColorLookupTableUID': '00281199',
    'GrayLookupTableData': '00281200',
    'RedPaletteColorLookupTableData': '00281201',
    'GreenPaletteColorLookupTableData': '00281202',
    'BluePaletteColorLookupTableData': '00281203',
    'AlphaPaletteColorLookupTableData': '00281204',
    'LargeRedPaletteColorLookupTableData': '00281211',
    'LargeGreenPaletteColorLookupTableData': '00281212',
    'LargeBluePaletteColorLookupTableData': '00281213',
    'LargePaletteColorLookupTableUID': '00281214',
    'SegmentedRedPaletteColorLookupTableData': '00281221',
    'SegmentedGreenPaletteColorLookupTableData': '00281222',
    'SegmentedBluePaletteColorLookupTableData': '00281223',
    'SegmentedAlphaPaletteColorLookupTableData': '00281224',
    'StoredValueColorRangeSequence': '00281230',
    'MinimumStoredValueMapped': '00281231',
    'MaximumStoredValueMapped': '00281232',
    'BreastImplantPresent': '00281300',
    'PartialView': '00281350',
    'PartialViewDescription': '00281351',
    'PartialViewCodeSequence': '00281352',
    'SpatialLocationsPreserved': '0028135A',
    'DataFrameAssignmentSequence': '00281401',
    'DataPathAssignment': '00281402',
    'BitsMappedToColorLookupTable': '00281403',
    '00281404': ('BlendingLUT1Sequence'),
    '00281405': ('BlendingLUT1TransferFunction'),
    'BlendingWeightConstant': '00281406',
    'BlendingLookupTableDescriptor': '00281407',
    'BlendingLookupTableData': '00281408',
    'EnhancedPaletteColorLookupTableSequence': '0028140B',
    '0028140C': ('BlendingLUT2Sequence'),
    '0028140D': ('BlendingLUT2TransferFunction'),
    'DataPathID': '0028140E',
    'RGBLUTTransferFunction': '0028140F',
    'AlphaLUTTransferFunction': '00281410',
    'ICCProfile': '00282000',
    'ColorSpace': '00282002',
    'LossyImageCompression': '00282110',
    'LossyImageCompressionRatio': '00282112',
    'LossyImageCompressionMethod': '00282114',
    'ModalityLUTSequence': '00283000',
    'LUTDescriptor': '00283002',
    'LUTExplanation': '00283003',
    'ModalityLUTType': '00283004',
    'LUTData': '00283006',
    'VOILUTSequence': '00283010',
    'SoftcopyVOILUTSequence': '00283110',
    'ImagePresentationComments': '00284000',
    'BiPlaneAcquisitionSequence': '00285000',
    'RepresentativeFrameNumber': '00286010',
    'FrameNumbersOfInterest': '00286020',
    'FrameOfInterestDescription': '00286022',
    'FrameOfInterestType': '00286023',
    'MaskPointers': '00286030',
    'RWavePointer': '00286040',
    'MaskSubtractionSequence': '00286100',
    'MaskOperation': '00286101',
    'ApplicableFrameRange': '00286102',
    'MaskFrameNumbers': '00286110',
    'ContrastFrameAveraging': '00286112',
    'MaskSubPixelShift': '00286114',
    'TIDOffset': '00286120',
    'MaskOperationExplanation': '00286190',
    'EquipmentAdministratorSequence': '00287000',
    'NumberOfDisplaySubsystems': '00287001',
    'CurrentConfigurationID': '00287002',
    'DisplaySubsystemID': '00287003',
    'DisplaySubsystemName': '00287004',
    'DisplaySubsystemDescription': '00287005',
    'SystemStatus': '00287006',
    'SystemStatusComment': '00287007',
    'TargetLuminanceCharacteristicsSequence': '00287008',
    'LuminanceCharacteristicsID': '00287009',
    'DisplaySubsystemConfigurationSequence': '0028700A',
    'ConfigurationID': '0028700B',
    'ConfigurationName': '0028700C',
    'ConfigurationDescription': '0028700D',
    'ReferencedTargetLuminanceCharacteristicsID': '0028700E',
    'QAResultsSequence': '0028700F',
    'DisplaySubsystemQAResultsSequence': '00287010',
    'ConfigurationQAResultsSequence': '00287011',
    'MeasurementEquipmentSequence': '00287012',
    'MeasurementFunctions': '00287013',
    'MeasurementEquipmentType': '00287014',
    'VisualEvaluationResultSequence': '00287015',
    'DisplayCalibrationResultSequence': '00287016',
    'DDLValue': '00287017',
    'CIExyWhitePoint': '00287018',
    'DisplayFunctionType': '00287019',
    'GammaValue': '0028701A',
    'NumberOfLuminancePoints': '0028701B',
    'LuminanceResponseSequence': '0028701C',
    'TargetMinimumLuminance': '0028701D',
    'TargetMaximumLuminance': '0028701E',
    'LuminanceValue': '0028701F',
    'LuminanceResponseDescription': '00287020',
    'WhitePointFlag': '00287021',
    'DisplayDeviceTypeCodeSequence': '00287022',
    'DisplaySubsystemSequence': '00287023',
    'LuminanceResultSequence': '00287024',
    'AmbientLightValueSource': '00287025',
    'MeasuredCharacteristics': '00287026',
    'LuminanceUniformityResultSequence': '00287027',
    'VisualEvaluationTestSequence': '00287028',
    'TestResult': '00287029',
    'TestResultComment': '0028702A',
    'TestImageValidation': '0028702B',
    'TestPatternCodeSequence': '0028702C',
    'MeasurementPatternCodeSequence': '0028702D',
    'VisualEvaluationMethodCodeSequence': '0028702E',
    'PixelDataProviderURL': '00287FE0',
    'DataPointRows': '00289001',
    'DataPointColumns': '00289002',
    'SignalDomainColumns': '00289003',
    'LargestMonochromePixelValue': '00289099',
    'DataRepresentation': '00289108',
    'PixelMeasuresSequence': '00289110',
    'FrameVOILUTSequence': '00289132',
    'PixelValueTransformationSequence': '00289145',
    'SignalDomainRows': '00289235',
    'DisplayFilterPercentage': '00289411',
    'FramePixelShiftSequence': '00289415',
    'SubtractionItemID': '00289416',
    'PixelIntensityRelationshipLUTSequence': '00289422',
    'FramePixelDataPropertiesSequence': '00289443',
    'GeometricalProperties': '00289444',
    'GeometricMaximumDistortion': '00289445',
    'ImageProcessingApplied': '00289446',
    'MaskSelectionMode': '00289454',
    'LUTFunction': '00289474',
    'MaskVisibilityPercentage': '00289478',
    'PixelShiftSequence': '00289501',
    'RegionPixelShiftSequence': '00289502',
    'VerticesOfTheRegion': '00289503',
    'MultiFramePresentationSequence': '00289505',
    'PixelShiftFrameRange': '00289506',
    'LUTFrameRange': '00289507',
    'ImageToEquipmentMappingMatrix': '00289520',
    'EquipmentCoordinateSystemIdentification': '00289537',
    'StudyStatusID': '0032000A',
    'StudyPriorityID': '0032000C',
    'StudyIDIssuer': '00320012',
    'StudyVerifiedDate': '00320032',
    'StudyVerifiedTime': '00320033',
    'StudyReadDate': '00320034',
    'StudyReadTime': '00320035',
    'ScheduledStudyStartDate': '00321000',
    'ScheduledStudyStartTime': '00321001',
    'ScheduledStudyStopDate': '00321010',
    'ScheduledStudyStopTime': '00321011',
    'ScheduledStudyLocation': '00321020',
    'ScheduledStudyLocationAETitle': '00321021',
    'ReasonForStudy': '00321030',
    'RequestingPhysicianIdentificationSequence': '00321031',
    'RequestingPhysician': '00321032',
    'RequestingService': '00321033',
    'RequestingServiceCodeSequence': '00321034',
    'StudyArrivalDate': '00321040',
    'StudyArrivalTime': '00321041',
    'StudyCompletionDate': '00321050',
    'StudyCompletionTime': '00321051',
    'StudyComponentStatusID': '00321055',
    'RequestedProcedureDescription': '00321060',
    'RequestedProcedureCodeSequence': '00321064',
    'RequestedContrastAgent': '00321070',
    'StudyComments': '00324000',
    'ReferencedPatientAliasSequence': '00380004',
    'VisitStatusID': '00380008',
    'AdmissionID': '00380010',
    'IssuerOfAdmissionID': '00380011',
    'IssuerOfAdmissionIDSequence': '00380014',
    'RouteOfAdmissions': '00380016',
    'ScheduledAdmissionDate': '0038001A',
    'ScheduledAdmissionTime': '0038001B',
    'ScheduledDischargeDate': '0038001C',
    'ScheduledDischargeTime': '0038001D',
    'ScheduledPatientInstitutionResidence': '0038001E',
    'AdmittingDate': '00380020',
    'AdmittingTime': '00380021',
    'DischargeDate': '00380030',
    'DischargeTime': '00380032',
    'DischargeDiagnosisDescription': '00380040',
    'DischargeDiagnosisCodeSequence': '00380044',
    'SpecialNeeds': '00380050',
    'ServiceEpisodeID': '00380060',
    'IssuerOfServiceEpisodeID': '00380061',
    'ServiceEpisodeDescription': '00380062',
    'IssuerOfServiceEpisodeIDSequence': '00380064',
    'PertinentDocumentsSequence': '00380100',
    'PertinentResourcesSequence': '00380101',
    'ResourceDescription': '00380102',
    'CurrentPatientLocation': '00380300',
    'PatientInstitutionResidence': '00380400',
    'PatientState': '00380500',
    'PatientClinicalTrialParticipationSequence': '00380502',
    'VisitComments': '00384000',
    'WaveformOriginality': '003A0004',
    'NumberOfWaveformChannels': '003A0005',
    'NumberOfWaveformSamples': '003A0010',
    'SamplingFrequency': '003A001A',
    'MultiplexGroupLabel': '003A0020',
    'ChannelDefinitionSequence': '003A0200',
    'WaveformChannelNumber': '003A0202',
    'ChannelLabel': '003A0203',
    'ChannelStatus': '003A0205',
    'ChannelSourceSequence': '003A0208',
    'ChannelSourceModifiersSequence': '003A0209',
    'SourceWaveformSequence': '003A020A',
    'ChannelDerivationDescription': '003A020C',
    'ChannelSensitivity': '003A0210',
    'ChannelSensitivityUnitsSequence': '003A0211',
    'ChannelSensitivityCorrectionFactor': '003A0212',
    'ChannelBaseline': '003A0213',
    'ChannelTimeSkew': '003A0214',
    'ChannelSampleSkew': '003A0215',
    'ChannelOffset': '003A0218',
    'WaveformBitsStored': '003A021A',
    'FilterLowFrequency': '003A0220',
    'FilterHighFrequency': '003A0221',
    'NotchFilterFrequency': '003A0222',
    'NotchFilterBandwidth': '003A0223',
    'WaveformDataDisplayScale': '003A0230',
    'WaveformDisplayBackgroundCIELabValue': '003A0231',
    'WaveformPresentationGroupSequence': '003A0240',
    'PresentationGroupNumber': '003A0241',
    'ChannelDisplaySequence': '003A0242',
    'ChannelRecommendedDisplayCIELabValue': '003A0244',
    'ChannelPosition': '003A0245',
    'DisplayShadingFlag': '003A0246',
    'FractionalChannelDisplayScale': '003A0247',
    'AbsoluteChannelDisplayScale': '003A0248',
    'MultiplexedAudioChannelsDescriptionCodeSequence': '003A0300',
    'ChannelIdentificationCode': '003A0301',
    'ChannelMode': '003A0302',
    'ScheduledStationAETitle': '00400001',
    'ScheduledProcedureStepStartDate': '00400002',
    'ScheduledProcedureStepStartTime': '00400003',
    'ScheduledProcedureStepEndDate': '00400004',
    'ScheduledProcedureStepEndTime': '00400005',
    'ScheduledPerformingPhysicianName': '00400006',
    'ScheduledProcedureStepDescription': '00400007',
    'ScheduledProtocolCodeSequence': '00400008',
    'ScheduledProcedureStepID': '00400009',
    'StageCodeSequence': '0040000A',
    'ScheduledPerformingPhysicianIdentificationSequence': '0040000B',
    'ScheduledStationName': '00400010',
    'ScheduledProcedureStepLocation': '00400011',
    'PreMedication': '00400012',
    'ScheduledProcedureStepStatus': '00400020',
    'OrderPlacerIdentifierSequence': '00400026',
    'OrderFillerIdentifierSequence': '00400027',
    'LocalNamespaceEntityID': '00400031',
    'UniversalEntityID': '00400032',
    'UniversalEntityIDType': '00400033',
    'IdentifierTypeCode': '00400035',
    'AssigningFacilitySequence': '00400036',
    'AssigningJurisdictionCodeSequence': '00400039',
    'AssigningAgencyOrDepartmentCodeSequence': '0040003A',
    'ScheduledProcedureStepSequence': '00400100',
    'ReferencedNonImageCompositeSOPInstanceSequence': '00400220',
    'PerformedStationAETitle': '00400241',
    'PerformedStationName': '00400242',
    'PerformedLocation': '00400243',
    'PerformedProcedureStepStartDate': '00400244',
    'PerformedProcedureStepStartTime': '00400245',
    'PerformedProcedureStepEndDate': '00400250',
    'PerformedProcedureStepEndTime': '00400251',
    'PerformedProcedureStepStatus': '00400252',
    'PerformedProcedureStepID': '00400253',
    'PerformedProcedureStepDescription': '00400254',
    'PerformedProcedureTypeDescription': '00400255',
    'PerformedProtocolCodeSequence': '00400260',
    'PerformedProtocolType': '00400261',
    'ScheduledStepAttributesSequence': '00400270',
    'RequestAttributesSequence': '00400275',
    'CommentsOnThePerformedProcedureStep': '00400280',
    'PerformedProcedureStepDiscontinuationReasonCodeSequence': '00400281',
    'QuantitySequence': '00400293',
    'Quantity': '00400294',
    'MeasuringUnitsSequence': '00400295',
    'BillingItemSequence': '00400296',
    'TotalTimeOfFluoroscopy': '00400300',
    'TotalNumberOfExposures': '00400301',
    'EntranceDose': '00400302',
    'ExposedArea': '00400303',
    'DistanceSourceToEntrance': '00400306',
    'DistanceSourceToSupport': '00400307',
    'ExposureDoseSequence': '0040030E',
    'CommentsOnRadiationDose': '00400310',
    'XRayOutput': '00400312',
    'HalfValueLayer': '00400314',
    'OrganDose': '00400316',
    'OrganExposed': '00400318',
    'BillingProcedureStepSequence': '00400320',
    'FilmConsumptionSequence': '00400321',
    'BillingSuppliesAndDevicesSequence': '00400324',
    'ReferencedProcedureStepSequence': '00400330',
    'PerformedSeriesSequence': '00400340',
    'CommentsOnTheScheduledProcedureStep': '00400400',
    'ProtocolContextSequence': '00400440',
    'ContentItemModifierSequence': '00400441',
    'ScheduledSpecimenSequence': '00400500',
    'SpecimenAccessionNumber': '0040050A',
    'ContainerIdentifier': '00400512',
    'IssuerOfTheContainerIdentifierSequence': '00400513',
    'AlternateContainerIdentifierSequence': '00400515',
    'ContainerTypeCodeSequence': '00400518',
    'ContainerDescription': '0040051A',
    'ContainerComponentSequence': '00400520',
    'SpecimenSequence': '00400550',
    'SpecimenIdentifier': '00400551',
    'SpecimenDescriptionSequenceTrial': '00400552',
    'SpecimenDescriptionTrial': '00400553',
    'SpecimenUID': '00400554',
    'AcquisitionContextSequence': '00400555',
    'AcquisitionContextDescription': '00400556',
    'SpecimenDescriptionSequence': '00400560',
    'IssuerOfTheSpecimenIdentifierSequence': '00400562',
    'SpecimenTypeCodeSequence': '0040059A',
    'SpecimenShortDescription': '00400600',
    'SpecimenDetailedDescription': '00400602',
    'SpecimenPreparationSequence': '00400610',
    'SpecimenPreparationStepContentItemSequence': '00400612',
    'SpecimenLocalizationContentItemSequence': '00400620',
    'SlideIdentifier': '004006FA',
    'WholeSlideMicroscopyImageFrameTypeSequence': '00400710',
    'ImageCenterPointCoordinatesSequence': '0040071A',
    'XOffsetInSlideCoordinateSystem': '0040072A',
    'YOffsetInSlideCoordinateSystem': '0040073A',
    'ZOffsetInSlideCoordinateSystem': '0040074A',
    'PixelSpacingSequence': '004008D8',
    'CoordinateSystemAxisCodeSequence': '004008DA',
    'MeasurementUnitsCodeSequence': '004008EA',
    'VitalStainCodeSequenceTrial': '004009F8',
    'RequestedProcedureID': '00401001',
    'ReasonForTheRequestedProcedure': '00401002',
    'RequestedProcedurePriority': '00401003',
    'PatientTransportArrangements': '00401004',
    'RequestedProcedureLocation': '00401005',
    'PlacerOrderNumberProcedure': '00401006',
    'FillerOrderNumberProcedure': '00401007',
    'ConfidentialityCode': '00401008',
    'ReportingPriority': '00401009',
    'ReasonForRequestedProcedureCodeSequence': '0040100A',
    'NamesOfIntendedRecipientsOfResults': '00401010',
    'IntendedRecipientsOfResultsIdentificationSequence': '00401011',
    'ReasonForPerformedProcedureCodeSequence': '00401012',
    'RequestedProcedureDescriptionTrial': '00401060',
    'PersonIdentificationCodeSequence': '00401101',
    'PersonAddress': '00401102',
    'PersonTelephoneNumbers': '00401103',
    'PersonTelecomInformation': '00401104',
    'RequestedProcedureComments': '00401400',
    'ReasonForTheImagingServiceRequest': '00402001',
    'IssueDateOfImagingServiceRequest': '00402004',
    'IssueTimeOfImagingServiceRequest': '00402005',
    'PlacerOrderNumberImagingServiceRequestRetired': '00402006',
    'FillerOrderNumberImagingServiceRequestRetired': '00402007',
    'OrderEnteredBy': '00402008',
    'OrderEntererLocation': '00402009',
    'OrderCallbackPhoneNumber': '00402010',
    'OrderCallbackTelecomInformation': '00402011',
    'PlacerOrderNumberImagingServiceRequest': '00402016',
    'FillerOrderNumberImagingServiceRequest': '00402017',
    'ImagingServiceRequestComments': '00402400',
    'ConfidentialityConstraintOnPatientDataDescription': '00403001',
    'GeneralPurposeScheduledProcedureStepStatus': '00404001',
    'GeneralPurposePerformedProcedureStepStatus': '00404002',
    'GeneralPurposeScheduledProcedureStepPriority': '00404003',
    'ScheduledProcessingApplicationsCodeSequence': '00404004',
    'ScheduledProcedureStepStartDateTime': '00404005',
    'MultipleCopiesFlag': '00404006',
    'PerformedProcessingApplicationsCodeSequence': '00404007',
    'ScheduledProcedureStepExpirationDateTime': '00404008',
    'HumanPerformerCodeSequence': '00404009',
    'ScheduledProcedureStepModificationDateTime': '00404010',
    'ExpectedCompletionDateTime': '00404011',
    'ResultingGeneralPurposePerformedProcedureStepsSequence': '00404015',
    'ReferencedGeneralPurposeScheduledProcedureStepSequence': '00404016',
    'ScheduledWorkitemCodeSequence': '00404018',
    'PerformedWorkitemCodeSequence': '00404019',
    'InputAvailabilityFlag': '00404020',
    'InputInformationSequence': '00404021',
    'RelevantInformationSequence': '00404022',
    'ReferencedGeneralPurposeScheduledProcedureStepTransactionUID': '00404023',
    'ScheduledStationNameCodeSequence': '00404025',
    'ScheduledStationClassCodeSequence': '00404026',
    'ScheduledStationGeographicLocationCodeSequence': '00404027',
    'PerformedStationNameCodeSequence': '00404028',
    'PerformedStationClassCodeSequence': '00404029',
    'PerformedStationGeographicLocationCodeSequence': '00404030',
    'RequestedSubsequentWorkitemCodeSequence': '00404031',
    'NonDICOMOutputCodeSequence': '00404032',
    'OutputInformationSequence': '00404033',
    'ScheduledHumanPerformersSequence': '00404034',
    'ActualHumanPerformersSequence': '00404035',
    'HumanPerformerOrganization': '00404036',
    'HumanPerformerName': '00404037',
    'RawDataHandling': '00404040',
    'InputReadinessState': '00404041',
    'PerformedProcedureStepStartDateTime': '00404050',
    'PerformedProcedureStepEndDateTime': '00404051',
    'ProcedureStepCancellationDateTime': '00404052',
    'OutputDestinationSequence': '00404070',
    'DICOMStorageSequence': '00404071',
    'STOWRSStorageSequence': '00404072',
    'StorageURL': '00404073',
    'XDSStorageSequence': '00404074',
    'EntranceDoseInmGy': '00408302',
    'EntranceDoseDerivation': '00408303',
    'ParametricMapFrameTypeSequence': '00409092',
    'ReferencedImageRealWorldValueMappingSequence': '00409094',
    'RealWorldValueMappingSequence': '00409096',
    'PixelValueMappingCodeSequence': '00409098',
    'LUTLabel': '00409210',
    'RealWorldValueLastValueMapped': '00409211',
    'RealWorldValueLUTData': '00409212',
    'DoubleFloatRealWorldValueLastValueMapped': '00409213',
    'DoubleFloatRealWorldValueFirstValueMapped': '00409214',
    'RealWorldValueFirstValueMapped': '00409216',
    'QuantityDefinitionSequence': '00409220',
    'RealWorldValueIntercept': '00409224',
    'RealWorldValueSlope': '00409225',
    'FindingsFlagTrial': '0040A007',
    'RelationshipType': '0040A010',
    'FindingsSequenceTrial': '0040A020',
    'FindingsGroupUIDTrial': '0040A021',
    'ReferencedFindingsGroupUIDTrial': '0040A022',
    'FindingsGroupRecordingDateTrial': '0040A023',
    'FindingsGroupRecordingTimeTrial': '0040A024',
    'FindingsSourceCategoryCodeSequenceTrial': '0040A026',
    'VerifyingOrganization': '0040A027',
    'DocumentingOrganizationIdentifierCodeSequenceTrial': '0040A028',
    'VerificationDateTime': '0040A030',
    'ObservationDateTime': '0040A032',
    'ValueType': '0040A040',
    'ConceptNameCodeSequence': '0040A043',
    'MeasurementPrecisionDescriptionTrial': '0040A047',
    'ContinuityOfContent': '0040A050',
    'UrgencyOrPriorityAlertsTrial': '0040A057',
    'SequencingIndicatorTrial': '0040A060',
    'DocumentIdentifierCodeSequenceTrial': '0040A066',
    'DocumentAuthorTrial': '0040A067',
    'DocumentAuthorIdentifierCodeSequenceTrial': '0040A068',
    'IdentifierCodeSequenceTrial': '0040A070',
    'VerifyingObserverSequence': '0040A073',
    'ObjectBinaryIdentifierTrial': '0040A074',
    'VerifyingObserverName': '0040A075',
    'DocumentingObserverIdentifierCodeSequenceTrial': '0040A076',
    'AuthorObserverSequence': '0040A078',
    'ParticipantSequence': '0040A07A',
    'CustodialOrganizationSequence': '0040A07C',
    'ParticipationType': '0040A080',
    'ParticipationDateTime': '0040A082',
    'ObserverType': '0040A084',
    'ProcedureIdentifierCodeSequenceTrial': '0040A085',
    'VerifyingObserverIdentificationCodeSequence': '0040A088',
    'ObjectDirectoryBinaryIdentifierTrial': '0040A089',
    'EquivalentCDADocumentSequence': '0040A090',
    'ReferencedWaveformChannels': '0040A0B0',
    'DateOfDocumentOrVerbalTransactionTrial': '0040A110',
    'TimeOfDocumentCreationOrVerbalTransactionTrial': '0040A112',
    'DateTime': '0040A120',
    'Date': '0040A121',
    'Time': '0040A122',
    'PersonName': '0040A123',
    'UID': '0040A124',
    'ReportStatusIDTrial': '0040A125',
    'TemporalRangeType': '0040A130',
    'ReferencedSamplePositions': '0040A132',
    'ReferencedFrameNumbers': '0040A136',
    'ReferencedTimeOffsets': '0040A138',
    'ReferencedDateTime': '0040A13A',
    'TextValue': '0040A160',
    'FloatingPointValue': '0040A161',
    'RationalNumeratorValue': '0040A162',
    'RationalDenominatorValue': '0040A163',
    'ObservationCategoryCodeSequenceTrial': '0040A167',
    'ConceptCodeSequence': '0040A168',
    'BibliographicCitationTrial': '0040A16A',
    'PurposeOfReferenceCodeSequence': '0040A170',
    'ObservationUID': '0040A171',
    'ReferencedObservationUIDTrial': '0040A172',
    'ReferencedObservationClassTrial': '0040A173',
    'ReferencedObjectObservationClassTrial': '0040A174',
    'AnnotationGroupNumber': '0040A180',
    'ObservationDateTrial': '0040A192',
    'ObservationTimeTrial': '0040A193',
    'MeasurementAutomationTrial': '0040A194',
    'ModifierCodeSequence': '0040A195',
    'IdentificationDescriptionTrial': '0040A224',
    'CoordinatesSetGeometricTypeTrial': '0040A290',
    'AlgorithmCodeSequenceTrial': '0040A296',
    'AlgorithmDescriptionTrial': '0040A297',
    'PixelCoordinatesSetTrial': '0040A29A',
    'MeasuredValueSequence': '0040A300',
    'NumericValueQualifierCodeSequence': '0040A301',
    'CurrentObserverTrial': '0040A307',
    'NumericValue': '0040A30A',
    'ReferencedAccessionSequenceTrial': '0040A313',
    'ReportStatusCommentTrial': '0040A33A',
    'ProcedureContextSequenceTrial': '0040A340',
    'VerbalSourceTrial': '0040A352',
    'AddressTrial': '0040A353',
    'TelephoneNumberTrial': '0040A354',
    'VerbalSourceIdentifierCodeSequenceTrial': '0040A358',
    'PredecessorDocumentsSequence': '0040A360',
    'ReferencedRequestSequence': '0040A370',
    'PerformedProcedureCodeSequence': '0040A372',
    'CurrentRequestedProcedureEvidenceSequence': '0040A375',
    'ReportDetailSequenceTrial': '0040A380',
    'PertinentOtherEvidenceSequence': '0040A385',
    '0040A390': ('HL7StructuredDocumentReferenceSequence'),
    'ObservationSubjectUIDTrial': '0040A402',
    'ObservationSubjectClassTrial': '0040A403',
    'ObservationSubjectTypeCodeSequenceTrial': '0040A404',
    'CompletionFlag': '0040A491',
    'CompletionFlagDescription': '0040A492',
    'VerificationFlag': '0040A493',
    'ArchiveRequested': '0040A494',
    'PreliminaryFlag': '0040A496',
    'ContentTemplateSequence': '0040A504',
    'IdenticalDocumentsSequence': '0040A525',
    'ObservationSubjectContextFlagTrial': '0040A600',
    'ObserverContextFlagTrial': '0040A601',
    'ProcedureContextFlagTrial': '0040A603',
    'ContentSequence': '0040A730',
    'RelationshipSequenceTrial': '0040A731',
    'RelationshipTypeCodeSequenceTrial': '0040A732',
    'LanguageCodeSequenceTrial': '0040A744',
    'UniformResourceLocatorTrial': '0040A992',
    'WaveformAnnotationSequence': '0040B020',
    'TemplateIdentifier': '0040DB00',
    'TemplateVersion': '0040DB06',
    'TemplateLocalVersion': '0040DB07',
    'TemplateExtensionFlag': '0040DB0B',
    'TemplateExtensionOrganizationUID': '0040DB0C',
    'TemplateExtensionCreatorUID': '0040DB0D',
    'ReferencedContentItemIdentifier': '0040DB73',
    '0040E001': ('HL7InstanceIdentifier'),
    '0040E004': ('HL7DocumentEffectiveTime'),
    '0040E006': ('HL7DocumentTypeCodeSequence'),
    'DocumentClassCodeSequence': '0040E008',
    'RetrieveURI': '0040E010',
    'RetrieveLocationUID': '0040E011',
    'TypeOfInstances': '0040E020',
    'DICOMRetrievalSequence': '0040E021',
    'DICOMMediaRetrievalSequence': '0040E022',
    'WADORetrievalSequence': '0040E023',
    'XDSRetrievalSequence': '0040E024',
    'WADORSRetrievalSequence': '0040E025',
    'RepositoryUniqueID': '0040E030',
    'HomeCommunityID': '0040E031',
    'DocumentTitle': '00420010',
    'EncapsulatedDocument': '00420011',
    'MIMETypeOfEncapsulatedDocument': '00420012',
    'SourceInstanceSequence': '00420013',
    'ListOfMIMETypes': '00420014',
    'ProductPackageIdentifier': '00440001',
    'SubstanceAdministrationApproval': '00440002',
    'ApprovalStatusFurtherDescription': '00440003',
    'ApprovalStatusDateTime': '00440004',
    'ProductTypeCodeSequence': '00440007',
    'ProductName': '00440008',
    'ProductDescription': '00440009',
    'ProductLotIdentifier': '0044000A',
    'ProductExpirationDateTime': '0044000B',
    'SubstanceAdministrationDateTime': '00440010',
    'SubstanceAdministrationNotes': '00440011',
    'SubstanceAdministrationDeviceID': '00440012',
    'ProductParameterSequence': '00440013',
    'SubstanceAdministrationParameterSequence': '00440019',
    'ApprovalSequence': '00440100',
    'AssertionCodeSequence': '00440101',
    'AssertionUID': '00440102',
    'AsserterIdentificationSequence': '00440103',
    'AssertionDateTime': '00440104',
    'AssertionExpirationDateTime': '00440105',
    'AssertionComments': '00440106',
    'RelatedAssertionSequence': '00440107',
    'ReferencedAssertionUID': '00440108',
    'ApprovalSubjectSequence': '00440109',
    'OrganizationalRoleCodeSequence': '0044010A',
    'LensDescription': '00460012',
    'RightLensSequence': '00460014',
    'LeftLensSequence': '00460015',
    'UnspecifiedLateralityLensSequence': '00460016',
    'CylinderSequence': '00460018',
    'PrismSequence': '00460028',
    'HorizontalPrismPower': '00460030',
    'HorizontalPrismBase': '00460032',
    'VerticalPrismPower': '00460034',
    'VerticalPrismBase': '00460036',
    'LensSegmentType': '00460038',
    'OpticalTransmittance': '00460040',
    'ChannelWidth': '00460042',
    'PupilSize': '00460044',
    'CornealSize': '00460046',
    'AutorefractionRightEyeSequence': '00460050',
    'AutorefractionLeftEyeSequence': '00460052',
    'DistancePupillaryDistance': '00460060',
    'NearPupillaryDistance': '00460062',
    'IntermediatePupillaryDistance': '00460063',
    'OtherPupillaryDistance': '00460064',
    'KeratometryRightEyeSequence': '00460070',
    'KeratometryLeftEyeSequence': '00460071',
    'SteepKeratometricAxisSequence': '00460074',
    'RadiusOfCurvature': '00460075',
    'KeratometricPower': '00460076',
    'KeratometricAxis': '00460077',
    'FlatKeratometricAxisSequence': '00460080',
    'BackgroundColor': '00460092',
    'Optotype': '00460094',
    'OptotypePresentation': '00460095',
    'SubjectiveRefractionRightEyeSequence': '00460097',
    'SubjectiveRefractionLeftEyeSequence': '00460098',
    'AddNearSequence': '00460100',
    'AddIntermediateSequence': '00460101',
    'AddOtherSequence': '00460102',
    'AddPower': '00460104',
    'ViewingDistance': '00460106',
    'VisualAcuityTypeCodeSequence': '00460121',
    'VisualAcuityRightEyeSequence': '00460122',
    'VisualAcuityLeftEyeSequence': '00460123',
    'VisualAcuityBothEyesOpenSequence': '00460124',
    'ViewingDistanceType': '00460125',
    'VisualAcuityModifiers': '00460135',
    'DecimalVisualAcuity': '00460137',
    'OptotypeDetailedDefinition': '00460139',
    'ReferencedRefractiveMeasurementsSequence': '00460145',
    'SpherePower': '00460146',
    'CylinderPower': '00460147',
    'CornealTopographySurface': '00460201',
    'CornealVertexLocation': '00460202',
    'PupilCentroidXCoordinate': '00460203',
    'PupilCentroidYCoordinate': '00460204',
    'EquivalentPupilRadius': '00460205',
    'CornealTopographyMapTypeCodeSequence': '00460207',
    'VerticesOfTheOutlineOfPupil': '00460208',
    'CornealTopographyMappingNormalsSequence': '00460210',
    'MaximumCornealCurvatureSequence': '00460211',
    'MaximumCornealCurvature': '00460212',
    'MaximumCornealCurvatureLocation': '00460213',
    'MinimumKeratometricSequence': '00460215',
    'SimulatedKeratometricCylinderSequence': '00460218',
    'AverageCornealPower': '00460220',
    'CornealISValue': '00460224',
    'AnalyzedArea': '00460227',
    'SurfaceRegularityIndex': '00460230',
    'SurfaceAsymmetryIndex': '00460232',
    'CornealEccentricityIndex': '00460234',
    'KeratoconusPredictionIndex': '00460236',
    'DecimalPotentialVisualAcuity': '00460238',
    'CornealTopographyMapQualityEvaluation': '00460242',
    'SourceImageCornealProcessedDataSequence': '00460244',
    'CornealPointLocation': '00460247',
    'CornealPointEstimated': '00460248',
    'AxialPower': '00460249',
    'TangentialPower': '00460250',
    'RefractivePower': '00460251',
    'RelativeElevation': '00460252',
    'CornealWavefront': '00460253',
    'ImagedVolumeWidth': '00480001',
    'ImagedVolumeHeight': '00480002',
    'ImagedVolumeDepth': '00480003',
    'TotalPixelMatrixColumns': '00480006',
    'TotalPixelMatrixRows': '00480007',
    'TotalPixelMatrixOriginSequence': '00480008',
    'SpecimenLabelInImage': '00480010',
    'FocusMethod': '00480011',
    'ExtendedDepthOfField': '00480012',
    'NumberOfFocalPlanes': '00480013',
    'DistanceBetweenFocalPlanes': '00480014',
    'RecommendedAbsentPixelCIELabValue': '00480015',
    'IlluminatorTypeCodeSequence': '00480100',
    'ImageOrientationSlide': '00480102',
    'OpticalPathSequence': '00480105',
    'OpticalPathIdentifier': '00480106',
    'OpticalPathDescription': '00480107',
    'IlluminationColorCodeSequence': '00480108',
    'SpecimenReferenceSequence': '00480110',
    'CondenserLensPower': '00480111',
    'ObjectiveLensPower': '00480112',
    'ObjectiveLensNumericalAperture': '00480113',
    'PaletteColorLookupTableSequence': '00480120',
    'ReferencedImageNavigationSequence': '00480200',
    'TopLeftHandCornerOfLocalizerArea': '00480201',
    'BottomRightHandCornerOfLocalizerArea': '00480202',
    'OpticalPathIdentificationSequence': '00480207',
    'PlanePositionSlideSequence': '0048021A',
    'ColumnPositionInTotalImagePixelMatrix': '0048021E',
    'RowPositionInTotalImagePixelMatrix': '0048021F',
    'PixelOriginInterpretation': '00480301',
    'NumberOfOpticalPaths': '00480302',
    'TotalPixelMatrixFocalPlanes': '00480303',
    'CalibrationImage': '00500004',
    'DeviceSequence': '00500010',
    'ContainerComponentTypeCodeSequence': '00500012',
    'ContainerComponentThickness': '00500013',
    'DeviceLength': '00500014',
    'ContainerComponentWidth': '00500015',
    'DeviceDiameter': '00500016',
    'DeviceDiameterUnits': '00500017',
    'DeviceVolume': '00500018',
    'InterMarkerDistance': '00500019',
    'ContainerComponentMaterial': '0050001A',
    'ContainerComponentID': '0050001B',
    'ContainerComponentLength': '0050001C',
    'ContainerComponentDiameter': '0050001D',
    'ContainerComponentDescription': '0050001E',
    'DeviceDescription': '00500020',
    'ContrastBolusIngredientPercentByVolume': '00520001',
    'OCTFocalDistance': '00520002',
    'BeamSpotSize': '00520003',
    'EffectiveRefractiveIndex': '00520004',
    'OCTAcquisitionDomain': '00520006',
    'OCTOpticalCenterWavelength': '00520007',
    'AxialResolution': '00520008',
    'RangingDepth': '00520009',
    'ALineRate': '00520011',
    'ALinesPerFrame': '00520012',
    'CatheterRotationalRate': '00520013',
    'ALinePixelSpacing': '00520014',
    'ModeOfPercutaneousAccessSequence': '00520016',
    'IntravascularOCTFrameTypeSequence': '00520025',
    'OCTZOffsetApplied': '00520026',
    'IntravascularFrameContentSequence': '00520027',
    'IntravascularLongitudinalDistance': '00520028',
    'IntravascularOCTFrameContentSequence': '00520029',
    'OCTZOffsetCorrection': '00520030',
    'CatheterDirectionOfRotation': '00520031',
    'SeamLineLocation': '00520033',
    'FirstALineLocation': '00520034',
    'SeamLineIndex': '00520036',
    'NumberOfPaddedALines': '00520038',
    'InterpolationType': '00520039',
    'RefractiveIndexApplied': '0052003A',
    'EnergyWindowVector': '00540010',
    'NumberOfEnergyWindows': '00540011',
    'EnergyWindowInformationSequence': '00540012',
    'EnergyWindowRangeSequence': '00540013',
    'EnergyWindowLowerLimit': '00540014',
    'EnergyWindowUpperLimit': '00540015',
    'RadiopharmaceuticalInformationSequence': '00540016',
    'ResidualSyringeCounts': '00540017',
    'EnergyWindowName': '00540018',
    'DetectorVector': '00540020',
    'NumberOfDetectors': '00540021',
    'DetectorInformationSequence': '00540022',
    'PhaseVector': '00540030',
    'NumberOfPhases': '00540031',
    'PhaseInformationSequence': '00540032',
    'NumberOfFramesInPhase': '00540033',
    'PhaseDelay': '00540036',
    'PauseBetweenFrames': '00540038',
    'PhaseDescription': '00540039',
    'RotationVector': '00540050',
    'NumberOfRotations': '00540051',
    'RotationInformationSequence': '00540052',
    'NumberOfFramesInRotation': '00540053',
    'RRIntervalVector': '00540060',
    'NumberOfRRIntervals': '00540061',
    'GatedInformationSequence': '00540062',
    'DataInformationSequence': '00540063',
    'TimeSlotVector': '00540070',
    'NumberOfTimeSlots': '00540071',
    'TimeSlotInformationSequence': '00540072',
    'TimeSlotTime': '00540073',
    'SliceVector': '00540080',
    'NumberOfSlices': '00540081',
    'AngularViewVector': '00540090',
    'TimeSliceVector': '00540100',
    'NumberOfTimeSlices': '00540101',
    'StartAngle': '00540200',
    'TypeOfDetectorMotion': '00540202',
    'TriggerVector': '00540210',
    'NumberOfTriggersInPhase': '00540211',
    'ViewCodeSequence': '00540220',
    'ViewModifierCodeSequence': '00540222',
    'RadionuclideCodeSequence': '00540300',
    'AdministrationRouteCodeSequence': '00540302',
    'RadiopharmaceuticalCodeSequence': '00540304',
    'CalibrationDataSequence': '00540306',
    'EnergyWindowNumber': '00540308',
    'ImageID': '00540400',
    'PatientOrientationCodeSequence': '00540410',
    'PatientOrientationModifierCodeSequence': '00540412',
    'PatientGantryRelationshipCodeSequence': '00540414',
    'SliceProgressionDirection': '00540500',
    'ScanProgressionDirection': '00540501',
    'SeriesType': '00541000',
    'Units': '00541001',
    'CountsSource': '00541002',
    'ReprojectionMethod': '00541004',
    'SUVType': '00541006',
    'RandomsCorrectionMethod': '00541100',
    'AttenuationCorrectionMethod': '00541101',
    'DecayCorrection': '00541102',
    'ReconstructionMethod': '00541103',
    'DetectorLinesOfResponseUsed': '00541104',
    'ScatterCorrectionMethod': '00541105',
    'AxialAcceptance': '00541200',
    'AxialMash': '00541201',
    'TransverseMash': '00541202',
    'DetectorElementSize': '00541203',
    'CoincidenceWindowWidth': '00541210',
    'SecondaryCountsType': '00541220',
    'FrameReferenceTime': '00541300',
    'PrimaryPromptsCountsAccumulated': '00541310',
    'SecondaryCountsAccumulated': '00541311',
    'SliceSensitivityFactor': '00541320',
    'DecayFactor': '00541321',
    'DoseCalibrationFactor': '00541322',
    'ScatterFractionFactor': '00541323',
    'DeadTimeFactor': '00541324',
    'ImageIndex': '00541330',
    'CountsIncluded': '00541400',
    'DeadTimeCorrectionFlag': '00541401',
    'HistogramSequence': '00603000',
    'HistogramNumberOfBins': '00603002',
    'HistogramFirstBinValue': '00603004',
    'HistogramLastBinValue': '00603006',
    'HistogramBinWidth': '00603008',
    'HistogramExplanation': '00603010',
    'HistogramData': '00603020',
    'SegmentationType': '00620001',
    'SegmentSequence': '00620002',
    'SegmentedPropertyCategoryCodeSequence': '00620003',
    'SegmentNumber': '00620004',
    'SegmentLabel': '00620005',
    'SegmentDescription': '00620006',
    'SegmentationAlgorithmIdentificationSequence': '00620007',
    'SegmentAlgorithmType': '00620008',
    'SegmentAlgorithmName': '00620009',
    'SegmentIdentificationSequence': '0062000A',
    'ReferencedSegmentNumber': '0062000B',
    'RecommendedDisplayGrayscaleValue': '0062000C',
    'RecommendedDisplayCIELabValue': '0062000D',
    'MaximumFractionalValue': '0062000E',
    'SegmentedPropertyTypeCodeSequence': '0062000F',
    'SegmentationFractionalType': '00620010',
    'SegmentedPropertyTypeModifierCodeSequence': '00620011',
    'UsedSegmentsSequence': '00620012',
    'TrackingID': '00620020',
    'TrackingUID': '00620021',
    'DeformableRegistrationSequence': '00640002',
    'SourceFrameOfReferenceUID': '00640003',
    'DeformableRegistrationGridSequence': '00640005',
    'GridDimensions': '00640007',
    'GridResolution': '00640008',
    'VectorGridData': '00640009',
    'PreDeformationMatrixRegistrationSequence': '0064000F',
    'PostDeformationMatrixRegistrationSequence': '00640010',
    'NumberOfSurfaces': '00660001',
    'SurfaceSequence': '00660002',
    'SurfaceNumber': '00660003',
    'SurfaceComments': '00660004',
    'SurfaceProcessing': '00660009',
    'SurfaceProcessingRatio': '0066000A',
    'SurfaceProcessingDescription': '0066000B',
    'RecommendedPresentationOpacity': '0066000C',
    'RecommendedPresentationType': '0066000D',
    'FiniteVolume': '0066000E',
    'Manifold': '00660010',
    'SurfacePointsSequence': '00660011',
    'SurfacePointsNormalsSequence': '00660012',
    'SurfaceMeshPrimitivesSequence': '00660013',
    'NumberOfSurfacePoints': '00660015',
    'PointCoordinatesData': '00660016',
    'PointPositionAccuracy': '00660017',
    'MeanPointDistance': '00660018',
    'MaximumPointDistance': '00660019',
    'PointsBoundingBoxCoordinates': '0066001A',
    'AxisOfRotation': '0066001B',
    'CenterOfRotation': '0066001C',
    'NumberOfVectors': '0066001E',
    'VectorDimensionality': '0066001F',
    'VectorAccuracy': '00660020',
    'VectorCoordinateData': '00660021',
    'TrianglePointIndexList': '00660023',
    'EdgePointIndexList': '00660024',
    'VertexPointIndexList': '00660025',
    'TriangleStripSequence': '00660026',
    'TriangleFanSequence': '00660027',
    'LineSequence': '00660028',
    'PrimitivePointIndexList': '00660029',
    'SurfaceCount': '0066002A',
    'ReferencedSurfaceSequence': '0066002B',
    'ReferencedSurfaceNumber': '0066002C',
    'SegmentSurfaceGenerationAlgorithmIdentificationSequence': '0066002D',
    'SegmentSurfaceSourceInstanceSequence': '0066002E',
    'AlgorithmFamilyCodeSequence': '0066002F',
    'AlgorithmNameCodeSequence': '00660030',
    'AlgorithmVersion': '00660031',
    'AlgorithmParameters': '00660032',
    'FacetSequence': '00660034',
    'SurfaceProcessingAlgorithmIdentificationSequence': '00660035',
    'AlgorithmName': '00660036',
    'RecommendedPointRadius': '00660037',
    'RecommendedLineThickness': '00660038',
    'LongPrimitivePointIndexList': '00660040',
    'LongTrianglePointIndexList': '00660041',
    'LongEdgePointIndexList': '00660042',
    'LongVertexPointIndexList': '00660043',
    'TrackSetSequence': '00660101',
    'TrackSequence': '00660102',
    'RecommendedDisplayCIELabValueList': '00660103',
    'TrackingAlgorithmIdentificationSequence': '00660104',
    'TrackSetNumber': '00660105',
    'TrackSetLabel': '00660106',
    'TrackSetDescription': '00660107',
    'TrackSetAnatomicalTypeCodeSequence': '00660108',
    'MeasurementsSequence': '00660121',
    'TrackSetStatisticsSequence': '00660124',
    'FloatingPointValues': '00660125',
    'TrackPointIndexList': '00660129',
    'TrackStatisticsSequence': '00660130',
    'MeasurementValuesSequence': '00660132',
    'DiffusionAcquisitionCodeSequence': '00660133',
    'DiffusionModelCodeSequence': '00660134',
    'ImplantSize': '00686210',
    'ImplantTemplateVersion': '00686221',
    'ReplacedImplantTemplateSequence': '00686222',
    'ImplantType': '00686223',
    'DerivationImplantTemplateSequence': '00686224',
    'OriginalImplantTemplateSequence': '00686225',
    'EffectiveDateTime': '00686226',
    'ImplantTargetAnatomySequence': '00686230',
    'InformationFromManufacturerSequence': '00686260',
    'NotificationFromManufacturerSequence': '00686265',
    'InformationIssueDateTime': '00686270',
    'InformationSummary': '00686280',
    'ImplantRegulatoryDisapprovalCodeSequence': '006862A0',
    'OverallTemplateSpatialTolerance': '006862A5',
    'HPGLDocumentSequence': '006862C0',
    'HPGLDocumentID': '006862D0',
    'HPGLDocumentLabel': '006862D5',
    'ViewOrientationCodeSequence': '006862E0',
    'ViewOrientationModifierCodeSequence': '006862F0',
    'HPGLDocumentScaling': '006862F2',
    'HPGLDocument': '00686300',
    'HPGLContourPenNumber': '00686310',
    'HPGLPenSequence': '00686320',
    'HPGLPenNumber': '00686330',
    'HPGLPenLabel': '00686340',
    'HPGLPenDescription': '00686345',
    'RecommendedRotationPoint': '00686346',
    'BoundingRectangle': '00686347',
    '00686350': ('ImplantTemplate3DModelSurfaceNumber'),
    'SurfaceModelDescriptionSequence': '00686360',
    'SurfaceModelLabel': '00686380',
    'SurfaceModelScalingFactor': '00686390',
    'MaterialsCodeSequence': '006863A0',
    'CoatingMaterialsCodeSequence': '006863A4',
    'ImplantTypeCodeSequence': '006863A8',
    'FixationMethodCodeSequence': '006863AC',
    'MatingFeatureSetsSequence': '006863B0',
    'MatingFeatureSetID': '006863C0',
    'MatingFeatureSetLabel': '006863D0',
    'MatingFeatureSequence': '006863E0',
    'MatingFeatureID': '006863F0',
    'MatingFeatureDegreeOfFreedomSequence': '00686400',
    'DegreeOfFreedomID': '00686410',
    'DegreeOfFreedomType': '00686420',
    'TwoDMatingFeatureCoordinatesSequence': '00686430',
    'ReferencedHPGLDocumentID': '00686440',
    'TwoDMatingPoint': '00686450',
    'TwoDMatingAxes': '00686460',
    'TwoDDegreeOfFreedomSequence': '00686470',
    'ThreeDDegreeOfFreedomAxis': '00686490',
    'RangeOfFreedom': '006864A0',
    'ThreeDMatingPoint': '006864C0',
    'ThreeDMatingAxes': '006864D0',
    'TwoDDegreeOfFreedomAxis': '006864F0',
    'PlanningLandmarkPointSequence': '00686500',
    'PlanningLandmarkLineSequence': '00686510',
    'PlanningLandmarkPlaneSequence': '00686520',
    'PlanningLandmarkID': '00686530',
    'PlanningLandmarkDescription': '00686540',
    'PlanningLandmarkIdentificationCodeSequence': '00686545',
    'TwoDPointCoordinatesSequence': '00686550',
    'TwoDPointCoordinates': '00686560',
    'ThreeDPointCoordinates': '00686590',
    'TwoDLineCoordinatesSequence': '006865A0',
    'TwoDLineCoordinates': '006865B0',
    'ThreeDLineCoordinates': '006865D0',
    'TwoDPlaneCoordinatesSequence': '006865E0',
    'TwoDPlaneIntersection': '006865F0',
    'ThreeDPlaneOrigin': '00686610',
    'ThreeDPlaneNormal': '00686620',
    'ModelModification': '00687001',
    'ModelMirroring': '00687002',
    'ModelUsageCodeSequence': '00687003',
    'GraphicAnnotationSequence': '00700001',
    'GraphicLayer': '00700002',
    'BoundingBoxAnnotationUnits': '00700003',
    'AnchorPointAnnotationUnits': '00700004',
    'GraphicAnnotationUnits': '00700005',
    'UnformattedTextValue': '00700006',
    'TextObjectSequence': '00700008',
    'GraphicObjectSequence': '00700009',
    'BoundingBoxTopLeftHandCorner': '00700010',
    'BoundingBoxBottomRightHandCorner': '00700011',
    'BoundingBoxTextHorizontalJustification': '00700012',
    'AnchorPoint': '00700014',
    'AnchorPointVisibility': '00700015',
    'GraphicDimensions': '00700020',
    'NumberOfGraphicPoints': '00700021',
    'GraphicData': '00700022',
    'GraphicType': '00700023',
    'GraphicFilled': '00700024',
    'ImageRotationRetired': '00700040',
    'ImageHorizontalFlip': '00700041',
    'ImageRotation': '00700042',
    'DisplayedAreaTopLeftHandCornerTrial': '00700050',
    'DisplayedAreaBottomRightHandCornerTrial': '00700051',
    'DisplayedAreaTopLeftHandCorner': '00700052',
    'DisplayedAreaBottomRightHandCorner': '00700053',
    'DisplayedAreaSelectionSequence': '0070005A',
    'GraphicLayerSequence': '00700060',
    'GraphicLayerOrder': '00700062',
    'GraphicLayerRecommendedDisplayGrayscaleValue': '00700066',
    'GraphicLayerRecommendedDisplayRGBValue': '00700067',
    'GraphicLayerDescription': '00700068',
    'ContentLabel': '00700080',
    'ContentDescription': '00700081',
    'PresentationCreationDate': '00700082',
    'PresentationCreationTime': '00700083',
    'ContentCreatorName': '00700084',
    'ContentCreatorIdentificationCodeSequence': '00700086',
    'AlternateContentDescriptionSequence': '00700087',
    'PresentationSizeMode': '00700100',
    'PresentationPixelSpacing': '00700101',
    'PresentationPixelAspectRatio': '00700102',
    'PresentationPixelMagnificationRatio': '00700103',
    'GraphicGroupLabel': '00700207',
    'GraphicGroupDescription': '00700208',
    'CompoundGraphicSequence': '00700209',
    'CompoundGraphicInstanceID': '00700226',
    'FontName': '00700227',
    'FontNameType': '00700228',
    'CSSFontName': '00700229',
    'RotationAngle': '00700230',
    'TextStyleSequence': '00700231',
    'LineStyleSequence': '00700232',
    'FillStyleSequence': '00700233',
    'GraphicGroupSequence': '00700234',
    'TextColorCIELabValue': '00700241',
    'HorizontalAlignment': '00700242',
    'VerticalAlignment': '00700243',
    'ShadowStyle': '00700244',
    'ShadowOffsetX': '00700245',
    'ShadowOffsetY': '00700246',
    'ShadowColorCIELabValue': '00700247',
    'Underlined': '00700248',
    'Bold': '00700249',
    'Italic': '00700250',
    'PatternOnColorCIELabValue': '00700251',
    'PatternOffColorCIELabValue': '00700252',
    'LineThickness': '00700253',
    'LineDashingStyle': '00700254',
    'LinePattern': '00700255',
    'FillPattern': '00700256',
    'FillMode': '00700257',
    'ShadowOpacity': '00700258',
    'GapLength': '00700261',
    'DiameterOfVisibility': '00700262',
    'RotationPoint': '00700273',
    'TickAlignment': '00700274',
    'ShowTickLabel': '00700278',
    'TickLabelAlignment': '00700279',
    'CompoundGraphicUnits': '00700282',
    'PatternOnOpacity': '00700284',
    'PatternOffOpacity': '00700285',
    'MajorTicksSequence': '00700287',
    'TickPosition': '00700288',
    'TickLabel': '00700289',
    'CompoundGraphicType': '00700294',
    'GraphicGroupID': '00700295',
    'ShapeType': '00700306',
    'RegistrationSequence': '00700308',
    'MatrixRegistrationSequence': '00700309',
    'MatrixSequence': '0070030A',
    'FrameOfReferenceToDisplayedCoordinateSystemTransformationMatrix': '0070030B',
    'FrameOfReferenceTransformationMatrixType': '0070030C',
    'RegistrationTypeCodeSequence': '0070030D',
    'FiducialDescription': '0070030F',
    'FiducialIdentifier': '00700310',
    'FiducialIdentifierCodeSequence': '00700311',
    'ContourUncertaintyRadius': '00700312',
    'UsedFiducialsSequence': '00700314',
    'GraphicCoordinatesDataSequence': '00700318',
    'FiducialUID': '0070031A',
    'ReferencedFiducialUID': '0070031B',
    'FiducialSetSequence': '0070031C',
    'FiducialSequence': '0070031E',
    'FiducialsPropertyCategoryCodeSequence': '0070031F',
    'GraphicLayerRecommendedDisplayCIELabValue': '00700401',
    'BlendingSequence': '00700402',
    'RelativeOpacity': '00700403',
    'ReferencedSpatialRegistrationSequence': '00700404',
    'BlendingPosition': '00700405',
    'PresentationDisplayCollectionUID': '00701101',
    'PresentationSequenceCollectionUID': '00701102',
    'PresentationSequencePositionIndex': '00701103',
    'RenderedImageReferenceSequence': '00701104',
    'VolumetricPresentationStateInputSequence': '00701201',
    'PresentationInputType': '00701202',
    'InputSequencePositionIndex': '00701203',
    'Crop': '00701204',
    'CroppingSpecificationIndex': '00701205',
    'CompositingMethod': '00701206',
    'VolumetricPresentationInputNumber': '00701207',
    'ImageVolumeGeometry': '00701208',
    'VolumetricPresentationInputSetUID': '00701209',
    'VolumetricPresentationInputSetSequence': '0070120A',
    'GlobalCrop': '0070120B',
    'GlobalCroppingSpecificationIndex': '0070120C',
    'RenderingMethod': '0070120D',
    'VolumeCroppingSequence': '00701301',
    'VolumeCroppingMethod': '00701302',
    'BoundingBoxCrop': '00701303',
    'ObliqueCroppingPlaneSequence': '00701304',
    'Plane': '00701305',
    'PlaneNormal': '00701306',
    'CroppingSpecificationNumber': '00701309',
    'MultiPlanarReconstructionStyle': '00701501',
    'MPRThicknessType': '00701502',
    'MPRSlabThickness': '00701503',
    'MPRTopLeftHandCorner': '00701505',
    'MPRViewWidthDirection': '00701507',
    'MPRViewWidth': '00701508',
    'NumberOfVolumetricCurvePoints': '0070150C',
    'VolumetricCurvePoints': '0070150D',
    'MPRViewHeightDirection': '00701511',
    'MPRViewHeight': '00701512',
    'RenderProjection': '00701602',
    'ViewpointPosition': '00701603',
    'ViewpointLookAtPoint': '00701604',
    'ViewpointUpDirection': '00701605',
    'RenderFieldOfView': '00701606',
    'SamplingStepSize': '00701607',
    'ShadingStyle': '00701701',
    'AmbientReflectionIntensity': '00701702',
    'LightDirection': '00701703',
    'DiffuseReflectionIntensity': '00701704',
    'SpecularReflectionIntensity': '00701705',
    'Shininess': '00701706',
    'PresentationStateClassificationComponentSequence': '00701801',
    'ComponentType': '00701802',
    'ComponentInputSequence': '00701803',
    'VolumetricPresentationInputIndex': '00701804',
    'PresentationStateCompositorComponentSequence': '00701805',
    'WeightingTransferFunctionSequence': '00701806',
    'WeightingLookupTableDescriptor': '00701807',
    'WeightingLookupTableData': '00701808',
    'VolumetricAnnotationSequence': '00701901',
    'ReferencedStructuredContextSequence': '00701903',
    'ReferencedContentItem': '00701904',
    'VolumetricPresentationInputAnnotationSequence': '00701905',
    'AnnotationClipping': '00701907',
    'PresentationAnimationStyle': '00701A01',
    'RecommendedAnimationRate': '00701A03',
    'AnimationCurveSequence': '00701A04',
    'AnimationStepSize': '00701A05',
    'SwivelRange': '00701A06',
    'VolumetricCurveUpDirections': '00701A07',
    'VolumeStreamSequence': '00701A08',
    'RGBATransferFunctionDescription': '00701A09',
    'AdvancedBlendingSequence': '00701B01',
    'BlendingInputNumber': '00701B02',
    'BlendingDisplayInputSequence': '00701B03',
    'BlendingDisplaySequence': '00701B04',
    'BlendingMode': '00701B06',
    'TimeSeriesBlending': '00701B07',
    'GeometryForDisplay': '00701B08',
    'ThresholdSequence': '00701B11',
    'ThresholdValueSequence': '00701B12',
    'ThresholdType': '00701B13',
    'ThresholdValue': '00701B14',
    'HangingProtocolName': '00720002',
    'HangingProtocolDescription': '00720004',
    'HangingProtocolLevel': '00720006',
    'HangingProtocolCreator': '00720008',
    'HangingProtocolCreationDateTime': '0072000A',
    'HangingProtocolDefinitionSequence': '0072000C',
    'HangingProtocolUserIdentificationCodeSequence': '0072000E',
    'HangingProtocolUserGroupName': '00720010',
    'SourceHangingProtocolSequence': '00720012',
    'NumberOfPriorsReferenced': '00720014',
    'ImageSetsSequence': '00720020',
    'ImageSetSelectorSequence': '00720022',
    'ImageSetSelectorUsageFlag': '00720024',
    'SelectorAttribute': '00720026',
    'SelectorValueNumber': '00720028',
    'TimeBasedImageSetsSequence': '00720030',
    'ImageSetNumber': '00720032',
    'ImageSetSelectorCategory': '00720034',
    'RelativeTime': '00720038',
    'RelativeTimeUnits': '0072003A',
    'AbstractPriorValue': '0072003C',
    'AbstractPriorCodeSequence': '0072003E',
    'ImageSetLabel': '00720040',
    'SelectorAttributeVR': '00720050',
    'SelectorSequencePointer': '00720052',
    'SelectorSequencePointerPrivateCreator': '00720054',
    'SelectorAttributePrivateCreator': '00720056',
    'SelectorAEValue': '0072005E',
    'SelectorASValue': '0072005F',
    'SelectorATValue': '00720060',
    'SelectorDAValue': '00720061',
    'SelectorCSValue': '00720062',
    'SelectorDTValue': '00720063',
    'SelectorISValue': '00720064',
    'SelectorOBValue': '00720065',
    'SelectorLOValue': '00720066',
    'SelectorOFValue': '00720067',
    'SelectorLTValue': '00720068',
    'SelectorOWValue': '00720069',
    'SelectorPNValue': '0072006A',
    'SelectorTMValue': '0072006B',
    'SelectorSHValue': '0072006C',
    'SelectorUNValue': '0072006D',
    'SelectorSTValue': '0072006E',
    'SelectorUCValue': '0072006F',
    'SelectorUTValue': '00720070',
    'SelectorURValue': '00720071',
    'SelectorDSValue': '00720072',
    'SelectorODValue': '00720073',
    'SelectorFDValue': '00720074',
    'SelectorOLValue': '00720075',
    'SelectorFLValue': '00720076',
    'SelectorULValue': '00720078',
    'SelectorUSValue': '0072007A',
    'SelectorSLValue': '0072007C',
    'SelectorSSValue': '0072007E',
    'SelectorUIValue': '0072007F',
    'SelectorCodeSequenceValue': '00720080',
    'NumberOfScreens': '00720100',
    'NominalScreenDefinitionSequence': '00720102',
    'NumberOfVerticalPixels': '00720104',
    'NumberOfHorizontalPixels': '00720106',
    'DisplayEnvironmentSpatialPosition': '00720108',
    'ScreenMinimumGrayscaleBitDepth': '0072010A',
    'ScreenMinimumColorBitDepth': '0072010C',
    'ApplicationMaximumRepaintTime': '0072010E',
    'DisplaySetsSequence': '00720200',
    'DisplaySetNumber': '00720202',
    'DisplaySetLabel': '00720203',
    'DisplaySetPresentationGroup': '00720204',
    'DisplaySetPresentationGroupDescription': '00720206',
    'PartialDataDisplayHandling': '00720208',
    'SynchronizedScrollingSequence': '00720210',
    'DisplaySetScrollingGroup': '00720212',
    'NavigationIndicatorSequence': '00720214',
    'NavigationDisplaySet': '00720216',
    'ReferenceDisplaySets': '00720218',
    'ImageBoxesSequence': '00720300',
    'ImageBoxNumber': '00720302',
    'ImageBoxLayoutType': '00720304',
    'ImageBoxTileHorizontalDimension': '00720306',
    'ImageBoxTileVerticalDimension': '00720308',
    'ImageBoxScrollDirection': '00720310',
    'ImageBoxSmallScrollType': '00720312',
    'ImageBoxSmallScrollAmount': '00720314',
    'ImageBoxLargeScrollType': '00720316',
    'ImageBoxLargeScrollAmount': '00720318',
    'ImageBoxOverlapPriority': '00720320',
    'CineRelativeToRealTime': '00720330',
    'FilterOperationsSequence': '00720400',
    'FilterByCategory': '00720402',
    'FilterByAttributePresence': '00720404',
    'FilterByOperator': '00720406',
    'StructuredDisplayBackgroundCIELabValue': '00720420',
    'EmptyImageBoxCIELabValue': '00720421',
    'StructuredDisplayImageBoxSequence': '00720422',
    'StructuredDisplayTextBoxSequence': '00720424',
    'ReferencedFirstFrameSequence': '00720427',
    'ImageBoxSynchronizationSequence': '00720430',
    'SynchronizedImageBoxList': '00720432',
    'TypeOfSynchronization': '00720434',
    'BlendingOperationType': '00720500',
    'ReformattingOperationType': '00720510',
    'ReformattingThickness': '00720512',
    'ReformattingInterval': '00720514',
    'ReformattingOperationInitialViewDirection': '00720516',
    'ThreeDRenderingType': '00720520',
    'SortingOperationsSequence': '00720600',
    'SortByCategory': '00720602',
    'SortingDirection': '00720604',
    'DisplaySetPatientOrientation': '00720700',
    'VOIType': '00720702',
    'PseudoColorType': '00720704',
    'PseudoColorPaletteInstanceReferenceSequence': '00720705',
    'ShowGrayscaleInverted': '00720706',
    'ShowImageTrueSizeFlag': '00720710',
    'ShowGraphicAnnotationFlag': '00720712',
    'ShowPatientDemographicsFlag': '00720714',
    'ShowAcquisitionTechniquesFlag': '00720716',
    'DisplaySetHorizontalJustification': '00720717',
    'DisplaySetVerticalJustification': '00720718',
    'ContinuationStartMeterset': '00740120',
    'ContinuationEndMeterset': '00740121',
    'ProcedureStepState': '00741000',
    'ProcedureStepProgressInformationSequence': '00741002',
    'ProcedureStepProgress': '00741004',
    'ProcedureStepProgressDescription': '00741006',
    'ProcedureStepProgressParametersSequence': '00741007',
    'ProcedureStepCommunicationsURISequence': '00741008',
    'ContactURI': '0074100A',
    'ContactDisplayName': '0074100C',
    'ProcedureStepDiscontinuationReasonCodeSequence': '0074100E',
    'BeamTaskSequence': '00741020',
    'BeamTaskType': '00741022',
    'BeamOrderIndexTrial': '00741024',
    'AutosequenceFlag': '00741025',
    'TableTopVerticalAdjustedPosition': '00741026',
    'TableTopLongitudinalAdjustedPosition': '00741027',
    'TableTopLateralAdjustedPosition': '00741028',
    'PatientSupportAdjustedAngle': '0074102A',
    'TableTopEccentricAdjustedAngle': '0074102B',
    'TableTopPitchAdjustedAngle': '0074102C',
    'TableTopRollAdjustedAngle': '0074102D',
    'DeliveryVerificationImageSequence': '00741030',
    'VerificationImageTiming': '00741032',
    'DoubleExposureFlag': '00741034',
    'DoubleExposureOrdering': '00741036',
    'DoubleExposureMetersetTrial': '00741038',
    'DoubleExposureFieldDeltaTrial': '0074103A',
    'RelatedReferenceRTImageSequence': '00741040',
    'GeneralMachineVerificationSequence': '00741042',
    'ConventionalMachineVerificationSequence': '00741044',
    'IonMachineVerificationSequence': '00741046',
    'FailedAttributesSequence': '00741048',
    'OverriddenAttributesSequence': '0074104A',
    'ConventionalControlPointVerificationSequence': '0074104C',
    'IonControlPointVerificationSequence': '0074104E',
    'AttributeOccurrenceSequence': '00741050',
    'AttributeOccurrencePointer': '00741052',
    'AttributeItemSelector': '00741054',
    'AttributeOccurrencePrivateCreator': '00741056',
    'SelectorSequencePointerItems': '00741057',
    'ScheduledProcedureStepPriority': '00741200',
    'WorklistLabel': '00741202',
    'ProcedureStepLabel': '00741204',
    'ScheduledProcessingParametersSequence': '00741210',
    'PerformedProcessingParametersSequence': '00741212',
    'UnifiedProcedureStepPerformedProcedureSequence': '00741216',
    'RelatedProcedureStepSequence': '00741220',
    'ProcedureStepRelationshipType': '00741222',
    'ReplacedProcedureStepSequence': '00741224',
    'DeletionLock': '00741230',
    'ReceivingAE': '00741234',
    'RequestingAE': '00741236',
    'ReasonForCancellation': '00741238',
    'SCPStatus': '00741242',
    'SubscriptionListStatus': '00741244',
    'UnifiedProcedureStepListStatus': '00741246',
    'BeamOrderIndex': '00741324',
    'DoubleExposureMeterset': '00741338',
    'DoubleExposureFieldDelta': '0074133A',
    'BrachyTaskSequence': '00741401',
    'ContinuationStartTotalReferenceAirKerma': '00741402',
    'ContinuationEndTotalReferenceAirKerma': '00741403',
    'ContinuationPulseNumber': '00741404',
    'ChannelDeliveryOrderSequence': '00741405',
    'ReferencedChannelNumber': '00741406',
    'StartCumulativeTimeWeight': '00741407',
    'EndCumulativeTimeWeight': '00741408',
    'OmittedChannelSequence': '00741409',
    'ReasonForChannelOmission': '0074140A',
    'ReasonForChannelOmissionDescription': '0074140B',
    'ChannelDeliveryOrderIndex': '0074140C',
    'ChannelDeliveryContinuationSequence': '0074140D',
    'OmittedApplicationSetupSequence': '0074140E',
    'ImplantAssemblyTemplateName': '00760001',
    'ImplantAssemblyTemplateIssuer': '00760003',
    'ImplantAssemblyTemplateVersion': '00760006',
    'ReplacedImplantAssemblyTemplateSequence': '00760008',
    'ImplantAssemblyTemplateType': '0076000A',
    'OriginalImplantAssemblyTemplateSequence': '0076000C',
    'DerivationImplantAssemblyTemplateSequence': '0076000E',
    'ImplantAssemblyTemplateTargetAnatomySequence': '00760010',
    'ProcedureTypeCodeSequence': '00760020',
    'SurgicalTechnique': '00760030',
    'ComponentTypesSequence': '00760032',
    'ComponentTypeCodeSequence': '00760034',
    'ExclusiveComponentType': '00760036',
    'MandatoryComponentType': '00760038',
    'ComponentSequence': '00760040',
    'ComponentID': '00760055',
    'ComponentAssemblySequence': '00760060',
    '00760070': ('Component1ReferencedID'),
    '00760080': ('Component1ReferencedMatingFeatureSetID'),
    '00760090': ('Component1ReferencedMatingFeatureID'),
    '007600A0': ('Component2ReferencedID'),
    '007600B0': ('Component2ReferencedMatingFeatureSetID'),
    '007600C0': ('Component2ReferencedMatingFeatureID'),
    'ImplantTemplateGroupName': '00780001',
    'ImplantTemplateGroupDescription': '00780010',
    'ImplantTemplateGroupIssuer': '00780020',
    'ImplantTemplateGroupVersion': '00780024',
    'ReplacedImplantTemplateGroupSequence': '00780026',
    'ImplantTemplateGroupTargetAnatomySequence': '00780028',
    'ImplantTemplateGroupMembersSequence': '0078002A',
    'ImplantTemplateGroupMemberID': '0078002E',
    'ThreeDImplantTemplateGroupMemberMatchingPoint': '00780050',
    'ThreeDImplantTemplateGroupMemberMatchingAxes': '00780060',
    '00780070': ('ImplantTemplateGroupMemberMatching2DCoordinatesSequence'),
    'TwoDImplantTemplateGroupMemberMatchingPoint': '00780090',
    'TwoDImplantTemplateGroupMemberMatchingAxes': '007800A0',
    'ImplantTemplateGroupVariationDimensionSequence': '007800B0',
    'ImplantTemplateGroupVariationDimensionName': '007800B2',
    'ImplantTemplateGroupVariationDimensionRankSequence': '007800B4',
    'ReferencedImplantTemplateGroupMemberID': '007800B6',
    'ImplantTemplateGroupVariationDimensionRank': '007800B8',
    'SurfaceScanAcquisitionTypeCodeSequence': '00800001',
    'SurfaceScanModeCodeSequence': '00800002',
    'RegistrationMethodCodeSequence': '00800003',
    'ShotDurationTime': '00800004',
    'ShotOffsetTime': '00800005',
    'SurfacePointPresentationValueData': '00800006',
    'SurfacePointColorCIELabValueData': '00800007',
    'UVMappingSequence': '00800008',
    'TextureLabel': '00800009',
    'UValueData': '00800010',
    'VValueData': '00800011',
    'ReferencedTextureSequence': '00800012',
    'ReferencedSurfaceDataSequence': '00800013',
    'AssessmentSummary': '00820001',
    'AssessmentSummaryDescription': '00820003',
    'AssessedSOPInstanceSequence': '00820004',
    'ReferencedComparisonSOPInstanceSequence': '00820005',
    'NumberOfAssessmentObservations': '00820006',
    'AssessmentObservationsSequence': '00820007',
    'ObservationSignificance': '00820008',
    'ObservationDescription': '0082000A',
    'StructuredConstraintObservationSequence': '0082000C',
    'AssessedAttributeValueSequence': '00820010',
    'AssessmentSetID': '00820016',
    'AssessmentRequesterSequence': '00820017',
    'SelectorAttributeName': '00820018',
    'SelectorAttributeKeyword': '00820019',
    'AssessmentTypeCodeSequence': '00820021',
    'ObservationBasisCodeSequence': '00820022',
    'AssessmentLabel': '00820023',
    'ConstraintType': '00820032',
    'SpecificationSelectionGuidance': '00820033',
    'ConstraintValueSequence': '00820034',
    'RecommendedDefaultValueSequence': '00820035',
    'ConstraintViolationSignificance': '00820036',
    'ConstraintViolationCondition': '00820037',
    'ModifiableConstraintFlag': '00820038',
    'StorageMediaFileSetID': '00880130',
    'StorageMediaFileSetUID': '00880140',
    'IconImageSequence': '00880200',
    'TopicTitle': '00880904',
    'TopicSubject': '00880906',
    'TopicAuthor': '00880910',
    'TopicKeywords': '00880912',
    'SOPInstanceStatus': '01000410',
    'SOPAuthorizationDateTime': '01000420',
    'SOPAuthorizationComment': '01000424',
    'AuthorizationEquipmentCertificationNumber': '01000426',
    'MACIDNumber': '04000005',
    'MACCalculationTransferSyntaxUID': '04000010',
    'MACAlgorithm': '04000015',
    'DataElementsSigned': '04000020',
    'DigitalSignatureUID': '04000100',
    'DigitalSignatureDateTime': '04000105',
    'CertificateType': '04000110',
    'CertificateOfSigner': '04000115',
    'Signature': '04000120',
    'CertifiedTimestampType': '04000305',
    'CertifiedTimestamp': '04000310',
    '': '04000315',
    'DigitalSignaturePurposeCodeSequence': '04000401',
    'ReferencedDigitalSignatureSequence': '04000402',
    'ReferencedSOPInstanceMACSequence': '04000403',
    'MAC': '04000404',
    'EncryptedAttributesSequence': '04000500',
    'EncryptedContentTransferSyntaxUID': '04000510',
    'EncryptedContent': '04000520',
    'ModifiedAttributesSequence': '04000550',
    'OriginalAttributesSequence': '04000561',
    'AttributeModificationDateTime': '04000562',
    'ModifyingSystem': '04000563',
    'SourceOfPreviousValues': '04000564',
    'ReasonForTheAttributeModification': '04000565',
    'InstanceOriginStatus': '04000600',
    'NumberOfCopies': '20000010',
    'PrinterConfigurationSequence': '2000001E',
    'PrintPriority': '20000020',
    'MediumType': '20000030',
    'FilmDestination': '20000040',
    'FilmSessionLabel': '20000050',
    'MemoryAllocation': '20000060',
    'MaximumMemoryAllocation': '20000061',
    'ColorImagePrintingFlag': '20000062',
    'CollationFlag': '20000063',
    'AnnotationFlag': '20000065',
    'ImageOverlayFlag': '20000067',
    'PresentationLUTFlag': '20000069',
    'ImageBoxPresentationLUTFlag': '2000006A',
    'MemoryBitDepth': '200000A0',
    'PrintingBitDepth': '200000A1',
    'MediaInstalledSequence': '200000A2',
    'OtherMediaAvailableSequence': '200000A4',
    'SupportedImageDisplayFormatsSequence': '200000A8',
    'ReferencedFilmBoxSequence': '20000500',
    'ReferencedStoredPrintSequence': '20000510',
    'ImageDisplayFormat': '20100010',
    'AnnotationDisplayFormatID': '20100030',
    'FilmOrientation': '20100040',
    'FilmSizeID': '20100050',
    'PrinterResolutionID': '20100052',
    'DefaultPrinterResolutionID': '20100054',
    'MagnificationType': '20100060',
    'SmoothingType': '20100080',
    'DefaultMagnificationType': '201000A6',
    'OtherMagnificationTypesAvailable': '201000A7',
    'DefaultSmoothingType': '201000A8',
    'OtherSmoothingTypesAvailable': '201000A9',
    'BorderDensity': '20100100',
    'EmptyImageDensity': '20100110',
    'MinDensity': '20100120',
    'MaxDensity': '20100130',
    'Trim': '20100140',
    'ConfigurationInformation': '20100150',
    'ConfigurationInformationDescription': '20100152',
    'MaximumCollatedFilms': '20100154',
    'Illumination': '2010015E',
    'ReflectedAmbientLight': '20100160',
    'PrinterPixelSpacing': '20100376',
    'ReferencedFilmSessionSequence': '20100500',
    'ReferencedImageBoxSequence': '20100510',
    'ReferencedBasicAnnotationBoxSequence': '20100520',
    'ImageBoxPosition': '20200010',
    'Polarity': '20200020',
    'RequestedImageSize': '20200030',
    'RequestedDecimateCropBehavior': '20200040',
    'RequestedResolutionID': '20200050',
    'RequestedImageSizeFlag': '202000A0',
    'DecimateCropResult': '202000A2',
    'BasicGrayscaleImageSequence': '20200110',
    'BasicColorImageSequence': '20200111',
    'ReferencedImageOverlayBoxSequence': '20200130',
    'ReferencedVOILUTBoxSequence': '20200140',
    'AnnotationPosition': '20300010',
    'TextString': '20300020',
    'ReferencedOverlayPlaneSequence': '20400010',
    'ReferencedOverlayPlaneGroups': '20400011',
    'OverlayPixelDataSequence': '20400020',
    'OverlayMagnificationType': '20400060',
    'OverlaySmoothingType': '20400070',
    'OverlayOrImageMagnification': '20400072',
    'MagnifyToNumberOfColumns': '20400074',
    'OverlayForegroundDensity': '20400080',
    'OverlayBackgroundDensity': '20400082',
    'OverlayMode': '20400090',
    'ThresholdDensity': '20400100',
    'ReferencedImageBoxSequenceRetired': '20400500',
    'PresentationLUTSequence': '20500010',
    'PresentationLUTShape': '20500020',
    'ReferencedPresentationLUTSequence': '20500500',
    'PrintJobID': '21000010',
    'ExecutionStatus': '21000020',
    'ExecutionStatusInfo': '21000030',
    'CreationDate': '21000040',
    'CreationTime': '21000050',
    'Originator': '21000070',
    'DestinationAE': '21000140',
    'OwnerID': '21000160',
    'NumberOfFilms': '21000170',
    'ReferencedPrintJobSequencePullStoredPrint': '21000500',
    'PrinterStatus': '21100010',
    'PrinterStatusInfo': '21100020',
    'PrinterName': '21100030',
    'PrintQueueID': '21100099',
    'QueueStatus': '21200010',
    'PrintJobDescriptionSequence': '21200050',
    'ReferencedPrintJobSequence': '21200070',
    'PrintManagementCapabilitiesSequence': '21300010',
    'PrinterCharacteristicsSequence': '21300015',
    'FilmBoxContentSequence': '21300030',
    'ImageBoxContentSequence': '21300040',
    'AnnotationContentSequence': '21300050',
    'ImageOverlayBoxContentSequence': '21300060',
    'PresentationLUTContentSequence': '21300080',
    'ProposedStudySequence': '213000A0',
    'OriginalImageSequence': '213000C0',
    'LabelUsingInformationExtractedFromInstances': '22000001',
    'LabelText': '22000002',
    'LabelStyleSelection': '22000003',
    'MediaDisposition': '22000004',
    'BarcodeValue': '22000005',
    'BarcodeSymbology': '22000006',
    'AllowMediaSplitting': '22000007',
    'IncludeNonDICOMObjects': '22000008',
    'IncludeDisplayApplication': '22000009',
    'PreserveCompositeInstancesAfterMediaCreation': '2200000A',
    'TotalNumberOfPiecesOfMediaCreated': '2200000B',
    'RequestedMediaApplicationProfile': '2200000C',
    'ReferencedStorageMediaSequence': '2200000D',
    'FailureAttributes': '2200000E',
    'AllowLossyCompression': '2200000F',
    'RequestPriority': '22000020',
    'RTImageLabel': '30020002',
    'RTImageName': '30020003',
    'RTImageDescription': '30020004',
    'ReportedValuesOrigin': '3002000A',
    'RTImagePlane': '3002000C',
    'XRayImageReceptorTranslation': '3002000D',
    'XRayImageReceptorAngle': '3002000E',
    'RTImageOrientation': '30020010',
    'ImagePlanePixelSpacing': '30020011',
    'RTImagePosition': '30020012',
    'RadiationMachineName': '30020020',
    'RadiationMachineSAD': '30020022',
    'RadiationMachineSSD': '30020024',
    'RTImageSID': '30020026',
    'SourceToReferenceObjectDistance': '30020028',
    'FractionNumber': '30020029',
    'ExposureSequence': '30020030',
    'MetersetExposure': '30020032',
    'DiaphragmPosition': '30020034',
    'FluenceMapSequence': '30020040',
    'FluenceDataSource': '30020041',
    'FluenceDataScale': '30020042',
    'PrimaryFluenceModeSequence': '30020050',
    'FluenceMode': '30020051',
    'FluenceModeID': '30020052',
    'DVHType': '30040001',
    'DoseUnits': '30040002',
    'DoseType': '30040004',
    'SpatialTransformOfDose': '30040005',
    'DoseComment': '30040006',
    'NormalizationPoint': '30040008',
    'DoseSummationType': '3004000A',
    'GridFrameOffsetVector': '3004000C',
    'DoseGridScaling': '3004000E',
    'RTDoseROISequence': '30040010',
    'DoseValue': '30040012',
    'TissueHeterogeneityCorrection': '30040014',
    'DVHNormalizationPoint': '30040040',
    'DVHNormalizationDoseValue': '30040042',
    'DVHSequence': '30040050',
    'DVHDoseScaling': '30040052',
    'DVHVolumeUnits': '30040054',
    'DVHNumberOfBins': '30040056',
    'DVHData': '30040058',
    'DVHReferencedROISequence': '30040060',
    'DVHROIContributionType': '30040062',
    'DVHMinimumDose': '30040070',
    'DVHMaximumDose': '30040072',
    'DVHMeanDose': '30040074',
    'StructureSetLabel': '30060002',
    'StructureSetName': '30060004',
    'StructureSetDescription': '30060006',
    'StructureSetDate': '30060008',
    'StructureSetTime': '30060009',
    'ReferencedFrameOfReferenceSequence': '30060010',
    'RTReferencedStudySequence': '30060012',
    'RTReferencedSeriesSequence': '30060014',
    'ContourImageSequence': '30060016',
    'PredecessorStructureSetSequence': '30060018',
    'StructureSetROISequence': '30060020',
    'ROINumber': '30060022',
    'ReferencedFrameOfReferenceUID': '30060024',
    'ROIName': '30060026',
    'ROIDescription': '30060028',
    'ROIDisplayColor': '3006002A',
    'ROIVolume': '3006002C',
    'RTRelatedROISequence': '30060030',
    'RTROIRelationship': '30060033',
    'ROIGenerationAlgorithm': '30060036',
    'ROIGenerationDescription': '30060038',
    'ROIContourSequence': '30060039',
    'ContourSequence': '30060040',
    'ContourGeometricType': '30060042',
    'ContourSlabThickness': '30060044',
    'ContourOffsetVector': '30060045',
    'NumberOfContourPoints': '30060046',
    'ContourNumber': '30060048',
    'AttachedContours': '30060049',
    'ContourData': '30060050',
    'RTROIObservationsSequence': '30060080',
    'ObservationNumber': '30060082',
    'ReferencedROINumber': '30060084',
    'ROIObservationLabel': '30060085',
    'RTROIIdentificationCodeSequence': '30060086',
    'ROIObservationDescription': '30060088',
    'RelatedRTROIObservationsSequence': '300600A0',
    'RTROIInterpretedType': '300600A4',
    'ROIInterpreter': '300600A6',
    'ROIPhysicalPropertiesSequence': '300600B0',
    'ROIPhysicalProperty': '300600B2',
    'ROIPhysicalPropertyValue': '300600B4',
    'ROIElementalCompositionSequence': '300600B6',
    'ROIElementalCompositionAtomicNumber': '300600B7',
    'ROIElementalCompositionAtomicMassFraction': '300600B8',
    'AdditionalRTROIIdentificationCodeSequence': '300600B9',
    'FrameOfReferenceRelationshipSequence': '300600C0',
    'RelatedFrameOfReferenceUID': '300600C2',
    'FrameOfReferenceTransformationType': '300600C4',
    'FrameOfReferenceTransformationMatrix': '300600C6',
    'FrameOfReferenceTransformationComment': '300600C8',
    'MeasuredDoseReferenceSequence': '30080010',
    'MeasuredDoseDescription': '30080012',
    'MeasuredDoseType': '30080014',
    'MeasuredDoseValue': '30080016',
    'TreatmentSessionBeamSequence': '30080020',
    'TreatmentSessionIonBeamSequence': '30080021',
    'CurrentFractionNumber': '30080022',
    'TreatmentControlPointDate': '30080024',
    'TreatmentControlPointTime': '30080025',
    'TreatmentTerminationStatus': '3008002A',
    'TreatmentTerminationCode': '3008002B',
    'TreatmentVerificationStatus': '3008002C',
    'ReferencedTreatmentRecordSequence': '30080030',
    'SpecifiedPrimaryMeterset': '30080032',
    'SpecifiedSecondaryMeterset': '30080033',
    'DeliveredPrimaryMeterset': '30080036',
    'DeliveredSecondaryMeterset': '30080037',
    'SpecifiedTreatmentTime': '3008003A',
    'DeliveredTreatmentTime': '3008003B',
    'ControlPointDeliverySequence': '30080040',
    'IonControlPointDeliverySequence': '30080041',
    'SpecifiedMeterset': '30080042',
    'DeliveredMeterset': '30080044',
    'MetersetRateSet': '30080045',
    'MetersetRateDelivered': '30080046',
    'ScanSpotMetersetsDelivered': '30080047',
    'DoseRateDelivered': '30080048',
    'TreatmentSummaryCalculatedDoseReferenceSequence': '30080050',
    'CumulativeDoseToDoseReference': '30080052',
    'FirstTreatmentDate': '30080054',
    'MostRecentTreatmentDate': '30080056',
    'NumberOfFractionsDelivered': '3008005A',
    'OverrideSequence': '30080060',
    'ParameterSequencePointer': '30080061',
    'OverrideParameterPointer': '30080062',
    'ParameterItemIndex': '30080063',
    'MeasuredDoseReferenceNumber': '30080064',
    'ParameterPointer': '30080065',
    'OverrideReason': '30080066',
    'ParameterValueNumber': '30080067',
    'CorrectedParameterSequence': '30080068',
    'CorrectionValue': '3008006A',
    'CalculatedDoseReferenceSequence': '30080070',
    'CalculatedDoseReferenceNumber': '30080072',
    'CalculatedDoseReferenceDescription': '30080074',
    'CalculatedDoseReferenceDoseValue': '30080076',
    'StartMeterset': '30080078',
    'EndMeterset': '3008007A',
    'ReferencedMeasuredDoseReferenceSequence': '30080080',
    'ReferencedMeasuredDoseReferenceNumber': '30080082',
    'ReferencedCalculatedDoseReferenceSequence': '30080090',
    'ReferencedCalculatedDoseReferenceNumber': '30080092',
    'BeamLimitingDeviceLeafPairsSequence': '300800A0',
    'RecordedWedgeSequence': '300800B0',
    'RecordedCompensatorSequence': '300800C0',
    'RecordedBlockSequence': '300800D0',
    'TreatmentSummaryMeasuredDoseReferenceSequence': '300800E0',
    'RecordedSnoutSequence': '300800F0',
    'RecordedRangeShifterSequence': '300800F2',
    'RecordedLateralSpreadingDeviceSequence': '300800F4',
    'RecordedRangeModulatorSequence': '300800F6',
    'RecordedSourceSequence': '30080100',
    'SourceSerialNumber': '30080105',
    'TreatmentSessionApplicationSetupSequence': '30080110',
    'ApplicationSetupCheck': '30080116',
    'RecordedBrachyAccessoryDeviceSequence': '30080120',
    'ReferencedBrachyAccessoryDeviceNumber': '30080122',
    'RecordedChannelSequence': '30080130',
    'SpecifiedChannelTotalTime': '30080132',
    'DeliveredChannelTotalTime': '30080134',
    'SpecifiedNumberOfPulses': '30080136',
    'DeliveredNumberOfPulses': '30080138',
    'SpecifiedPulseRepetitionInterval': '3008013A',
    'DeliveredPulseRepetitionInterval': '3008013C',
    'RecordedSourceApplicatorSequence': '30080140',
    'ReferencedSourceApplicatorNumber': '30080142',
    'RecordedChannelShieldSequence': '30080150',
    'ReferencedChannelShieldNumber': '30080152',
    'BrachyControlPointDeliveredSequence': '30080160',
    'SafePositionExitDate': '30080162',
    'SafePositionExitTime': '30080164',
    'SafePositionReturnDate': '30080166',
    'SafePositionReturnTime': '30080168',
    'PulseSpecificBrachyControlPointDeliveredSequence': '30080171',
    'PulseNumber': '30080172',
    'BrachyPulseControlPointDeliveredSequence': '30080173',
    'CurrentTreatmentStatus': '30080200',
    'TreatmentStatusComment': '30080202',
    'FractionGroupSummarySequence': '30080220',
    'ReferencedFractionNumber': '30080223',
    'FractionGroupType': '30080224',
    'BeamStopperPosition': '30080230',
    'FractionStatusSummarySequence': '30080240',
    'TreatmentDate': '30080250',
    'TreatmentTime': '30080251',
    'RTPlanLabel': '300A0002',
    'RTPlanName': '300A0003',
    'RTPlanDescription': '300A0004',
    'RTPlanDate': '300A0006',
    'RTPlanTime': '300A0007',
    'TreatmentProtocols': '300A0009',
    'PlanIntent': '300A000A',
    'TreatmentSites': '300A000B',
    'RTPlanGeometry': '300A000C',
    'PrescriptionDescription': '300A000E',
    'DoseReferenceSequence': '300A0010',
    'DoseReferenceNumber': '300A0012',
    'DoseReferenceUID': '300A0013',
    'DoseReferenceStructureType': '300A0014',
    'NominalBeamEnergyUnit': '300A0015',
    'DoseReferenceDescription': '300A0016',
    'DoseReferencePointCoordinates': '300A0018',
    'NominalPriorDose': '300A001A',
    'DoseReferenceType': '300A0020',
    'ConstraintWeight': '300A0021',
    'DeliveryWarningDose': '300A0022',
    'DeliveryMaximumDose': '300A0023',
    'TargetMinimumDose': '300A0025',
    'TargetPrescriptionDose': '300A0026',
    'TargetMaximumDose': '300A0027',
    'TargetUnderdoseVolumeFraction': '300A0028',
    'OrganAtRiskFullVolumeDose': '300A002A',
    'OrganAtRiskLimitDose': '300A002B',
    'OrganAtRiskMaximumDose': '300A002C',
    'OrganAtRiskOverdoseVolumeFraction': '300A002D',
    'ToleranceTableSequence': '300A0040',
    'ToleranceTableNumber': '300A0042',
    'ToleranceTableLabel': '300A0043',
    'GantryAngleTolerance': '300A0044',
    'BeamLimitingDeviceAngleTolerance': '300A0046',
    'BeamLimitingDeviceToleranceSequence': '300A0048',
    'BeamLimitingDevicePositionTolerance': '300A004A',
    'SnoutPositionTolerance': '300A004B',
    'PatientSupportAngleTolerance': '300A004C',
    'TableTopEccentricAngleTolerance': '300A004E',
    'TableTopPitchAngleTolerance': '300A004F',
    'TableTopRollAngleTolerance': '300A0050',
    'TableTopVerticalPositionTolerance': '300A0051',
    'TableTopLongitudinalPositionTolerance': '300A0052',
    'TableTopLateralPositionTolerance': '300A0053',
    'RTPlanRelationship': '300A0055',
    'FractionGroupSequence': '300A0070',
    'FractionGroupNumber': '300A0071',
    'FractionGroupDescription': '300A0072',
    'NumberOfFractionsPlanned': '300A0078',
    'NumberOfFractionPatternDigitsPerDay': '300A0079',
    'RepeatFractionCycleLength': '300A007A',
    'FractionPattern': '300A007B',
    'NumberOfBeams': '300A0080',
    'BeamDoseSpecificationPoint': '300A0082',
    'ReferencedDoseReferenceUID': '300A0083',
    'BeamDose': '300A0084',
    'BeamMeterset': '300A0086',
    'BeamDosePointDepth': '300A0088',
    'BeamDosePointEquivalentDepth': '300A0089',
    'BeamDosePointSSD': '300A008A',
    'BeamDoseMeaning': '300A008B',
    'BeamDoseVerificationControlPointSequence': '300A008C',
    'AverageBeamDosePointDepth': '300A008D',
    'AverageBeamDosePointEquivalentDepth': '300A008E',
    'AverageBeamDosePointSSD': '300A008F',
    'BeamDoseType': '300A0090',
    'AlternateBeamDose': '300A0091',
    'AlternateBeamDoseType': '300A0092',
    'DepthValueAveragingFlag': '300A0093',
    'BeamDosePointSourceToExternalContourDistance': '300A0094',
    'NumberOfBrachyApplicationSetups': '300A00A0',
    'BrachyApplicationSetupDoseSpecificationPoint': '300A00A2',
    'BrachyApplicationSetupDose': '300A00A4',
    'BeamSequence': '300A00B0',
    'TreatmentMachineName': '300A00B2',
    'PrimaryDosimeterUnit': '300A00B3',
    'SourceAxisDistance': '300A00B4',
    'BeamLimitingDeviceSequence': '300A00B6',
    'RTBeamLimitingDeviceType': '300A00B8',
    'SourceToBeamLimitingDeviceDistance': '300A00BA',
    'IsocenterToBeamLimitingDeviceDistance': '300A00BB',
    'NumberOfLeafJawPairs': '300A00BC',
    'LeafPositionBoundaries': '300A00BE',
    'BeamNumber': '300A00C0',
    'BeamName': '300A00C2',
    'BeamDescription': '300A00C3',
    'BeamType': '300A00C4',
    'BeamDeliveryDurationLimit': '300A00C5',
    'RadiationType': '300A00C6',
    'HighDoseTechniqueType': '300A00C7',
    'ReferenceImageNumber': '300A00C8',
    'PlannedVerificationImageSequence': '300A00CA',
    'ImagingDeviceSpecificAcquisitionParameters': '300A00CC',
    'TreatmentDeliveryType': '300A00CE',
    'NumberOfWedges': '300A00D0',
    'WedgeSequence': '300A00D1',
    'WedgeNumber': '300A00D2',
    'WedgeType': '300A00D3',
    'WedgeID': '300A00D4',
    'WedgeAngle': '300A00D5',
    'WedgeFactor': '300A00D6',
    'TotalWedgeTrayWaterEquivalentThickness': '300A00D7',
    'WedgeOrientation': '300A00D8',
    'IsocenterToWedgeTrayDistance': '300A00D9',
    'SourceToWedgeTrayDistance': '300A00DA',
    'WedgeThinEdgePosition': '300A00DB',
    'BolusID': '300A00DC',
    'BolusDescription': '300A00DD',
    'EffectiveWedgeAngle': '300A00DE',
    'NumberOfCompensators': '300A00E0',
    'MaterialID': '300A00E1',
    'TotalCompensatorTrayFactor': '300A00E2',
    'CompensatorSequence': '300A00E3',
    'CompensatorNumber': '300A00E4',
    'CompensatorID': '300A00E5',
    'SourceToCompensatorTrayDistance': '300A00E6',
    'CompensatorRows': '300A00E7',
    'CompensatorColumns': '300A00E8',
    'CompensatorPixelSpacing': '300A00E9',
    'CompensatorPosition': '300A00EA',
    'CompensatorTransmissionData': '300A00EB',
    'CompensatorThicknessData': '300A00EC',
    'NumberOfBoli': '300A00ED',
    'CompensatorType': '300A00EE',
    'CompensatorTrayID': '300A00EF',
    'NumberOfBlocks': '300A00F0',
    'TotalBlockTrayFactor': '300A00F2',
    'TotalBlockTrayWaterEquivalentThickness': '300A00F3',
    'BlockSequence': '300A00F4',
    'BlockTrayID': '300A00F5',
    'SourceToBlockTrayDistance': '300A00F6',
    'IsocenterToBlockTrayDistance': '300A00F7',
    'BlockType': '300A00F8',
    'AccessoryCode': '300A00F9',
    'BlockDivergence': '300A00FA',
    'BlockMountingPosition': '300A00FB',
    'BlockNumber': '300A00FC',
    'BlockName': '300A00FE',
    'BlockThickness': '300A0100',
    'BlockTransmission': '300A0102',
    'BlockNumberOfPoints': '300A0104',
    'BlockData': '300A0106',
    'ApplicatorSequence': '300A0107',
    'ApplicatorID': '300A0108',
    'ApplicatorType': '300A0109',
    'ApplicatorDescription': '300A010A',
    'CumulativeDoseReferenceCoefficient': '300A010C',
    'FinalCumulativeMetersetWeight': '300A010E',
    'NumberOfControlPoints': '300A0110',
    'ControlPointSequence': '300A0111',
    'ControlPointIndex': '300A0112',
    'NominalBeamEnergy': '300A0114',
    'DoseRateSet': '300A0115',
    'WedgePositionSequence': '300A0116',
    'WedgePosition': '300A0118',
    'BeamLimitingDevicePositionSequence': '300A011A',
    'LeafJawPositions': '300A011C',
    'GantryAngle': '300A011E',
    'GantryRotationDirection': '300A011F',
    'BeamLimitingDeviceAngle': '300A0120',
    'BeamLimitingDeviceRotationDirection': '300A0121',
    'PatientSupportAngle': '300A0122',
    'PatientSupportRotationDirection': '300A0123',
    'TableTopEccentricAxisDistance': '300A0124',
    'TableTopEccentricAngle': '300A0125',
    'TableTopEccentricRotationDirection': '300A0126',
    'TableTopVerticalPosition': '300A0128',
    'TableTopLongitudinalPosition': '300A0129',
    'TableTopLateralPosition': '300A012A',
    'IsocenterPosition': '300A012C',
    'SurfaceEntryPoint': '300A012E',
    'SourceToSurfaceDistance': '300A0130',
    'AverageBeamDosePointSourceToExternalContourDistance': '300A0131',
    'SourceToExternalContourDistance': '300A0132',
    'ExternalContourEntryPoint': '300A0133',
    'CumulativeMetersetWeight': '300A0134',
    'TableTopPitchAngle': '300A0140',
    'TableTopPitchRotationDirection': '300A0142',
    'TableTopRollAngle': '300A0144',
    'TableTopRollRotationDirection': '300A0146',
    'HeadFixationAngle': '300A0148',
    'GantryPitchAngle': '300A014A',
    'GantryPitchRotationDirection': '300A014C',
    'GantryPitchAngleTolerance': '300A014E',
    'FixationEye': '300A0150',
    'ChairHeadFramePosition': '300A0151',
    'HeadFixationAngleTolerance': '300A0152',
    'ChairHeadFramePositionTolerance': '300A0153',
    'FixationLightAzimuthalAngleTolerance': '300A0154',
    'FixationLightPolarAngleTolerance': '300A0155',
    'PatientSetupSequence': '300A0180',
    'PatientSetupNumber': '300A0182',
    'PatientSetupLabel': '300A0183',
    'PatientAdditionalPosition': '300A0184',
    'FixationDeviceSequence': '300A0190',
    'FixationDeviceType': '300A0192',
    'FixationDeviceLabel': '300A0194',
    'FixationDeviceDescription': '300A0196',
    'FixationDevicePosition': '300A0198',
    'FixationDevicePitchAngle': '300A0199',
    'FixationDeviceRollAngle': '300A019A',
    'ShieldingDeviceSequence': '300A01A0',
    'ShieldingDeviceType': '300A01A2',
    'ShieldingDeviceLabel': '300A01A4',
    'ShieldingDeviceDescription': '300A01A6',
    'ShieldingDevicePosition': '300A01A8',
    'SetupTechnique': '300A01B0',
    'SetupTechniqueDescription': '300A01B2',
    'SetupDeviceSequence': '300A01B4',
    'SetupDeviceType': '300A01B6',
    'SetupDeviceLabel': '300A01B8',
    'SetupDeviceDescription': '300A01BA',
    'SetupDeviceParameter': '300A01BC',
    'SetupReferenceDescription': '300A01D0',
    'TableTopVerticalSetupDisplacement': '300A01D2',
    'TableTopLongitudinalSetupDisplacement': '300A01D4',
    'TableTopLateralSetupDisplacement': '300A01D6',
    'BrachyTreatmentTechnique': '300A0200',
    'BrachyTreatmentType': '300A0202',
    'TreatmentMachineSequence': '300A0206',
    'SourceSequence': '300A0210',
    'SourceNumber': '300A0212',
    'SourceType': '300A0214',
    'SourceManufacturer': '300A0216',
    'ActiveSourceDiameter': '300A0218',
    'ActiveSourceLength': '300A021A',
    'SourceModelID': '300A021B',
    'SourceDescription': '300A021C',
    'SourceEncapsulationNominalThickness': '300A0222',
    'SourceEncapsulationNominalTransmission': '300A0224',
    'SourceIsotopeName': '300A0226',
    'SourceIsotopeHalfLife': '300A0228',
    'SourceStrengthUnits': '300A0229',
    'ReferenceAirKermaRate': '300A022A',
    'SourceStrength': '300A022B',
    'SourceStrengthReferenceDate': '300A022C',
    'SourceStrengthReferenceTime': '300A022E',
    'ApplicationSetupSequence': '300A0230',
    'ApplicationSetupType': '300A0232',
    'ApplicationSetupNumber': '300A0234',
    'ApplicationSetupName': '300A0236',
    'ApplicationSetupManufacturer': '300A0238',
    'TemplateNumber': '300A0240',
    'TemplateType': '300A0242',
    'TemplateName': '300A0244',
    'TotalReferenceAirKerma': '300A0250',
    'BrachyAccessoryDeviceSequence': '300A0260',
    'BrachyAccessoryDeviceNumber': '300A0262',
    'BrachyAccessoryDeviceID': '300A0263',
    'BrachyAccessoryDeviceType': '300A0264',
    'BrachyAccessoryDeviceName': '300A0266',
    'BrachyAccessoryDeviceNominalThickness': '300A026A',
    'BrachyAccessoryDeviceNominalTransmission': '300A026C',
    'ChannelEffectiveLength': '300A0271',
    'ChannelInnerLength': '300A0272',
    'AfterloaderChannelID': '300A0273',
    'SourceApplicatorTipLength': '300A0274',
    'ChannelSequence': '300A0280',
    'ChannelNumber': '300A0282',
    'ChannelLength': '300A0284',
    'ChannelTotalTime': '300A0286',
    'SourceMovementType': '300A0288',
    'NumberOfPulses': '300A028A',
    'PulseRepetitionInterval': '300A028C',
    'SourceApplicatorNumber': '300A0290',
    'SourceApplicatorID': '300A0291',
    'SourceApplicatorType': '300A0292',
    'SourceApplicatorName': '300A0294',
    'SourceApplicatorLength': '300A0296',
    'SourceApplicatorManufacturer': '300A0298',
    'SourceApplicatorWallNominalThickness': '300A029C',
    'SourceApplicatorWallNominalTransmission': '300A029E',
    'SourceApplicatorStepSize': '300A02A0',
    'TransferTubeNumber': '300A02A2',
    'TransferTubeLength': '300A02A4',
    'ChannelShieldSequence': '300A02B0',
    'ChannelShieldNumber': '300A02B2',
    'ChannelShieldID': '300A02B3',
    'ChannelShieldName': '300A02B4',
    'ChannelShieldNominalThickness': '300A02B8',
    'ChannelShieldNominalTransmission': '300A02BA',
    'FinalCumulativeTimeWeight': '300A02C8',
    'BrachyControlPointSequence': '300A02D0',
    'ControlPointRelativePosition': '300A02D2',
    '300A02D4': ('ControlPoint3DPosition'),
    'CumulativeTimeWeight': '300A02D6',
    'CompensatorDivergence': '300A02E0',
    'CompensatorMountingPosition': '300A02E1',
    'SourceToCompensatorDistance': '300A02E2',
    'TotalCompensatorTrayWaterEquivalentThickness': '300A02E3',
    'IsocenterToCompensatorTrayDistance': '300A02E4',
    'CompensatorColumnOffset': '300A02E5',
    'IsocenterToCompensatorDistances': '300A02E6',
    'CompensatorRelativeStoppingPowerRatio': '300A02E7',
    'CompensatorMillingToolDiameter': '300A02E8',
    'IonRangeCompensatorSequence': '300A02EA',
    'CompensatorDescription': '300A02EB',
    'RadiationMassNumber': '300A0302',
    'RadiationAtomicNumber': '300A0304',
    'RadiationChargeState': '300A0306',
    'ScanMode': '300A0308',
    'ModulatedScanModeType': '300A0309',
    'VirtualSourceAxisDistances': '300A030A',
    'SnoutSequence': '300A030C',
    'SnoutPosition': '300A030D',
    'SnoutID': '300A030F',
    'NumberOfRangeShifters': '300A0312',
    'RangeShifterSequence': '300A0314',
    'RangeShifterNumber': '300A0316',
    'RangeShifterID': '300A0318',
    'RangeShifterType': '300A0320',
    'RangeShifterDescription': '300A0322',
    'NumberOfLateralSpreadingDevices': '300A0330',
    'LateralSpreadingDeviceSequence': '300A0332',
    'LateralSpreadingDeviceNumber': '300A0334',
    'LateralSpreadingDeviceID': '300A0336',
    'LateralSpreadingDeviceType': '300A0338',
    'LateralSpreadingDeviceDescription': '300A033A',
    'LateralSpreadingDeviceWaterEquivalentThickness': '300A033C',
    'NumberOfRangeModulators': '300A0340',
    'RangeModulatorSequence': '300A0342',
    'RangeModulatorNumber': '300A0344',
    'RangeModulatorID': '300A0346',
    'RangeModulatorType': '300A0348',
    'RangeModulatorDescription': '300A034A',
    'BeamCurrentModulationID': '300A034C',
    'PatientSupportType': '300A0350',
    'PatientSupportID': '300A0352',
    'PatientSupportAccessoryCode': '300A0354',
    'TrayAccessoryCode': '300A0355',
    'FixationLightAzimuthalAngle': '300A0356',
    'FixationLightPolarAngle': '300A0358',
    'MetersetRate': '300A035A',
    'RangeShifterSettingsSequence': '300A0360',
    'RangeShifterSetting': '300A0362',
    'IsocenterToRangeShifterDistance': '300A0364',
    'RangeShifterWaterEquivalentThickness': '300A0366',
    'LateralSpreadingDeviceSettingsSequence': '300A0370',
    'LateralSpreadingDeviceSetting': '300A0372',
    'IsocenterToLateralSpreadingDeviceDistance': '300A0374',
    'RangeModulatorSettingsSequence': '300A0380',
    'RangeModulatorGatingStartValue': '300A0382',
    'RangeModulatorGatingStopValue': '300A0384',
    'RangeModulatorGatingStartWaterEquivalentThickness': '300A0386',
    'RangeModulatorGatingStopWaterEquivalentThickness': '300A0388',
    'IsocenterToRangeModulatorDistance': '300A038A',
    'ScanSpotTimeOffset': '300A038F',
    'ScanSpotTuneID': '300A0390',
    'ScanSpotPrescribedIndices': '300A0391',
    'NumberOfScanSpotPositions': '300A0392',
    'ScanSpotReordered': '300A0393',
    'ScanSpotPositionMap': '300A0394',
    'ScanSpotReorderingAllowed': '300A0395',
    'ScanSpotMetersetWeights': '300A0396',
    'ScanningSpotSize': '300A0398',
    'NumberOfPaintings': '300A039A',
    'IonToleranceTableSequence': '300A03A0',
    'IonBeamSequence': '300A03A2',
    'IonBeamLimitingDeviceSequence': '300A03A4',
    'IonBlockSequence': '300A03A6',
    'IonControlPointSequence': '300A03A8',
    'IonWedgeSequence': '300A03AA',
    'IonWedgePositionSequence': '300A03AC',
    'ReferencedSetupImageSequence': '300A0401',
    'SetupImageComment': '300A0402',
    'MotionSynchronizationSequence': '300A0410',
    'ControlPointOrientation': '300A0412',
    'GeneralAccessorySequence': '300A0420',
    'GeneralAccessoryID': '300A0421',
    'GeneralAccessoryDescription': '300A0422',
    'GeneralAccessoryType': '300A0423',
    'GeneralAccessoryNumber': '300A0424',
    'SourceToGeneralAccessoryDistance': '300A0425',
    'ApplicatorGeometrySequence': '300A0431',
    'ApplicatorApertureShape': '300A0432',
    'ApplicatorOpening': '300A0433',
    'ApplicatorOpeningX': '300A0434',
    'ApplicatorOpeningY': '300A0435',
    'SourceToApplicatorMountingPositionDistance': '300A0436',
    'NumberOfBlockSlabItems': '300A0440',
    'BlockSlabSequence': '300A0441',
    'BlockSlabThickness': '300A0442',
    'BlockSlabNumber': '300A0443',
    'DeviceMotionControlSequence': '300A0450',
    'DeviceMotionExecutionMode': '300A0451',
    'DeviceMotionObservationMode': '300A0452',
    'DeviceMotionParameterCodeSequence': '300A0453',
    'DistalDepthFraction': '300A0501',
    'DistalDepth': '300A0502',
    'NominalRangeModulationFractions': '300A0503',
    'NominalRangeModulatedRegionDepths': '300A0504',
    'DepthDoseParametersSequence': '300A0505',
    'DeliveredDepthDoseParametersSequence': '300A0506',
    'DeliveredDistalDepthFraction': '300A0507',
    'DeliveredDistalDepth': '300A0508',
    'DeliveredNominalRangeModulationFractions': '300A0509',
    'DeliveredNominalRangeModulatedRegionDepths': '300A0510',
    'DeliveredReferenceDoseDefinition': '300A0511',
    'ReferenceDoseDefinition': '300A0512',
    'ReferencedRTPlanSequence': '300C0002',
    'ReferencedBeamSequence': '300C0004',
    'ReferencedBeamNumber': '300C0006',
    'ReferencedReferenceImageNumber': '300C0007',
    'StartCumulativeMetersetWeight': '300C0008',
    'EndCumulativeMetersetWeight': '300C0009',
    'ReferencedBrachyApplicationSetupSequence': '300C000A',
    'ReferencedBrachyApplicationSetupNumber': '300C000C',
    'ReferencedSourceNumber': '300C000E',
    'ReferencedFractionGroupSequence': '300C0020',
    'ReferencedFractionGroupNumber': '300C0022',
    'ReferencedVerificationImageSequence': '300C0040',
    'ReferencedReferenceImageSequence': '300C0042',
    'ReferencedDoseReferenceSequence': '300C0050',
    'ReferencedDoseReferenceNumber': '300C0051',
    'BrachyReferencedDoseReferenceSequence': '300C0055',
    'ReferencedStructureSetSequence': '300C0060',
    'ReferencedPatientSetupNumber': '300C006A',
    'ReferencedDoseSequence': '300C0080',
    'ReferencedToleranceTableNumber': '300C00A0',
    'ReferencedBolusSequence': '300C00B0',
    'ReferencedWedgeNumber': '300C00C0',
    'ReferencedCompensatorNumber': '300C00D0',
    'ReferencedBlockNumber': '300C00E0',
    'ReferencedControlPointIndex': '300C00F0',
    'ReferencedControlPointSequence': '300C00F2',
    'ReferencedStartControlPointIndex': '300C00F4',
    'ReferencedStopControlPointIndex': '300C00F6',
    'ReferencedRangeShifterNumber': '300C0100',
    'ReferencedLateralSpreadingDeviceNumber': '300C0102',
    'ReferencedRangeModulatorNumber': '300C0104',
    'OmittedBeamTaskSequence': '300C0111',
    'ReasonForOmission': '300C0112',
    'ReasonForOmissionDescription': '300C0113',
    'ApprovalStatus': '300E0002',
    'ReviewDate': '300E0004',
    'ReviewTime': '300E0005',
    'ReviewerName': '300E0008',
    'Arbitrary': '40000010',
    'TextComments': '40004000',
    'ResultsID': '40080040',
    'ResultsIDIssuer': '40080042',
    'ReferencedInterpretationSequence': '40080050',
    'ReportProductionStatusTrial': '400800FF',
    'InterpretationRecordedDate': '40080100',
    'InterpretationRecordedTime': '40080101',
    'InterpretationRecorder': '40080102',
    'ReferenceToRecordedSound': '40080103',
    'InterpretationTranscriptionDate': '40080108',
    'InterpretationTranscriptionTime': '40080109',
    'InterpretationTranscriber': '4008010A',
    'InterpretationText': '4008010B',
    'InterpretationAuthor': '4008010C',
    'InterpretationApproverSequence': '40080111',
    'InterpretationApprovalDate': '40080112',
    'InterpretationApprovalTime': '40080113',
    'PhysicianApprovingInterpretation': '40080114',
    'InterpretationDiagnosisDescription': '40080115',
    'InterpretationDiagnosisCodeSequence': '40080117',
    'ResultsDistributionListSequence': '40080118',
    'DistributionName': '40080119',
    'DistributionAddress': '4008011A',
    'InterpretationID': '40080200',
    'InterpretationIDIssuer': '40080202',
    'InterpretationTypeID': '40080210',
    'InterpretationStatusID': '40080212',
    'Impressions': '40080300',
    'ResultsComments': '40084000',
    'LowEnergyDetectors': '40100001',
    'HighEnergyDetectors': '40100002',
    'DetectorGeometrySequence': '40100004',
    'ThreatROIVoxelSequence': '40101001',
    'ThreatROIBase': '40101004',
    'ThreatROIExtents': '40101005',
    'ThreatROIBitmap': '40101006',
    'RouteSegmentID': '40101007',
    'GantryType': '40101008',
    'OOIOwnerType': '40101009',
    'RouteSegmentSequence': '4010100A',
    'PotentialThreatObjectID': '40101010',
    'ThreatSequence': '40101011',
    'ThreatCategory': '40101012',
    'ThreatCategoryDescription': '40101013',
    'ATDAbilityAssessment': '40101014',
    'ATDAssessmentFlag': '40101015',
    'ATDAssessmentProbability': '40101016',
    'Mass': '40101017',
    'Density': '40101018',
    'ZEffective': '40101019',
    'BoardingPassID': '4010101A',
    'CenterOfMass': '4010101B',
    'CenterOfPTO': '4010101C',
    'BoundingPolygon': '4010101D',
    'RouteSegmentStartLocationID': '4010101E',
    'RouteSegmentEndLocationID': '4010101F',
    'RouteSegmentLocationIDType': '40101020',
    'AbortReason': '40101021',
    'VolumeOfPTO': '40101023',
    'AbortFlag': '40101024',
    'RouteSegmentStartTime': '40101025',
    'RouteSegmentEndTime': '40101026',
    'TDRType': '40101027',
    'InternationalRouteSegment': '40101028',
    'ThreatDetectionAlgorithmandVersion': '40101029',
    'AssignedLocation': '4010102A',
    'AlarmDecisionTime': '4010102B',
    'AlarmDecision': '40101031',
    'NumberOfTotalObjects': '40101033',
    'NumberOfAlarmObjects': '40101034',
    'PTORepresentationSequence': '40101037',
    'ATDAssessmentSequence': '40101038',
    'TIPType': '40101039',
    'DICOSVersion': '4010103A',
    'OOIOwnerCreationTime': '40101041',
    'OOIType': '40101042',
    'OOISize': '40101043',
    'AcquisitionStatus': '40101044',
    'BasisMaterialsCodeSequence': '40101045',
    'PhantomType': '40101046',
    'OOIOwnerSequence': '40101047',
    'ScanType': '40101048',
    'ItineraryID': '40101051',
    'ItineraryIDType': '40101052',
    'ItineraryIDAssigningAuthority': '40101053',
    'RouteID': '40101054',
    'RouteIDAssigningAuthority': '40101055',
    'InboundArrivalType': '40101056',
    'CarrierID': '40101058',
    'CarrierIDAssigningAuthority': '40101059',
    'SourceOrientation': '40101060',
    'SourcePosition': '40101061',
    'BeltHeight': '40101062',
    'AlgorithmRoutingCodeSequence': '40101064',
    'TransportClassification': '40101067',
    'OOITypeDescriptor': '40101068',
    'TotalProcessingTime': '40101069',
    'DetectorCalibrationData': '4010106C',
    'AdditionalScreeningPerformed': '4010106D',
    'AdditionalInspectionSelectionCriteria': '4010106E',
    'AdditionalInspectionMethodSequence': '4010106F',
    'AITDeviceType': '40101070',
    'QRMeasurementsSequence': '40101071',
    'TargetMaterialSequence': '40101072',
    'SNRThreshold': '40101073',
    'ImageScaleRepresentation': '40101075',
    'ReferencedPTOSequence': '40101076',
    'ReferencedTDRInstanceSequence': '40101077',
    'PTOLocationDescription': '40101078',
    'AnomalyLocatorIndicatorSequence': '40101079',
    'AnomalyLocatorIndicator': '4010107A',
    'PTORegionSequence': '4010107B',
    'InspectionSelectionCriteria': '4010107C',
    'SecondaryInspectionMethodSequence': '4010107D',
    'PRCSToRCSOrientation': '4010107E',
    'MACParametersSequence': '4FFE0001',
    'SharedFunctionalGroupsSequence': '52009229',
    'PerFrameFunctionalGroupsSequence': '52009230',
    'WaveformSequence': '54000100',
    'ChannelMinimumValue': '54000110',
    'ChannelMaximumValue': '54000112',
    'WaveformBitsAllocated': '54001004',
    'WaveformSampleInterpretation': '54001006',
    'WaveformPaddingValue': '5400100A',
    'WaveformData': '54001010',
    'FirstOrderPhaseCorrectionAngle': '56000010',
    'SpectroscopyData': '56000020',
    'FloatPixelData': '7FE00008',
    'DoubleFloatPixelData': '7FE00009',
    'PixelData': '7FE00010',
    'CoefficientsSDVN': '7FE00020',
    'CoefficientsSDHN': '7FE00030',
    'CoefficientsSDDN': '7FE00040',
    'DigitalSignaturesSequence': 'FFFAFFFA',
    'DataSetTrailingPadding': 'FFFCFFFC',
    'Item': 'FFFEE000',
    'ItemDelimitationItem': 'FFFEE00D',
    'SequenceDelimitationItem': 'FFFEE0DD',
  };
  Object.freeze(keywordToTag);

  /** Determines the mapping of pyramid tile positions to frame numbers.
   *
   * @param {Object} Formatted metadata of a VL Whole Slide Microscopy Image instance
   * @returns {Object} Mapping of pyramid tile position (Row-Column) to frame URI
   * @private
   */
  function getFrameMapping(metadata) {
    const rows = metadata.Rows;
    const columns = metadata.Columns;
    const totalPixelMatrixColumns = metadata.TotalPixelMatrixColumns;
    const totalPixelMatrixRows = metadata.TotalPixelMatrixRows;
    const sopInstanceUID = metadata.SOPInstanceUID;
    let numberOfFrames = metadata.NumberOfFrames || 1;
    numberOfFrames = Number(numberOfFrames);
    let frameOffsetNumber = metadata.ConcatenationFrameOffsetNumber || 0;
    frameOffsetNumber = Number(frameOffsetNumber);
    /*
     * The values "TILED_SPARSE" and "TILED_FULL" were introduced in the 2018
     * of the standard. Older datasets are equivalent to "TILED_SPARSE"
     * even though they may not have a value or a different value.
    */
    const dimensionOrganizationType = metadata.DimensionOrganizationType || 'TILED_SPARSE';
    const tilesPerRow = Math.ceil(totalPixelMatrixColumns / columns);
    const frameMapping = {};
    if (dimensionOrganizationType === 'TILED_FULL') {
      let offset = frameOffsetNumber + 1;
      let limit = frameOffsetNumber + numberOfFrames;
      for (let j = offset; j <= limit; j++) {
        let rowFraction = j / tilesPerRow;
        let rowIndex = Math.ceil(rowFraction);
        let colIndex = j - (rowIndex * tilesPerRow) + tilesPerRow;
        let index = rowIndex + '-' + colIndex;
        let frameNumber = j - offset + 1;
        frameMapping[index] = `${sopInstanceUID}/frames/${frameNumber}`;
      }
    } else {
      const functionalGroups = metadata.PerFrameFunctionalGroupsSequence;
      for (let j = 0; j < numberOfFrames; j++) {
        let planePositions = functionalGroups[j].PlanePositionSlideSequence[0];
        let rowPosition = planePositions.RowPositionInTotalImagePixelMatrix;
        let columnPosition = planePositions.ColumnPositionInTotalImagePixelMatrix;
        let rowIndex = Math.ceil(rowPosition / rows);
        let colIndex = Math.ceil(columnPosition / columns);
        let index = rowIndex + '-' + colIndex;
        let frameNumber = j + 1;
        frameMapping[index] = `${sopInstanceUID}/frames/${frameNumber}`;
      }
    }
    return frameMapping;
  }


  /** Formats DICOM metadata structured according to the DICOM JSON model into a
   * more human friendly representation, where values of data elements can be
   * directly accessed via their keyword (e.g., "SOPInstanceUID").
   * Bulkdata elements will be skipped.
   *
   * @param {Object} Metadata structured according to the DICOM JSON model
   * @returns {Object} Formatted metadata
   * @memberof metadata
   */
  function formatMetadata(metadata) {
    const loadJSONDataset = (elements) => {
      const dataset = {};
      Object.keys(elements).forEach(tag => {
        const keyword = tagToKeyword[tag];
        const vr = elements[tag]['vr'];
        if ('BulkDataURI' in elements[tag]) {
          console.debug(`skip bulk data element "${keyword}"`);
        } else if ('Value' in elements[tag]) {
          const value = elements[tag]['Value'];
          if (vr === 'SQ') {
            dataset[keyword] = value.map(item => loadJSONDataset(item));
          } else {
            // Handle value multiplicity.
            if (value.length === 1) {
              if (vr === 'DS' || vr === 'IS') {
                dataset[keyword] = Number(value[0]);
              } else {
                dataset[keyword] = value[0];
              }
            } else {
              if (vr === 'DS' || vr === 'IS') {
                dataset[keyword] = value.map(v => Number(v));
              } else {
                dataset[keyword] = value;
              }
            }
          }
        } else {
          if (vr === 'SQ') {
            dataset[keyword] = [];
          } else {
            dataset[keyword] = null;
          }
        }
      });
      return dataset;
    };

    const dataset = loadJSONDataset(metadata);

    // The top level (lowest resolution) image may be a single frame image in
    // which case the "NumberOfFrames" attribute is optional. We include it for
    // consistency.
    if (dataset === undefined) {
      throw new Error('Could not format metadata: ', metadata)
    }
    if (!('NumberOfFrames' in dataset) && (dataset.Modality === 'SM')) {
      dataset.NumberOfFrames = 1;
    }

    return dataset;
  }


  /** DICOM VL Whole Slide Microscopy Image instance
   * (without Pixel Data or any other bulk data).
   *
   * @class
   * @memberof metadata
   */
  class VLWholeSlideMicroscopyImage {

      /**
       * @params {Object} options
       * @params {Object} options.metadata - Metadata in DICOM JSON format
       */
      constructor(options) {
        const dataset = formatMetadata(options.metadata);
        if (dataset.SOPClassUID !== '1.2.840.10008.5.1.4.1.1.77.1.6') {
          throw new Error(
            'Cannot construct VL Whole Slide Microscopy Image instance ' +
            `given dataset with SOP Class UID "${dataset.SOPClassUID}"`
          );
        }

        Object.assign(this, dataset);
      }
  }

  /** DICOM Comprehensive 3D SR instance.
   *
   * @class
   * @memberof metadata
   */
  class Comprehensive3DSR {

      /**
       * @params {Object} options
       * @params {Object} options.metadata - Metadata in DICOM JSON format
       */
      constructor(options) {
        const dataset = formatMetadata(options.metadata);
        if (dataset.SOPClassUID !== '1.2.840.10008.5.1.4.1.1.88.34') {
          throw new Error(
            'Cannot construct Comprehensive 3D SR instance ' +
            `given dataset with SOP Class UID "${dataset.SOPClassUID}"`
          );
        }

        Object.assign(this, dataset);
      }
  }

  var DEFAULT_CONFIG = {
    // minimum relative difference between two compared values,
    // used by all comparison functions
    epsilon: 1e-12,
    // type of default matrix output. Choose 'matrix' (default) or 'array'
    matrix: 'Matrix',
    // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
    number: 'number',
    // number of significant digits in BigNumbers
    precision: 64,
    // predictable output type of functions. When true, output type depends only
    // on the input types. When false (default), output type can vary depending
    // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
    // predictable is false, and returns `NaN` when true.
    predictable: false,
    // random seed for seeded pseudo random number generation
    // null = randomly seed
    randomSeed: null
  };

  function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  // type checks for all known types
  //
  // note that:
  //
  // - check by duck-typing on a property like `isUnit`, instead of checking instanceof.
  //   instanceof cannot be used because that would not allow to pass data from
  //   one instance of math.js to another since each has it's own instance of Unit.
  // - check the `isUnit` property via the constructor, so there will be no
  //   matches for "fake" instances like plain objects with a property `isUnit`.
  //   That is important for security reasons.
  // - It must not be possible to override the type checks used internally,
  //   for security reasons, so these functions are not exposed in the expression
  //   parser.
  function isNumber(x) {
    return typeof x === 'number';
  }
  function isBigNumber(x) {
    return x && x.constructor.prototype.isBigNumber === true || false;
  }
  function isComplex(x) {
    return x && _typeof(x) === 'object' && Object.getPrototypeOf(x).isComplex === true || false;
  }
  function isFraction(x) {
    return x && _typeof(x) === 'object' && Object.getPrototypeOf(x).isFraction === true || false;
  }
  function isUnit(x) {
    return x && x.constructor.prototype.isUnit === true || false;
  }
  function isString(x) {
    return typeof x === 'string';
  }
  var isArray = Array.isArray;
  function isMatrix(x) {
    return x && x.constructor.prototype.isMatrix === true || false;
  }
  /**
   * Test whether a value is a collection: an Array or Matrix
   * @param {*} x
   * @returns {boolean} isCollection
   */

  function isCollection(x) {
    return Array.isArray(x) || isMatrix(x);
  }
  function isDenseMatrix(x) {
    return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
  }
  function isSparseMatrix(x) {
    return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
  }
  function isRange(x) {
    return x && x.constructor.prototype.isRange === true || false;
  }
  function isIndex(x) {
    return x && x.constructor.prototype.isIndex === true || false;
  }
  function isBoolean(x) {
    return typeof x === 'boolean';
  }
  function isResultSet(x) {
    return x && x.constructor.prototype.isResultSet === true || false;
  }
  function isHelp(x) {
    return x && x.constructor.prototype.isHelp === true || false;
  }
  function isFunction(x) {
    return typeof x === 'function';
  }
  function isDate(x) {
    return x instanceof Date;
  }
  function isRegExp(x) {
    return x instanceof RegExp;
  }
  function isObject(x) {
    return !!(x && _typeof(x) === 'object' && x.constructor === Object && !isComplex(x) && !isFraction(x));
  }
  function isNull(x) {
    return x === null;
  }
  function isUndefined(x) {
    return x === undefined;
  }
  function isAccessorNode(x) {
    return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isArrayNode(x) {
    return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isAssignmentNode(x) {
    return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isBlockNode(x) {
    return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isConditionalNode(x) {
    return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isConstantNode(x) {
    return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isFunctionAssignmentNode(x) {
    return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isFunctionNode(x) {
    return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isIndexNode(x) {
    return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isNode(x) {
    return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isObjectNode(x) {
    return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isOperatorNode(x) {
    return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isParenthesisNode(x) {
    return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isRangeNode(x) {
    return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isSymbolNode(x) {
    return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isChain(x) {
    return x && x.constructor.prototype.isChain === true || false;
  }
  function typeOf(x) {
    var t = _typeof(x);

    if (t === 'object') {
      // JavaScript types
      if (x === null) return 'null';
      if (Array.isArray(x)) return 'Array';
      if (x instanceof Date) return 'Date';
      if (x instanceof RegExp) return 'RegExp'; // math.js types

      if (isBigNumber(x)) return 'BigNumber';
      if (isComplex(x)) return 'Complex';
      if (isFraction(x)) return 'Fraction';
      if (isMatrix(x)) return 'Matrix';
      if (isUnit(x)) return 'Unit';
      if (isIndex(x)) return 'Index';
      if (isRange(x)) return 'Range';
      if (isResultSet(x)) return 'ResultSet';
      if (isNode(x)) return x.type;
      if (isChain(x)) return 'Chain';
      if (isHelp(x)) return 'Help';
      return 'Object';
    }

    if (t === 'function') return 'Function';
    return t; // can be 'string', 'number', 'boolean', ...
  }

  function _typeof$1(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }
  /**
   * Clone an object
   *
   *     clone(x)
   *
   * Can clone any primitive type, array, and object.
   * If x has a function clone, this function will be invoked to clone the object.
   *
   * @param {*} x
   * @return {*} clone
   */

  function clone(x) {
    var type = _typeof$1(x); // immutable primitive types


    if (type === 'number' || type === 'string' || type === 'boolean' || x === null || x === undefined) {
      return x;
    } // use clone function of the object when available


    if (typeof x.clone === 'function') {
      return x.clone();
    } // array


    if (Array.isArray(x)) {
      return x.map(function (value) {
        return clone(value);
      });
    }

    if (x instanceof Date) return new Date(x.valueOf());
    if (isBigNumber(x)) return x; // bignumbers are immutable

    if (x instanceof RegExp) throw new TypeError('Cannot clone ' + x); // TODO: clone a RegExp
    // object

    return mapObject(x, clone);
  }
  /**
   * Apply map to all properties of an object
   * @param {Object} object
   * @param {function} callback
   * @return {Object} Returns a copy of the object with mapped properties
   */

  function mapObject(object, callback) {
    var clone = {};

    for (var key in object) {
      if (hasOwnProperty(object, key)) {
        clone[key] = callback(object[key]);
      }
    }

    return clone;
  }
  /**
   * Extend object a with the properties of object b
   * @param {Object} a
   * @param {Object} b
   * @return {Object} a
   */

  function extend(a, b) {
    for (var prop in b) {
      if (hasOwnProperty(b, prop)) {
        a[prop] = b[prop];
      }
    }

    return a;
  }
  /**
   * Deep test equality of all fields in two pairs of arrays or objects.
   * Compares values and functions strictly (ie. 2 is not the same as '2').
   * @param {Array | Object} a
   * @param {Array | Object} b
   * @returns {boolean}
   */

  function deepStrictEqual(a, b) {
    var prop, i, len;

    if (Array.isArray(a)) {
      if (!Array.isArray(b)) {
        return false;
      }

      if (a.length !== b.length) {
        return false;
      }

      for (i = 0, len = a.length; i < len; i++) {
        if (!deepStrictEqual(a[i], b[i])) {
          return false;
        }
      }

      return true;
    } else if (typeof a === 'function') {
      return a === b;
    } else if (a instanceof Object) {
      if (Array.isArray(b) || !(b instanceof Object)) {
        return false;
      }

      for (prop in a) {
        // noinspection JSUnfilteredForInLoop
        if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
          return false;
        }
      }

      for (prop in b) {
        // noinspection JSUnfilteredForInLoop
        if (!(prop in a) || !deepStrictEqual(a[prop], b[prop])) {
          return false;
        }
      }

      return true;
    } else {
      return a === b;
    }
  }
  /**
   * Attach a lazy loading property to a constant.
   * The given function `fn` is called once when the property is first requested.
   *
   * @param {Object} object         Object where to add the property
   * @param {string} prop           Property name
   * @param {Function} valueResolver Function returning the property value. Called
   *                                without arguments.
   */

  function lazy(object, prop, valueResolver) {
    var _uninitialized = true;

    var _value;

    Object.defineProperty(object, prop, {
      get: function get() {
        if (_uninitialized) {
          _value = valueResolver();
          _uninitialized = false;
        }

        return _value;
      },
      set: function set(value) {
        _value = value;
        _uninitialized = false;
      },
      configurable: true,
      enumerable: true
    });
  }
  /**
   * A safe hasOwnProperty
   * @param {Object} object
   * @param {string} property
   */

  function hasOwnProperty(object, property) {
    return object && Object.hasOwnProperty.call(object, property);
  }
  /**
   * Shallow version of pick, creating an object composed of the picked object properties
   * but not for nested properties
   * @param {Object} object
   * @param {string[]} properties
   * @return {Object}
   */

  function pickShallow(object, properties) {
    var copy = {};

    for (var i = 0; i < properties.length; i++) {
      var key = properties[i];
      var value = object[key];

      if (value !== undefined) {
        copy[key] = value;
      }
    }

    return copy;
  }

  var MATRIX_OPTIONS = ['Matrix', 'Array']; // valid values for option matrix

  var NUMBER_OPTIONS = ['number', 'BigNumber', 'Fraction']; // valid values for option number

  function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

  var config = /* #__PURE__ */function config(options) {
    if (options) {
      throw new Error('The global config is readonly. \n' + 'Please create a mathjs instance if you want to change the default configuration. \n' + 'Example:\n' + '\n' + '  import { create, all } from \'mathjs\';\n' + '  const mathjs = create(all);\n' + '  mathjs.config({ number: \'BigNumber\' });\n');
    }

    return Object.freeze(DEFAULT_CONFIG);
  };

  _extends(config, DEFAULT_CONFIG, {
    MATRIX_OPTIONS: MATRIX_OPTIONS,
    NUMBER_OPTIONS: NUMBER_OPTIONS
  });

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var typedFunction = createCommonjsModule(function (module, exports) {

  (function (root, factory) {
    {
      // OldNode. Does not work with strict CommonJS, but
      // only CommonJS-like environments that support module.exports,
      // like OldNode.
      module.exports = factory();
    }
  }(commonjsGlobal, function () {

    function ok () {
      return true;
    }

    function notOk () {
      return false;
    }

    function undef () {
      return undefined;
    }

    /**
     * @typedef {{
     *   params: Param[],
     *   fn: function
     * }} Signature
     *
     * @typedef {{
     *   types: Type[],
     *   restParam: boolean
     * }} Param
     *
     * @typedef {{
     *   name: string,
     *   typeIndex: number,
     *   test: function,
     *   conversion?: ConversionDef,
     *   conversionIndex: number,
     * }} Type
     *
     * @typedef {{
     *   from: string,
     *   to: string,
     *   convert: function (*) : *
     * }} ConversionDef
     *
     * @typedef {{
     *   name: string,
     *   test: function(*) : boolean
     * }} TypeDef
     */

    // create a new instance of typed-function
    function create () {
      // data type tests
      var _types = [
        { name: 'number',    test: function (x) { return typeof x === 'number' } },
        { name: 'string',    test: function (x) { return typeof x === 'string' } },
        { name: 'boolean',   test: function (x) { return typeof x === 'boolean' } },
        { name: 'Function',  test: function (x) { return typeof x === 'function'} },
        { name: 'Array',     test: Array.isArray },
        { name: 'Date',      test: function (x) { return x instanceof Date } },
        { name: 'RegExp',    test: function (x) { return x instanceof RegExp } },
        { name: 'Object',    test: function (x) {
          return typeof x === 'object' && x !== null && x.constructor === Object
        }},
        { name: 'null',      test: function (x) { return x === null } },
        { name: 'undefined', test: function (x) { return x === undefined } }
      ];

      var anyType = {
        name: 'any',
        test: ok
      };

      // types which need to be ignored
      var _ignore = [];

      // type conversions
      var _conversions = [];

      // This is a temporary object, will be replaced with a typed function at the end
      var typed = {
        types: _types,
        conversions: _conversions,
        ignore: _ignore
      };

      /**
       * Find the test function for a type
       * @param {String} typeName
       * @return {TypeDef} Returns the type definition when found,
       *                    Throws a TypeError otherwise
       */
      function findTypeByName (typeName) {
        var entry = findInArray(typed.types, function (entry) {
          return entry.name === typeName;
        });

        if (entry) {
          return entry;
        }

        if (typeName === 'any') { // special baked-in case 'any'
          return anyType;
        }

        var hint = findInArray(typed.types, function (entry) {
          return entry.name.toLowerCase() === typeName.toLowerCase();
        });

        throw new TypeError('Unknown type "' + typeName + '"' +
            (hint ? ('. Did you mean "' + hint.name + '"?') : ''));
      }

      /**
       * Find the index of a type definition. Handles special case 'any'
       * @param {TypeDef} type
       * @return {number}
       */
      function findTypeIndex(type) {
        if (type === anyType) {
          return 999;
        }

        return typed.types.indexOf(type);
      }

      /**
       * Find a type that matches a value.
       * @param {*} value
       * @return {string} Returns the name of the first type for which
       *                  the type test matches the value.
       */
      function findTypeName(value) {
        var entry = findInArray(typed.types, function (entry) {
          return entry.test(value);
        });

        if (entry) {
          return entry.name;
        }

        throw new TypeError('Value has unknown type. Value: ' + value);
      }

      /**
       * Find a specific signature from a (composed) typed function, for example:
       *
       *   typed.find(fn, ['number', 'string'])
       *   typed.find(fn, 'number, string')
       *
       * Function find only only works for exact matches.
       *
       * @param {Function} fn                   A typed-function
       * @param {string | string[]} signature   Signature to be found, can be
       *                                        an array or a comma separated string.
       * @return {Function}                     Returns the matching signature, or
       *                                        throws an error when no signature
       *                                        is found.
       */
      function find (fn, signature) {
        if (!fn.signatures) {
          throw new TypeError('Function is no typed-function');
        }

        // normalize input
        var arr;
        if (typeof signature === 'string') {
          arr = signature.split(',');
          for (var i = 0; i < arr.length; i++) {
            arr[i] = arr[i].trim();
          }
        }
        else if (Array.isArray(signature)) {
          arr = signature;
        }
        else {
          throw new TypeError('String array or a comma separated string expected');
        }

        var str = arr.join(',');

        // find an exact match
        var match = fn.signatures[str];
        if (match) {
          return match;
        }

        // TODO: extend find to match non-exact signatures

        throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');
      }

      /**
       * Convert a given value to another data type.
       * @param {*} value
       * @param {string} type
       */
      function convert (value, type) {
        var from = findTypeName(value);

        // check conversion is needed
        if (type === from) {
          return value;
        }

        for (var i = 0; i < typed.conversions.length; i++) {
          var conversion = typed.conversions[i];
          if (conversion.from === from && conversion.to === type) {
            return conversion.convert(value);
          }
        }

        throw new Error('Cannot convert from ' + from + ' to ' + type);
      }
      
      /**
       * Stringify parameters in a normalized way
       * @param {Param[]} params
       * @return {string}
       */
      function stringifyParams (params) {
        return params
            .map(function (param) {
              var typeNames = param.types.map(getTypeName);

              return (param.restParam ? '...' : '') + typeNames.join('|');
            })
            .join(',');
      }

      /**
       * Parse a parameter, like "...number | boolean"
       * @param {string} param
       * @param {ConversionDef[]} conversions
       * @return {Param} param
       */
      function parseParam (param, conversions) {
        var restParam = param.indexOf('...') === 0;
        var types = (!restParam)
            ? param
            : (param.length > 3)
                ? param.slice(3)
                : 'any';

        var typeNames = types.split('|').map(trim)
            .filter(notEmpty)
            .filter(notIgnore);

        var matchingConversions = filterConversions(conversions, typeNames);

        var exactTypes = typeNames.map(function (typeName) {
          var type = findTypeByName(typeName);

          return {
            name: typeName,
            typeIndex: findTypeIndex(type),
            test: type.test,
            conversion: null,
            conversionIndex: -1
          };
        });

        var convertibleTypes = matchingConversions.map(function (conversion) {
          var type = findTypeByName(conversion.from);

          return {
            name: conversion.from,
            typeIndex: findTypeIndex(type),
            test: type.test,
            conversion: conversion,
            conversionIndex: conversions.indexOf(conversion)
          };
        });

        return {
          types: exactTypes.concat(convertibleTypes),
          restParam: restParam
        };
      }

      /**
       * Parse a signature with comma separated parameters,
       * like "number | boolean, ...string"
       * @param {string} signature
       * @param {function} fn
       * @param {ConversionDef[]} conversions
       * @return {Signature | null} signature
       */
      function parseSignature (signature, fn, conversions) {
        var params = [];

        if (signature.trim() !== '') {
          params = signature
              .split(',')
              .map(trim)
              .map(function (param, index, array) {
                var parsedParam = parseParam(param, conversions);

                if (parsedParam.restParam && (index !== array.length - 1)) {
                  throw new SyntaxError('Unexpected rest parameter "' + param + '": ' +
                      'only allowed for the last parameter');
                }

                return parsedParam;
            });
        }

        if (params.some(isInvalidParam)) {
          // invalid signature: at least one parameter has no types
          // (they may have been filtered)
          return null;
        }

        return {
          params: params,
          fn: fn
        };
      }

      /**
       * Test whether a set of params contains a restParam
       * @param {Param[]} params
       * @return {boolean} Returns true when the last parameter is a restParam
       */
      function hasRestParam(params) {
        var param = last(params);
        return param ? param.restParam : false;
      }

      /**
       * Test whether a parameter contains conversions
       * @param {Param} param
       * @return {boolean} Returns true when at least one of the parameters
       *                   contains a conversion.
       */
      function hasConversions(param) {
        return param.types.some(function (type) {
          return type.conversion != null;
        });
      }

      /**
       * Create a type test for a single parameter, which can have one or multiple
       * types.
       * @param {Param} param
       * @return {function(x: *) : boolean} Returns a test function
       */
      function compileTest(param) {
        if (!param || param.types.length === 0) {
          // nothing to do
          return ok;
        }
        else if (param.types.length === 1) {
          return findTypeByName(param.types[0].name).test;
        }
        else if (param.types.length === 2) {
          var test0 = findTypeByName(param.types[0].name).test;
          var test1 = findTypeByName(param.types[1].name).test;
          return function or(x) {
            return test0(x) || test1(x);
          }
        }
        else { // param.types.length > 2
          var tests = param.types.map(function (type) {
            return findTypeByName(type.name).test;
          });
          return function or(x) {
            for (var i = 0; i < tests.length; i++) {
              if (tests[i](x)) {
                return true;
              }
            }
            return false;
          }
        }
      }

      /**
       * Create a test for all parameters of a signature
       * @param {Param[]} params
       * @return {function(args: Array<*>) : boolean}
       */
      function compileTests(params) {
        var tests, test0, test1;

        if (hasRestParam(params)) {
          // variable arguments like '...number'
          tests = initial(params).map(compileTest);
          var varIndex = tests.length;
          var lastTest = compileTest(last(params));
          var testRestParam = function (args) {
            for (var i = varIndex; i < args.length; i++) {
              if (!lastTest(args[i])) {
                return false;
              }
            }
            return true;
          };

          return function testArgs(args) {
            for (var i = 0; i < tests.length; i++) {
              if (!tests[i](args[i])) {
                return false;
              }
            }
            return testRestParam(args) && (args.length >= varIndex + 1);
          };
        }
        else {
          // no variable arguments
          if (params.length === 0) {
            return function testArgs(args) {
              return args.length === 0;
            };
          }
          else if (params.length === 1) {
            test0 = compileTest(params[0]);
            return function testArgs(args) {
              return test0(args[0]) && args.length === 1;
            };
          }
          else if (params.length === 2) {
            test0 = compileTest(params[0]);
            test1 = compileTest(params[1]);
            return function testArgs(args) {
              return test0(args[0]) && test1(args[1]) && args.length === 2;
            };
          }
          else { // arguments.length > 2
            tests = params.map(compileTest);
            return function testArgs(args) {
              for (var i = 0; i < tests.length; i++) {
                if (!tests[i](args[i])) {
                  return false;
                }
              }
              return args.length === tests.length;
            };
          }
        }
      }

      /**
       * Find the parameter at a specific index of a signature.
       * Handles rest parameters.
       * @param {Signature} signature
       * @param {number} index
       * @return {Param | null} Returns the matching parameter when found,
       *                        null otherwise.
       */
      function getParamAtIndex(signature, index) {
        return index < signature.params.length
            ? signature.params[index]
            : hasRestParam(signature.params)
                ? last(signature.params)
                : null
      }

      /**
       * Get all type names of a parameter
       * @param {Signature} signature
       * @param {number} index
       * @param {boolean} excludeConversions
       * @return {string[]} Returns an array with type names
       */
      function getExpectedTypeNames (signature, index, excludeConversions) {
        var param = getParamAtIndex(signature, index);
        var types = param
            ? excludeConversions
                    ? param.types.filter(isExactType)
                    : param.types
            : [];

        return types.map(getTypeName);
      }

      /**
       * Returns the name of a type
       * @param {Type} type
       * @return {string} Returns the type name
       */
      function getTypeName(type) {
        return type.name;
      }

      /**
       * Test whether a type is an exact type or conversion
       * @param {Type} type
       * @return {boolean} Returns true when
       */
      function isExactType(type) {
        return type.conversion === null || type.conversion === undefined;
      }

      /**
       * Helper function for creating error messages: create an array with
       * all available types on a specific argument index.
       * @param {Signature[]} signatures
       * @param {number} index
       * @return {string[]} Returns an array with available types
       */
      function mergeExpectedParams(signatures, index) {
        var typeNames = uniq(flatMap(signatures, function (signature) {
          return getExpectedTypeNames(signature, index, false);
        }));

        return (typeNames.indexOf('any') !== -1) ? ['any'] : typeNames;
      }

      /**
       * Create
       * @param {string} name             The name of the function
       * @param {array.<*>} args          The actual arguments passed to the function
       * @param {Signature[]} signatures  A list with available signatures
       * @return {TypeError} Returns a type error with additional data
       *                     attached to it in the property `data`
       */
      function createError(name, args, signatures) {
        var err, expected;
        var _name = name || 'unnamed';

        // test for wrong type at some index
        var matchingSignatures = signatures;
        var index;
        for (index = 0; index < args.length; index++) {
          var nextMatchingDefs = matchingSignatures.filter(function (signature) {
            var test = compileTest(getParamAtIndex(signature, index));
            return (index < signature.params.length || hasRestParam(signature.params)) &&
                test(args[index]);
          });

          if (nextMatchingDefs.length === 0) {
            // no matching signatures anymore, throw error "wrong type"
            expected = mergeExpectedParams(matchingSignatures, index);
            if (expected.length > 0) {
              var actualType = findTypeName(args[index]);

              err = new TypeError('Unexpected type of argument in function ' + _name +
                  ' (expected: ' + expected.join(' or ') +
                  ', actual: ' + actualType + ', index: ' + index + ')');
              err.data = {
                category: 'wrongType',
                fn: _name,
                index: index,
                actual: actualType,
                expected: expected
              };
              return err;
            }
          }
          else {
            matchingSignatures = nextMatchingDefs;
          }
        }

        // test for too few arguments
        var lengths = matchingSignatures.map(function (signature) {
          return hasRestParam(signature.params) ? Infinity : signature.params.length;
        });
        if (args.length < Math.min.apply(null, lengths)) {
          expected = mergeExpectedParams(matchingSignatures, index);
          err = new TypeError('Too few arguments in function ' + _name +
              ' (expected: ' + expected.join(' or ') +
              ', index: ' + args.length + ')');
          err.data = {
            category: 'tooFewArgs',
            fn: _name,
            index: args.length,
            expected: expected
          };
          return err;
        }

        // test for too many arguments
        var maxLength = Math.max.apply(null, lengths);
        if (args.length > maxLength) {
          err = new TypeError('Too many arguments in function ' + _name +
              ' (expected: ' + maxLength + ', actual: ' + args.length + ')');
          err.data = {
            category: 'tooManyArgs',
            fn: _name,
            index: args.length,
            expectedLength: maxLength
          };
          return err;
        }

        err = new TypeError('Arguments of type "' + args.join(', ') +
            '" do not match any of the defined signatures of function ' + _name + '.');
        err.data = {
          category: 'mismatch',
          actual: args.map(findTypeName)
        };
        return err;
      }

      /**
       * Find the lowest index of all exact types of a parameter (no conversions)
       * @param {Param} param
       * @return {number} Returns the index of the lowest type in typed.types
       */
      function getLowestTypeIndex (param) {
        var min = 999;

        for (var i = 0; i < param.types.length; i++) {
          if (isExactType(param.types[i])) {
            min = Math.min(min, param.types[i].typeIndex);
          }
        }

        return min;
      }

      /**
       * Find the lowest index of the conversion of all types of the parameter
       * having a conversion
       * @param {Param} param
       * @return {number} Returns the lowest index of the conversions of this type
       */
      function getLowestConversionIndex (param) {
        var min = 999;

        for (var i = 0; i < param.types.length; i++) {
          if (!isExactType(param.types[i])) {
            min = Math.min(min, param.types[i].conversionIndex);
          }
        }

        return min;
      }

      /**
       * Compare two params
       * @param {Param} param1
       * @param {Param} param2
       * @return {number} returns a negative number when param1 must get a lower
       *                  index than param2, a positive number when the opposite,
       *                  or zero when both are equal
       */
      function compareParams (param1, param2) {
        var c;

        // compare having a rest parameter or not
        c = param1.restParam - param2.restParam;
        if (c !== 0) {
          return c;
        }

        // compare having conversions or not
        c = hasConversions(param1) - hasConversions(param2);
        if (c !== 0) {
          return c;
        }

        // compare the index of the types
        c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
        if (c !== 0) {
          return c;
        }

        // compare the index of any conversion
        return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
      }

      /**
       * Compare two signatures
       * @param {Signature} signature1
       * @param {Signature} signature2
       * @return {number} returns a negative number when param1 must get a lower
       *                  index than param2, a positive number when the opposite,
       *                  or zero when both are equal
       */
      function compareSignatures (signature1, signature2) {
        var len = Math.min(signature1.params.length, signature2.params.length);
        var i;
        var c;

        // compare whether the params have conversions at all or not
        c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions);
        if (c !== 0) {
          return c;
        }

        // next compare whether the params have conversions one by one
        for (i = 0; i < len; i++) {
          c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);
          if (c !== 0) {
            return c;
          }
        }

        // compare the types of the params one by one
        for (i = 0; i < len; i++) {
          c = compareParams(signature1.params[i], signature2.params[i]);
          if (c !== 0) {
            return c;
          }
        }

        // compare the number of params
        return signature1.params.length - signature2.params.length;
      }

      /**
       * Get params containing all types that can be converted to the defined types.
       *
       * @param {ConversionDef[]} conversions
       * @param {string[]} typeNames
       * @return {ConversionDef[]} Returns the conversions that are available
       *                        for every type (if any)
       */
      function filterConversions(conversions, typeNames) {
        var matches = {};

        conversions.forEach(function (conversion) {
          if (typeNames.indexOf(conversion.from) === -1 &&
              typeNames.indexOf(conversion.to) !== -1 &&
              !matches[conversion.from]) {
            matches[conversion.from] = conversion;
          }
        });

        return Object.keys(matches).map(function (from) {
          return matches[from];
        });
      }

      /**
       * Preprocess arguments before calling the original function:
       * - if needed convert the parameters
       * - in case of rest parameters, move the rest parameters into an Array
       * @param {Param[]} params
       * @param {function} fn
       * @return {function} Returns a wrapped function
       */
      function compileArgsPreprocessing(params, fn) {
        var fnConvert = fn;

        // TODO: can we make this wrapper function smarter/simpler?

        if (params.some(hasConversions)) {
          var restParam = hasRestParam(params);
          var compiledConversions = params.map(compileArgConversion);

          fnConvert = function convertArgs() {
            var args = [];
            var last = restParam ? arguments.length - 1 : arguments.length;
            for (var i = 0; i < last; i++) {
              args[i] = compiledConversions[i](arguments[i]);
            }
            if (restParam) {
              args[last] = arguments[last].map(compiledConversions[last]);
            }

            return fn.apply(this, args);
          };
        }

        var fnPreprocess = fnConvert;
        if (hasRestParam(params)) {
          var offset = params.length - 1;

          fnPreprocess = function preprocessRestParams () {
            return fnConvert.apply(this,
                slice(arguments, 0, offset).concat([slice(arguments, offset)]));
          };
        }

        return fnPreprocess;
      }

      /**
       * Compile conversion for a parameter to the right type
       * @param {Param} param
       * @return {function} Returns the wrapped function that will convert arguments
       *
       */
      function compileArgConversion(param) {
        var test0, test1, conversion0, conversion1;
        var tests = [];
        var conversions = [];

        param.types.forEach(function (type) {
          if (type.conversion) {
            tests.push(findTypeByName(type.conversion.from).test);
            conversions.push(type.conversion.convert);
          }
        });

        // create optimized conversion functions depending on the number of conversions
        switch (conversions.length) {
          case 0:
            return function convertArg(arg) {
              return arg;
            }

          case 1:
            test0 = tests[0];
            conversion0 = conversions[0];
            return function convertArg(arg) {
              if (test0(arg)) {
                return conversion0(arg)
              }
              return arg;
            }

          case 2:
            test0 = tests[0];
            test1 = tests[1];
            conversion0 = conversions[0];
            conversion1 = conversions[1];
            return function convertArg(arg) {
              if (test0(arg)) {
                return conversion0(arg)
              }
              if (test1(arg)) {
                return conversion1(arg)
              }
              return arg;
            }

          default:
            return function convertArg(arg) {
              for (var i = 0; i < conversions.length; i++) {
                if (tests[i](arg)) {
                  return conversions[i](arg);
                }
              }
              return arg;
            }
        }
      }

      /**
       * Convert an array with signatures into a map with signatures,
       * where signatures with union types are split into separate signatures
       *
       * Throws an error when there are conflicting types
       *
       * @param {Signature[]} signatures
       * @return {Object.<string, function>}  Returns a map with signatures
       *                                      as key and the original function
       *                                      of this signature as value.
       */
      function createSignaturesMap(signatures) {
        var signaturesMap = {};
        signatures.forEach(function (signature) {
          if (!signature.params.some(hasConversions)) {
            splitParams(signature.params, true).forEach(function (params) {
              signaturesMap[stringifyParams(params)] = signature.fn;
            });
          }
        });

        return signaturesMap;
      }

      /**
       * Split params with union types in to separate params.
       *
       * For example:
       *
       *     splitParams([['Array', 'Object'], ['string', 'RegExp'])
       *     // returns:
       *     // [
       *     //   ['Array', 'string'],
       *     //   ['Array', 'RegExp'],
       *     //   ['Object', 'string'],
       *     //   ['Object', 'RegExp']
       *     // ]
       *
       * @param {Param[]} params
       * @param {boolean} ignoreConversionTypes
       * @return {Param[]}
       */
      function splitParams(params, ignoreConversionTypes) {
        function _splitParams(params, index, types) {
          if (index < params.length) {
            var param = params[index];
            var filteredTypes = ignoreConversionTypes
                ? param.types.filter(isExactType)
                : param.types;
            var typeGroups;

            if (param.restParam) {
              // split the types of a rest parameter in two:
              // one with only exact types, and one with exact types and conversions
              var exactTypes = filteredTypes.filter(isExactType);
              typeGroups = exactTypes.length < filteredTypes.length
                  ? [exactTypes, filteredTypes]
                  : [filteredTypes];

            }
            else {
              // split all the types of a regular parameter into one type per group
              typeGroups = filteredTypes.map(function (type) {
                return [type]
              });
            }

            // recurse over the groups with types
            return flatMap(typeGroups, function (typeGroup) {
              return _splitParams(params, index + 1, types.concat([typeGroup]));
            });

          }
          else {
            // we've reached the end of the parameters. Now build a new Param
            var splittedParams = types.map(function (type, typeIndex) {
              return {
                types: type,
                restParam: (typeIndex === params.length - 1) && hasRestParam(params)
              }
            });

            return [splittedParams];
          }
        }

        return _splitParams(params, 0, []);
      }

      /**
       * Test whether two signatures have a conflicting signature
       * @param {Signature} signature1
       * @param {Signature} signature2
       * @return {boolean} Returns true when the signatures conflict, false otherwise.
       */
      function hasConflictingParams(signature1, signature2) {
        var ii = Math.max(signature1.params.length, signature2.params.length);

        for (var i = 0; i < ii; i++) {
          var typesNames1 = getExpectedTypeNames(signature1, i, true);
          var typesNames2 = getExpectedTypeNames(signature2, i, true);

          if (!hasOverlap(typesNames1, typesNames2)) {
            return false;
          }
        }

        var len1 = signature1.params.length;
        var len2 = signature2.params.length;
        var restParam1 = hasRestParam(signature1.params);
        var restParam2 = hasRestParam(signature2.params);

        return restParam1
            ? restParam2 ? (len1 === len2) : (len2 >= len1)
            : restParam2 ? (len1 >= len2)  : (len1 === len2)
      }

      /**
       * Create a typed function
       * @param {String} name               The name for the typed function
       * @param {Object.<string, function>} signaturesMap
       *                                    An object with one or
       *                                    multiple signatures as key, and the
       *                                    function corresponding to the
       *                                    signature as value.
       * @return {function}  Returns the created typed function.
       */
      function createTypedFunction(name, signaturesMap) {
        if (Object.keys(signaturesMap).length === 0) {
          throw new SyntaxError('No signatures provided');
        }

        // parse the signatures, and check for conflicts
        var parsedSignatures = [];
        Object.keys(signaturesMap)
            .map(function (signature) {
              return parseSignature(signature, signaturesMap[signature], typed.conversions);
            })
            .filter(notNull)
            .forEach(function (parsedSignature) {
              // check whether this parameter conflicts with already parsed signatures
              var conflictingSignature = findInArray(parsedSignatures, function (s) {
                return hasConflictingParams(s, parsedSignature)
              });
              if (conflictingSignature) {
                throw new TypeError('Conflicting signatures "' +
                    stringifyParams(conflictingSignature.params) + '" and "' +
                    stringifyParams(parsedSignature.params) + '".');
              }

              parsedSignatures.push(parsedSignature);
            });

        // split and filter the types of the signatures, and then order them
        var signatures = flatMap(parsedSignatures, function (parsedSignature) {
          var params = parsedSignature ? splitParams(parsedSignature.params, false) : [];

          return params.map(function (params) {
            return {
              params: params,
              fn: parsedSignature.fn
            };
          });
        }).filter(notNull);

        signatures.sort(compareSignatures);

        // we create a highly optimized checks for the first couple of signatures with max 2 arguments
        var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
        var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
        var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
        var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
        var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
        var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
        var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;

        // compile the tests
        var tests = signatures.map(function (signature) {
          return compileTests(signature.params);
        });

        var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
        var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
        var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
        var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
        var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
        var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;

        var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
        var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
        var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
        var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
        var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
        var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;

        // compile the functions
        var fns = signatures.map(function(signature) {
          return compileArgsPreprocessing(signature.params, signature.fn);
        });

        var fn0 = ok0 ? fns[0] : undef;
        var fn1 = ok1 ? fns[1] : undef;
        var fn2 = ok2 ? fns[2] : undef;
        var fn3 = ok3 ? fns[3] : undef;
        var fn4 = ok4 ? fns[4] : undef;
        var fn5 = ok5 ? fns[5] : undef;

        var len0 = ok0 ? signatures[0].params.length : -1;
        var len1 = ok1 ? signatures[1].params.length : -1;
        var len2 = ok2 ? signatures[2].params.length : -1;
        var len3 = ok3 ? signatures[3].params.length : -1;
        var len4 = ok4 ? signatures[4].params.length : -1;
        var len5 = ok5 ? signatures[5].params.length : -1;

        // simple and generic, but also slow
        var iStart = allOk ? 6 : 0;
        var iEnd = signatures.length;
        var generic = function generic() {

          for (var i = iStart; i < iEnd; i++) {
            if (tests[i](arguments)) {
              return fns[i].apply(this, arguments);
            }
          }

          throw createError(name, arguments, signatures);
        };

        // create the typed function
        // fast, specialized version. Falls back to the slower, generic one if needed
        var fn = function fn(arg0, arg1) {

          if (arguments.length === len0 && test00(arg0) && test01(arg1)) { return fn0.apply(fn, arguments); }
          if (arguments.length === len1 && test10(arg0) && test11(arg1)) { return fn1.apply(fn, arguments); }
          if (arguments.length === len2 && test20(arg0) && test21(arg1)) { return fn2.apply(fn, arguments); }
          if (arguments.length === len3 && test30(arg0) && test31(arg1)) { return fn3.apply(fn, arguments); }
          if (arguments.length === len4 && test40(arg0) && test41(arg1)) { return fn4.apply(fn, arguments); }
          if (arguments.length === len5 && test50(arg0) && test51(arg1)) { return fn5.apply(fn, arguments); }

          return generic.apply(fn, arguments);
        };

        // attach name the typed function
        try {
          Object.defineProperty(fn, 'name', {value: name});
        }
        catch (err) {
          // old browsers do not support Object.defineProperty and some don't support setting the name property
          // the function name is not essential for the functioning, it's mostly useful for debugging,
          // so it's fine to have unnamed functions.
        }

        // attach signatures to the function
        fn.signatures = createSignaturesMap(signatures);

        return fn;
      }

      /**
       * Test whether a type should be NOT be ignored
       * @param {string} typeName
       * @return {boolean}
       */
      function notIgnore(typeName) {
        return typed.ignore.indexOf(typeName) === -1;
      }

      /**
       * trim a string
       * @param {string} str
       * @return {string}
       */
      function trim(str) {
        return str.trim();
      }

      /**
       * Test whether a string is not empty
       * @param {string} str
       * @return {boolean}
       */
      function notEmpty(str) {
        return !!str;
      }

      /**
       * test whether a value is not strict equal to null
       * @param {*} value
       * @return {boolean}
       */
      function notNull(value) {
        return value !== null;
      }

      /**
       * Test whether a parameter has no types defined
       * @param {Param} param
       * @return {boolean}
       */
      function isInvalidParam (param) {
        return param.types.length === 0;
      }

      /**
       * Return all but the last items of an array
       * @param {Array} arr
       * @return {Array}
       */
      function initial(arr) {
        return arr.slice(0, arr.length - 1);
      }

      /**
       * return the last item of an array
       * @param {Array} arr
       * @return {*}
       */
      function last(arr) {
        return arr[arr.length - 1];
      }

      /**
       * Slice an array or function Arguments
       * @param {Array | Arguments | IArguments} arr
       * @param {number} start
       * @param {number} [end]
       * @return {Array}
       */
      function slice(arr, start, end) {
        return Array.prototype.slice.call(arr, start, end);
      }

      /**
       * Test whether an array contains some item
       * @param {Array} array
       * @param {*} item
       * @return {boolean} Returns true if array contains item, false if not.
       */
      function contains(array, item) {
        return array.indexOf(item) !== -1;
      }

      /**
       * Test whether two arrays have overlapping items
       * @param {Array} array1
       * @param {Array} array2
       * @return {boolean} Returns true when at least one item exists in both arrays
       */
      function hasOverlap(array1, array2) {
        for (var i = 0; i < array1.length; i++) {
          if (contains(array2, array1[i])) {
            return true;
          }
        }

        return false;
      }

      /**
       * Return the first item from an array for which test(arr[i]) returns true
       * @param {Array} arr
       * @param {function} test
       * @return {* | undefined} Returns the first matching item
       *                         or undefined when there is no match
       */
      function findInArray(arr, test) {
        for (var i = 0; i < arr.length; i++) {
          if (test(arr[i])) {
            return arr[i];
          }
        }
        return undefined;
      }

      /**
       * Filter unique items of an array with strings
       * @param {string[]} arr
       * @return {string[]}
       */
      function uniq(arr) {
        var entries = {};
        for (var i = 0; i < arr.length; i++) {
          entries[arr[i]] = true;
        }
        return Object.keys(entries);
      }

      /**
       * Flat map the result invoking a callback for every item in an array.
       * https://gist.github.com/samgiles/762ee337dff48623e729
       * @param {Array} arr
       * @param {function} callback
       * @return {Array}
       */
      function flatMap(arr, callback) {
        return Array.prototype.concat.apply([], arr.map(callback));
      }

      /**
       * Retrieve the function name from a set of typed functions,
       * and check whether the name of all functions match (if given)
       * @param {function[]} fns
       */
      function getName (fns) {
        var name = '';

        for (var i = 0; i < fns.length; i++) {
          var fn = fns[i];

          // check whether the names are the same when defined
          if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {
            if (name === '') {
              name = fn.name;
            }
            else if (name !== fn.name) {
              var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');
              err.data = {
                actual: fn.name,
                expected: name
              };
              throw err;
            }
          }
        }

        return name;
      }

      // extract and merge all signatures of a list with typed functions
      function extractSignatures(fns) {
        var err;
        var signaturesMap = {};

        function validateUnique(_signature, _fn) {
          if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {
            err = new Error('Signature "' + _signature + '" is defined twice');
            err.data = {signature: _signature};
            throw err;
            // else: both signatures point to the same function, that's fine
          }
        }

        for (var i = 0; i < fns.length; i++) {
          var fn = fns[i];

          // test whether this is a typed-function
          if (typeof fn.signatures === 'object') {
            // merge the signatures
            for (var signature in fn.signatures) {
              if (fn.signatures.hasOwnProperty(signature)) {
                validateUnique(signature, fn.signatures[signature]);
                signaturesMap[signature] = fn.signatures[signature];
              }
            }
          }
          else if (typeof fn.signature === 'string') {
            validateUnique(fn.signature, fn);
            signaturesMap[fn.signature] = fn;
          }
          else {
            err = new TypeError('Function is no typed-function (index: ' + i + ')');
            err.data = {index: i};
            throw err;
          }
        }

        return signaturesMap;
      }

      typed = createTypedFunction('typed', {
        'string, Object': createTypedFunction,
        'Object': function (signaturesMap) {
          // find existing name
          var fns = [];
          for (var signature in signaturesMap) {
            if (signaturesMap.hasOwnProperty(signature)) {
              fns.push(signaturesMap[signature]);
            }
          }
          var name = getName(fns);
          return createTypedFunction(name, signaturesMap);
        },
        '...Function': function (fns) {
          return createTypedFunction(getName(fns), extractSignatures(fns));
        },
        'string, ...Function': function (name, fns) {
          return createTypedFunction(name, extractSignatures(fns));
        }
      });

      typed.create = create;
      typed.types = _types;
      typed.conversions = _conversions;
      typed.ignore = _ignore;
      typed.convert = convert;
      typed.find = find;

      /**
       * add a type
       * @param {{name: string, test: function}} type
       * @param {boolean} [beforeObjectTest=true]
       *                          If true, the new test will be inserted before
       *                          the test with name 'Object' (if any), since
       *                          tests for Object match Array and classes too.
       */
      typed.addType = function (type, beforeObjectTest) {
        if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {
          throw new TypeError('Object with properties {name: string, test: function} expected');
        }

        if (beforeObjectTest !== false) {
          for (var i = 0; i < typed.types.length; i++) {
            if (typed.types[i].name === 'Object') {
              typed.types.splice(i, 0, type);
              return
            }
          }
        }

        typed.types.push(type);
      };

      // add a conversion
      typed.addConversion = function (conversion) {
        if (!conversion
            || typeof conversion.from !== 'string'
            || typeof conversion.to !== 'string'
            || typeof conversion.convert !== 'function') {
          throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');
        }

        typed.conversions.push(conversion);
      };

      return typed;
    }

    return create();
  }));
  });

  /**
   * @typedef {{sign: '+' | '-' | '', coefficients: number[], exponent: number}} SplitValue
   */

  /**
   * Check if a number is integer
   * @param {number | boolean} value
   * @return {boolean} isInteger
   */

  function isInteger(value) {
    if (typeof value === 'boolean') {
      return true;
    }

    return isFinite(value) ? value === Math.round(value) : false; // Note: we use ==, not ===, as we can have Booleans as well
  }
  /**
   * Calculate the sign of a number
   * @param {number} x
   * @returns {number}
   */

  var sign = /* #__PURE__ */Math.sign || function (x) {
    if (x > 0) {
      return 1;
    } else if (x < 0) {
      return -1;
    } else {
      return 0;
    }
  };
  /**
   * Calculate the base-2 logarithm of a number
   * @param {number} x
   * @returns {number}
   */

  var log2 = /* #__PURE__ */Math.log2 || function log2(x) {
    return Math.log(x) / Math.LN2;
  };
  /**
   * Calculate the base-10 logarithm of a number
   * @param {number} x
   * @returns {number}
   */

  var log10 = /* #__PURE__ */Math.log10 || function log10(x) {
    return Math.log(x) / Math.LN10;
  };
  /**
   * Calculate the natural logarithm of a number + 1
   * @param {number} x
   * @returns {number}
   */

  var log1p = /* #__PURE__ */Math.log1p || function (x) {
    return Math.log(x + 1);
  };
  /**
   * Calculate cubic root for a number
   *
   * Code from es6-shim.js:
   *   https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1564-L1577
   *
   * @param {number} x
   * @returns {number} Returns the cubic root of x
   */

  var cbrt = /* #__PURE__ */Math.cbrt || function cbrt(x) {
    if (x === 0) {
      return x;
    }

    var negate = x < 0;
    var result;

    if (negate) {
      x = -x;
    }

    if (isFinite(x)) {
      result = Math.exp(Math.log(x) / 3); // from https://en.wikipedia.org/wiki/Cube_root#Numerical_methods

      result = (x / (result * result) + 2 * result) / 3;
    } else {
      result = x;
    }

    return negate ? -result : result;
  };
  /**
   * Calculates exponentiation minus 1
   * @param {number} x
   * @return {number} res
   */

  var expm1 = /* #__PURE__ */Math.expm1 || function expm1(x) {
    return x >= 2e-4 || x <= -2e-4 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;
  };
  /**
   * Convert a number to a formatted string representation.
   *
   * Syntax:
   *
   *    format(value)
   *    format(value, options)
   *    format(value, precision)
   *    format(value, fn)
   *
   * Where:
   *
   *    {number} value   The value to be formatted
   *    {Object} options An object with formatting options. Available options:
   *                     {string} notation
   *                         Number notation. Choose from:
   *                         'fixed'          Always use regular number notation.
   *                                          For example '123.40' and '14000000'
   *                         'exponential'    Always use exponential notation.
   *                                          For example '1.234e+2' and '1.4e+7'
   *                         'engineering'    Always use engineering notation.
   *                                          For example '123.4e+0' and '14.0e+6'
   *                         'auto' (default) Regular number notation for numbers
   *                                          having an absolute value between
   *                                          `lowerExp` and `upperExp` bounds, and
   *                                          uses exponential notation elsewhere.
   *                                          Lower bound is included, upper bound
   *                                          is excluded.
   *                                          For example '123.4' and '1.4e7'.
   *                     {number} precision   A number between 0 and 16 to round
   *                                          the digits of the number.
   *                                          In case of notations 'exponential',
   *                                          'engineering', and 'auto',
   *                                          `precision` defines the total
   *                                          number of significant digits returned.
   *                                          In case of notation 'fixed',
   *                                          `precision` defines the number of
   *                                          significant digits after the decimal
   *                                          point.
   *                                          `precision` is undefined by default,
   *                                          not rounding any digits.
   *                     {number} lowerExp    Exponent determining the lower boundary
   *                                          for formatting a value with an exponent
   *                                          when `notation='auto`.
   *                                          Default value is `-3`.
   *                     {number} upperExp    Exponent determining the upper boundary
   *                                          for formatting a value with an exponent
   *                                          when `notation='auto`.
   *                                          Default value is `5`.
   *    {Function} fn    A custom formatting function. Can be used to override the
   *                     built-in notations. Function `fn` is called with `value` as
   *                     parameter and must return a string. Is useful for example to
   *                     format all values inside a matrix in a particular way.
   *
   * Examples:
   *
   *    format(6.4)                                        // '6.4'
   *    format(1240000)                                    // '1.24e6'
   *    format(1/3)                                        // '0.3333333333333333'
   *    format(1/3, 3)                                     // '0.333'
   *    format(21385, 2)                                   // '21000'
   *    format(12.071, {notation: 'fixed'})                // '12'
   *    format(2.3,    {notation: 'fixed', precision: 2})  // '2.30'
   *    format(52.8,   {notation: 'exponential'})          // '5.28e+1'
   *    format(12345678, {notation: 'engineering'})        // '12.345678e+6'
   *
   * @param {number} value
   * @param {Object | Function | number} [options]
   * @return {string} str The formatted value
   */

  function format(value, options) {
    if (typeof options === 'function') {
      // handle format(value, fn)
      return options(value);
    } // handle special cases


    if (value === Infinity) {
      return 'Infinity';
    } else if (value === -Infinity) {
      return '-Infinity';
    } else if (isNaN(value)) {
      return 'NaN';
    } // default values for options


    var notation = 'auto';
    var precision;

    if (options) {
      // determine notation from options
      if (options.notation) {
        notation = options.notation;
      } // determine precision from options


      if (isNumber(options)) {
        precision = options;
      } else if (isNumber(options.precision)) {
        precision = options.precision;
      }
    } // handle the various notations


    switch (notation) {
      case 'fixed':
        return toFixed(value, precision);

      case 'exponential':
        return toExponential(value, precision);

      case 'engineering':
        return toEngineering(value, precision);

      case 'auto':
        // remove trailing zeros after the decimal point
        return toPrecision(value, precision, options && options).replace(/((\.\d*?)(0+))($|e)/, function () {
          var digits = arguments[2];
          var e = arguments[4];
          return digits !== '.' ? digits + e : e;
        });

      default:
        throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", or "fixed".');
    }
  }
  /**
   * Split a number into sign, coefficients, and exponent
   * @param {number | string} value
   * @return {SplitValue}
   *              Returns an object containing sign, coefficients, and exponent
   */

  function splitNumber(value) {
    // parse the input value
    var match = String(value).toLowerCase().match(/^0*?(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);

    if (!match) {
      throw new SyntaxError('Invalid number ' + value);
    }

    var sign = match[1];
    var digits = match[2];
    var exponent = parseFloat(match[4] || '0');
    var dot = digits.indexOf('.');
    exponent += dot !== -1 ? dot - 1 : digits.length - 1;
    var coefficients = digits.replace('.', '') // remove the dot (must be removed before removing leading zeros)
    .replace(/^0*/, function (zeros) {
      // remove leading zeros, add their count to the exponent
      exponent -= zeros.length;
      return '';
    }).replace(/0*$/, '') // remove trailing zeros
    .split('').map(function (d) {
      return parseInt(d);
    });

    if (coefficients.length === 0) {
      coefficients.push(0);
      exponent++;
    }

    return {
      sign: sign,
      coefficients: coefficients,
      exponent: exponent
    };
  }
  /**
   * Format a number in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'
   * @param {number | string} value
   * @param {number} [precision]        Optional number of significant figures to return.
   */

  function toEngineering(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }

    var split = splitNumber(value);
    var rounded = roundDigits(split, precision);
    var e = rounded.exponent;
    var c = rounded.coefficients; // find nearest lower multiple of 3 for exponent

    var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;

    if (isNumber(precision)) {
      // add zeroes to give correct sig figs
      while (precision > c.length || e - newExp + 1 > c.length) {
        c.push(0);
      }
    } else {
      // concatenate coefficients with necessary zeros
      // add zeros if necessary (for example: 1e+8 -> 100e+6)
      var missingZeros = Math.abs(e - newExp) - (c.length - 1);

      for (var i = 0; i < missingZeros; i++) {
        c.push(0);
      }
    } // find difference in exponents


    var expDiff = Math.abs(e - newExp);
    var decimalIdx = 1; // push decimal index over by expDiff times

    while (expDiff > 0) {
      decimalIdx++;
      expDiff--;
    } // if all coefficient values are zero after the decimal point and precision is unset, don't add a decimal value.
    // otherwise concat with the rest of the coefficients


    var decimals = c.slice(decimalIdx).join('');
    var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? '.' + decimals : '';
    var str = c.slice(0, decimalIdx).join('') + decimalVal + 'e' + (e >= 0 ? '+' : '') + newExp.toString();
    return rounded.sign + str;
  }
  /**
   * Format a number with fixed notation.
   * @param {number | string} value
   * @param {number} [precision=undefined]  Optional number of decimals after the
   *                                        decimal point. null by default.
   */

  function toFixed(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }

    var splitValue = splitNumber(value);
    var rounded = typeof precision === 'number' ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
    var c = rounded.coefficients;
    var p = rounded.exponent + 1; // exponent may have changed
    // append zeros if needed

    var pp = p + (precision || 0);

    if (c.length < pp) {
      c = c.concat(zeros(pp - c.length));
    } // prepend zeros if needed


    if (p < 0) {
      c = zeros(-p + 1).concat(c);
      p = 1;
    } // insert a dot if needed


    if (p < c.length) {
      c.splice(p, 0, p === 0 ? '0.' : '.');
    }

    return rounded.sign + c.join('');
  }
  /**
   * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
   * @param {number | string} value
   * @param {number} [precision]  Number of digits in formatted output.
   *                              If not provided, the maximum available digits
   *                              is used.
   */

  function toExponential(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    } // round if needed, else create a clone


    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    var c = rounded.coefficients;
    var e = rounded.exponent; // append zeros if needed

    if (c.length < precision) {
      c = c.concat(zeros(precision - c.length));
    } // format as `C.CCCe+EEE` or `C.CCCe-EEE`


    var first = c.shift();
    return rounded.sign + first + (c.length > 0 ? '.' + c.join('') : '') + 'e' + (e >= 0 ? '+' : '') + e;
  }
  /**
   * Format a number with a certain precision
   * @param {number | string} value
   * @param {number} [precision=undefined] Optional number of digits.
   * @param {{lowerExp: number | undefined, upperExp: number | undefined}} [options]
   *                                       By default:
   *                                         lowerExp = -3 (incl)
   *                                         upper = +5 (excl)
   * @return {string}
   */

  function toPrecision(value, precision, options) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    } // determine lower and upper bound for exponential notation.


    var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;
    var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5;
    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;

    if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
      // exponential notation
      return toExponential(value, precision);
    } else {
      var c = rounded.coefficients;
      var e = rounded.exponent; // append trailing zeros

      if (c.length < precision) {
        c = c.concat(zeros(precision - c.length));
      } // append trailing zeros
      // TODO: simplify the next statement


      c = c.concat(zeros(e - c.length + 1 + (c.length < precision ? precision - c.length : 0))); // prepend zeros

      c = zeros(-e).concat(c);
      var dot = e > 0 ? e : 0;

      if (dot < c.length - 1) {
        c.splice(dot + 1, 0, '.');
      }

      return rounded.sign + c.join('');
    }
  }
  /**
   * Round the number of digits of a number *
   * @param {SplitValue} split       A value split with .splitNumber(value)
   * @param {number} precision  A positive integer
   * @return {SplitValue}
   *              Returns an object containing sign, coefficients, and exponent
   *              with rounded digits
   */

  function roundDigits(split, precision) {
    // create a clone
    var rounded = {
      sign: split.sign,
      coefficients: split.coefficients,
      exponent: split.exponent
    };
    var c = rounded.coefficients; // prepend zeros if needed

    while (precision <= 0) {
      c.unshift(0);
      rounded.exponent++;
      precision++;
    }

    if (c.length > precision) {
      var removed = c.splice(precision, c.length - precision);

      if (removed[0] >= 5) {
        var i = precision - 1;
        c[i]++;

        while (c[i] === 10) {
          c.pop();

          if (i === 0) {
            c.unshift(0);
            rounded.exponent++;
            i++;
          }

          i--;
          c[i]++;
        }
      }
    }

    return rounded;
  }
  /**
   * Create an array filled with zeros.
   * @param {number} length
   * @return {Array}
   */

  function zeros(length) {
    var arr = [];

    for (var i = 0; i < length; i++) {
      arr.push(0);
    }

    return arr;
  }
  /**
   * Count the number of significant digits of a number.
   *
   * For example:
   *   2.34 returns 3
   *   0.0034 returns 2
   *   120.5e+30 returns 4
   *
   * @param {number} value
   * @return {number} digits   Number of significant digits
   */


  function digits(value) {
    return value.toExponential().replace(/e.*$/, '') // remove exponential notation
    .replace(/^0\.?0*|\./, '') // remove decimal point and leading zeros
    .length;
  }
  /**
   * Minimum number added to one that makes the result different than one
   */

  var DBL_EPSILON = Number.EPSILON || 2.2204460492503130808472633361816E-16;
  /**
   * Compares two floating point numbers.
   * @param {number} x          First value to compare
   * @param {number} y          Second value to compare
   * @param {number} [epsilon]  The maximum relative difference between x and y
   *                            If epsilon is undefined or null, the function will
   *                            test whether x and y are exactly equal.
   * @return {boolean} whether the two numbers are nearly equal
  */

  function nearlyEqual(x, y, epsilon) {
    // if epsilon is null or undefined, test whether x and y are exactly equal
    if (epsilon === null || epsilon === undefined) {
      return x === y;
    }

    if (x === y) {
      return true;
    } // NaN


    if (isNaN(x) || isNaN(y)) {
      return false;
    } // at this point x and y should be finite


    if (isFinite(x) && isFinite(y)) {
      // check numbers are very close, needed when comparing numbers near zero
      var diff = Math.abs(x - y);

      if (diff < DBL_EPSILON) {
        return true;
      } else {
        // use relative error
        return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
      }
    } // Infinite and Number or negative Infinite and positive Infinite cases


    return false;
  }
  /**
   * Calculate the hyperbolic arccos of a number
   * @param {number} x
   * @return {number}
   */

  var acosh = Math.acosh || function (x) {
    return Math.log(Math.sqrt(x * x - 1) + x);
  };
  var asinh = Math.asinh || function (x) {
    return Math.log(Math.sqrt(x * x + 1) + x);
  };
  /**
   * Calculate the hyperbolic arctangent of a number
   * @param {number} x
   * @return {number}
   */

  var atanh = Math.atanh || function (x) {
    return Math.log((1 + x) / (1 - x)) / 2;
  };
  /**
   * Calculate the hyperbolic cosine of a number
   * @param {number} x
   * @returns {number}
   */

  var cosh = Math.cosh || function (x) {
    return (Math.exp(x) + Math.exp(-x)) / 2;
  };
  /**
   * Calculate the hyperbolic sine of a number
   * @param {number} x
   * @returns {number}
   */

  var sinh = Math.sinh || function (x) {
    return (Math.exp(x) - Math.exp(-x)) / 2;
  };
  /**
   * Calculate the hyperbolic tangent of a number
   * @param {number} x
   * @returns {number}
   */

  var tanh = Math.tanh || function (x) {
    var e = Math.exp(2 * x);
    return (e - 1) / (e + 1);
  };

  /**
   * Convert a BigNumber to a formatted string representation.
   *
   * Syntax:
   *
   *    format(value)
   *    format(value, options)
   *    format(value, precision)
   *    format(value, fn)
   *
   * Where:
   *
   *    {number} value   The value to be formatted
   *    {Object} options An object with formatting options. Available options:
   *                     {string} notation
   *                         Number notation. Choose from:
   *                         'fixed'          Always use regular number notation.
   *                                          For example '123.40' and '14000000'
   *                         'exponential'    Always use exponential notation.
   *                                          For example '1.234e+2' and '1.4e+7'
   *                         'auto' (default) Regular number notation for numbers
   *                                          having an absolute value between
   *                                          `lower` and `upper` bounds, and uses
   *                                          exponential notation elsewhere.
   *                                          Lower bound is included, upper bound
   *                                          is excluded.
   *                                          For example '123.4' and '1.4e7'.
   *                     {number} precision   A number between 0 and 16 to round
   *                                          the digits of the number.
   *                                          In case of notations 'exponential',
   *                                          'engineering', and 'auto',
   *                                          `precision` defines the total
   *                                          number of significant digits returned.
   *                                          In case of notation 'fixed',
   *                                          `precision` defines the number of
   *                                          significant digits after the decimal
   *                                          point.
   *                                          `precision` is undefined by default.
   *                     {number} lowerExp    Exponent determining the lower boundary
   *                                          for formatting a value with an exponent
   *                                          when `notation='auto`.
   *                                          Default value is `-3`.
   *                     {number} upperExp    Exponent determining the upper boundary
   *                                          for formatting a value with an exponent
   *                                          when `notation='auto`.
   *                                          Default value is `5`.
   *    {Function} fn    A custom formatting function. Can be used to override the
   *                     built-in notations. Function `fn` is called with `value` as
   *                     parameter and must return a string. Is useful for example to
   *                     format all values inside a matrix in a particular way.
   *
   * Examples:
   *
   *    format(6.4)                                        // '6.4'
   *    format(1240000)                                    // '1.24e6'
   *    format(1/3)                                        // '0.3333333333333333'
   *    format(1/3, 3)                                     // '0.333'
   *    format(21385, 2)                                   // '21000'
   *    format(12e8, {notation: 'fixed'})                  // returns '1200000000'
   *    format(2.3,    {notation: 'fixed', precision: 4})  // returns '2.3000'
   *    format(52.8,   {notation: 'exponential'})          // returns '5.28e+1'
   *    format(12400,  {notation: 'engineering'})          // returns '12.400e+3'
   *
   * @param {BigNumber} value
   * @param {Object | Function | number} [options]
   * @return {string} str The formatted value
   */
  function format$1(value, options) {
    if (typeof options === 'function') {
      // handle format(value, fn)
      return options(value);
    } // handle special cases


    if (!value.isFinite()) {
      return value.isNaN() ? 'NaN' : value.gt(0) ? 'Infinity' : '-Infinity';
    } // default values for options


    var notation = 'auto';
    var precision;

    if (options !== undefined) {
      // determine notation from options
      if (options.notation) {
        notation = options.notation;
      } // determine precision from options


      if (typeof options === 'number') {
        precision = options;
      } else if (options.precision) {
        precision = options.precision;
      }
    } // handle the various notations


    switch (notation) {
      case 'fixed':
        return toFixed$1(value, precision);

      case 'exponential':
        return toExponential$1(value, precision);

      case 'engineering':
        return toEngineering$1(value, precision);

      case 'auto':
        {
          // determine lower and upper bound for exponential notation.
          // TODO: implement support for upper and lower to be BigNumbers themselves
          var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;
          var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5; // handle special case zero

          if (value.isZero()) return '0'; // determine whether or not to output exponential notation

          var str;
          var rounded = value.toSignificantDigits(precision);
          var exp = rounded.e;

          if (exp >= lowerExp && exp < upperExp) {
            // normal number notation
            str = rounded.toFixed();
          } else {
            // exponential notation
            str = toExponential$1(value, precision);
          } // remove trailing zeros after the decimal point


          return str.replace(/((\.\d*?)(0+))($|e)/, function () {
            var digits = arguments[2];
            var e = arguments[4];
            return digits !== '.' ? digits + e : e;
          });
        }

      default:
        throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", or "fixed".');
    }
  }
  /**
   * Format a BigNumber in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'
   * @param {BigNumber | string} value
   * @param {number} [precision]        Optional number of significant figures to return.
   */

  function toEngineering$1(value, precision) {
    // find nearest lower multiple of 3 for exponent
    var e = value.e;
    var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3; // find difference in exponents, and calculate the value without exponent

    var valueWithoutExp = value.mul(Math.pow(10, -newExp));
    var valueStr = valueWithoutExp.toPrecision(precision);

    if (valueStr.indexOf('e') !== -1) {
      valueStr = valueWithoutExp.toString();
    }

    return valueStr + 'e' + (e >= 0 ? '+' : '') + newExp.toString();
  }
  /**
   * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
   * @param {BigNumber} value
   * @param {number} [precision]  Number of digits in formatted output.
   *                              If not provided, the maximum available digits
   *                              is used.
   * @returns {string} str
   */

  function toExponential$1(value, precision) {
    if (precision !== undefined) {
      return value.toExponential(precision - 1); // Note the offset of one
    } else {
      return value.toExponential();
    }
  }
  /**
   * Format a number with fixed notation.
   * @param {BigNumber} value
   * @param {number} [precision=undefined] Optional number of decimals after the
   *                                       decimal point. Undefined by default.
   */

  function toFixed$1(value, precision) {
    return value.toFixed(precision);
  }

  function _typeof$2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$2 = function _typeof(obj) { return typeof obj; }; } else { _typeof$2 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$2(obj); }
  /**
   * Check if a text ends with a certain string.
   * @param {string} text
   * @param {string} search
   */

  function endsWith(text, search) {
    var start = text.length - search.length;
    var end = text.length;
    return text.substring(start, end) === search;
  }
  /**
   * Format a value of any type into a string.
   *
   * Usage:
   *     math.format(value)
   *     math.format(value, precision)
   *
   * When value is a function:
   *
   * - When the function has a property `syntax`, it returns this
   *   syntax description.
   * - In other cases, a string `'function'` is returned.
   *
   * When `value` is an Object:
   *
   * - When the object contains a property `format` being a function, this
   *   function is invoked as `value.format(options)` and the result is returned.
   * - When the object has its own `toString` method, this method is invoked
   *   and the result is returned.
   * - In other cases the function will loop over all object properties and
   *   return JSON object notation like '{"a": 2, "b": 3}'.
   *
   * Example usage:
   *     math.format(2/7)                // '0.2857142857142857'
   *     math.format(math.pi, 3)         // '3.14'
   *     math.format(new Complex(2, 3))  // '2 + 3i'
   *     math.format('hello')            // '"hello"'
   *
   * @param {*} value             Value to be stringified
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @return {string} str
   */

  function format$2(value, options) {
    if (typeof value === 'number') {
      return format(value, options);
    }

    if (isBigNumber(value)) {
      return format$1(value, options);
    } // note: we use unsafe duck-typing here to check for Fractions, this is
    // ok here since we're only invoking toString or concatenating its values


    if (looksLikeFraction(value)) {
      if (!options || options.fraction !== 'decimal') {
        // output as ratio, like '1/3'
        return value.s * value.n + '/' + value.d;
      } else {
        // output as decimal, like '0.(3)'
        return value.toString();
      }
    }

    if (Array.isArray(value)) {
      return formatArray(value, options);
    }

    if (isString(value)) {
      return '"' + value + '"';
    }

    if (typeof value === 'function') {
      return value.syntax ? String(value.syntax) : 'function';
    }

    if (value && _typeof$2(value) === 'object') {
      if (typeof value.format === 'function') {
        return value.format(options);
      } else if (value && value.toString(options) !== {}.toString()) {
        // this object has a non-native toString method, use that one
        return value.toString(options);
      } else {
        var entries = Object.keys(value).map(function (key) {
          return '"' + key + '": ' + format$2(value[key], options);
        });
        return '{' + entries.join(', ') + '}';
      }
    }

    return String(value);
  }
  /**
   * Stringify a value into a string enclosed in double quotes.
   * Unescaped double quotes and backslashes inside the value are escaped.
   * @param {*} value
   * @return {string}
   */

  function stringify(value) {
    var text = String(value);
    var escaped = '';
    var i = 0;

    while (i < text.length) {
      var c = text.charAt(i);

      if (c === '\\') {
        escaped += c;
        i++;
        c = text.charAt(i);

        if (c === '' || '"\\/bfnrtu'.indexOf(c) === -1) {
          escaped += '\\'; // no valid escape character -> escape it
        }

        escaped += c;
      } else if (c === '"') {
        escaped += '\\"';
      } else {
        escaped += c;
      }

      i++;
    }

    return '"' + escaped + '"';
  }
  /**
   * Escape special HTML characters
   * @param {*} value
   * @return {string}
   */

  function escape(value) {
    var text = String(value);
    text = text.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    return text;
  }
  /**
   * Recursively format an n-dimensional matrix
   * Example output: "[[1, 2], [3, 4]]"
   * @param {Array} array
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @returns {string} str
   */

  function formatArray(array, options) {
    if (Array.isArray(array)) {
      var str = '[';
      var len = array.length;

      for (var i = 0; i < len; i++) {
        if (i !== 0) {
          str += ', ';
        }

        str += formatArray(array[i], options);
      }

      str += ']';
      return str;
    } else {
      return format$2(array, options);
    }
  }
  /**
   * Check whether a value looks like a Fraction (unsafe duck-type check)
   * @param {*} value
   * @return {boolean}
   */


  function looksLikeFraction(value) {
    return value && _typeof$2(value) === 'object' && typeof value.s === 'number' && typeof value.n === 'number' && typeof value.d === 'number' || false;
  }
  /**
   * Compare two strings
   * @param {string} x
   * @param {string} y
   * @returns {number}
   */


  function compareText(x, y) {
    // we don't want to convert numbers to string, only accept string input
    if (!isString(x)) {
      throw new TypeError('Unexpected type of argument in function compareText ' + '(expected: string or Array or Matrix, actual: ' + typeOf(x) + ', index: 0)');
    }

    if (!isString(y)) {
      throw new TypeError('Unexpected type of argument in function compareText ' + '(expected: string or Array or Matrix, actual: ' + typeOf(y) + ', index: 1)');
    }

    return x === y ? 0 : x > y ? 1 : -1;
  }

  /**
   * Create a range error with the message:
   *     'Dimension mismatch (<actual size> != <expected size>)'
   * @param {number | number[]} actual        The actual size
   * @param {number | number[]} expected      The expected size
   * @param {string} [relation='!=']          Optional relation between actual
   *                                          and expected size: '!=', '<', etc.
   * @extends RangeError
   */
  function DimensionError(actual, expected, relation) {
    if (!(this instanceof DimensionError)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.actual = actual;
    this.expected = expected;
    this.relation = relation;
    this.message = 'Dimension mismatch (' + (Array.isArray(actual) ? '[' + actual.join(', ') + ']' : actual) + ' ' + (this.relation || '!=') + ' ' + (Array.isArray(expected) ? '[' + expected.join(', ') + ']' : expected) + ')';
    this.stack = new Error().stack;
  }
  DimensionError.prototype = new RangeError();
  DimensionError.prototype.constructor = RangeError;
  DimensionError.prototype.name = 'DimensionError';
  DimensionError.prototype.isDimensionError = true;

  /**
   * Create a range error with the message:
   *     'Index out of range (index < min)'
   *     'Index out of range (index < max)'
   *
   * @param {number} index     The actual index
   * @param {number} [min=0]   Minimum index (included)
   * @param {number} [max]     Maximum index (excluded)
   * @extends RangeError
   */
  function IndexError(index, min, max) {
    if (!(this instanceof IndexError)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.index = index;

    if (arguments.length < 3) {
      this.min = 0;
      this.max = min;
    } else {
      this.min = min;
      this.max = max;
    }

    if (this.min !== undefined && this.index < this.min) {
      this.message = 'Index out of range (' + this.index + ' < ' + this.min + ')';
    } else if (this.max !== undefined && this.index >= this.max) {
      this.message = 'Index out of range (' + this.index + ' > ' + (this.max - 1) + ')';
    } else {
      this.message = 'Index out of range (' + this.index + ')';
    }

    this.stack = new Error().stack;
  }
  IndexError.prototype = new RangeError();
  IndexError.prototype.constructor = RangeError;
  IndexError.prototype.name = 'IndexError';
  IndexError.prototype.isIndexError = true;

  /**
   * Calculate the size of a multi dimensional array.
   * This function checks the size of the first entry, it does not validate
   * whether all dimensions match. (use function `validate` for that)
   * @param {Array} x
   * @Return {Number[]} size
   */

  function arraySize(x) {
    var s = [];

    while (Array.isArray(x)) {
      s.push(x.length);
      x = x[0];
    }

    return s;
  }
  /**
   * Recursively validate whether each element in a multi dimensional array
   * has a size corresponding to the provided size array.
   * @param {Array} array    Array to be validated
   * @param {number[]} size  Array with the size of each dimension
   * @param {number} dim   Current dimension
   * @throws DimensionError
   * @private
   */

  function _validate(array, size, dim) {
    var i;
    var len = array.length;

    if (len !== size[dim]) {
      throw new DimensionError(len, size[dim]);
    }

    if (dim < size.length - 1) {
      // recursively validate each child array
      var dimNext = dim + 1;

      for (i = 0; i < len; i++) {
        var child = array[i];

        if (!Array.isArray(child)) {
          throw new DimensionError(size.length - 1, size.length, '<');
        }

        _validate(array[i], size, dimNext);
      }
    } else {
      // last dimension. none of the childs may be an array
      for (i = 0; i < len; i++) {
        if (Array.isArray(array[i])) {
          throw new DimensionError(size.length + 1, size.length, '>');
        }
      }
    }
  }
  /**
   * Validate whether each element in a multi dimensional array has
   * a size corresponding to the provided size array.
   * @param {Array} array    Array to be validated
   * @param {number[]} size  Array with the size of each dimension
   * @throws DimensionError
   */


  function validate(array, size) {
    var isScalar = size.length === 0;

    if (isScalar) {
      // scalar
      if (Array.isArray(array)) {
        throw new DimensionError(array.length, 0);
      }
    } else {
      // array
      _validate(array, size, 0);
    }
  }
  /**
   * Test whether index is an integer number with index >= 0 and index < length
   * when length is provided
   * @param {number} index    Zero-based index
   * @param {number} [length] Length of the array
   */

  function validateIndex(index, length) {
    if (!isNumber(index) || !isInteger(index)) {
      throw new TypeError('Index must be an integer (value: ' + index + ')');
    }

    if (index < 0 || typeof length === 'number' && index >= length) {
      throw new IndexError(index, length);
    }
  }
  /**
   * Resize a multi dimensional array. The resized array is returned.
   * @param {Array} array         Array to be resized
   * @param {Array.<number>} size Array with the size of each dimension
   * @param {*} [defaultValue=0]  Value to be filled in in new entries,
   *                              zero by default. Specify for example `null`,
   *                              to clearly see entries that are not explicitly
   *                              set.
   * @return {Array} array         The resized array
   */

  function resize(array, size, defaultValue) {
    // TODO: add support for scalars, having size=[] ?
    // check the type of the arguments
    if (!Array.isArray(array) || !Array.isArray(size)) {
      throw new TypeError('Array expected');
    }

    if (size.length === 0) {
      throw new Error('Resizing to scalar is not supported');
    } // check whether size contains positive integers


    size.forEach(function (value) {
      if (!isNumber(value) || !isInteger(value) || value < 0) {
        throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format$2(size) + ')');
      }
    }); // recursively resize the array

    var _defaultValue = defaultValue !== undefined ? defaultValue : 0;

    _resize(array, size, 0, _defaultValue);

    return array;
  }
  /**
   * Recursively resize a multi dimensional array
   * @param {Array} array         Array to be resized
   * @param {number[]} size       Array with the size of each dimension
   * @param {number} dim          Current dimension
   * @param {*} [defaultValue]    Value to be filled in in new entries,
   *                              undefined by default.
   * @private
   */

  function _resize(array, size, dim, defaultValue) {
    var i;
    var elem;
    var oldLen = array.length;
    var newLen = size[dim];
    var minLen = Math.min(oldLen, newLen); // apply new length

    array.length = newLen;

    if (dim < size.length - 1) {
      // non-last dimension
      var dimNext = dim + 1; // resize existing child arrays

      for (i = 0; i < minLen; i++) {
        // resize child array
        elem = array[i];

        if (!Array.isArray(elem)) {
          elem = [elem]; // add a dimension

          array[i] = elem;
        }

        _resize(elem, size, dimNext, defaultValue);
      } // create new child arrays


      for (i = minLen; i < newLen; i++) {
        // get child array
        elem = [];
        array[i] = elem; // resize new child array

        _resize(elem, size, dimNext, defaultValue);
      }
    } else {
      // last dimension
      // remove dimensions of existing values
      for (i = 0; i < minLen; i++) {
        while (Array.isArray(array[i])) {
          array[i] = array[i][0];
        }
      } // fill new elements with the default value


      for (i = minLen; i < newLen; i++) {
        array[i] = defaultValue;
      }
    }
  }
  /**
   * Re-shape a multi dimensional array to fit the specified dimensions
   * @param {Array} array           Array to be reshaped
   * @param {Array.<number>} sizes  List of sizes for each dimension
   * @returns {Array}               Array whose data has been formatted to fit the
   *                                specified dimensions
   *
   * @throws {DimensionError}       If the product of the new dimension sizes does
   *                                not equal that of the old ones
   */


  function reshape(array, sizes) {
    var flatArray = flatten(array);
    var newArray;

    function product(arr) {
      return arr.reduce(function (prev, curr) {
        return prev * curr;
      });
    }

    if (!Array.isArray(array) || !Array.isArray(sizes)) {
      throw new TypeError('Array expected');
    }

    if (sizes.length === 0) {
      throw new DimensionError(0, product(arraySize(array)), '!=');
    }

    var totalSize = 1;

    for (var sizeIndex = 0; sizeIndex < sizes.length; sizeIndex++) {
      totalSize *= sizes[sizeIndex];
    }

    if (flatArray.length !== totalSize) {
      throw new DimensionError(product(sizes), product(arraySize(array)), '!=');
    }

    try {
      newArray = _reshape(flatArray, sizes);
    } catch (e) {
      if (e instanceof DimensionError) {
        throw new DimensionError(product(sizes), product(arraySize(array)), '!=');
      }

      throw e;
    }

    return newArray;
  }
  /**
   * Iteratively re-shape a multi dimensional array to fit the specified dimensions
   * @param {Array} array           Array to be reshaped
   * @param {Array.<number>} sizes  List of sizes for each dimension
   * @returns {Array}               Array whose data has been formatted to fit the
   *                                specified dimensions
   */

  function _reshape(array, sizes) {
    // testing if there are enough elements for the requested shape
    var tmpArray = array;
    var tmpArray2; // for each dimensions starting by the last one and ignoring the first one

    for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
      var size = sizes[sizeIndex];
      tmpArray2 = []; // aggregate the elements of the current tmpArray in elements of the requested size

      var length = tmpArray.length / size;

      for (var i = 0; i < length; i++) {
        tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
      } // set it as the new tmpArray for the next loop turn or for return


      tmpArray = tmpArray2;
    }

    return tmpArray;
  }
  /**
   * Squeeze a multi dimensional array
   * @param {Array} array
   * @param {Array} [size]
   * @returns {Array} returns the array itself
   */


  function squeeze(array, size) {
    var s = size || arraySize(array); // squeeze outer dimensions

    while (Array.isArray(array) && array.length === 1) {
      array = array[0];
      s.shift();
    } // find the first dimension to be squeezed


    var dims = s.length;

    while (s[dims - 1] === 1) {
      dims--;
    } // squeeze inner dimensions


    if (dims < s.length) {
      array = _squeeze(array, dims, 0);
      s.length = dims;
    }

    return array;
  }
  /**
   * Recursively squeeze a multi dimensional array
   * @param {Array} array
   * @param {number} dims Required number of dimensions
   * @param {number} dim  Current dimension
   * @returns {Array | *} Returns the squeezed array
   * @private
   */

  function _squeeze(array, dims, dim) {
    var i, ii;

    if (dim < dims) {
      var next = dim + 1;

      for (i = 0, ii = array.length; i < ii; i++) {
        array[i] = _squeeze(array[i], dims, next);
      }
    } else {
      while (Array.isArray(array)) {
        array = array[0];
      }
    }

    return array;
  }
  /**
   * Unsqueeze a multi dimensional array: add dimensions when missing
   *
   * Paramter `size` will be mutated to match the new, unqueezed matrix size.
   *
   * @param {Array} array
   * @param {number} dims       Desired number of dimensions of the array
   * @param {number} [outer]    Number of outer dimensions to be added
   * @param {Array} [size] Current size of array.
   * @returns {Array} returns the array itself
   * @private
   */


  function unsqueeze(array, dims, outer, size) {
    var s = size || arraySize(array); // unsqueeze outer dimensions

    if (outer) {
      for (var i = 0; i < outer; i++) {
        array = [array];
        s.unshift(1);
      }
    } // unsqueeze inner dimensions


    array = _unsqueeze(array, dims, 0);

    while (s.length < dims) {
      s.push(1);
    }

    return array;
  }
  /**
   * Recursively unsqueeze a multi dimensional array
   * @param {Array} array
   * @param {number} dims Required number of dimensions
   * @param {number} dim  Current dimension
   * @returns {Array | *} Returns the squeezed array
   * @private
   */

  function _unsqueeze(array, dims, dim) {
    var i, ii;

    if (Array.isArray(array)) {
      var next = dim + 1;

      for (i = 0, ii = array.length; i < ii; i++) {
        array[i] = _unsqueeze(array[i], dims, next);
      }
    } else {
      for (var d = dim; d < dims; d++) {
        array = [array];
      }
    }

    return array;
  }
  /**
   * Flatten a multi dimensional array, put all elements in a one dimensional
   * array
   * @param {Array} array   A multi dimensional array
   * @return {Array}        The flattened array (1 dimensional)
   */


  function flatten(array) {
    if (!Array.isArray(array)) {
      // if not an array, return as is
      return array;
    }

    var flat = [];
    array.forEach(function callback(value) {
      if (Array.isArray(value)) {
        value.forEach(callback); // traverse through sub-arrays recursively
      } else {
        flat.push(value);
      }
    });
    return flat;
  }
  /**
   * A safe map
   * @param {Array} array
   * @param {function} callback
   */

  function map(array, callback) {
    return Array.prototype.map.call(array, callback);
  }
  /**
   * A safe forEach
   * @param {Array} array
   * @param {function} callback
   */

  function forEach(array, callback) {
    Array.prototype.forEach.call(array, callback);
  }
  /**
   * A safe filter
   * @param {Array} array
   * @param {function} callback
   */

  function filter(array, callback) {
    if (arraySize(array).length !== 1) {
      throw new Error('Only one dimensional matrices supported');
    }

    return Array.prototype.filter.call(array, callback);
  }
  /**
   * Filter values in a callback given a regular expression
   * @param {Array} array
   * @param {RegExp} regexp
   * @return {Array} Returns the filtered array
   * @private
   */

  function filterRegExp(array, regexp) {
    if (arraySize(array).length !== 1) {
      throw new Error('Only one dimensional matrices supported');
    }

    return Array.prototype.filter.call(array, function (entry) {
      return regexp.test(entry);
    });
  }
  /**
   * A safe join
   * @param {Array} array
   * @param {string} separator
   */

  function join(array, separator) {
    return Array.prototype.join.call(array, separator);
  }
  /**
   * Assign a numeric identifier to every element of a sorted array
   * @param {Array} a  An array
   * @return {Array} An array of objects containing the original value and its identifier
   */

  function identify(a) {
    if (!Array.isArray(a)) {
      throw new TypeError('Array input expected');
    }

    if (a.length === 0) {
      return a;
    }

    var b = [];
    var count = 0;
    b[0] = {
      value: a[0],
      identifier: 0
    };

    for (var i = 1; i < a.length; i++) {
      if (a[i] === a[i - 1]) {
        count++;
      } else {
        count = 0;
      }

      b.push({
        value: a[i],
        identifier: count
      });
    }

    return b;
  }
  /**
   * Remove the numeric identifier from the elements
   * @param {array} a  An array
   * @return {array} An array of values without identifiers
   */

  function generalize(a) {
    if (!Array.isArray(a)) {
      throw new TypeError('Array input expected');
    }

    if (a.length === 0) {
      return a;
    }

    var b = [];

    for (var i = 0; i < a.length; i++) {
      b.push(a[i].value);
    }

    return b;
  }
  /**
   * Check the datatype of a given object
   * This is a low level implementation that should only be used by
   * parent Matrix classes such as SparseMatrix or DenseMatrix
   * This method does not validate Array Matrix shape
   * @param {Array} array
   * @param {function} typeOf   Callback function to use to determine the type of a value
   * @return string
   */

  function getArrayDataType(array, typeOf$$1) {
    var type; // to hold type info

    var length = 0; // to hold length value to ensure it has consistent sizes

    for (var i = 0; i < array.length; i++) {
      var item = array[i];
      var isArray$$1 = Array.isArray(item); // Saving the target matrix row size

      if (i === 0 && isArray$$1) {
        length = item.length;
      } // If the current item is an array but the length does not equal the targetVectorSize


      if (isArray$$1 && item.length !== length) {
        return undefined;
      }

      var itemType = isArray$$1 ? getArrayDataType(item, typeOf$$1) // recurse into a nested array
      : typeOf$$1(item);

      if (type === undefined) {
        type = itemType; // first item
      } else if (type !== itemType) {
        return 'mixed';
      }
    }

    return type;
  }

  /**
   * Create a factory function, which can be used to inject dependencies.
   *
   * The created functions are memoized, a consecutive call of the factory
   * with the exact same inputs will return the same function instance.
   * The memoized cache is exposed on `factory.cache` and can be cleared
   * if needed.
   *
   * Example:
   *
   *     const name = 'log'
   *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']
   *
   *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {
   *       // ... create the function log here and return it
   *     }
   *
   * @param {string} name           Name of the function to be created
   * @param {string[]} dependencies The names of all required dependencies
   * @param {function} create       Callback function called with an object with all dependencies
   * @param {Object} [meta]         Optional object with meta information that will be attached
   *                                to the created factory function as property `meta`.
   * @returns {function}
   */

  function factory(name, dependencies, create, meta) {
    function assertAndCreate(scope) {
      // we only pass the requested dependencies to the factory function
      // to prevent functions to rely on dependencies that are not explicitly
      // requested.
      var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));
      assertDependencies(name, dependencies, scope);
      return create(deps);
    }

    assertAndCreate.isFactory = true;
    assertAndCreate.fn = name;
    assertAndCreate.dependencies = dependencies.slice().sort();

    if (meta) {
      assertAndCreate.meta = meta;
    }

    return assertAndCreate;
  }
  /**
   * Assert that all dependencies of a list with dependencies are available in the provided scope.
   *
   * Will throw an exception when there are dependencies missing.
   *
   * @param {string} name   Name for the function to be created. Used to generate a useful error message
   * @param {string[]} dependencies
   * @param {Object} scope
   */

  function assertDependencies(name, dependencies, scope) {
    var allDefined = dependencies.filter(function (dependency) {
      return !isOptionalDependency(dependency);
    }) // filter optionals
    .every(function (dependency) {
      return scope[dependency] !== undefined;
    });

    if (!allDefined) {
      var missingDependencies = dependencies.filter(function (dependency) {
        return scope[dependency] === undefined;
      }); // TODO: create a custom error class for this, a MathjsError or something like that

      throw new Error("Cannot create function \"".concat(name, "\", ") + "some dependencies are missing: ".concat(missingDependencies.map(function (d) {
        return "\"".concat(d, "\"");
      }).join(', '), "."));
    }
  }
  function isOptionalDependency(dependency) {
    return dependency && dependency[0] === '?';
  }
  function stripOptionalNotation(dependency) {
    return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;
  }

  /**
   * Create a typed-function which checks the types of the arguments and
   * can match them against multiple provided signatures. The typed-function
   * automatically converts inputs in order to find a matching signature.
   * Typed functions throw informative errors in case of wrong input arguments.
   *
   * See the library [typed-function](https://github.com/josdejong/typed-function)
   * for detailed documentation.
   *
   * Syntax:
   *
   *     math.typed(name, signatures) : function
   *     math.typed(signatures) : function
   *
   * Examples:
   *
   *     // create a typed function with multiple types per argument (type union)
   *     const fn2 = typed({
   *       'number | boolean': function (b) {
   *         return 'b is a number or boolean'
   *       },
   *       'string, number | boolean': function (a, b) {
   *         return 'a is a string, b is a number or boolean'
   *       }
   *     })
   *
   *     // create a typed function with an any type argument
   *     const log = typed({
   *       'string, any': function (event, data) {
   *         console.log('event: ' + event + ', data: ' + JSON.stringify(data))
   *       }
   *     })
   *
   * @param {string} [name]                          Optional name for the typed-function
   * @param {Object<string, function>} signatures   Object with one or multiple function signatures
   * @returns {function} The created typed-function.
   */

  var _createTyped2 = function _createTyped() {
    // initially, return the original instance of typed-function
    // consecutively, return a new instance from typed.create.
    _createTyped2 = typedFunction.create;
    return typedFunction;
  };

  var dependencies = ['?BigNumber', '?Complex', '?DenseMatrix', '?Fraction'];
  /**
   * Factory function for creating a new typed instance
   * @param {Object} dependencies   Object with data types like Complex and BigNumber
   * @returns {Function}
   */

  var createTyped = /* #__PURE__ */factory('typed', dependencies, function createTyped(_ref) {
    var BigNumber = _ref.BigNumber,
        Complex = _ref.Complex,
        DenseMatrix = _ref.DenseMatrix,
        Fraction = _ref.Fraction;

    // TODO: typed-function must be able to silently ignore signatures with unknown data types
    // get a new instance of typed-function
    var typed = _createTyped2(); // define all types. The order of the types determines in which order function
    // arguments are type-checked (so for performance it's important to put the
    // most used types first).


    typed.types = [{
      name: 'number',
      test: isNumber
    }, {
      name: 'Complex',
      test: isComplex
    }, {
      name: 'BigNumber',
      test: isBigNumber
    }, {
      name: 'Fraction',
      test: isFraction
    }, {
      name: 'Unit',
      test: isUnit
    }, {
      name: 'string',
      test: isString
    }, {
      name: 'Chain',
      test: isChain
    }, {
      name: 'Array',
      test: isArray
    }, {
      name: 'Matrix',
      test: isMatrix
    }, {
      name: 'DenseMatrix',
      test: isDenseMatrix
    }, {
      name: 'SparseMatrix',
      test: isSparseMatrix
    }, {
      name: 'Range',
      test: isRange
    }, {
      name: 'Index',
      test: isIndex
    }, {
      name: 'boolean',
      test: isBoolean
    }, {
      name: 'ResultSet',
      test: isResultSet
    }, {
      name: 'Help',
      test: isHelp
    }, {
      name: 'function',
      test: isFunction
    }, {
      name: 'Date',
      test: isDate
    }, {
      name: 'RegExp',
      test: isRegExp
    }, {
      name: 'null',
      test: isNull
    }, {
      name: 'undefined',
      test: isUndefined
    }, {
      name: 'AccessorNode',
      test: isAccessorNode
    }, {
      name: 'ArrayNode',
      test: isArrayNode
    }, {
      name: 'AssignmentNode',
      test: isAssignmentNode
    }, {
      name: 'BlockNode',
      test: isBlockNode
    }, {
      name: 'ConditionalNode',
      test: isConditionalNode
    }, {
      name: 'ConstantNode',
      test: isConstantNode
    }, {
      name: 'FunctionNode',
      test: isFunctionNode
    }, {
      name: 'FunctionAssignmentNode',
      test: isFunctionAssignmentNode
    }, {
      name: 'IndexNode',
      test: isIndexNode
    }, {
      name: 'Node',
      test: isNode
    }, {
      name: 'ObjectNode',
      test: isObjectNode
    }, {
      name: 'OperatorNode',
      test: isOperatorNode
    }, {
      name: 'ParenthesisNode',
      test: isParenthesisNode
    }, {
      name: 'RangeNode',
      test: isRangeNode
    }, {
      name: 'SymbolNode',
      test: isSymbolNode
    }, {
      name: 'Object',
      test: isObject
    } // order 'Object' last, it matches on other classes too
    ];
    typed.conversions = [{
      from: 'number',
      to: 'BigNumber',
      convert: function convert(x) {
        if (!BigNumber) {
          throwNoBignumber(x);
        } // note: conversion from number to BigNumber can fail if x has >15 digits


        if (digits(x) > 15) {
          throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' + '(value: ' + x + '). ' + 'Use function bignumber(x) to convert to BigNumber.');
        }

        return new BigNumber(x);
      }
    }, {
      from: 'number',
      to: 'Complex',
      convert: function convert(x) {
        if (!Complex) {
          throwNoComplex(x);
        }

        return new Complex(x, 0);
      }
    }, {
      from: 'number',
      to: 'string',
      convert: function convert(x) {
        return x + '';
      }
    }, {
      from: 'BigNumber',
      to: 'Complex',
      convert: function convert(x) {
        if (!Complex) {
          throwNoComplex(x);
        }

        return new Complex(x.toNumber(), 0);
      }
    }, {
      from: 'Fraction',
      to: 'BigNumber',
      convert: function convert(x) {
        throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' + 'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
      }
    }, {
      from: 'Fraction',
      to: 'Complex',
      convert: function convert(x) {
        if (!Complex) {
          throwNoComplex(x);
        }

        return new Complex(x.valueOf(), 0);
      }
    }, {
      from: 'number',
      to: 'Fraction',
      convert: function convert(x) {
        if (!Fraction) {
          throwNoFraction(x);
        }

        var f = new Fraction(x);

        if (f.valueOf() !== x) {
          throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' + '(value: ' + x + '). ' + 'Use function fraction(x) to convert to Fraction.');
        }

        return f;
      }
    }, {
      // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
      //  from: 'Fraction',
      //  to: 'number',
      //  convert: function (x) {
      //    return x.valueOf()
      //  }
      // }, {
      from: 'string',
      to: 'number',
      convert: function convert(x) {
        var n = Number(x);

        if (isNaN(n)) {
          throw new Error('Cannot convert "' + x + '" to a number');
        }

        return n;
      }
    }, {
      from: 'string',
      to: 'BigNumber',
      convert: function convert(x) {
        if (!BigNumber) {
          throwNoBignumber(x);
        }

        try {
          return new BigNumber(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to BigNumber');
        }
      }
    }, {
      from: 'string',
      to: 'Fraction',
      convert: function convert(x) {
        if (!Fraction) {
          throwNoFraction(x);
        }

        try {
          return new Fraction(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to Fraction');
        }
      }
    }, {
      from: 'string',
      to: 'Complex',
      convert: function convert(x) {
        if (!Complex) {
          throwNoComplex(x);
        }

        try {
          return new Complex(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to Complex');
        }
      }
    }, {
      from: 'boolean',
      to: 'number',
      convert: function convert(x) {
        return +x;
      }
    }, {
      from: 'boolean',
      to: 'BigNumber',
      convert: function convert(x) {
        if (!BigNumber) {
          throwNoBignumber(x);
        }

        return new BigNumber(+x);
      }
    }, {
      from: 'boolean',
      to: 'Fraction',
      convert: function convert(x) {
        if (!Fraction) {
          throwNoFraction(x);
        }

        return new Fraction(+x);
      }
    }, {
      from: 'boolean',
      to: 'string',
      convert: function convert(x) {
        return String(x);
      }
    }, {
      from: 'Array',
      to: 'Matrix',
      convert: function convert(array) {
        if (!DenseMatrix) {
          throwNoMatrix();
        }

        return new DenseMatrix(array);
      }
    }, {
      from: 'Matrix',
      to: 'Array',
      convert: function convert(matrix) {
        return matrix.valueOf();
      }
    }];
    return typed;
  });

  function throwNoBignumber(x) {
    throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
  }

  function throwNoComplex(x) {
    throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
  }

  function throwNoMatrix() {
    throw new Error('Cannot convert array into a Matrix: no class \'DenseMatrix\' provided');
  }

  function throwNoFraction(x) {
    throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
  }

  var name = 'ResultSet';
  var dependencies$1 = [];
  var createResultSet = /* #__PURE__ */factory(name, dependencies$1, function () {
    /**
     * A ResultSet contains a list or results
     * @class ResultSet
     * @param {Array} entries
     * @constructor ResultSet
     */
    function ResultSet(entries) {
      if (!(this instanceof ResultSet)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      this.entries = entries || [];
    }
    /**
     * Attach type information
     */


    ResultSet.prototype.type = 'ResultSet';
    ResultSet.prototype.isResultSet = true;
    /**
     * Returns the array with results hold by this ResultSet
     * @memberof ResultSet
     * @returns {Array} entries
     */

    ResultSet.prototype.valueOf = function () {
      return this.entries;
    };
    /**
     * Returns the stringified results of the ResultSet
     * @memberof ResultSet
     * @returns {string} string
     */


    ResultSet.prototype.toString = function () {
      return '[' + this.entries.join(', ') + ']';
    };
    /**
     * Get a JSON representation of the ResultSet
     * @memberof ResultSet
     * @returns {Object} Returns a JSON object structured as:
     *                   `{"mathjs": "ResultSet", "entries": [...]}`
     */


    ResultSet.prototype.toJSON = function () {
      return {
        mathjs: 'ResultSet',
        entries: this.entries
      };
    };
    /**
     * Instantiate a ResultSet from a JSON object
     * @memberof ResultSet
     * @param {Object} json  A JSON object structured as:
     *                       `{"mathjs": "ResultSet", "entries": [...]}`
     * @return {ResultSet}
     */


    ResultSet.fromJSON = function (json) {
      return new ResultSet(json.entries);
    };

    return ResultSet;
  }, {
    isClass: true
  });

  var decimal = createCommonjsModule(function (module) {
  (function (globalScope) {


    /*
     *  decimal.js v10.2.0
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2019 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     */


    // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //


      // The maximum exponent magnitude.
      // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.
    var EXP_LIMIT = 9e15,                      // 0 to 9e15

      // The limit on the value of `precision`, and on the value of the first argument to
      // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
      MAX_DIGITS = 1e9,                        // 0 to 1e9

      // Base conversion alphabet.
      NUMERALS = '0123456789abcdef',

      // The natural logarithm of 10 (1025 digits).
      LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',

      // Pi (1025 digits).
      PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',


      // The initial configuration properties of the Decimal constructor.
      DEFAULTS = {

        // These values must be integers within the stated ranges (inclusive).
        // Most of these values can be changed at run-time using the `Decimal.config` method.

        // The maximum number of significant digits of the result of a calculation or base conversion.
        // E.g. `Decimal.config({ precision: 20 });`
        precision: 20,                         // 1 to MAX_DIGITS

        // The rounding mode used when rounding to `precision`.
        //
        // ROUND_UP         0 Away from zero.
        // ROUND_DOWN       1 Towards zero.
        // ROUND_CEIL       2 Towards +Infinity.
        // ROUND_FLOOR      3 Towards -Infinity.
        // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
        // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
        // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
        // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
        // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
        //
        // E.g.
        // `Decimal.rounding = 4;`
        // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
        rounding: 4,                           // 0 to 8

        // The modulo mode used when calculating the modulus: a mod n.
        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
        // The remainder (r) is calculated as: r = a - n * q.
        //
        // UP         0 The remainder is positive if the dividend is negative, else is negative.
        // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
        // FLOOR      3 The remainder has the same sign as the divisor (Python %).
        // HALF_EVEN  6 The IEEE 754 remainder function.
        // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
        //
        // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
        // division (9) are commonly used for the modulus operation. The other rounding modes can also
        // be used, but they may not give useful results.
        modulo: 1,                             // 0 to 9

        // The exponent value at and beneath which `toString` returns exponential notation.
        // JavaScript numbers: -7
        toExpNeg: -7,                          // 0 to -EXP_LIMIT

        // The exponent value at and above which `toString` returns exponential notation.
        // JavaScript numbers: 21
        toExpPos:  21,                         // 0 to EXP_LIMIT

        // The minimum exponent value, beneath which underflow to zero occurs.
        // JavaScript numbers: -324  (5e-324)
        minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT

        // The maximum exponent value, above which overflow to Infinity occurs.
        // JavaScript numbers: 308  (1.7976931348623157e+308)
        maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT

        // Whether to use cryptographically-secure random number generation, if available.
        crypto: false                          // true/false
      },


    // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //


      Decimal, inexact, noConflict, quadrant,
      external = true,

      decimalError = '[DecimalError] ',
      invalidArgument = decimalError + 'Invalid argument: ',
      precisionLimitExceeded = decimalError + 'Precision limit exceeded',
      cryptoUnavailable = decimalError + 'crypto unavailable',

      mathfloor = Math.floor,
      mathpow = Math.pow,

      isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
      isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
      isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
      isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,

      BASE = 1e7,
      LOG_BASE = 7,
      MAX_SAFE_INTEGER = 9007199254740991,

      LN10_PRECISION = LN10.length - 1,
      PI_PRECISION = PI.length - 1,

      // Decimal.prototype object
      P = { name: '[object Decimal]' };


    // Decimal prototype methods


    /*
     *  absoluteValue             abs
     *  ceil
     *  comparedTo                cmp
     *  cosine                    cos
     *  cubeRoot                  cbrt
     *  decimalPlaces             dp
     *  dividedBy                 div
     *  dividedToIntegerBy        divToInt
     *  equals                    eq
     *  floor
     *  greaterThan               gt
     *  greaterThanOrEqualTo      gte
     *  hyperbolicCosine          cosh
     *  hyperbolicSine            sinh
     *  hyperbolicTangent         tanh
     *  inverseCosine             acos
     *  inverseHyperbolicCosine   acosh
     *  inverseHyperbolicSine     asinh
     *  inverseHyperbolicTangent  atanh
     *  inverseSine               asin
     *  inverseTangent            atan
     *  isFinite
     *  isInteger                 isInt
     *  isNaN
     *  isNegative                isNeg
     *  isPositive                isPos
     *  isZero
     *  lessThan                  lt
     *  lessThanOrEqualTo         lte
     *  logarithm                 log
     *  [maximum]                 [max]
     *  [minimum]                 [min]
     *  minus                     sub
     *  modulo                    mod
     *  naturalExponential        exp
     *  naturalLogarithm          ln
     *  negated                   neg
     *  plus                      add
     *  precision                 sd
     *  round
     *  sine                      sin
     *  squareRoot                sqrt
     *  tangent                   tan
     *  times                     mul
     *  toBinary
     *  toDecimalPlaces           toDP
     *  toExponential
     *  toFixed
     *  toFraction
     *  toHexadecimal             toHex
     *  toNearest
     *  toNumber
     *  toOctal
     *  toPower                   pow
     *  toPrecision
     *  toSignificantDigits       toSD
     *  toString
     *  truncated                 trunc
     *  valueOf                   toJSON
     */


    /*
     * Return a new Decimal whose value is the absolute value of this Decimal.
     *
     */
    P.absoluteValue = P.abs = function () {
      var x = new this.constructor(this);
      if (x.s < 0) x.s = 1;
      return finalise(x);
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
     * direction of positive Infinity.
     *
     */
    P.ceil = function () {
      return finalise(new this.constructor(this), this.e + 1, 2);
    };


    /*
     * Return
     *   1    if the value of this Decimal is greater than the value of `y`,
     *  -1    if the value of this Decimal is less than the value of `y`,
     *   0    if they have the same value,
     *   NaN  if the value of either Decimal is NaN.
     *
     */
    P.comparedTo = P.cmp = function (y) {
      var i, j, xdL, ydL,
        x = this,
        xd = x.d,
        yd = (y = new x.constructor(y)).d,
        xs = x.s,
        ys = y.s;

      // Either NaN or Infinity?
      if (!xd || !yd) {
        return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
      }

      // Either zero?
      if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;

      // Signs differ?
      if (xs !== ys) return xs;

      // Compare exponents.
      if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;

      xdL = xd.length;
      ydL = yd.length;

      // Compare digit by digit.
      for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
        if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
      }

      // Compare lengths.
      return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
    };


    /*
     * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-1, 1]
     *
     * cos(0)         = 1
     * cos(-0)        = 1
     * cos(Infinity)  = NaN
     * cos(-Infinity) = NaN
     * cos(NaN)       = NaN
     *
     */
    P.cosine = P.cos = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (!x.d) return new Ctor(NaN);

      // cos(0) = cos(-0) = 1
      if (!x.d[0]) return new Ctor(1);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
      Ctor.rounding = 1;

      x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
    };


    /*
     *
     * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     *  cbrt(0)  =  0
     *  cbrt(-0) = -0
     *  cbrt(1)  =  1
     *  cbrt(-1) = -1
     *  cbrt(N)  =  N
     *  cbrt(-I) = -I
     *  cbrt(I)  =  I
     *
     * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
     *
     */
    P.cubeRoot = P.cbrt = function () {
      var e, m, n, r, rep, s, sd, t, t3, t3plusx,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite() || x.isZero()) return new Ctor(x);
      external = false;

      // Initial estimate.
      s = x.s * mathpow(x.s * x, 1 / 3);

       // Math.cbrt underflow/overflow?
       // Pass x to Math.pow as integer, then adjust the exponent of the result.
      if (!s || Math.abs(s) == 1 / 0) {
        n = digitsToString(x.d);
        e = x.e;

        // Adjust n exponent so it is a multiple of 3 away from x exponent.
        if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
        s = mathpow(n, 1 / 3);

        // Rarely, e may be one less than the result exponent value.
        e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new Ctor(n);
        r.s = x.s;
      } else {
        r = new Ctor(s.toString());
      }

      sd = (e = Ctor.precision) + 3;

      // Halley's method.
      // TODO? Compare Newton's method.
      for (;;) {
        t = r;
        t3 = t.times(t).times(t);
        t3plusx = t3.plus(x);
        r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);

        // TODO? Replace with for-loop and checkRoundingDigits.
        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
          n = n.slice(sd - 3, sd + 1);

          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
          // , i.e. approaching a rounding boundary, continue the iteration.
          if (n == '9999' || !rep && n == '4999') {

            // On the first iteration only, check to see if rounding up gives the exact result as the
            // nines may infinitely repeat.
            if (!rep) {
              finalise(t, e + 1, 0);

              if (t.times(t).times(t).eq(x)) {
                r = t;
                break;
              }
            }

            sd += 4;
            rep = 1;
          } else {

            // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
            // If not, then there are further digits and m will be truthy.
            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

              // Truncate to the first rounding digit.
              finalise(r, e + 1, 1);
              m = !r.times(r).times(r).eq(x);
            }

            break;
          }
        }
      }

      external = true;

      return finalise(r, e, Ctor.rounding, m);
    };


    /*
     * Return the number of decimal places of the value of this Decimal.
     *
     */
    P.decimalPlaces = P.dp = function () {
      var w,
        d = this.d,
        n = NaN;

      if (d) {
        w = d.length - 1;
        n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;

        // Subtract the number of trailing zeros of the last word.
        w = d[w];
        if (w) for (; w % 10 == 0; w /= 10) n--;
        if (n < 0) n = 0;
      }

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     */
    P.dividedBy = P.div = function (y) {
      return divide(this, new this.constructor(y));
    };


    /*
     * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
     * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.
     *
     */
    P.dividedToIntegerBy = P.divToInt = function (y) {
      var x = this,
        Ctor = x.constructor;
      return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
    };


    /*
     * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
     *
     */
    P.equals = P.eq = function (y) {
      return this.cmp(y) === 0;
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
     * direction of negative Infinity.
     *
     */
    P.floor = function () {
      return finalise(new this.constructor(this), this.e + 1, 3);
    };


    /*
     * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
     * false.
     *
     */
    P.greaterThan = P.gt = function (y) {
      return this.cmp(y) > 0;
    };


    /*
     * Return true if the value of this Decimal is greater than or equal to the value of `y`,
     * otherwise return false.
     *
     */
    P.greaterThanOrEqualTo = P.gte = function (y) {
      var k = this.cmp(y);
      return k == 1 || k === 0;
    };


    /*
     * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this
     * Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [1, Infinity]
     *
     * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...
     *
     * cosh(0)         = 1
     * cosh(-0)        = 1
     * cosh(Infinity)  = Infinity
     * cosh(-Infinity) = Infinity
     * cosh(NaN)       = NaN
     *
     *  x        time taken (ms)   result
     * 1000      9                 9.8503555700852349694e+433
     * 10000     25                4.4034091128314607936e+4342
     * 100000    171               1.4033316802130615897e+43429
     * 1000000   3817              1.5166076984010437725e+434294
     * 10000000  abandoned after 2 minute wait
     *
     * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))
     *
     */
    P.hyperbolicCosine = P.cosh = function () {
      var k, n, pr, rm, len,
        x = this,
        Ctor = x.constructor,
        one = new Ctor(1);

      if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
      if (x.isZero()) return one;

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
      Ctor.rounding = 1;
      len = x.d.length;

      // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
      // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))

      // Estimate the optimum number of times to use the argument reduction.
      // TODO? Estimation reused from cosine() and may not be optimal here.
      if (len < 32) {
        k = Math.ceil(len / 3);
        n = (1 / tinyPow(4, k)).toString();
      } else {
        k = 16;
        n = '2.3283064365386962890625e-10';
      }

      x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);

      // Reverse argument reduction
      var cosh2_x,
        i = k,
        d8 = new Ctor(8);
      for (; i--;) {
        cosh2_x = x.times(x);
        x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
      }

      return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
    };


    /*
     * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this
     * Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-Infinity, Infinity]
     *
     * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...
     *
     * sinh(0)         = 0
     * sinh(-0)        = -0
     * sinh(Infinity)  = Infinity
     * sinh(-Infinity) = -Infinity
     * sinh(NaN)       = NaN
     *
     * x        time taken (ms)
     * 10       2 ms
     * 100      5 ms
     * 1000     14 ms
     * 10000    82 ms
     * 100000   886 ms            1.4033316802130615897e+43429
     * 200000   2613 ms
     * 300000   5407 ms
     * 400000   8824 ms
     * 500000   13026 ms          8.7080643612718084129e+217146
     * 1000000  48543 ms
     *
     * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))
     *
     */
    P.hyperbolicSine = P.sinh = function () {
      var k, pr, rm, len,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite() || x.isZero()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
      Ctor.rounding = 1;
      len = x.d.length;

      if (len < 3) {
        x = taylorSeries(Ctor, 2, x, x, true);
      } else {

        // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
        // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
        // 3 multiplications and 1 addition

        // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
        // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
        // 4 multiplications and 2 additions

        // Estimate the optimum number of times to use the argument reduction.
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;

        x = x.times(1 / tinyPow(5, k));
        x = taylorSeries(Ctor, 2, x, x, true);

        // Reverse argument reduction
        var sinh2_x,
          d5 = new Ctor(5),
          d16 = new Ctor(16),
          d20 = new Ctor(20);
        for (; k--;) {
          sinh2_x = x.times(x);
          x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
        }
      }

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return finalise(x, pr, rm, true);
    };


    /*
     * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this
     * Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-1, 1]
     *
     * tanh(x) = sinh(x) / cosh(x)
     *
     * tanh(0)         = 0
     * tanh(-0)        = -0
     * tanh(Infinity)  = 1
     * tanh(-Infinity) = -1
     * tanh(NaN)       = NaN
     *
     */
    P.hyperbolicTangent = P.tanh = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite()) return new Ctor(x.s);
      if (x.isZero()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 7;
      Ctor.rounding = 1;

      return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
    };


    /*
     * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
     * this Decimal.
     *
     * Domain: [-1, 1]
     * Range: [0, pi]
     *
     * acos(x) = pi/2 - asin(x)
     *
     * acos(0)       = pi/2
     * acos(-0)      = pi/2
     * acos(1)       = 0
     * acos(-1)      = pi
     * acos(1/2)     = pi/3
     * acos(-1/2)    = 2*pi/3
     * acos(|x| > 1) = NaN
     * acos(NaN)     = NaN
     *
     */
    P.inverseCosine = P.acos = function () {
      var halfPi,
        x = this,
        Ctor = x.constructor,
        k = x.abs().cmp(1),
        pr = Ctor.precision,
        rm = Ctor.rounding;

      if (k !== -1) {
        return k === 0
          // |x| is 1
          ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)
          // |x| > 1 or x is NaN
          : new Ctor(NaN);
      }

      if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

      // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

      Ctor.precision = pr + 6;
      Ctor.rounding = 1;

      x = x.asin();
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return halfPi.minus(x);
    };


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the
     * value of this Decimal.
     *
     * Domain: [1, Infinity]
     * Range: [0, Infinity]
     *
     * acosh(x) = ln(x + sqrt(x^2 - 1))
     *
     * acosh(x < 1)     = NaN
     * acosh(NaN)       = NaN
     * acosh(Infinity)  = Infinity
     * acosh(-Infinity) = NaN
     * acosh(0)         = NaN
     * acosh(-0)        = NaN
     * acosh(1)         = 0
     * acosh(-1)        = NaN
     *
     */
    P.inverseHyperbolicCosine = P.acosh = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
      if (!x.isFinite()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
      Ctor.rounding = 1;
      external = false;

      x = x.times(x).minus(1).sqrt().plus(x);

      external = true;
      Ctor.precision = pr;
      Ctor.rounding = rm;

      return x.ln();
    };


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
     * of this Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-Infinity, Infinity]
     *
     * asinh(x) = ln(x + sqrt(x^2 + 1))
     *
     * asinh(NaN)       = NaN
     * asinh(Infinity)  = Infinity
     * asinh(-Infinity) = -Infinity
     * asinh(0)         = 0
     * asinh(-0)        = -0
     *
     */
    P.inverseHyperbolicSine = P.asinh = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite() || x.isZero()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
      Ctor.rounding = 1;
      external = false;

      x = x.times(x).plus(1).sqrt().plus(x);

      external = true;
      Ctor.precision = pr;
      Ctor.rounding = rm;

      return x.ln();
    };


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the
     * value of this Decimal.
     *
     * Domain: [-1, 1]
     * Range: [-Infinity, Infinity]
     *
     * atanh(x) = 0.5 * ln((1 + x) / (1 - x))
     *
     * atanh(|x| > 1)   = NaN
     * atanh(NaN)       = NaN
     * atanh(Infinity)  = NaN
     * atanh(-Infinity) = NaN
     * atanh(0)         = 0
     * atanh(-0)        = -0
     * atanh(1)         = Infinity
     * atanh(-1)        = -Infinity
     *
     */
    P.inverseHyperbolicTangent = P.atanh = function () {
      var pr, rm, wpr, xsd,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite()) return new Ctor(NaN);
      if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      xsd = x.sd();

      if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);

      Ctor.precision = wpr = xsd - x.e;

      x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);

      Ctor.precision = pr + 4;
      Ctor.rounding = 1;

      x = x.ln();

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return x.times(0.5);
    };


    /*
     * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this
     * Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-pi/2, pi/2]
     *
     * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))
     *
     * asin(0)       = 0
     * asin(-0)      = -0
     * asin(1/2)     = pi/6
     * asin(-1/2)    = -pi/6
     * asin(1)       = pi/2
     * asin(-1)      = -pi/2
     * asin(|x| > 1) = NaN
     * asin(NaN)     = NaN
     *
     * TODO? Compare performance of Taylor series.
     *
     */
    P.inverseSine = P.asin = function () {
      var halfPi, k,
        pr, rm,
        x = this,
        Ctor = x.constructor;

      if (x.isZero()) return new Ctor(x);

      k = x.abs().cmp(1);
      pr = Ctor.precision;
      rm = Ctor.rounding;

      if (k !== -1) {

        // |x| is 1
        if (k === 0) {
          halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
          halfPi.s = x.s;
          return halfPi;
        }

        // |x| > 1 or x is NaN
        return new Ctor(NaN);
      }

      // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

      Ctor.precision = pr + 6;
      Ctor.rounding = 1;

      x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return x.times(2);
    };


    /*
     * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value
     * of this Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-pi/2, pi/2]
     *
     * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
     *
     * atan(0)         = 0
     * atan(-0)        = -0
     * atan(1)         = pi/4
     * atan(-1)        = -pi/4
     * atan(Infinity)  = pi/2
     * atan(-Infinity) = -pi/2
     * atan(NaN)       = NaN
     *
     */
    P.inverseTangent = P.atan = function () {
      var i, j, k, n, px, t, r, wpr, x2,
        x = this,
        Ctor = x.constructor,
        pr = Ctor.precision,
        rm = Ctor.rounding;

      if (!x.isFinite()) {
        if (!x.s) return new Ctor(NaN);
        if (pr + 4 <= PI_PRECISION) {
          r = getPi(Ctor, pr + 4, rm).times(0.5);
          r.s = x.s;
          return r;
        }
      } else if (x.isZero()) {
        return new Ctor(x);
      } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.25);
        r.s = x.s;
        return r;
      }

      Ctor.precision = wpr = pr + 10;
      Ctor.rounding = 1;

      // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

      // Argument reduction
      // Ensure |x| < 0.42
      // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

      k = Math.min(28, wpr / LOG_BASE + 2 | 0);

      for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

      external = false;

      j = Math.ceil(wpr / LOG_BASE);
      n = 1;
      x2 = x.times(x);
      r = new Ctor(x);
      px = x;

      // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
      for (; i !== -1;) {
        px = px.times(x2);
        t = r.minus(px.div(n += 2));

        px = px.times(x2);
        r = t.plus(px.div(n += 2));

        if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);
      }

      if (k) r = r.times(2 << (k - 1));

      external = true;

      return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
    };


    /*
     * Return true if the value of this Decimal is a finite number, otherwise return false.
     *
     */
    P.isFinite = function () {
      return !!this.d;
    };


    /*
     * Return true if the value of this Decimal is an integer, otherwise return false.
     *
     */
    P.isInteger = P.isInt = function () {
      return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
    };


    /*
     * Return true if the value of this Decimal is NaN, otherwise return false.
     *
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this Decimal is negative, otherwise return false.
     *
     */
    P.isNegative = P.isNeg = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this Decimal is positive, otherwise return false.
     *
     */
    P.isPositive = P.isPos = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this Decimal is 0 or -0, otherwise return false.
     *
     */
    P.isZero = function () {
      return !!this.d && this.d[0] === 0;
    };


    /*
     * Return true if the value of this Decimal is less than `y`, otherwise return false.
     *
     */
    P.lessThan = P.lt = function (y) {
      return this.cmp(y) < 0;
    };


    /*
     * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
     *
     */
    P.lessThanOrEqualTo = P.lte = function (y) {
      return this.cmp(y) < 1;
    };


    /*
     * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * If no base is specified, return log[10](arg).
     *
     * log[base](arg) = ln(arg) / ln(base)
     *
     * The result will always be correctly rounded if the base of the log is 10, and 'almost always'
     * otherwise:
     *
     * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
     * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
     * between the result and the correctly rounded result will be one ulp (unit in the last place).
     *
     * log[-b](a)       = NaN
     * log[0](a)        = NaN
     * log[1](a)        = NaN
     * log[NaN](a)      = NaN
     * log[Infinity](a) = NaN
     * log[b](0)        = -Infinity
     * log[b](-0)       = -Infinity
     * log[b](-a)       = NaN
     * log[b](1)        = 0
     * log[b](Infinity) = Infinity
     * log[b](NaN)      = NaN
     *
     * [base] {number|string|Decimal} The base of the logarithm.
     *
     */
    P.logarithm = P.log = function (base) {
      var isBase10, d, denominator, k, inf, num, sd, r,
        arg = this,
        Ctor = arg.constructor,
        pr = Ctor.precision,
        rm = Ctor.rounding,
        guard = 5;

      // Default base is 10.
      if (base == null) {
        base = new Ctor(10);
        isBase10 = true;
      } else {
        base = new Ctor(base);
        d = base.d;

        // Return NaN if base is negative, or non-finite, or is 0 or 1.
        if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);

        isBase10 = base.eq(10);
      }

      d = arg.d;

      // Is arg negative, non-finite, 0 or 1?
      if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
        return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
      }

      // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
      // integer power of 10.
      if (isBase10) {
        if (d.length > 1) {
          inf = true;
        } else {
          for (k = d[0]; k % 10 === 0;) k /= 10;
          inf = k !== 1;
        }
      }

      external = false;
      sd = pr + guard;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);

      // The result will have 5 rounding digits.
      r = divide(num, denominator, sd, 1);

      // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
      // calculate 10 further digits.
      //
      // If the result is known to have an infinite decimal expansion, repeat this until it is clear
      // that the result is above or below the boundary. Otherwise, if after calculating the 10
      // further digits, the last 14 are nines, round up and assume the result is exact.
      // Also assume the result is exact if the last 14 are zero.
      //
      // Example of a result that will be incorrectly rounded:
      // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
      // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
      // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
      // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
      // place is still 2.6.
      if (checkRoundingDigits(r.d, k = pr, rm)) {

        do {
          sd += 10;
          num = naturalLogarithm(arg, sd);
          denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
          r = divide(num, denominator, sd, 1);

          if (!inf) {

            // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
            if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
              r = finalise(r, pr + 1, 0);
            }

            break;
          }
        } while (checkRoundingDigits(r.d, k += 10, rm));
      }

      external = true;

      return finalise(r, pr, rm);
    };


    /*
     * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.
     *
     * arguments {number|string|Decimal}
     *
    P.max = function () {
      Array.prototype.push.call(arguments, this);
      return maxOrMin(this.constructor, arguments, 'lt');
    };
     */


    /*
     * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.
     *
     * arguments {number|string|Decimal}
     *
    P.min = function () {
      Array.prototype.push.call(arguments, this);
      return maxOrMin(this.constructor, arguments, 'gt');
    };
     */


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     */
    P.minus = P.sub = function (y) {
      var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,
        x = this,
        Ctor = x.constructor;

      y = new Ctor(y);

      // If either is not finite...
      if (!x.d || !y.d) {

        // Return NaN if either is NaN.
        if (!x.s || !y.s) y = new Ctor(NaN);

        // Return y negated if x is finite and y is Infinity.
        else if (x.d) y.s = -y.s;

        // Return x if y is finite and x is Infinity.
        // Return x if both are Infinity with different signs.
        // Return NaN if both are Infinity with the same sign.
        else y = new Ctor(y.d || x.s !== y.s ? x : NaN);

        return y;
      }

      // If signs differ...
      if (x.s != y.s) {
        y.s = -y.s;
        return x.plus(y);
      }

      xd = x.d;
      yd = y.d;
      pr = Ctor.precision;
      rm = Ctor.rounding;

      // If either is zero...
      if (!xd[0] || !yd[0]) {

        // Return y negated if x is zero and y is non-zero.
        if (yd[0]) y.s = -y.s;

        // Return x if y is zero and x is non-zero.
        else if (xd[0]) y = new Ctor(x);

        // Return zero if both are zero.
        // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
        else return new Ctor(rm === 3 ? -0 : 0);

        return external ? finalise(y, pr, rm) : y;
      }

      // x and y are finite, non-zero numbers with the same sign.

      // Calculate base 1e7 exponents.
      e = mathfloor(y.e / LOG_BASE);
      xe = mathfloor(x.e / LOG_BASE);

      xd = xd.slice();
      k = xe - e;

      // If base 1e7 exponents differ...
      if (k) {
        xLTy = k < 0;

        if (xLTy) {
          d = xd;
          k = -k;
          len = yd.length;
        } else {
          d = yd;
          e = xe;
          len = xd.length;
        }

        // Numbers with massively different exponents would result in a very high number of
        // zeros needing to be prepended, but this can be avoided while still ensuring correct
        // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
        i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

        if (k > i) {
          k = i;
          d.length = 1;
        }

        // Prepend zeros to equalise exponents.
        d.reverse();
        for (i = k; i--;) d.push(0);
        d.reverse();

      // Base 1e7 exponents equal.
      } else {

        // Check digits to determine which is the bigger number.

        i = xd.length;
        len = yd.length;
        xLTy = i < len;
        if (xLTy) len = i;

        for (i = 0; i < len; i++) {
          if (xd[i] != yd[i]) {
            xLTy = xd[i] < yd[i];
            break;
          }
        }

        k = 0;
      }

      if (xLTy) {
        d = xd;
        xd = yd;
        yd = d;
        y.s = -y.s;
      }

      len = xd.length;

      // Append zeros to `xd` if shorter.
      // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
      for (i = yd.length - len; i > 0; --i) xd[len++] = 0;

      // Subtract yd from xd.
      for (i = yd.length; i > k;) {

        if (xd[--i] < yd[i]) {
          for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
          --xd[j];
          xd[i] += BASE;
        }

        xd[i] -= yd[i];
      }

      // Remove trailing zeros.
      for (; xd[--len] === 0;) xd.pop();

      // Remove leading zeros and adjust exponent accordingly.
      for (; xd[0] === 0; xd.shift()) --e;

      // Zero?
      if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);

      y.d = xd;
      y.e = getBase10Exponent(xd, e);

      return external ? finalise(y, pr, rm) : y;
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     * The result depends on the modulo mode.
     *
     */
    P.modulo = P.mod = function (y) {
      var q,
        x = this,
        Ctor = x.constructor;

      y = new Ctor(y);

      // Return NaN if x is Infinity or NaN, or y is NaN or 0.
      if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);

      // Return x if y is Infinity or x is 0.
      if (!y.d || x.d && !x.d[0]) {
        return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
      }

      // Prevent rounding of intermediate calculations.
      external = false;

      if (Ctor.modulo == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // result = x - q * y    where  0 <= result < abs(y)
        q = divide(x, y.abs(), 0, 3, 1);
        q.s *= y.s;
      } else {
        q = divide(x, y, 0, Ctor.modulo, 1);
      }

      q = q.times(y);

      external = true;

      return x.minus(q);
    };


    /*
     * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
     * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     */
    P.naturalExponential = P.exp = function () {
      return naturalExponential(this);
    };


    /*
     * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
     * rounded to `precision` significant digits using rounding mode `rounding`.
     *
     */
    P.naturalLogarithm = P.ln = function () {
      return naturalLogarithm(this);
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
     * -1.
     *
     */
    P.negated = P.neg = function () {
      var x = new this.constructor(this);
      x.s = -x.s;
      return finalise(x);
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     */
    P.plus = P.add = function (y) {
      var carry, d, e, i, k, len, pr, rm, xd, yd,
        x = this,
        Ctor = x.constructor;

      y = new Ctor(y);

      // If either is not finite...
      if (!x.d || !y.d) {

        // Return NaN if either is NaN.
        if (!x.s || !y.s) y = new Ctor(NaN);

        // Return x if y is finite and x is Infinity.
        // Return x if both are Infinity with the same sign.
        // Return NaN if both are Infinity with different signs.
        // Return y if x is finite and y is Infinity.
        else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);

        return y;
      }

       // If signs differ...
      if (x.s != y.s) {
        y.s = -y.s;
        return x.minus(y);
      }

      xd = x.d;
      yd = y.d;
      pr = Ctor.precision;
      rm = Ctor.rounding;

      // If either is zero...
      if (!xd[0] || !yd[0]) {

        // Return x if y is zero.
        // Return y if y is non-zero.
        if (!yd[0]) y = new Ctor(x);

        return external ? finalise(y, pr, rm) : y;
      }

      // x and y are finite, non-zero numbers with the same sign.

      // Calculate base 1e7 exponents.
      k = mathfloor(x.e / LOG_BASE);
      e = mathfloor(y.e / LOG_BASE);

      xd = xd.slice();
      i = k - e;

      // If base 1e7 exponents differ...
      if (i) {

        if (i < 0) {
          d = xd;
          i = -i;
          len = yd.length;
        } else {
          d = yd;
          e = k;
          len = xd.length;
        }

        // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
        k = Math.ceil(pr / LOG_BASE);
        len = k > len ? k + 1 : len + 1;

        if (i > len) {
          i = len;
          d.length = 1;
        }

        // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
        d.reverse();
        for (; i--;) d.push(0);
        d.reverse();
      }

      len = xd.length;
      i = yd.length;

      // If yd is longer than xd, swap xd and yd so xd points to the longer array.
      if (len - i < 0) {
        i = len;
        d = yd;
        yd = xd;
        xd = d;
      }

      // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
      for (carry = 0; i;) {
        carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
        xd[i] %= BASE;
      }

      if (carry) {
        xd.unshift(carry);
        ++e;
      }

      // Remove trailing zeros.
      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      for (len = xd.length; xd[--len] == 0;) xd.pop();

      y.d = xd;
      y.e = getBase10Exponent(xd, e);

      return external ? finalise(y, pr, rm) : y;
    };


    /*
     * Return the number of significant digits of the value of this Decimal.
     *
     * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
     *
     */
    P.precision = P.sd = function (z) {
      var k,
        x = this;

      if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

      if (x.d) {
        k = getPrecision(x.d);
        if (z && x.e + 1 > k) k = x.e + 1;
      } else {
        k = NaN;
      }

      return k;
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
     * rounding mode `rounding`.
     *
     */
    P.round = function () {
      var x = this,
        Ctor = x.constructor;

      return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
    };


    /*
     * Return a new Decimal whose value is the sine of the value in radians of this Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-1, 1]
     *
     * sin(x) = x - x^3/3! + x^5/5! - ...
     *
     * sin(0)         = 0
     * sin(-0)        = -0
     * sin(Infinity)  = NaN
     * sin(-Infinity) = NaN
     * sin(NaN)       = NaN
     *
     */
    P.sine = P.sin = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite()) return new Ctor(NaN);
      if (x.isZero()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
      Ctor.rounding = 1;

      x = sine(Ctor, toLessThanHalfPi(Ctor, x));

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
    };


    /*
     * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     *  sqrt(-n) =  N
     *  sqrt(N)  =  N
     *  sqrt(-I) =  N
     *  sqrt(I)  =  I
     *  sqrt(0)  =  0
     *  sqrt(-0) = -0
     *
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, sd, r, rep, t,
        x = this,
        d = x.d,
        e = x.e,
        s = x.s,
        Ctor = x.constructor;

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !d || !d[0]) {
        return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
      }

      external = false;

      // Initial estimate.
      s = Math.sqrt(+x);

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = digitsToString(d);

        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(n);
        e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '1e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new Ctor(n);
      } else {
        r = new Ctor(s.toString());
      }

      sd = (e = Ctor.precision) + 3;

      // Newton-Raphson iteration.
      for (;;) {
        t = r;
        r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);

        // TODO? Replace with for-loop and checkRoundingDigits.
        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
          n = n.slice(sd - 3, sd + 1);

          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
          // 4999, i.e. approaching a rounding boundary, continue the iteration.
          if (n == '9999' || !rep && n == '4999') {

            // On the first iteration only, check to see if rounding up gives the exact result as the
            // nines may infinitely repeat.
            if (!rep) {
              finalise(t, e + 1, 0);

              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }

            sd += 4;
            rep = 1;
          } else {

            // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
            // If not, then there are further digits and m will be truthy.
            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

              // Truncate to the first rounding digit.
              finalise(r, e + 1, 1);
              m = !r.times(r).eq(x);
            }

            break;
          }
        }
      }

      external = true;

      return finalise(r, e, Ctor.rounding, m);
    };


    /*
     * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-Infinity, Infinity]
     *
     * tan(0)         = 0
     * tan(-0)        = -0
     * tan(Infinity)  = NaN
     * tan(-Infinity) = NaN
     * tan(NaN)       = NaN
     *
     */
    P.tangent = P.tan = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite()) return new Ctor(NaN);
      if (x.isZero()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 10;
      Ctor.rounding = 1;

      x = x.sin();
      x.s = 1;
      x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     */
    P.times = P.mul = function (y) {
      var carry, e, i, k, r, rL, t, xdL, ydL,
        x = this,
        Ctor = x.constructor,
        xd = x.d,
        yd = (y = new Ctor(y)).d;

      y.s *= x.s;

       // If either is NaN, Infinity or 0...
      if (!xd || !xd[0] || !yd || !yd[0]) {

        return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd

          // Return NaN if either is NaN.
          // Return NaN if x is 0 and y is Infinity, or y is 0 and x is Infinity.
          ? NaN

          // Return Infinity if either is Infinity.
          // Return 0 if either is 0.
          : !xd || !yd ? y.s / 0 : y.s * 0);
      }

      e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
      xdL = xd.length;
      ydL = yd.length;

      // Ensure xd points to the longer array.
      if (xdL < ydL) {
        r = xd;
        xd = yd;
        yd = r;
        rL = xdL;
        xdL = ydL;
        ydL = rL;
      }

      // Initialise the result array with zeros.
      r = [];
      rL = xdL + ydL;
      for (i = rL; i--;) r.push(0);

      // Multiply!
      for (i = ydL; --i >= 0;) {
        carry = 0;
        for (k = xdL + i; k > i;) {
          t = r[k] + yd[i] * xd[k - i - 1] + carry;
          r[k--] = t % BASE | 0;
          carry = t / BASE | 0;
        }

        r[k] = (r[k] + carry) % BASE | 0;
      }

      // Remove trailing zeros.
      for (; !r[--rL];) r.pop();

      if (carry) ++e;
      else r.shift();

      y.d = r;
      y.e = getBase10Exponent(r, e);

      return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
    };


    /*
     * Return a string representing the value of this Decimal in base 2, round to `sd` significant
     * digits using rounding mode `rm`.
     *
     * If the optional `sd` argument is present then return binary exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toBinary = function (sd, rm) {
      return toStringBinary(this, 2, sd, rm);
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
     * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
     *
     * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toDecimalPlaces = P.toDP = function (dp, rm) {
      var x = this,
        Ctor = x.constructor;

      x = new Ctor(x);
      if (dp === void 0) return x;

      checkInt32(dp, 0, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      return finalise(x, dp + x.e + 1, rm);
    };


    /*
     * Return a string representing the value of this Decimal in exponential notation rounded to
     * `dp` fixed decimal places using rounding mode `rounding`.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toExponential = function (dp, rm) {
      var str,
        x = this,
        Ctor = x.constructor;

      if (dp === void 0) {
        str = finiteToString(x, true);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);

        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);

        x = finalise(new Ctor(x), dp + 1, rm);
        str = finiteToString(x, true, dp + 1);
      }

      return x.isNeg() && !x.isZero() ? '-' + str : str;
    };


    /*
     * Return a string representing the value of this Decimal in normal (fixed-point) notation to
     * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
     * omitted.
     *
     * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
     * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
     * (-0).toFixed(3) is '0.000'.
     * (-0.5).toFixed(0) is '-0'.
     *
     */
    P.toFixed = function (dp, rm) {
      var str, y,
        x = this,
        Ctor = x.constructor;

      if (dp === void 0) {
        str = finiteToString(x);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);

        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);

        y = finalise(new Ctor(x), dp + x.e + 1, rm);
        str = finiteToString(y, false, dp + y.e + 1);
      }

      // To determine whether to add the minus sign look at the value before it was rounded,
      // i.e. look at `x` rather than `y`.
      return x.isNeg() && !x.isZero() ? '-' + str : str;
    };


    /*
     * Return an array representing the value of this Decimal as a simple fraction with an integer
     * numerator and an integer denominator.
     *
     * The denominator will be a positive non-zero value less than or equal to the specified maximum
     * denominator. If a maximum denominator is not specified, the denominator will be the lowest
     * value necessary to represent the number exactly.
     *
     * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
     *
     */
    P.toFraction = function (maxD) {
      var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,
        x = this,
        xd = x.d,
        Ctor = x.constructor;

      if (!xd) return new Ctor(x);

      n1 = d0 = new Ctor(1);
      d1 = n0 = new Ctor(0);

      d = new Ctor(d1);
      e = d.e = getPrecision(xd) - x.e - 1;
      k = e % LOG_BASE;
      d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);

      if (maxD == null) {

        // d is 10**e, the minimum max-denominator needed.
        maxD = e > 0 ? d : n1;
      } else {
        n = new Ctor(maxD);
        if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
        maxD = n.gt(d) ? (e > 0 ? d : n1) : n;
      }

      external = false;
      n = new Ctor(digitsToString(xd));
      pr = Ctor.precision;
      Ctor.precision = e = xd.length * LOG_BASE * 2;

      for (;;)  {
        q = divide(n, d, 0, 1, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.cmp(maxD) == 1) break;
        d0 = d1;
        d1 = d2;
        d2 = n1;
        n1 = n0.plus(q.times(d2));
        n0 = d2;
        d2 = d;
        d = n.minus(q.times(d2));
        n = d2;
      }

      d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;

      // Determine which fraction is closer to x, n0/d0 or n1/d1?
      r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1
          ? [n1, d1] : [n0, d0];

      Ctor.precision = pr;
      external = true;

      return r;
    };


    /*
     * Return a string representing the value of this Decimal in base 16, round to `sd` significant
     * digits using rounding mode `rm`.
     *
     * If the optional `sd` argument is present then return binary exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toHexadecimal = P.toHex = function (sd, rm) {
      return toStringBinary(this, 16, sd, rm);
    };


    /*
     * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding
     * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.
     *
     * The return value will always have the same sign as this Decimal, unless either this Decimal
     * or `y` is NaN, in which case the return value will be also be NaN.
     *
     * The return value is not affected by the value of `precision`.
     *
     * y {number|string|Decimal} The magnitude to round to a multiple of.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * 'toNearest() rounding mode not an integer: {rm}'
     * 'toNearest() rounding mode out of range: {rm}'
     *
     */
    P.toNearest = function (y, rm) {
      var x = this,
        Ctor = x.constructor;

      x = new Ctor(x);

      if (y == null) {

        // If x is not finite, return x.
        if (!x.d) return x;

        y = new Ctor(1);
        rm = Ctor.rounding;
      } else {
        y = new Ctor(y);
        if (rm === void 0) {
          rm = Ctor.rounding;
        } else {
          checkInt32(rm, 0, 8);
        }

        // If x is not finite, return x if y is not NaN, else NaN.
        if (!x.d) return y.s ? x : y;

        // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.
        if (!y.d) {
          if (y.s) y.s = x.s;
          return y;
        }
      }

      // If y is not zero, calculate the nearest multiple of y to x.
      if (y.d[0]) {
        external = false;
        x = divide(x, y, 0, rm, 1).times(y);
        external = true;
        finalise(x);

      // If y is zero, return zero with the sign of x.
      } else {
        y.s = x.s;
        x = y;
      }

      return x;
    };


    /*
     * Return the value of this Decimal converted to a number primitive.
     * Zero keeps its sign.
     *
     */
    P.toNumber = function () {
      return +this;
    };


    /*
     * Return a string representing the value of this Decimal in base 8, round to `sd` significant
     * digits using rounding mode `rm`.
     *
     * If the optional `sd` argument is present then return binary exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toOctal = function (sd, rm) {
      return toStringBinary(this, 8, sd, rm);
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded
     * to `precision` significant digits using rounding mode `rounding`.
     *
     * ECMAScript compliant.
     *
     *   pow(x, NaN)                           = NaN
     *   pow(x, 0)                            = 1

     *   pow(NaN, non-zero)                    = NaN
     *   pow(abs(x) > 1, +Infinity)            = +Infinity
     *   pow(abs(x) > 1, -Infinity)            = +0
     *   pow(abs(x) == 1, Infinity)           = NaN
     *   pow(abs(x) < 1, +Infinity)            = +0
     *   pow(abs(x) < 1, -Infinity)            = +Infinity
     *   pow(+Infinity, y > 0)                 = +Infinity
     *   pow(+Infinity, y < 0)                 = +0
     *   pow(-Infinity, odd integer > 0)       = -Infinity
     *   pow(-Infinity, even integer > 0)      = +Infinity
     *   pow(-Infinity, odd integer < 0)       = -0
     *   pow(-Infinity, even integer < 0)      = +0
     *   pow(+0, y > 0)                        = +0
     *   pow(+0, y < 0)                        = +Infinity
     *   pow(-0, odd integer > 0)              = -0
     *   pow(-0, even integer > 0)             = +0
     *   pow(-0, odd integer < 0)              = -Infinity
     *   pow(-0, even integer < 0)             = +Infinity
     *   pow(finite x < 0, finite non-integer) = NaN
     *
     * For non-integer or very large exponents pow(x, y) is calculated using
     *
     *   x^y = exp(y*ln(x))
     *
     * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
     * probability of an incorrectly rounded result
     * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
     * i.e. 1 in 250,000,000,000,000
     *
     * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
     *
     * y {number|string|Decimal} The power to which to raise this Decimal.
     *
     */
    P.toPower = P.pow = function (y) {
      var e, k, pr, r, rm, s,
        x = this,
        Ctor = x.constructor,
        yn = +(y = new Ctor(y));

      // Either Infinity, NaN or 0?
      if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));

      x = new Ctor(x);

      if (x.eq(1)) return x;

      pr = Ctor.precision;
      rm = Ctor.rounding;

      if (y.eq(1)) return finalise(x, pr, rm);

      // y exponent
      e = mathfloor(y.e / LOG_BASE);

      // If y is a small integer use the 'exponentiation by squaring' algorithm.
      if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
        r = intPow(Ctor, x, k, pr);
        return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
      }

      s = x.s;

      // if x is negative
      if (s < 0) {

        // if y is not an integer
        if (e < y.d.length - 1) return new Ctor(NaN);

        // Result is positive if x is negative and the last digit of integer y is even.
        if ((y.d[e] & 1) == 0) s = 1;

        // if x.eq(-1)
        if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
          x.s = s;
          return x;
        }
      }

      // Estimate result exponent.
      // x^y = 10^e,  where e = y * log10(x)
      // log10(x) = log10(x_significand) + x_exponent
      // log10(x_significand) = ln(x_significand) / ln(10)
      k = mathpow(+x, yn);
      e = k == 0 || !isFinite(k)
        ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
        : new Ctor(k + '').e;

      // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

      // Overflow/underflow?
      if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);

      external = false;
      Ctor.rounding = x.s = 1;

      // Estimate the extra guard digits needed to ensure five correct rounding digits from
      // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
      // new Decimal(2.32456).pow('2087987436534566.46411')
      // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
      k = Math.min(12, (e + '').length);

      // r = x^y = exp(y*ln(x))
      r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);

      // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)
      if (r.d) {

        // Truncate to the required precision plus five rounding digits.
        r = finalise(r, pr + 5, 1);

        // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
        // the result.
        if (checkRoundingDigits(r.d, pr, rm)) {
          e = pr + 10;

          // Truncate to the increased precision plus five rounding digits.
          r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);

          // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
          if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }
        }
      }

      r.s = s;
      external = true;
      Ctor.rounding = rm;

      return finalise(r, pr, rm);
    };


    /*
     * Return a string representing the value of this Decimal rounded to `sd` significant digits
     * using rounding mode `rounding`.
     *
     * Return exponential notation if `sd` is less than the number of digits necessary to represent
     * the integer part of the value in normal notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toPrecision = function (sd, rm) {
      var str,
        x = this,
        Ctor = x.constructor;

      if (sd === void 0) {
        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      } else {
        checkInt32(sd, 1, MAX_DIGITS);

        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);

        x = finalise(new Ctor(x), sd, rm);
        str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
      }

      return x.isNeg() && !x.isZero() ? '-' + str : str;
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
     * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
     * omitted.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * 'toSD() digits out of range: {sd}'
     * 'toSD() digits not an integer: {sd}'
     * 'toSD() rounding mode not an integer: {rm}'
     * 'toSD() rounding mode out of range: {rm}'
     *
     */
    P.toSignificantDigits = P.toSD = function (sd, rm) {
      var x = this,
        Ctor = x.constructor;

      if (sd === void 0) {
        sd = Ctor.precision;
        rm = Ctor.rounding;
      } else {
        checkInt32(sd, 1, MAX_DIGITS);

        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
      }

      return finalise(new Ctor(x), sd, rm);
    };


    /*
     * Return a string representing the value of this Decimal.
     *
     * Return exponential notation if this Decimal has a positive exponent equal to or greater than
     * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
     *
     */
    P.toString = function () {
      var x = this,
        Ctor = x.constructor,
        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

      return x.isNeg() && !x.isZero() ? '-' + str : str;
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
     *
     */
    P.truncated = P.trunc = function () {
      return finalise(new this.constructor(this), this.e + 1, 1);
    };


    /*
     * Return a string representing the value of this Decimal.
     * Unlike `toString`, negative zero will include the minus sign.
     *
     */
    P.valueOf = P.toJSON = function () {
      var x = this,
        Ctor = x.constructor,
        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

      return x.isNeg() ? '-' + str : str;
    };


    /*
    // Add aliases to match BigDecimal method names.
    // P.add = P.plus;
    P.subtract = P.minus;
    P.multiply = P.times;
    P.divide = P.div;
    P.remainder = P.mod;
    P.compareTo = P.cmp;
    P.negate = P.neg;
     */


    // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.


    /*
     *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,
     *                           finiteToString, naturalExponential, naturalLogarithm
     *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,
     *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random
     *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm
     *  convertBase              toStringBinary, parseOther
     *  cos                      P.cos
     *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,
     *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,
     *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,
     *                           taylorSeries, atan2, parseOther
     *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,
     *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,
     *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,
     *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,
     *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,
     *                           P.truncated, divide, getLn10, getPi, naturalExponential,
     *                           naturalLogarithm, ceil, floor, round, trunc
     *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,
     *                           toStringBinary
     *  getBase10Exponent        P.minus, P.plus, P.times, parseOther
     *  getLn10                  P.logarithm, naturalLogarithm
     *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2
     *  getPrecision             P.precision, P.toFraction
     *  getZeroString            digitsToString, finiteToString
     *  intPow                   P.toPower, parseOther
     *  isOdd                    toLessThanHalfPi
     *  maxOrMin                 max, min
     *  naturalExponential       P.naturalExponential, P.toPower
     *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,
     *                           P.toPower, naturalExponential
     *  nonFiniteToString        finiteToString, toStringBinary
     *  parseDecimal             Decimal
     *  parseOther               Decimal
     *  sin                      P.sin
     *  taylorSeries             P.cosh, P.sinh, cos, sin
     *  toLessThanHalfPi         P.cos, P.sin
     *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal
     *  truncate                 intPow
     *
     *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,
     *                           naturalLogarithm, config, parseOther, random, Decimal
     */


    function digitsToString(d) {
      var i, k, ws,
        indexOfLastWord = d.length - 1,
        str = '',
        w = d[0];

      if (indexOfLastWord > 0) {
        str += w;
        for (i = 1; i < indexOfLastWord; i++) {
          ws = d[i] + '';
          k = LOG_BASE - ws.length;
          if (k) str += getZeroString(k);
          str += ws;
        }

        w = d[i];
        ws = w + '';
        k = LOG_BASE - ws.length;
        if (k) str += getZeroString(k);
      } else if (w === 0) {
        return '0';
      }

      // Remove trailing zeros of last w.
      for (; w % 10 === 0;) w /= 10;

      return str + w;
    }


    function checkInt32(i, min, max) {
      if (i !== ~~i || i < min || i > max) {
        throw Error(invalidArgument + i);
      }
    }


    /*
     * Check 5 rounding digits if `repeating` is null, 4 otherwise.
     * `repeating == null` if caller is `log` or `pow`,
     * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.
     */
    function checkRoundingDigits(d, i, rm, repeating) {
      var di, k, r, rd;

      // Get the length of the first word of the array d.
      for (k = d[0]; k >= 10; k /= 10) --i;

      // Is the rounding digit in the first word of d?
      if (--i < 0) {
        i += LOG_BASE;
        di = 0;
      } else {
        di = Math.ceil((i + 1) / LOG_BASE);
        i %= LOG_BASE;
      }

      // i is the index (0 - 6) of the rounding digit.
      // E.g. if within the word 3487563 the first rounding digit is 5,
      // then i = 4, k = 1000, rd = 3487563 % 1000 = 563
      k = mathpow(10, LOG_BASE - i);
      rd = d[di] % k | 0;

      if (repeating == null) {
        if (i < 3) {
          if (i == 0) rd = rd / 100 | 0;
          else if (i == 1) rd = rd / 10 | 0;
          r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
        } else {
          r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&
            (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||
              (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
        }
      } else {
        if (i < 4) {
          if (i == 0) rd = rd / 1000 | 0;
          else if (i == 1) rd = rd / 100 | 0;
          else if (i == 2) rd = rd / 10 | 0;
          r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
        } else {
          r = ((repeating || rm < 4) && rd + 1 == k ||
          (!repeating && rm > 3) && rd + 1 == k / 2) &&
            (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
        }
      }

      return r;
    }


    // Convert string of `baseIn` to an array of numbers of `baseOut`.
    // Eg. convertBase('255', 10, 16) returns [15, 15].
    // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
    function convertBase(str, baseIn, baseOut) {
      var j,
        arr = [0],
        arrL,
        i = 0,
        strL = str.length;

      for (; i < strL;) {
        for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;
        arr[0] += NUMERALS.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] === void 0) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }

      return arr.reverse();
    }


    /*
     * cos(x) = 1 - x^2/2! + x^4/4! - ...
     * |x| < pi/2
     *
     */
    function cosine(Ctor, x) {
      var k, y,
        len = x.d.length;

      // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1
      // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1

      // Estimate the optimum number of times to use the argument reduction.
      if (len < 32) {
        k = Math.ceil(len / 3);
        y = (1 / tinyPow(4, k)).toString();
      } else {
        k = 16;
        y = '2.3283064365386962890625e-10';
      }

      Ctor.precision += k;

      x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));

      // Reverse argument reduction
      for (var i = k; i--;) {
        var cos2x = x.times(x);
        x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
      }

      Ctor.precision -= k;

      return x;
    }


    /*
     * Perform division in the specified base.
     */
    var divide = (function () {

      // Assumes non-zero x and k, and hence non-zero result.
      function multiplyInteger(x, k, base) {
        var temp,
          carry = 0,
          i = x.length;

        for (x = x.slice(); i--;) {
          temp = x[i] * k + carry;
          x[i] = temp % base | 0;
          carry = temp / base | 0;
        }

        if (carry) x.unshift(carry);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, r;

        if (aL != bL) {
          r = aL > bL ? 1 : -1;
        } else {
          for (i = r = 0; i < aL; i++) {
            if (a[i] != b[i]) {
              r = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return r;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1;) a.shift();
      }

      return function (x, y, pr, rm, dp, base) {
        var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,
          yL, yz,
          Ctor = x.constructor,
          sign = x.s == y.s ? 1 : -1,
          xd = x.d,
          yd = y.d;

        // Either NaN, Infinity or 0?
        if (!xd || !xd[0] || !yd || !yd[0]) {

          return new Ctor(// Return NaN if either NaN, or both Infinity or 0.
            !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :

            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);
        }

        if (base) {
          logBase = 1;
          e = x.e - y.e;
        } else {
          base = BASE;
          logBase = LOG_BASE;
          e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
        }

        yL = yd.length;
        xL = xd.length;
        q = new Ctor(sign);
        qd = q.d = [];

        // Result exponent may be one less than e.
        // The digit array of a Decimal from toStringBinary may have trailing zeros.
        for (i = 0; yd[i] == (xd[i] || 0); i++);

        if (yd[i] > (xd[i] || 0)) e--;

        if (pr == null) {
          sd = pr = Ctor.precision;
          rm = Ctor.rounding;
        } else if (dp) {
          sd = pr + (x.e - y.e) + 1;
        } else {
          sd = pr;
        }

        if (sd < 0) {
          qd.push(1);
          more = true;
        } else {

          // Convert precision in number of base 10 digits to base 1e7 digits.
          sd = sd / logBase + 2 | 0;
          i = 0;

          // divisor < 1e7
          if (yL == 1) {
            k = 0;
            yd = yd[0];
            sd++;

            // k is the carry.
            for (; (i < xL || k) && sd--; i++) {
              t = k * base + (xd[i] || 0);
              qd[i] = t / yd | 0;
              k = t % yd | 0;
            }

            more = k || i < xL;

          // divisor >= 1e7
          } else {

            // Normalise xd and yd so highest order digit of yd is >= base/2
            k = base / (yd[0] + 1) | 0;

            if (k > 1) {
              yd = multiplyInteger(yd, k, base);
              xd = multiplyInteger(xd, k, base);
              yL = yd.length;
              xL = xd.length;
            }

            xi = yL;
            rem = xd.slice(0, yL);
            remL = rem.length;

            // Add zeros to make remainder as long as divisor.
            for (; remL < yL;) rem[remL++] = 0;

            yz = yd.slice();
            yz.unshift(0);
            yd0 = yd[0];

            if (yd[1] >= base / 2) ++yd0;

            do {
              k = 0;

              // Compare divisor and remainder.
              cmp = compare(yd, rem, yL, remL);

              // If divisor < remainder.
              if (cmp < 0) {

                // Calculate trial digit, k.
                rem0 = rem[0];
                if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

                // k will be how many times the divisor goes into the current remainder.
                k = rem0 / yd0 | 0;

                //  Algorithm:
                //  1. product = divisor * trial digit (k)
                //  2. if product > remainder: product -= divisor, k--
                //  3. remainder -= product
                //  4. if product was < remainder at 2:
                //    5. compare new remainder and divisor
                //    6. If remainder > divisor: remainder -= divisor, k++

                if (k > 1) {
                  if (k >= base) k = base - 1;

                  // product = divisor * trial digit.
                  prod = multiplyInteger(yd, k, base);
                  prodL = prod.length;
                  remL = rem.length;

                  // Compare product and remainder.
                  cmp = compare(prod, rem, prodL, remL);

                  // product > remainder.
                  if (cmp == 1) {
                    k--;

                    // Subtract divisor from product.
                    subtract(prod, yL < prodL ? yz : yd, prodL, base);
                  }
                } else {

                  // cmp is -1.
                  // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
                  // to avoid it. If k is 1 there is a need to compare yd and rem again below.
                  if (k == 0) cmp = k = 1;
                  prod = yd.slice();
                }

                prodL = prod.length;
                if (prodL < remL) prod.unshift(0);

                // Subtract product from remainder.
                subtract(rem, prod, remL, base);

                // If product was < previous remainder.
                if (cmp == -1) {
                  remL = rem.length;

                  // Compare divisor and new remainder.
                  cmp = compare(yd, rem, yL, remL);

                  // If divisor < new remainder, subtract divisor from remainder.
                  if (cmp < 1) {
                    k++;

                    // Subtract divisor from remainder.
                    subtract(rem, yL < remL ? yz : yd, remL, base);
                  }
                }

                remL = rem.length;
              } else if (cmp === 0) {
                k++;
                rem = [0];
              }    // if cmp === 1, k will be 0

              // Add the next digit, k, to the result array.
              qd[i++] = k;

              // Update the remainder.
              if (cmp && rem[0]) {
                rem[remL++] = xd[xi] || 0;
              } else {
                rem = [xd[xi]];
                remL = 1;
              }

            } while ((xi++ < xL || rem[0] !== void 0) && sd--);

            more = rem[0] !== void 0;
          }

          // Leading zero?
          if (!qd[0]) qd.shift();
        }

        // logBase is 1 when divide is being used for base conversion.
        if (logBase == 1) {
          q.e = e;
          inexact = more;
        } else {

          // To calculate q.e, first get the number of digits of qd[0].
          for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
          q.e = i + e * logBase - 1;

          finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
        }

        return q;
      };
    })();


    /*
     * Round `x` to `sd` significant digits using rounding mode `rm`.
     * Check for over/under-flow.
     */
     function finalise(x, sd, rm, isTruncated) {
      var digits, i, j, k, rd, roundUp, w, xd, xdi,
        Ctor = x.constructor;

      // Don't round if sd is null or undefined.
      out: if (sd != null) {
        xd = x.d;

        // Infinity/NaN.
        if (!xd) return x;

        // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
        // w: the word of xd containing rd, a base 1e7 number.
        // xdi: the index of w within xd.
        // digits: the number of digits of w.
        // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
        // they had leading zeros)
        // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).

        // Get the length of the first word of the digits array xd.
        for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
        i = sd - digits;

        // Is the rounding digit in the first word of xd?
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          w = xd[xdi = 0];

          // Get the rounding digit at index j of w.
          rd = w / mathpow(10, digits - j - 1) % 10 | 0;
        } else {
          xdi = Math.ceil((i + 1) / LOG_BASE);
          k = xd.length;
          if (xdi >= k) {
            if (isTruncated) {

              // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.
              for (; k++ <= xdi;) xd.push(0);
              w = rd = 0;
              digits = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            w = k = xd[xdi];

            // Get the number of digits of w.
            for (digits = 1; k >= 10; k /= 10) digits++;

            // Get the index of rd within w.
            i %= LOG_BASE;

            // Get the index of rd within w, adjusted for leading zeros.
            // The number of leading zeros of w is given by LOG_BASE - digits.
            j = i - LOG_BASE + digits;

            // Get the rounding digit at index j of w.
            rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
          }
        }

        // Are there any non-zero digits after the rounding digit?
        isTruncated = isTruncated || sd < 0 ||
          xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));

        // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right
        // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression
        // will give 714.

        roundUp = rm < 4
          ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
          : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||
              rm == (x.s < 0 ? 8 : 7));

        if (sd < 1 || !xd[0]) {
          xd.length = 0;
          if (roundUp) {

            // Convert sd to decimal places.
            sd -= x.e + 1;

            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
            xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
            x.e = -sd || 0;
          } else {

            // Zero.
            xd[0] = x.e = 0;
          }

          return x;
        }

        // Remove excess digits.
        if (i == 0) {
          xd.length = xdi;
          k = 1;
          xdi--;
        } else {
          xd.length = xdi + 1;
          k = mathpow(10, LOG_BASE - i);

          // E.g. 56700 becomes 56000 if 7 is the rounding digit.
          // j > 0 means i > number of leading zeros of w.
          xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
        }

        if (roundUp) {
          for (;;) {

            // Is the digit to be rounded up in the first word of xd?
            if (xdi == 0) {

              // i will be the length of xd[0] before k is added.
              for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
              j = xd[0] += k;
              for (k = 1; j >= 10; j /= 10) k++;

              // if i != k the length has increased.
              if (i != k) {
                x.e++;
                if (xd[0] == BASE) xd[0] = 1;
              }

              break;
            } else {
              xd[xdi] += k;
              if (xd[xdi] != BASE) break;
              xd[xdi--] = 0;
              k = 1;
            }
          }
        }

        // Remove trailing zeros.
        for (i = xd.length; xd[--i] === 0;) xd.pop();
      }

      if (external) {

        // Overflow?
        if (x.e > Ctor.maxE) {

          // Infinity.
          x.d = null;
          x.e = NaN;

        // Underflow?
        } else if (x.e < Ctor.minE) {

          // Zero.
          x.e = 0;
          x.d = [0];
          // Ctor.underflow = true;
        } // else Ctor.underflow = false;
      }

      return x;
    }


    function finiteToString(x, isExp, sd) {
      if (!x.isFinite()) return nonFiniteToString(x);
      var k,
        e = x.e,
        str = digitsToString(x.d),
        len = str.length;

      if (isExp) {
        if (sd && (k = sd - len) > 0) {
          str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
        } else if (len > 1) {
          str = str.charAt(0) + '.' + str.slice(1);
        }

        str = str + (x.e < 0 ? 'e' : 'e+') + x.e;
      } else if (e < 0) {
        str = '0.' + getZeroString(-e - 1) + str;
        if (sd && (k = sd - len) > 0) str += getZeroString(k);
      } else if (e >= len) {
        str += getZeroString(e + 1 - len);
        if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
      } else {
        if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);
        if (sd && (k = sd - len) > 0) {
          if (e + 1 === len) str += '.';
          str += getZeroString(k);
        }
      }

      return str;
    }


    // Calculate the base 10 exponent from the base 1e7 exponent.
    function getBase10Exponent(digits, e) {
      var w = digits[0];

      // Add the number of digits of the first word of the digits array.
      for ( e *= LOG_BASE; w >= 10; w /= 10) e++;
      return e;
    }


    function getLn10(Ctor, sd, pr) {
      if (sd > LN10_PRECISION) {

        // Reset global state in case the exception is caught.
        external = true;
        if (pr) Ctor.precision = pr;
        throw Error(precisionLimitExceeded);
      }
      return finalise(new Ctor(LN10), sd, 1, true);
    }


    function getPi(Ctor, sd, rm) {
      if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
      return finalise(new Ctor(PI), sd, rm, true);
    }


    function getPrecision(digits) {
      var w = digits.length - 1,
        len = w * LOG_BASE + 1;

      w = digits[w];

      // If non-zero...
      if (w) {

        // Subtract the number of trailing zeros of the last word.
        for (; w % 10 == 0; w /= 10) len--;

        // Add the number of digits of the first word.
        for (w = digits[0]; w >= 10; w /= 10) len++;
      }

      return len;
    }


    function getZeroString(k) {
      var zs = '';
      for (; k--;) zs += '0';
      return zs;
    }


    /*
     * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an
     * integer of type number.
     *
     * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.
     *
     */
    function intPow(Ctor, x, n, pr) {
      var isTruncated,
        r = new Ctor(1),

        // Max n of 9007199254740991 takes 53 loop iterations.
        // Maximum digits array length; leaves [28, 34] guard digits.
        k = Math.ceil(pr / LOG_BASE + 4);

      external = false;

      for (;;) {
        if (n % 2) {
          r = r.times(x);
          if (truncate(r.d, k)) isTruncated = true;
        }

        n = mathfloor(n / 2);
        if (n === 0) {

          // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
          n = r.d.length - 1;
          if (isTruncated && r.d[n] === 0) ++r.d[n];
          break;
        }

        x = x.times(x);
        truncate(x.d, k);
      }

      external = true;

      return r;
    }


    function isOdd(n) {
      return n.d[n.d.length - 1] & 1;
    }


    /*
     * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.
     */
    function maxOrMin(Ctor, args, ltgt) {
      var y,
        x = new Ctor(args[0]),
        i = 0;

      for (; ++i < args.length;) {
        y = new Ctor(args[i]);
        if (!y.s) {
          x = y;
          break;
        } else if (x[ltgt](y)) {
          x = y;
        }
      }

      return x;
    }


    /*
     * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant
     * digits.
     *
     * Taylor/Maclaurin series.
     *
     * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
     *
     * Argument reduction:
     *   Repeat x = x / 32, k += 5, until |x| < 0.1
     *   exp(x) = exp(x / 2^k)^(2^k)
     *
     * Previously, the argument was initially reduced by
     * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
     * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
     * found to be slower than just dividing repeatedly by 32 as above.
     *
     * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
     * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
     * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
     *
     *  exp(Infinity)  = Infinity
     *  exp(-Infinity) = 0
     *  exp(NaN)       = NaN
     *  exp(0)        = 1
     *
     *  exp(x) is non-terminating for any finite, non-zero x.
     *
     *  The result will always be correctly rounded.
     *
     */
    function naturalExponential(x, sd) {
      var denominator, guard, j, pow, sum, t, wpr,
        rep = 0,
        i = 0,
        k = 0,
        Ctor = x.constructor,
        rm = Ctor.rounding,
        pr = Ctor.precision;

      // 0/NaN/Infinity?
      if (!x.d || !x.d[0] || x.e > 17) {

        return new Ctor(x.d
          ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0
          : x.s ? x.s < 0 ? 0 : x : 0 / 0);
      }

      if (sd == null) {
        external = false;
        wpr = pr;
      } else {
        wpr = sd;
      }

      t = new Ctor(0.03125);

      // while abs(x) >= 0.1
      while (x.e > -2) {

        // x = x / 2^5
        x = x.times(t);
        k += 5;
      }

      // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision
      // necessary to ensure the first 4 rounding digits are correct.
      guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
      wpr += guard;
      denominator = pow = sum = new Ctor(1);
      Ctor.precision = wpr;

      for (;;) {
        pow = finalise(pow.times(x), wpr, 1);
        denominator = denominator.times(++i);
        t = sum.plus(divide(pow, denominator, wpr, 1));

        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
          j = k;
          while (j--) sum = finalise(sum.times(sum), wpr, 1);

          // Check to see if the first 4 rounding digits are [49]999.
          // If so, repeat the summation with a higher precision, otherwise
          // e.g. with precision: 18, rounding: 1
          // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)
          // `wpr - guard` is the index of first rounding digit.
          if (sd == null) {

            if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
              Ctor.precision = wpr += 10;
              denominator = pow = t = new Ctor(1);
              i = 0;
              rep++;
            } else {
              return finalise(sum, Ctor.precision = pr, rm, external = true);
            }
          } else {
            Ctor.precision = pr;
            return sum;
          }
        }

        sum = t;
      }
    }


    /*
     * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant
     * digits.
     *
     *  ln(-n)        = NaN
     *  ln(0)         = -Infinity
     *  ln(-0)        = -Infinity
     *  ln(1)         = 0
     *  ln(Infinity)  = Infinity
     *  ln(-Infinity) = NaN
     *  ln(NaN)       = NaN
     *
     *  ln(n) (n != 1) is non-terminating.
     *
     */
    function naturalLogarithm(y, sd) {
      var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,
        n = 1,
        guard = 10,
        x = y,
        xd = x.d,
        Ctor = x.constructor,
        rm = Ctor.rounding,
        pr = Ctor.precision;

      // Is x negative or Infinity, NaN, 0 or 1?
      if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
        return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
      }

      if (sd == null) {
        external = false;
        wpr = pr;
      } else {
        wpr = sd;
      }

      Ctor.precision = wpr += guard;
      c = digitsToString(xd);
      c0 = c.charAt(0);

      if (Math.abs(e = x.e) < 1.5e15) {

        // Argument reduction.
        // The series converges faster the closer the argument is to 1, so using
        // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
        // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
        // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
        // later be divided by this number, then separate out the power of 10 using
        // ln(a*10^b) = ln(a) + b*ln(10).

        // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
        //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
        // max n is 6 (gives 0.7 - 1.3)
        while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
          x = x.times(y);
          c = digitsToString(x.d);
          c0 = c.charAt(0);
          n++;
        }

        e = x.e;

        if (c0 > 1) {
          x = new Ctor('0.' + c);
          e++;
        } else {
          x = new Ctor(c0 + '.' + c.slice(1));
        }
      } else {

        // The argument reduction method above may result in overflow if the argument y is a massive
        // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
        // function using ln(x*10^e) = ln(x) + e*ln(10).
        t = getLn10(Ctor, wpr + 2, pr).times(e + '');
        x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);
        Ctor.precision = pr;

        return sd == null ? finalise(x, pr, rm, external = true) : x;
      }

      // x1 is x reduced to a value near 1.
      x1 = x;

      // Taylor series.
      // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
      // where x = (y - 1)/(y + 1)    (|x| < 1)
      sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
      x2 = finalise(x.times(x), wpr, 1);
      denominator = 3;

      for (;;) {
        numerator = finalise(numerator.times(x2), wpr, 1);
        t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));

        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
          sum = sum.times(2);

          // Reverse the argument reduction. Check that e is not 0 because, besides preventing an
          // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.
          if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
          sum = divide(sum, new Ctor(n), wpr, 1);

          // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
          // been repeated previously) and the first 4 rounding digits 9999?
          // If so, restart the summation with a higher precision, otherwise
          // e.g. with precision: 12, rounding: 1
          // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.
          // `wpr - guard` is the index of first rounding digit.
          if (sd == null) {
            if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
              Ctor.precision = wpr += guard;
              t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
              x2 = finalise(x.times(x), wpr, 1);
              denominator = rep = 1;
            } else {
              return finalise(sum, Ctor.precision = pr, rm, external = true);
            }
          } else {
            Ctor.precision = pr;
            return sum;
          }
        }

        sum = t;
        denominator += 2;
      }
    }


    // Infinity, NaN.
    function nonFiniteToString(x) {
      // Unsigned.
      return String(x.s * x.s / 0);
    }


    /*
     * Parse the value of a new Decimal `x` from string `str`.
     */
    function parseDecimal(x, str) {
      var e, i, len;

      // Decimal point?
      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

      // Exponential form?
      if ((i = str.search(/e/i)) > 0) {

        // Determine exponent.
        if (e < 0) e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {

        // Integer.
        e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(len - 1) === 48; --len);
      str = str.slice(i, len);

      if (str) {
        len -= i;
        x.e = e = e - i - 1;
        x.d = [];

        // Transform base

        // e is the base 10 exponent.
        // i is where to slice str to get the first word of the digits array.
        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE;

        if (i < len) {
          if (i) x.d.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
          str = str.slice(i);
          i = LOG_BASE - str.length;
        } else {
          i -= len;
        }

        for (; i--;) str += '0';
        x.d.push(+str);

        if (external) {

          // Overflow?
          if (x.e > x.constructor.maxE) {

            // Infinity.
            x.d = null;
            x.e = NaN;

          // Underflow?
          } else if (x.e < x.constructor.minE) {

            // Zero.
            x.e = 0;
            x.d = [0];
            // x.constructor.underflow = true;
          } // else x.constructor.underflow = false;
        }
      } else {

        // Zero.
        x.e = 0;
        x.d = [0];
      }

      return x;
    }


    /*
     * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.
     */
    function parseOther(x, str) {
      var base, Ctor, divisor, i, isFloat, len, p, xd, xe;

      if (str === 'Infinity' || str === 'NaN') {
        if (!+str) x.s = NaN;
        x.e = NaN;
        x.d = null;
        return x;
      }

      if (isHex.test(str))  {
        base = 16;
        str = str.toLowerCase();
      } else if (isBinary.test(str))  {
        base = 2;
      } else if (isOctal.test(str))  {
        base = 8;
      } else {
        throw Error(invalidArgument + str);
      }

      // Is there a binary exponent part?
      i = str.search(/p/i);

      if (i > 0) {
        p = +str.slice(i + 1);
        str = str.substring(2, i);
      } else {
        str = str.slice(2);
      }

      // Convert `str` as an integer then divide the result by `base` raised to a power such that the
      // fraction part will be restored.
      i = str.indexOf('.');
      isFloat = i >= 0;
      Ctor = x.constructor;

      if (isFloat) {
        str = str.replace('.', '');
        len = str.length;
        i = len - i;

        // log[10](16) = 1.2041... , log[10](88) = 1.9444....
        divisor = intPow(Ctor, new Ctor(base), i, i * 2);
      }

      xd = convertBase(str, base, BASE);
      xe = xd.length - 1;

      // Remove trailing zeros.
      for (i = xe; xd[i] === 0; --i) xd.pop();
      if (i < 0) return new Ctor(x.s * 0);
      x.e = getBase10Exponent(xd, xe);
      x.d = xd;
      external = false;

      // At what precision to perform the division to ensure exact conversion?
      // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)
      // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412
      // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.
      // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount
      // Therefore using 4 * the number of digits of str will always be enough.
      if (isFloat) x = divide(x, divisor, len * 4);

      // Multiply by the binary exponent part if present.
      if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
      external = true;

      return x;
    }


    /*
     * sin(x) = x - x^3/3! + x^5/5! - ...
     * |x| < pi/2
     *
     */
    function sine(Ctor, x) {
      var k,
        len = x.d.length;

      if (len < 3) return taylorSeries(Ctor, 2, x, x);

      // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)
      // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)
      // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))

      // Estimate the optimum number of times to use the argument reduction.
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;

      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x);

      // Reverse argument reduction
      var sin2_x,
        d5 = new Ctor(5),
        d16 = new Ctor(16),
        d20 = new Ctor(20);
      for (; k--;) {
        sin2_x = x.times(x);
        x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
      }

      return x;
    }


    // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.
    function taylorSeries(Ctor, n, x, y, isHyperbolic) {
      var j, t, u, x2,
        pr = Ctor.precision,
        k = Math.ceil(pr / LOG_BASE);

      external = false;
      x2 = x.times(x);
      u = new Ctor(y);

      for (;;) {
        t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
        u = isHyperbolic ? y.plus(t) : y.minus(t);
        y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
        t = u.plus(y);

        if (t.d[k] !== void 0) {
          for (j = k; t.d[j] === u.d[j] && j--;);
          if (j == -1) break;
        }

        j = u;
        u = y;
        y = t;
        t = j;
      }

      external = true;
      t.d.length = k + 1;

      return t;
    }


    // Exponent e must be positive and non-zero.
    function tinyPow(b, e) {
      var n = b;
      while (--e) n *= b;
      return n;
    }


    // Return the absolute value of `x` reduced to less than or equal to half pi.
    function toLessThanHalfPi(Ctor, x) {
      var t,
        isNeg = x.s < 0,
        pi = getPi(Ctor, Ctor.precision, 1),
        halfPi = pi.times(0.5);

      x = x.abs();

      if (x.lte(halfPi)) {
        quadrant = isNeg ? 4 : 1;
        return x;
      }

      t = x.divToInt(pi);

      if (t.isZero()) {
        quadrant = isNeg ? 3 : 2;
      } else {
        x = x.minus(t.times(pi));

        // 0 <= x < pi
        if (x.lte(halfPi)) {
          quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);
          return x;
        }

        quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);
      }

      return x.minus(pi).abs();
    }


    /*
     * Return the value of Decimal `x` as a string in base `baseOut`.
     *
     * If the optional `sd` argument is present include a binary exponent suffix.
     */
    function toStringBinary(x, baseOut, sd, rm) {
      var base, e, i, k, len, roundUp, str, xd, y,
        Ctor = x.constructor,
        isExp = sd !== void 0;

      if (isExp) {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
      } else {
        sd = Ctor.precision;
        rm = Ctor.rounding;
      }

      if (!x.isFinite()) {
        str = nonFiniteToString(x);
      } else {
        str = finiteToString(x);
        i = str.indexOf('.');

        // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:
        // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))
        // minBinaryExponent = floor(decimalExponent * log[2](10))
        // log[2](10) = 3.321928094887362347870319429489390175864

        if (isExp) {
          base = 2;
          if (baseOut == 16) {
            sd = sd * 4 - 3;
          } else if (baseOut == 8) {
            sd = sd * 3 - 2;
          }
        } else {
          base = baseOut;
        }

        // Convert the number as an integer then divide the result by its base raised to a power such
        // that the fraction part will be restored.

        // Non-integer.
        if (i >= 0) {
          str = str.replace('.', '');
          y = new Ctor(1);
          y.e = str.length - i;
          y.d = convertBase(finiteToString(y), 10, base);
          y.e = y.d.length;
        }

        xd = convertBase(str, 10, base);
        e = len = xd.length;

        // Remove trailing zeros.
        for (; xd[--len] == 0;) xd.pop();

        if (!xd[0]) {
          str = isExp ? '0p+0' : '0';
        } else {
          if (i < 0) {
            e--;
          } else {
            x = new Ctor(x);
            x.d = xd;
            x.e = e;
            x = divide(x, y, sd, rm, 0, base);
            xd = x.d;
            e = x.e;
            roundUp = inexact;
          }

          // The rounding digit, i.e. the digit after the digit that may be rounded up.
          i = xd[sd];
          k = base / 2;
          roundUp = roundUp || xd[sd + 1] !== void 0;

          roundUp = rm < 4
            ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))
            : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||
              rm === (x.s < 0 ? 8 : 7));

          xd.length = sd;

          if (roundUp) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (; ++xd[--sd] > base - 1;) {
              xd[sd] = 0;
              if (!sd) {
                ++e;
                xd.unshift(1);
              }
            }
          }

          // Determine trailing zeros.
          for (len = xd.length; !xd[len - 1]; --len);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);

          // Add binary exponent suffix?
          if (isExp) {
            if (len > 1) {
              if (baseOut == 16 || baseOut == 8) {
                i = baseOut == 16 ? 4 : 3;
                for (--len; len % i; len++) str += '0';
                xd = convertBase(str, base, baseOut);
                for (len = xd.length; !xd[len - 1]; --len);

                // xd[0] will always be be 1
                for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);
              } else {
                str = str.charAt(0) + '.' + str.slice(1);
              }
            }

            str =  str + (e < 0 ? 'p' : 'p+') + e;
          } else if (e < 0) {
            for (; ++e;) str = '0' + str;
            str = '0.' + str;
          } else {
            if (++e > len) for (e -= len; e-- ;) str += '0';
            else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);
          }
        }

        str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;
      }

      return x.s < 0 ? '-' + str : str;
    }


    // Does not strip trailing zeros.
    function truncate(arr, len) {
      if (arr.length > len) {
        arr.length = len;
        return true;
      }
    }


    // Decimal methods


    /*
     *  abs
     *  acos
     *  acosh
     *  add
     *  asin
     *  asinh
     *  atan
     *  atanh
     *  atan2
     *  cbrt
     *  ceil
     *  clone
     *  config
     *  cos
     *  cosh
     *  div
     *  exp
     *  floor
     *  hypot
     *  ln
     *  log
     *  log2
     *  log10
     *  max
     *  min
     *  mod
     *  mul
     *  pow
     *  random
     *  round
     *  set
     *  sign
     *  sin
     *  sinh
     *  sqrt
     *  sub
     *  tan
     *  tanh
     *  trunc
     */


    /*
     * Return a new Decimal whose value is the absolute value of `x`.
     *
     * x {number|string|Decimal}
     *
     */
    function abs(x) {
      return new this(x).abs();
    }


    /*
     * Return a new Decimal whose value is the arccosine in radians of `x`.
     *
     * x {number|string|Decimal}
     *
     */
    function acos(x) {
      return new this(x).acos();
    }


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function acosh(x) {
      return new this(x).acosh();
    }


    /*
     * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     * y {number|string|Decimal}
     *
     */
    function add(x, y) {
      return new this(x).plus(y);
    }


    /*
     * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function asin(x) {
      return new this(x).asin();
    }


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function asinh(x) {
      return new this(x).asinh();
    }


    /*
     * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function atan(x) {
      return new this(x).atan();
    }


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function atanh(x) {
      return new this(x).atanh();
    }


    /*
     * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
     * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-pi, pi]
     *
     * y {number|string|Decimal} The y-coordinate.
     * x {number|string|Decimal} The x-coordinate.
     *
     * atan2(0, -0)               = pi
     * atan2(0, +0)               = 0
     * atan2(0, -x)               = pi for x > 0
     * atan2(0, x)                = 0 for x > 0
     * atan2(-y, 0)               = -pi/2 for y > 0
     * atan2(y, 0)                = pi/2 for y > 0
     * atan2(y, -Infinity)        = pi for finite y > 0
     * atan2(y, +Infinity)        = 0 for finite y > 0
     * atan2(Infinity, x)         = pi/2 for finite x
     * atan2(Infinity, -Infinity) = 3*pi/4
     * atan2(Infinity, +Infinity) = pi/4
     * atan2(NaN, x) = NaN
     * atan2(y, NaN) = NaN
     *
     */
    function atan2(y, x) {
      y = new this(y);
      x = new this(x);
      var r,
        pr = this.precision,
        rm = this.rounding,
        wpr = pr + 4;

      // Either NaN
      if (!y.s || !x.s) {
        r = new this(NaN);

      // Both Infinity
      } else if (!y.d && !x.d) {
        r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
        r.s = y.s;

      // x is Infinity or y is 0
      } else if (!x.d || y.isZero()) {
        r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
        r.s = y.s;

      // y is Infinity or x is 0
      } else if (!y.d || x.isZero()) {
        r = getPi(this, wpr, 1).times(0.5);
        r.s = y.s;

      // Both non-zero and finite
      } else if (x.s < 0) {
        this.precision = wpr;
        this.rounding = 1;
        r = this.atan(divide(y, x, wpr, 1));
        x = getPi(this, wpr, 1);
        this.precision = pr;
        this.rounding = rm;
        r = y.s < 0 ? r.minus(x) : r.plus(x);
      } else {
        r = this.atan(divide(y, x, wpr, 1));
      }

      return r;
    }


    /*
     * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function cbrt(x) {
      return new this(x).cbrt();
    }


    /*
     * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.
     *
     * x {number|string|Decimal}
     *
     */
    function ceil(x) {
      return finalise(x = new this(x), x.e + 1, 2);
    }


    /*
     * Configure global settings for a Decimal constructor.
     *
     * `obj` is an object with one or more of the following properties,
     *
     *   precision  {number}
     *   rounding   {number}
     *   toExpNeg   {number}
     *   toExpPos   {number}
     *   maxE       {number}
     *   minE       {number}
     *   modulo     {number}
     *   crypto     {boolean|number}
     *   defaults   {true}
     *
     * E.g. Decimal.config({ precision: 20, rounding: 4 })
     *
     */
    function config(obj) {
      if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
      var i, p, v,
        useDefaults = obj.defaults === true,
        ps = [
          'precision', 1, MAX_DIGITS,
          'rounding', 0, 8,
          'toExpNeg', -EXP_LIMIT, 0,
          'toExpPos', 0, EXP_LIMIT,
          'maxE', 0, EXP_LIMIT,
          'minE', -EXP_LIMIT, 0,
          'modulo', 0, 9
        ];

      for (i = 0; i < ps.length; i += 3) {
        if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
        if ((v = obj[p]) !== void 0) {
          if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
          else throw Error(invalidArgument + p + ': ' + v);
        }
      }

      if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];
      if ((v = obj[p]) !== void 0) {
        if (v === true || v === false || v === 0 || v === 1) {
          if (v) {
            if (typeof crypto != 'undefined' && crypto &&
              (crypto.getRandomValues || crypto.randomBytes)) {
              this[p] = true;
            } else {
              throw Error(cryptoUnavailable);
            }
          } else {
            this[p] = false;
          }
        } else {
          throw Error(invalidArgument + p + ': ' + v);
        }
      }

      return this;
    }


    /*
     * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function cos(x) {
      return new this(x).cos();
    }


    /*
     * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function cosh(x) {
      return new this(x).cosh();
    }


    /*
     * Create and return a Decimal constructor with the same configuration properties as this Decimal
     * constructor.
     *
     */
    function clone(obj) {
      var i, p, ps;

      /*
       * The Decimal constructor and exported function.
       * Return a new Decimal instance.
       *
       * v {number|string|Decimal} A numeric value.
       *
       */
      function Decimal(v) {
        var e, i, t,
          x = this;

        // Decimal called without new.
        if (!(x instanceof Decimal)) return new Decimal(v);

        // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
        // which points to Object.
        x.constructor = Decimal;

        // Duplicate.
        if (v instanceof Decimal) {
          x.s = v.s;

          if (external) {
            if (!v.d || v.e > Decimal.maxE) {

              // Infinity.
              x.e = NaN;
              x.d = null;
            } else if (v.e < Decimal.minE) {

              // Zero.
              x.e = 0;
              x.d = [0];
            } else {
              x.e = v.e;
              x.d = v.d.slice();
            }
          } else {
            x.e = v.e;
            x.d = v.d ? v.d.slice() : v.d;
          }

          return;
        }

        t = typeof v;

        if (t === 'number') {
          if (v === 0) {
            x.s = 1 / v < 0 ? -1 : 1;
            x.e = 0;
            x.d = [0];
            return;
          }

          if (v < 0) {
            v = -v;
            x.s = -1;
          } else {
            x.s = 1;
          }

          // Fast path for small integers.
          if (v === ~~v && v < 1e7) {
            for (e = 0, i = v; i >= 10; i /= 10) e++;

            if (external) {
              if (e > Decimal.maxE) {
                x.e = NaN;
                x.d = null;
              } else if (e < Decimal.minE) {
                x.e = 0;
                x.d = [0];
              } else {
                x.e = e;
                x.d = [v];
              }
            } else {
              x.e = e;
              x.d = [v];
            }

            return;

          // Infinity, NaN.
          } else if (v * 0 !== 0) {
            if (!v) x.s = NaN;
            x.e = NaN;
            x.d = null;
            return;
          }

          return parseDecimal(x, v.toString());

        } else if (t !== 'string') {
          throw Error(invalidArgument + v);
        }

        // Minus sign?
        if ((i = v.charCodeAt(0)) === 45) {
          v = v.slice(1);
          x.s = -1;
        } else {
          // Plus sign?
          if (i === 43) v = v.slice(1);
          x.s = 1;
        }

        return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
      }

      Decimal.prototype = P;

      Decimal.ROUND_UP = 0;
      Decimal.ROUND_DOWN = 1;
      Decimal.ROUND_CEIL = 2;
      Decimal.ROUND_FLOOR = 3;
      Decimal.ROUND_HALF_UP = 4;
      Decimal.ROUND_HALF_DOWN = 5;
      Decimal.ROUND_HALF_EVEN = 6;
      Decimal.ROUND_HALF_CEIL = 7;
      Decimal.ROUND_HALF_FLOOR = 8;
      Decimal.EUCLID = 9;

      Decimal.config = Decimal.set = config;
      Decimal.clone = clone;
      Decimal.isDecimal = isDecimalInstance;

      Decimal.abs = abs;
      Decimal.acos = acos;
      Decimal.acosh = acosh;        // ES6
      Decimal.add = add;
      Decimal.asin = asin;
      Decimal.asinh = asinh;        // ES6
      Decimal.atan = atan;
      Decimal.atanh = atanh;        // ES6
      Decimal.atan2 = atan2;
      Decimal.cbrt = cbrt;          // ES6
      Decimal.ceil = ceil;
      Decimal.cos = cos;
      Decimal.cosh = cosh;          // ES6
      Decimal.div = div;
      Decimal.exp = exp;
      Decimal.floor = floor;
      Decimal.hypot = hypot;        // ES6
      Decimal.ln = ln;
      Decimal.log = log;
      Decimal.log10 = log10;        // ES6
      Decimal.log2 = log2;          // ES6
      Decimal.max = max;
      Decimal.min = min;
      Decimal.mod = mod;
      Decimal.mul = mul;
      Decimal.pow = pow;
      Decimal.random = random;
      Decimal.round = round;
      Decimal.sign = sign;          // ES6
      Decimal.sin = sin;
      Decimal.sinh = sinh;          // ES6
      Decimal.sqrt = sqrt;
      Decimal.sub = sub;
      Decimal.tan = tan;
      Decimal.tanh = tanh;          // ES6
      Decimal.trunc = trunc;        // ES6

      if (obj === void 0) obj = {};
      if (obj) {
        if (obj.defaults !== true) {
          ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];
          for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
        }
      }

      Decimal.config(obj);

      return Decimal;
    }


    /*
     * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     * y {number|string|Decimal}
     *
     */
    function div(x, y) {
      return new this(x).div(y);
    }


    /*
     * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} The power to which to raise the base of the natural log.
     *
     */
    function exp(x) {
      return new this(x).exp();
    }


    /*
     * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.
     *
     * x {number|string|Decimal}
     *
     */
    function floor(x) {
      return finalise(x = new this(x), x.e + 1, 3);
    }


    /*
     * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,
     * rounded to `precision` significant digits using rounding mode `rounding`.
     *
     * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)
     *
     * arguments {number|string|Decimal}
     *
     */
    function hypot() {
      var i, n,
        t = new this(0);

      external = false;

      for (i = 0; i < arguments.length;) {
        n = new this(arguments[i++]);
        if (!n.d) {
          if (n.s) {
            external = true;
            return new this(1 / 0);
          }
          t = n;
        } else if (t.d) {
          t = t.plus(n.times(n));
        }
      }

      external = true;

      return t.sqrt();
    }


    /*
     * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),
     * otherwise return false.
     *
     */
    function isDecimalInstance(obj) {
      return obj instanceof Decimal || obj && obj.name === '[object Decimal]' || false;
    }


    /*
     * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function ln(x) {
      return new this(x).ln();
    }


    /*
     * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base
     * is specified, rounded to `precision` significant digits using rounding mode `rounding`.
     *
     * log[y](x)
     *
     * x {number|string|Decimal} The argument of the logarithm.
     * y {number|string|Decimal} The base of the logarithm.
     *
     */
    function log(x, y) {
      return new this(x).log(y);
    }


    /*
     * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function log2(x) {
      return new this(x).log(2);
    }


    /*
     * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function log10(x) {
      return new this(x).log(10);
    }


    /*
     * Return a new Decimal whose value is the maximum of the arguments.
     *
     * arguments {number|string|Decimal}
     *
     */
    function max() {
      return maxOrMin(this, arguments, 'lt');
    }


    /*
     * Return a new Decimal whose value is the minimum of the arguments.
     *
     * arguments {number|string|Decimal}
     *
     */
    function min() {
      return maxOrMin(this, arguments, 'gt');
    }


    /*
     * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits
     * using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     * y {number|string|Decimal}
     *
     */
    function mod(x, y) {
      return new this(x).mod(y);
    }


    /*
     * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     * y {number|string|Decimal}
     *
     */
    function mul(x, y) {
      return new this(x).mul(y);
    }


    /*
     * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} The base.
     * y {number|string|Decimal} The exponent.
     *
     */
    function pow(x, y) {
      return new this(x).pow(y);
    }


    /*
     * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with
     * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros
     * are produced).
     *
     * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.
     *
     */
    function random(sd) {
      var d, e, k, n,
        i = 0,
        r = new this(1),
        rd = [];

      if (sd === void 0) sd = this.precision;
      else checkInt32(sd, 1, MAX_DIGITS);

      k = Math.ceil(sd / LOG_BASE);

      if (!this.crypto) {
        for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;

      // Browsers supporting crypto.getRandomValues.
      } else if (crypto.getRandomValues) {
        d = crypto.getRandomValues(new Uint32Array(k));

        for (; i < k;) {
          n = d[i];

          // 0 <= n < 4294967296
          // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
          if (n >= 4.29e9) {
            d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
          } else {

            // 0 <= n <= 4289999999
            // 0 <= (n % 1e7) <= 9999999
            rd[i++] = n % 1e7;
          }
        }

      // Node.js supporting crypto.randomBytes.
      } else if (crypto.randomBytes) {

        // buffer
        d = crypto.randomBytes(k *= 4);

        for (; i < k;) {

          // 0 <= n < 2147483648
          n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);

          // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
          if (n >= 2.14e9) {
            crypto.randomBytes(4).copy(d, i);
          } else {

            // 0 <= n <= 2139999999
            // 0 <= (n % 1e7) <= 9999999
            rd.push(n % 1e7);
            i += 4;
          }
        }

        i = k / 4;
      } else {
        throw Error(cryptoUnavailable);
      }

      k = rd[--i];
      sd %= LOG_BASE;

      // Convert trailing digits to zeros according to sd.
      if (k && sd) {
        n = mathpow(10, LOG_BASE - sd);
        rd[i] = (k / n | 0) * n;
      }

      // Remove trailing words which are zero.
      for (; rd[i] === 0; i--) rd.pop();

      // Zero?
      if (i < 0) {
        e = 0;
        rd = [0];
      } else {
        e = -1;

        // Remove leading words which are zero and adjust exponent accordingly.
        for (; rd[0] === 0; e -= LOG_BASE) rd.shift();

        // Count the digits of the first word of rd to determine leading zeros.
        for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;

        // Adjust the exponent for leading zeros of the first word of rd.
        if (k < LOG_BASE) e -= LOG_BASE - k;
      }

      r.e = e;
      r.d = rd;

      return r;
    }


    /*
     * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.
     *
     * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).
     *
     * x {number|string|Decimal}
     *
     */
    function round(x) {
      return finalise(x = new this(x), x.e + 1, this.rounding);
    }


    /*
     * Return
     *   1    if x > 0,
     *  -1    if x < 0,
     *   0    if x is 0,
     *  -0    if x is -0,
     *   NaN  otherwise
     *
     * x {number|string|Decimal}
     *
     */
    function sign(x) {
      x = new this(x);
      return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;
    }


    /*
     * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits
     * using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function sin(x) {
      return new this(x).sin();
    }


    /*
     * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function sinh(x) {
      return new this(x).sinh();
    }


    /*
     * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function sqrt(x) {
      return new this(x).sqrt();
    }


    /*
     * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits
     * using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     * y {number|string|Decimal}
     *
     */
    function sub(x, y) {
      return new this(x).sub(y);
    }


    /*
     * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function tan(x) {
      return new this(x).tan();
    }


    /*
     * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function tanh(x) {
      return new this(x).tanh();
    }


    /*
     * Return a new Decimal whose value is `x` truncated to an integer.
     *
     * x {number|string|Decimal}
     *
     */
    function trunc(x) {
      return finalise(x = new this(x), x.e + 1, 1);
    }


    // Create and configure initial Decimal constructor.
    Decimal = clone(DEFAULTS);

    Decimal['default'] = Decimal.Decimal = Decimal;

    // Create the internal constants from their string values.
    LN10 = new Decimal(LN10);
    PI = new Decimal(PI);


    // Export.


    // AMD.
    if (module.exports) {
      if (typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol') {
        P[Symbol.for('nodejs.util.inspect.custom')] = P.toString;
        P[Symbol.toStringTag] = 'Decimal';
      }

      module.exports = Decimal;

    // Browser.
    } else {
      if (!globalScope) {
        globalScope = typeof self != 'undefined' && self && self.self == self ? self : window;
      }

      noConflict = globalScope.Decimal;
      Decimal.noConflict = function () {
        globalScope.Decimal = noConflict;
        return Decimal;
      };

      globalScope.Decimal = Decimal;
    }
  })(commonjsGlobal);
  });

  var name$1 = 'BigNumber';
  var dependencies$2 = ['?on', 'config'];
  var createBigNumberClass = /* #__PURE__ */factory(name$1, dependencies$2, function (_ref) {
    var on = _ref.on,
        config = _ref.config;
    var BigNumber = decimal.clone({
      precision: config.precision
    });
    /**
     * Attach type information
     */

    BigNumber.prototype.type = 'BigNumber';
    BigNumber.prototype.isBigNumber = true;
    /**
     * Get a JSON representation of a BigNumber containing
     * type information
     * @returns {Object} Returns a JSON object structured as:
     *                   `{"mathjs": "BigNumber", "value": "0.2"}`
     */

    BigNumber.prototype.toJSON = function () {
      return {
        mathjs: 'BigNumber',
        value: this.toString()
      };
    };
    /**
     * Instantiate a BigNumber from a JSON object
     * @param {Object} json  a JSON object structured as:
     *                       `{"mathjs": "BigNumber", "value": "0.2"}`
     * @return {BigNumber}
     */


    BigNumber.fromJSON = function (json) {
      return new BigNumber(json.value);
    };

    if (on) {
      // listen for changed in the configuration, automatically apply changed precision
      on('config', function (curr, prev) {
        if (curr.precision !== prev.precision) {
          BigNumber.config({
            precision: curr.precision
          });
        }
      });
    }

    return BigNumber;
  }, {
    isClass: true
  });

  var complex = createCommonjsModule(function (module, exports) {
  /**
   * @license Complex.js v2.0.11 11/02/2016
   *
   * Copyright (c) 2016, Robert Eisele (robert@xarg.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **/

  /**
   *
   * This class allows the manipulation of complex numbers.
   * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.
   *
   * Object form
   * { re: <real>, im: <imaginary> }
   * { arg: <angle>, abs: <radius> }
   * { phi: <angle>, r: <radius> }
   *
   * Array / Vector form
   * [ real, imaginary ]
   *
   * Double form
   * 99.3 - Single double value
   *
   * String form
   * '23.1337' - Simple real number
   * '15+3i' - a simple complex number
   * '3-i' - a simple complex number
   *
   * Example:
   *
   * var c = new Complex('99.3+8i');
   * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);
   *
   */

  (function(root) {

    var cosh = function(x) {
      return (Math.exp(x) + Math.exp(-x)) * 0.5;
    };

    var sinh = function(x) {
      return (Math.exp(x) - Math.exp(-x)) * 0.5;
    };

    /**
     * Calculates cos(x) - 1 using Taylor series if x is small.
     *
     * @param {number} x
     * @returns {number} cos(x) - 1
     */

    var cosm1 = function(x) {
      var limit = Math.PI/4;
      if (x < -limit || x > limit) {
        return (Math.cos(x) - 1.0);
      }

      var xx = x * x;
      return xx *
        (-0.5 + xx *
          (1/24 + xx *
            (-1/720 + xx *
              (1/40320 + xx *
                (-1/3628800 + xx *
                  (1/4790014600 + xx *
                    (-1/87178291200 + xx *
                      (1/20922789888000)
                    )
                  )
                )
              )
            )
          )
        )
    };

    var hypot = function(x, y) {

      var a = Math.abs(x);
      var b = Math.abs(y);

      if (a < 3000 && b < 3000) {
        return Math.sqrt(a * a + b * b);
      }

      if (a < b) {
        a = b;
        b = x / y;
      } else {
        b = y / x;
      }
      return a * Math.sqrt(1 + b * b);
    };

    var parser_exit = function() {
      throw SyntaxError('Invalid Param');
    };

    /**
     * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows
     *
     * @param {number} a
     * @param {number} b
     * @returns {number}
     */
    function logHypot(a, b) {

      var _a = Math.abs(a);
      var _b = Math.abs(b);

      if (a === 0) {
        return Math.log(_b);
      }

      if (b === 0) {
        return Math.log(_a);
      }

      if (_a < 3000 && _b < 3000) {
        return Math.log(a * a + b * b) * 0.5;
      }

      /* I got 4 ideas to compute this property without overflow:
       *
       * Testing 1000000 times with random samples for a,b  [1, 1000000000] against a big decimal library to get an error estimate
       *
       * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)

       Math.log(a * a + b * b) / 2

       *
       *
       * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)

       var fn = function(a, b) {
       a = Math.abs(a);
       b = Math.abs(b);
       var t = Math.min(a, b);
       a = Math.max(a, b);
       t = t / a;

       return Math.log(a) + Math.log(1 + t * t) / 2;
       };

       * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)

       Math.log(a / Math.cos(Math.atan2(b, a)))

       * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)

       Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))

       */

      return Math.log(a / Math.cos(Math.atan2(b, a)));
    }

    var parse = function(a, b) {

      var z = {'re': 0, 'im': 0};

      if (a === undefined || a === null) {
        z['re'] =
                z['im'] = 0;
      } else if (b !== undefined) {
        z['re'] = a;
        z['im'] = b;
      } else
        switch (typeof a) {

          case 'object':

            if ('im' in a && 're' in a) {
              z['re'] = a['re'];
              z['im'] = a['im'];
            } else if ('abs' in a && 'arg' in a) {
              if (!Number.isFinite(a['abs']) && Number.isFinite(a['arg'])) {
                return Complex['INFINITY'];
              }
              z['re'] = a['abs'] * Math.cos(a['arg']);
              z['im'] = a['abs'] * Math.sin(a['arg']);
            } else if ('r' in a && 'phi' in a) {
              if (!Number.isFinite(a['r']) && Number.isFinite(a['phi'])) {
                return Complex['INFINITY'];
              }
              z['re'] = a['r'] * Math.cos(a['phi']);
              z['im'] = a['r'] * Math.sin(a['phi']);
            } else if (a.length === 2) { // Quick array check
              z['re'] = a[0];
              z['im'] = a[1];
            } else {
              parser_exit();
            }
            break;

          case 'string':

            z['im'] = /* void */
                    z['re'] = 0;

            var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
            var plus = 1;
            var minus = 0;

            if (tokens === null) {
              parser_exit();
            }

            for (var i = 0; i < tokens.length; i++) {

              var c = tokens[i];

              if (c === ' ' || c === '\t' || c === '\n') ; else if (c === '+') {
                plus++;
              } else if (c === '-') {
                minus++;
              } else if (c === 'i' || c === 'I') {

                if (plus + minus === 0) {
                  parser_exit();
                }

                if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {
                  z['im'] += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]);
                  i++;
                } else {
                  z['im'] += parseFloat((minus % 2 ? '-' : '') + '1');
                }
                plus = minus = 0;

              } else {

                if (plus + minus === 0 || isNaN(c)) {
                  parser_exit();
                }

                if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {
                  z['im'] += parseFloat((minus % 2 ? '-' : '') + c);
                  i++;
                } else {
                  z['re'] += parseFloat((minus % 2 ? '-' : '') + c);
                }
                plus = minus = 0;
              }
            }

            // Still something on the stack
            if (plus + minus > 0) {
              parser_exit();
            }
            break;

          case 'number':
            z['im'] = 0;
            z['re'] = a;
            break;

          default:
            parser_exit();
        }

      return z;
    };

    /**
     * @constructor
     * @returns {Complex}
     */
    function Complex(a, b) {

      if (!(this instanceof Complex)) {
        return new Complex(a, b);
      }

      var z = parse(a, b);

      this['re'] = z['re'];
      this['im'] = z['im'];
    }

    Complex.prototype = {

      're': 0,
      'im': 0,

      /**
       * Calculates the sign of a complex number, which is a normalized complex
       *
       * @returns {Complex}
       */
      'sign': function() {

        var abs = this['abs']();

        return new Complex(
                this['re'] / abs,
                this['im'] / abs);
      },

      /**
       * Adds two complex numbers
       *
       * @returns {Complex}
       */
      'add': function(a, b) {

        var z = new Complex(a, b);

        // Infinity + Infinity = NaN
        if (this['isInfinite']() && z['isInfinite']()) {
          return Complex['NAN'];
        }

        // Infinity + z = Infinity { where z != Infinity }
        if (this['isInfinite']() || z['isInfinite']()) {
          return Complex['INFINITY'];
        }

        return new Complex(
                this['re'] + z['re'],
                this['im'] + z['im']);
      },

      /**
       * Subtracts two complex numbers
       *
       * @returns {Complex}
       */
      'sub': function(a, b) {

        var z = new Complex(a, b);

        // Infinity - Infinity = NaN
        if (this['isInfinite']() && z['isInfinite']()) {
          return Complex['NAN'];
        }

        // Infinity - z = Infinity { where z != Infinity }
        if (this['isInfinite']() || z['isInfinite']()) {
          return Complex['INFINITY'];
        }

        return new Complex(
                this['re'] - z['re'],
                this['im'] - z['im']);
      },

      /**
       * Multiplies two complex numbers
       *
       * @returns {Complex}
       */
      'mul': function(a, b) {

        var z = new Complex(a, b);

        // Infinity * 0 = NaN
        if ((this['isInfinite']() && z['isZero']()) || (this['isZero']() && z['isInfinite']())) {
          return Complex['NAN'];
        }

        // Infinity * z = Infinity { where z != 0 }
        if (this['isInfinite']() || z['isInfinite']()) {
          return Complex['INFINITY'];
        }

        // Short circuit for real values
        if (z['im'] === 0 && this['im'] === 0) {
          return new Complex(this['re'] * z['re'], 0);
        }

        return new Complex(
                this['re'] * z['re'] - this['im'] * z['im'],
                this['re'] * z['im'] + this['im'] * z['re']);
      },

      /**
       * Divides two complex numbers
       *
       * @returns {Complex}
       */
      'div': function(a, b) {

        var z = new Complex(a, b);

        // 0 / 0 = NaN and Infinity / Infinity = NaN
        if ((this['isZero']() && z['isZero']()) || (this['isInfinite']() && z['isInfinite']())) {
          return Complex['NAN'];
        }

        // Infinity / 0 = Infinity
        if (this['isInfinite']() || z['isZero']()) {
          return Complex['INFINITY'];
        }

        // 0 / Infinity = 0
        if (this['isZero']() || z['isInfinite']()) {
          return Complex['ZERO'];
        }

        a = this['re'];
        b = this['im'];

        var c = z['re'];
        var d = z['im'];
        var t, x;

        if (0 === d) {
          // Divisor is real
          return new Complex(a / c, b / c);
        }

        if (Math.abs(c) < Math.abs(d)) {

          x = c / d;
          t = c * x + d;

          return new Complex(
                  (a * x + b) / t,
                  (b * x - a) / t);

        } else {

          x = d / c;
          t = d * x + c;

          return new Complex(
                  (a + b * x) / t,
                  (b - a * x) / t);
        }
      },

      /**
       * Calculate the power of two complex numbers
       *
       * @returns {Complex}
       */
      'pow': function(a, b) {

        var z = new Complex(a, b);

        a = this['re'];
        b = this['im'];

        if (z['isZero']()) {
          return Complex['ONE'];
        }

        // If the exponent is real
        if (z['im'] === 0) {

          if (b === 0 && a >= 0) {

            return new Complex(Math.pow(a, z['re']), 0);

          } else if (a === 0) { // If base is fully imaginary

            switch ((z['re'] % 4 + 4) % 4) {
              case 0:
                return new Complex(Math.pow(b, z['re']), 0);
              case 1:
                return new Complex(0, Math.pow(b, z['re']));
              case 2:
                return new Complex(-Math.pow(b, z['re']), 0);
              case 3:
                return new Complex(0, -Math.pow(b, z['re']));
            }
          }
        }

        /* I couldn't find a good formula, so here is a derivation and optimization
         *
         * z_1^z_2 = (a + bi)^(c + di)
         *         = exp((c + di) * log(a + bi)
         *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))
         * =>...
         * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
         * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
         *
         * =>...
         * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
         * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
         *
         * =>
         * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))
         * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))
         *
         */

        if (a === 0 && b === 0 && z['re'] > 0 && z['im'] >= 0) {
          return Complex['ZERO'];
        }

        var arg = Math.atan2(b, a);
        var loh = logHypot(a, b);

        a = Math.exp(z['re'] * loh - z['im'] * arg);
        b = z['im'] * loh + z['re'] * arg;
        return new Complex(
                a * Math.cos(b),
                a * Math.sin(b));
      },

      /**
       * Calculate the complex square root
       *
       * @returns {Complex}
       */
      'sqrt': function() {

        var a = this['re'];
        var b = this['im'];
        var r = this['abs']();

        var re, im;

        if (a >= 0) {

          if (b === 0) {
            return new Complex(Math.sqrt(a), 0);
          }

          re = 0.5 * Math.sqrt(2.0 * (r + a));
        } else {
          re = Math.abs(b) / Math.sqrt(2 * (r - a));
        }

        if (a <= 0) {
          im = 0.5 * Math.sqrt(2.0 * (r - a));
        } else {
          im = Math.abs(b) / Math.sqrt(2 * (r + a));
        }

        return new Complex(re, b < 0 ? -im : im);
      },

      /**
       * Calculate the complex exponent
       *
       * @returns {Complex}
       */
      'exp': function() {

        var tmp = Math.exp(this['re']);

        if (this['im'] === 0) ;
        return new Complex(
                tmp * Math.cos(this['im']),
                tmp * Math.sin(this['im']));
      },

      /**
       * Calculate the complex exponent and subtracts one.
       *
       * This may be more accurate than `Complex(x).exp().sub(1)` if
       * `x` is small.
       *
       * @returns {Complex}
       */
      'expm1': function() {

        /**
         * exp(a + i*b) - 1
         = exp(a) * (cos(b) + j*sin(b)) - 1
         = expm1(a)*cos(b) + cosm1(b) + j*exp(a)*sin(b)
         */

        var a = this['re'];
        var b = this['im'];

        return new Complex(
                Math.expm1(a) * Math.cos(b) + cosm1(b),
                Math.exp(a) * Math.sin(b));
      },

      /**
       * Calculate the natural log
       *
       * @returns {Complex}
       */
      'log': function() {

        var a = this['re'];
        var b = this['im'];

        return new Complex(
                logHypot(a, b),
                Math.atan2(b, a));
      },

      /**
       * Calculate the magnitude of the complex number
       *
       * @returns {number}
       */
      'abs': function() {

        return hypot(this['re'], this['im']);
      },

      /**
       * Calculate the angle of the complex number
       *
       * @returns {number}
       */
      'arg': function() {

        return Math.atan2(this['im'], this['re']);
      },

      /**
       * Calculate the sine of the complex number
       *
       * @returns {Complex}
       */
      'sin': function() {

        // sin(c) = (e^b - e^(-b)) / (2i)

        var a = this['re'];
        var b = this['im'];

        return new Complex(
                Math.sin(a) * cosh(b),
                Math.cos(a) * sinh(b));
      },

      /**
       * Calculate the cosine
       *
       * @returns {Complex}
       */
      'cos': function() {

        // cos(z) = (e^b + e^(-b)) / 2

        var a = this['re'];
        var b = this['im'];

        return new Complex(
                Math.cos(a) * cosh(b),
                -Math.sin(a) * sinh(b));
      },

      /**
       * Calculate the tangent
       *
       * @returns {Complex}
       */
      'tan': function() {

        // tan(c) = (e^(ci) - e^(-ci)) / (i(e^(ci) + e^(-ci)))

        var a = 2 * this['re'];
        var b = 2 * this['im'];
        var d = Math.cos(a) + cosh(b);

        return new Complex(
                Math.sin(a) / d,
                sinh(b) / d);
      },

      /**
       * Calculate the cotangent
       *
       * @returns {Complex}
       */
      'cot': function() {

        // cot(c) = i(e^(ci) + e^(-ci)) / (e^(ci) - e^(-ci))

        var a = 2 * this['re'];
        var b = 2 * this['im'];
        var d = Math.cos(a) - cosh(b);

        return new Complex(
                -Math.sin(a) / d,
                sinh(b) / d);
      },

      /**
       * Calculate the secant
       *
       * @returns {Complex}
       */
      'sec': function() {

        // sec(c) = 2 / (e^(ci) + e^(-ci))

        var a = this['re'];
        var b = this['im'];
        var d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);

        return new Complex(
                Math.cos(a) * cosh(b) / d,
                Math.sin(a) * sinh(b) / d);
      },

      /**
       * Calculate the cosecans
       *
       * @returns {Complex}
       */
      'csc': function() {

        // csc(c) = 2i / (e^(ci) - e^(-ci))

        var a = this['re'];
        var b = this['im'];
        var d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);

        return new Complex(
                Math.sin(a) * cosh(b) / d,
                -Math.cos(a) * sinh(b) / d);
      },

      /**
       * Calculate the complex arcus sinus
       *
       * @returns {Complex}
       */
      'asin': function() {

        // asin(c) = -i * log(ci + sqrt(1 - c^2))

        var a = this['re'];
        var b = this['im'];

        var t1 = new Complex(
                b * b - a * a + 1,
                -2 * a * b)['sqrt']();

        var t2 = new Complex(
                t1['re'] - b,
                t1['im'] + a)['log']();

        return new Complex(t2['im'], -t2['re']);
      },

      /**
       * Calculate the complex arcus cosinus
       *
       * @returns {Complex}
       */
      'acos': function() {

        // acos(c) = i * log(c - i * sqrt(1 - c^2))

        var a = this['re'];
        var b = this['im'];

        var t1 = new Complex(
                b * b - a * a + 1,
                -2 * a * b)['sqrt']();

        var t2 = new Complex(
                t1['re'] - b,
                t1['im'] + a)['log']();

        return new Complex(Math.PI / 2 - t2['im'], t2['re']);
      },

      /**
       * Calculate the complex arcus tangent
       *
       * @returns {Complex}
       */
      'atan': function() {

        // atan(c) = i / 2 log((i + x) / (i - x))

        var a = this['re'];
        var b = this['im'];

        if (a === 0) {

          if (b === 1) {
            return new Complex(0, Infinity);
          }

          if (b === -1) {
            return new Complex(0, -Infinity);
          }
        }

        var d = a * a + (1.0 - b) * (1.0 - b);

        var t1 = new Complex(
                (1 - b * b - a * a) / d,
                -2 * a / d).log();

        return new Complex(-0.5 * t1['im'], 0.5 * t1['re']);
      },

      /**
       * Calculate the complex arcus cotangent
       *
       * @returns {Complex}
       */
      'acot': function() {

        // acot(c) = i / 2 log((c - i) / (c + i))

        var a = this['re'];
        var b = this['im'];

        if (b === 0) {
          return new Complex(Math.atan2(1, a), 0);
        }

        var d = a * a + b * b;
        return (d !== 0)
                ? new Complex(
                        a / d,
                        -b / d).atan()
                : new Complex(
                        (a !== 0) ? a / 0 : 0,
                        (b !== 0) ? -b / 0 : 0).atan();
      },

      /**
       * Calculate the complex arcus secant
       *
       * @returns {Complex}
       */
      'asec': function() {

        // asec(c) = -i * log(1 / c + sqrt(1 - i / c^2))

        var a = this['re'];
        var b = this['im'];

        if (a === 0 && b === 0) {
          return new Complex(0, Infinity);
        }

        var d = a * a + b * b;
        return (d !== 0)
                ? new Complex(
                        a / d,
                        -b / d).acos()
                : new Complex(
                        (a !== 0) ? a / 0 : 0,
                        (b !== 0) ? -b / 0 : 0).acos();
      },

      /**
       * Calculate the complex arcus cosecans
       *
       * @returns {Complex}
       */
      'acsc': function() {

        // acsc(c) = -i * log(i / c + sqrt(1 - 1 / c^2))

        var a = this['re'];
        var b = this['im'];

        if (a === 0 && b === 0) {
          return new Complex(Math.PI / 2, Infinity);
        }

        var d = a * a + b * b;
        return (d !== 0)
                ? new Complex(
                        a / d,
                        -b / d).asin()
                : new Complex(
                        (a !== 0) ? a / 0 : 0,
                        (b !== 0) ? -b / 0 : 0).asin();
      },

      /**
       * Calculate the complex sinh
       *
       * @returns {Complex}
       */
      'sinh': function() {

        // sinh(c) = (e^c - e^-c) / 2

        var a = this['re'];
        var b = this['im'];

        return new Complex(
                sinh(a) * Math.cos(b),
                cosh(a) * Math.sin(b));
      },

      /**
       * Calculate the complex cosh
       *
       * @returns {Complex}
       */
      'cosh': function() {

        // cosh(c) = (e^c + e^-c) / 2

        var a = this['re'];
        var b = this['im'];

        return new Complex(
                cosh(a) * Math.cos(b),
                sinh(a) * Math.sin(b));
      },

      /**
       * Calculate the complex tanh
       *
       * @returns {Complex}
       */
      'tanh': function() {

        // tanh(c) = (e^c - e^-c) / (e^c + e^-c)

        var a = 2 * this['re'];
        var b = 2 * this['im'];
        var d = cosh(a) + Math.cos(b);

        return new Complex(
                sinh(a) / d,
                Math.sin(b) / d);
      },

      /**
       * Calculate the complex coth
       *
       * @returns {Complex}
       */
      'coth': function() {

        // coth(c) = (e^c + e^-c) / (e^c - e^-c)

        var a = 2 * this['re'];
        var b = 2 * this['im'];
        var d = cosh(a) - Math.cos(b);

        return new Complex(
                sinh(a) / d,
                -Math.sin(b) / d);
      },

      /**
       * Calculate the complex coth
       *
       * @returns {Complex}
       */
      'csch': function() {

        // csch(c) = 2 / (e^c - e^-c)

        var a = this['re'];
        var b = this['im'];
        var d = Math.cos(2 * b) - cosh(2 * a);

        return new Complex(
                -2 * sinh(a) * Math.cos(b) / d,
                2 * cosh(a) * Math.sin(b) / d);
      },

      /**
       * Calculate the complex sech
       *
       * @returns {Complex}
       */
      'sech': function() {

        // sech(c) = 2 / (e^c + e^-c)

        var a = this['re'];
        var b = this['im'];
        var d = Math.cos(2 * b) + cosh(2 * a);

        return new Complex(
                2 * cosh(a) * Math.cos(b) / d,
                -2 * sinh(a) * Math.sin(b) / d);
      },

      /**
       * Calculate the complex asinh
       *
       * @returns {Complex}
       */
      'asinh': function() {

        // asinh(c) = log(c + sqrt(c^2 + 1))

        var tmp = this['im'];
        this['im'] = -this['re'];
        this['re'] = tmp;
        var res = this['asin']();

        this['re'] = -this['im'];
        this['im'] = tmp;
        tmp = res['re'];

        res['re'] = -res['im'];
        res['im'] = tmp;
        return res;
      },

      /**
       * Calculate the complex asinh
       *
       * @returns {Complex}
       */
      'acosh': function() {

        // acosh(c) = log(c + sqrt(c^2 - 1))

        var res = this['acos']();
        if (res['im'] <= 0) {
          var tmp = res['re'];
          res['re'] = -res['im'];
          res['im'] = tmp;
        } else {
          var tmp = res['im'];
          res['im'] = -res['re'];
          res['re'] = tmp;
        }
        return res;
      },

      /**
       * Calculate the complex atanh
       *
       * @returns {Complex}
       */
      'atanh': function() {

        // atanh(c) = log((1+c) / (1-c)) / 2

        var a = this['re'];
        var b = this['im'];

        var noIM = a > 1 && b === 0;
        var oneMinus = 1 - a;
        var onePlus = 1 + a;
        var d = oneMinus * oneMinus + b * b;

        var x = (d !== 0)
                ? new Complex(
                        (onePlus * oneMinus - b * b) / d,
                        (b * oneMinus + onePlus * b) / d)
                : new Complex(
                        (a !== -1) ? (a / 0) : 0,
                        (b !== 0) ? (b / 0) : 0);

        var temp = x['re'];
        x['re'] = logHypot(x['re'], x['im']) / 2;
        x['im'] = Math.atan2(x['im'], temp) / 2;
        if (noIM) {
          x['im'] = -x['im'];
        }
        return x;
      },

      /**
       * Calculate the complex acoth
       *
       * @returns {Complex}
       */
      'acoth': function() {

        // acoth(c) = log((c+1) / (c-1)) / 2

        var a = this['re'];
        var b = this['im'];

        if (a === 0 && b === 0) {
          return new Complex(0, Math.PI / 2);
        }

        var d = a * a + b * b;
        return (d !== 0)
                ? new Complex(
                        a / d,
                        -b / d).atanh()
                : new Complex(
                        (a !== 0) ? a / 0 : 0,
                        (b !== 0) ? -b / 0 : 0).atanh();
      },

      /**
       * Calculate the complex acsch
       *
       * @returns {Complex}
       */
      'acsch': function() {

        // acsch(c) = log((1+sqrt(1+c^2))/c)

        var a = this['re'];
        var b = this['im'];

        if (b === 0) {

          return new Complex(
                  (a !== 0)
                  ? Math.log(a + Math.sqrt(a * a + 1))
                  : Infinity, 0);
        }

        var d = a * a + b * b;
        return (d !== 0)
                ? new Complex(
                        a / d,
                        -b / d).asinh()
                : new Complex(
                        (a !== 0) ? a / 0 : 0,
                        (b !== 0) ? -b / 0 : 0).asinh();
      },

      /**
       * Calculate the complex asech
       *
       * @returns {Complex}
       */
      'asech': function() {

        // asech(c) = log((1+sqrt(1-c^2))/c)

        var a = this['re'];
        var b = this['im'];

        if (this['isZero']()) {
          return Complex['INFINITY'];
        }

        var d = a * a + b * b;
        return (d !== 0)
                ? new Complex(
                        a / d,
                        -b / d).acosh()
                : new Complex(
                        (a !== 0) ? a / 0 : 0,
                        (b !== 0) ? -b / 0 : 0).acosh();
      },

      /**
       * Calculate the complex inverse 1/z
       *
       * @returns {Complex}
       */
      'inverse': function() {

        // 1 / 0 = Infinity and 1 / Infinity = 0
        if (this['isZero']()) {
          return Complex['INFINITY'];
        }

        if (this['isInfinite']()) {
          return Complex['ZERO'];
        }

        var a = this['re'];
        var b = this['im'];

        var d = a * a + b * b;

        return new Complex(a / d, -b / d);
      },

      /**
       * Returns the complex conjugate
       *
       * @returns {Complex}
       */
      'conjugate': function() {

        return new Complex(this['re'], -this['im']);
      },

      /**
       * Gets the negated complex number
       *
       * @returns {Complex}
       */
      'neg': function() {

        return new Complex(-this['re'], -this['im']);
      },

      /**
       * Ceils the actual complex number
       *
       * @returns {Complex}
       */
      'ceil': function(places) {

        places = Math.pow(10, places || 0);

        return new Complex(
                Math.ceil(this['re'] * places) / places,
                Math.ceil(this['im'] * places) / places);
      },

      /**
       * Floors the actual complex number
       *
       * @returns {Complex}
       */
      'floor': function(places) {

        places = Math.pow(10, places || 0);

        return new Complex(
                Math.floor(this['re'] * places) / places,
                Math.floor(this['im'] * places) / places);
      },

      /**
       * Ceils the actual complex number
       *
       * @returns {Complex}
       */
      'round': function(places) {

        places = Math.pow(10, places || 0);

        return new Complex(
                Math.round(this['re'] * places) / places,
                Math.round(this['im'] * places) / places);
      },

      /**
       * Compares two complex numbers
       *
       * **Note:** new Complex(Infinity).equals(Infinity) === false
       *
       * @returns {boolean}
       */
      'equals': function(a, b) {

        var z = new Complex(a, b);

        return Math.abs(z['re'] - this['re']) <= Complex['EPSILON'] &&
                Math.abs(z['im'] - this['im']) <= Complex['EPSILON'];
      },

      /**
       * Clones the actual object
       *
       * @returns {Complex}
       */
      'clone': function() {

        return new Complex(this['re'], this['im']);
      },

      /**
       * Gets a string of the actual complex number
       *
       * @returns {string}
       */
      'toString': function() {

        var a = this['re'];
        var b = this['im'];
        var ret = '';

        if (this['isNaN']()) {
          return 'NaN';
        }

        if (this['isZero']()) {
          return '0';
        }

        if (this['isInfinite']()) {
          return 'Infinity';
        }

        if (a !== 0) {
          ret += a;
        }

        if (b !== 0) {

          if (a !== 0) {
            ret += b < 0 ? ' - ' : ' + ';
          } else if (b < 0) {
            ret += '-';
          }

          b = Math.abs(b);

          if (1 !== b) {
            ret += b;
          }
          ret += 'i';
        }

        if (!ret)
          return '0';

        return ret;
      },

      /**
       * Returns the actual number as a vector
       *
       * @returns {Array}
       */
      'toVector': function() {

        return [this['re'], this['im']];
      },

      /**
       * Returns the actual real value of the current object
       *
       * @returns {number|null}
       */
      'valueOf': function() {

        if (this['im'] === 0) {
          return this['re'];
        }
        return null;
      },

      /**
       * Determines whether a complex number is not on the Riemann sphere.
       *
       * @returns {boolean}
       */
      'isNaN': function() {
        return isNaN(this['re']) || isNaN(this['im']);
      },

      /**
       * Determines whether or not a complex number is at the zero pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      'isZero': function() {
        return (
                (this['re'] === 0 || this['re'] === -0) &&
                (this['im'] === 0 || this['im'] === -0)
                );
      },

      /**
       * Determines whether a complex number is not at the infinity pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      'isFinite': function() {
        return isFinite(this['re']) && isFinite(this['im']);
      },

      /**
       * Determines whether or not a complex number is at the infinity pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      'isInfinite': function() {
        return !(this['isNaN']() || this['isFinite']());
      }
    };

    Complex['ZERO'] = new Complex(0, 0);
    Complex['ONE'] = new Complex(1, 0);
    Complex['I'] = new Complex(0, 1);
    Complex['PI'] = new Complex(Math.PI, 0);
    Complex['E'] = new Complex(Math.E, 0);
    Complex['INFINITY'] = new Complex(Infinity, Infinity);
    Complex['NAN'] = new Complex(NaN, NaN);
    Complex['EPSILON'] = 1e-16;

    {
      Object.defineProperty(exports, "__esModule", {'value': true});
      Complex['default'] = Complex;
      Complex['Complex'] = Complex;
      module['exports'] = Complex;
    }

  })(commonjsGlobal);
  });

  var Complex = unwrapExports(complex);

  function _typeof$3(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$3 = function _typeof(obj) { return typeof obj; }; } else { _typeof$3 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$3(obj); }
  var name$2 = 'Complex';
  var dependencies$3 = [];
  var createComplexClass = /* #__PURE__ */factory(name$2, dependencies$3, function () {
    /**
     * Attach type information
     */
    Complex.prototype.type = 'Complex';
    Complex.prototype.isComplex = true;
    /**
     * Get a JSON representation of the complex number
     * @returns {Object} Returns a JSON object structured as:
     *                   `{"mathjs": "Complex", "re": 2, "im": 3}`
     */

    Complex.prototype.toJSON = function () {
      return {
        mathjs: 'Complex',
        re: this.re,
        im: this.im
      };
    };
    /*
     * Return the value of the complex number in polar notation
     * The angle phi will be set in the interval of [-pi, pi].
     * @return {{r: number, phi: number}} Returns and object with properties r and phi.
     */


    Complex.prototype.toPolar = function () {
      return {
        r: this.abs(),
        phi: this.arg()
      };
    };
    /**
     * Get a string representation of the complex number,
     * with optional formatting options.
     * @param {Object | number | Function} [options]  Formatting options. See
     *                                                lib/utils/number:format for a
     *                                                description of the available
     *                                                options.
     * @return {string} str
     */


    Complex.prototype.format = function (options) {
      var str = '';
      var im = this.im;
      var re = this.re;
      var strRe = format(this.re, options);
      var strIm = format(this.im, options); // round either re or im when smaller than the configured precision

      var precision = isNumber(options) ? options : options ? options.precision : null;

      if (precision !== null) {
        var epsilon = Math.pow(10, -precision);

        if (Math.abs(re / im) < epsilon) {
          re = 0;
        }

        if (Math.abs(im / re) < epsilon) {
          im = 0;
        }
      }

      if (im === 0) {
        // real value
        str = strRe;
      } else if (re === 0) {
        // purely complex value
        if (im === 1) {
          str = 'i';
        } else if (im === -1) {
          str = '-i';
        } else {
          str = strIm + 'i';
        }
      } else {
        // complex value
        if (im < 0) {
          if (im === -1) {
            str = strRe + ' - i';
          } else {
            str = strRe + ' - ' + strIm.substring(1) + 'i';
          }
        } else {
          if (im === 1) {
            str = strRe + ' + i';
          } else {
            str = strRe + ' + ' + strIm + 'i';
          }
        }
      }

      return str;
    };
    /**
     * Create a complex number from polar coordinates
     *
     * Usage:
     *
     *     Complex.fromPolar(r: number, phi: number) : Complex
     *     Complex.fromPolar({r: number, phi: number}) : Complex
     *
     * @param {*} args...
     * @return {Complex}
     */


    Complex.fromPolar = function (args) {
      switch (arguments.length) {
        case 1:
          {
            var arg = arguments[0];

            if (_typeof$3(arg) === 'object') {
              return Complex(arg);
            } else {
              throw new TypeError('Input has to be an object with r and phi keys.');
            }
          }

        case 2:
          {
            var r = arguments[0];
            var phi = arguments[1];

            if (isNumber(r)) {
              if (isUnit(phi) && phi.hasBase('ANGLE')) {
                // convert unit to a number in radians
                phi = phi.toNumber('rad');
              }

              if (isNumber(phi)) {
                return new Complex({
                  r: r,
                  phi: phi
                });
              }

              throw new TypeError('Phi is not a number nor an angle unit.');
            } else {
              throw new TypeError('Radius r is not a number.');
            }
          }

        default:
          throw new SyntaxError('Wrong number of arguments in function fromPolar');
      }
    };

    Complex.prototype.valueOf = Complex.prototype.toString;
    /**
     * Create a Complex number from a JSON object
     * @param {Object} json  A JSON Object structured as
     *                       {"mathjs": "Complex", "re": 2, "im": 3}
     *                       All properties are optional, default values
     *                       for `re` and `im` are 0.
     * @return {Complex} Returns a new Complex number
     */

    Complex.fromJSON = function (json) {
      return new Complex(json);
    };
    /**
     * Compare two complex numbers, `a` and `b`:
     *
     * - Returns 1 when the real part of `a` is larger than the real part of `b`
     * - Returns -1 when the real part of `a` is smaller than the real part of `b`
     * - Returns 1 when the real parts are equal
     *   and the imaginary part of `a` is larger than the imaginary part of `b`
     * - Returns -1 when the real parts are equal
     *   and the imaginary part of `a` is smaller than the imaginary part of `b`
     * - Returns 0 when both real and imaginary parts are equal.
     *
     * @params {Complex} a
     * @params {Complex} b
     * @returns {number} Returns the comparison result: -1, 0, or 1
     */


    Complex.compare = function (a, b) {
      if (a.re > b.re) {
        return 1;
      }

      if (a.re < b.re) {
        return -1;
      }

      if (a.im > b.im) {
        return 1;
      }

      if (a.im < b.im) {
        return -1;
      }

      return 0;
    };

    return Complex;
  }, {
    isClass: true
  });

  var fraction = createCommonjsModule(function (module, exports) {
  /**
   * @license Fraction.js v4.0.12 09/09/2015
   * http://www.xarg.org/2014/03/rational-numbers-in-javascript/
   *
   * Copyright (c) 2015, Robert Eisele (robert@xarg.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **/


  /**
   *
   * This class offers the possibility to calculate fractions.
   * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
   *
   * Array/Object form
   * [ 0 => <nominator>, 1 => <denominator> ]
   * [ n => <nominator>, d => <denominator> ]
   *
   * Integer form
   * - Single integer value
   *
   * Double form
   * - Single double value
   *
   * String form
   * 123.456 - a simple double
   * 123/456 - a string fraction
   * 123.'456' - a double with repeating decimal places
   * 123.(456) - synonym
   * 123.45'6' - a double with repeating last place
   * 123.45(6) - synonym
   *
   * Example:
   *
   * var f = new Fraction("9.4'31'");
   * f.mul([-4, 3]).div(4.9);
   *
   */

  (function(root) {

    // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
    // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
    // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
    var MAX_CYCLE_LEN = 2000;

    // Parsed data to avoid calling "new" all the time
    var P = {
      "s": 1,
      "n": 0,
      "d": 1
    };

    function createError(name) {

      function errorConstructor() {
        var temp = Error.apply(this, arguments);
        temp['name'] = this['name'] = name;
        this['stack'] = temp['stack'];
        this['message'] = temp['message'];
      }

      /**
       * Error constructor
       *
       * @constructor
       */
      function IntermediateInheritor() {}
      IntermediateInheritor.prototype = Error.prototype;
      errorConstructor.prototype = new IntermediateInheritor();

      return errorConstructor;
    }

    var DivisionByZero = Fraction['DivisionByZero'] = createError('DivisionByZero');
    var InvalidParameter = Fraction['InvalidParameter'] = createError('InvalidParameter');

    function assign(n, s) {

      if (isNaN(n = parseInt(n, 10))) {
        throwInvalidParam();
      }
      return n * s;
    }

    function throwInvalidParam() {
      throw new InvalidParameter();
    }

    var parse = function(p1, p2) {

      var n = 0, d = 1, s = 1;
      var v = 0, w = 0, x = 0, y = 1, z = 1;

      var A = 0, B = 1;
      var C = 1, D = 1;

      var N = 10000000;
      var M;

      if (p1 === undefined || p1 === null) ; else if (p2 !== undefined) {
        n = p1;
        d = p2;
        s = n * d;
      } else
        switch (typeof p1) {

          case "object":
          {
            if ("d" in p1 && "n" in p1) {
              n = p1["n"];
              d = p1["d"];
              if ("s" in p1)
                n *= p1["s"];
            } else if (0 in p1) {
              n = p1[0];
              if (1 in p1)
                d = p1[1];
            } else {
              throwInvalidParam();
            }
            s = n * d;
            break;
          }
          case "number":
          {
            if (p1 < 0) {
              s = p1;
              p1 = -p1;
            }

            if (p1 % 1 === 0) {
              n = p1;
            } else if (p1 > 0) { // check for != 0, scale would become NaN (log(0)), which converges really slow

              if (p1 >= 1) {
                z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                p1 /= z;
              }

              // Using Farey Sequences
              // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/

              while (B <= N && D <= N) {
                M = (A + C) / (B + D);

                if (p1 === M) {
                  if (B + D <= N) {
                    n = A + C;
                    d = B + D;
                  } else if (D > B) {
                    n = C;
                    d = D;
                  } else {
                    n = A;
                    d = B;
                  }
                  break;

                } else {

                  if (p1 > M) {
                    A += C;
                    B += D;
                  } else {
                    C += A;
                    D += B;
                  }

                  if (B > N) {
                    n = C;
                    d = D;
                  } else {
                    n = A;
                    d = B;
                  }
                }
              }
              n *= z;
            } else if (isNaN(p1) || isNaN(p2)) {
              d = n = NaN;
            }
            break;
          }
          case "string":
          {
            B = p1.match(/\d+|./g);

            if (B === null)
              throwInvalidParam();

            if (B[A] === '-') {// Check for minus sign at the beginning
              s = -1;
              A++;
            } else if (B[A] === '+') {// Check for plus sign at the beginning
              A++;
            }

            if (B.length === A + 1) { // Check if it's just a simple number "1234"
              w = assign(B[A++], s);
            } else if (B[A + 1] === '.' || B[A] === '.') { // Check if it's a decimal number

              if (B[A] !== '.') { // Handle 0.5 and .5
                v = assign(B[A++], s);
              }
              A++;

              // Check for decimal places
              if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") {
                w = assign(B[A], s);
                y = Math.pow(10, B[A].length);
                A++;
              }

              // Check for repeating places
              if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") {
                x = assign(B[A + 1], s);
                z = Math.pow(10, B[A + 1].length) - 1;
                A += 3;
              }

            } else if (B[A + 1] === '/' || B[A + 1] === ':') { // Check for a simple fraction "123/456" or "123:456"
              w = assign(B[A], s);
              y = assign(B[A + 2], 1);
              A += 3;
            } else if (B[A + 3] === '/' && B[A + 1] === ' ') { // Check for a complex fraction "123 1/2"
              v = assign(B[A], s);
              w = assign(B[A + 2], s);
              y = assign(B[A + 4], 1);
              A += 5;
            }

            if (B.length <= A) { // Check for more tokens on the stack
              d = y * z;
              s = /* void */
                      n = x + d * v + z * w;
              break;
            }

            /* Fall through on error */
          }
          default:
            throwInvalidParam();
        }

      if (d === 0) {
        throw new DivisionByZero();
      }

      P["s"] = s < 0 ? -1 : 1;
      P["n"] = Math.abs(n);
      P["d"] = Math.abs(d);
    };

    function modpow(b, e, m) {

      var r = 1;
      for (; e > 0; b = (b * b) % m, e >>= 1) {

        if (e & 1) {
          r = (r * b) % m;
        }
      }
      return r;
    }


    function cycleLen(n, d) {

      for (; d % 2 === 0;
              d /= 2) {
      }

      for (; d % 5 === 0;
              d /= 5) {
      }

      if (d === 1) // Catch non-cyclic numbers
        return 0;

      // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
      // 10^(d-1) % d == 1
      // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
      // as we want to translate the numbers to strings.

      var rem = 10 % d;
      var t = 1;

      for (; rem !== 1; t++) {
        rem = rem * 10 % d;

        if (t > MAX_CYCLE_LEN)
          return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
      }
      return t;
    }


       function cycleStart(n, d, len) {

      var rem1 = 1;
      var rem2 = modpow(10, len, d);

      for (var t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)
        // Solve 10^s == 10^(s+t) (mod d)

        if (rem1 === rem2)
          return t;

        rem1 = rem1 * 10 % d;
        rem2 = rem2 * 10 % d;
      }
      return 0;
    }

    function gcd(a, b) {

      if (!a)
        return b;
      if (!b)
        return a;

      while (1) {
        a %= b;
        if (!a)
          return b;
        b %= a;
        if (!b)
          return a;
      }
    }
    /**
     * Module constructor
     *
     * @constructor
     * @param {number|Fraction=} a
     * @param {number=} b
     */
    function Fraction(a, b) {

      if (!(this instanceof Fraction)) {
        return new Fraction(a, b);
      }

      parse(a, b);

      if (Fraction['REDUCE']) {
        a = gcd(P["d"], P["n"]); // Abuse a
      } else {
        a = 1;
      }

      this["s"] = P["s"];
      this["n"] = P["n"] / a;
      this["d"] = P["d"] / a;
    }

    /**
     * Boolean global variable to be able to disable automatic reduction of the fraction
     *
     */
    Fraction['REDUCE'] = 1;

    Fraction.prototype = {

      "s": 1,
      "n": 0,
      "d": 1,

      /**
       * Calculates the absolute value
       *
       * Ex: new Fraction(-4).abs() => 4
       **/
      "abs": function() {

        return new Fraction(this["n"], this["d"]);
      },

      /**
       * Inverts the sign of the current fraction
       *
       * Ex: new Fraction(-4).neg() => 4
       **/
      "neg": function() {

        return new Fraction(-this["s"] * this["n"], this["d"]);
      },

      /**
       * Adds two rational numbers
       *
       * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
       **/
      "add": function(a, b) {

        parse(a, b);
        return new Fraction(
                this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
                this["d"] * P["d"]
                );
      },

      /**
       * Subtracts two rational numbers
       *
       * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
       **/
      "sub": function(a, b) {

        parse(a, b);
        return new Fraction(
                this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
                this["d"] * P["d"]
                );
      },

      /**
       * Multiplies two rational numbers
       *
       * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
       **/
      "mul": function(a, b) {

        parse(a, b);
        return new Fraction(
                this["s"] * P["s"] * this["n"] * P["n"],
                this["d"] * P["d"]
                );
      },

      /**
       * Divides two rational numbers
       *
       * Ex: new Fraction("-17.(345)").inverse().div(3)
       **/
      "div": function(a, b) {

        parse(a, b);
        return new Fraction(
                this["s"] * P["s"] * this["n"] * P["d"],
                this["d"] * P["n"]
                );
      },

      /**
       * Clones the actual object
       *
       * Ex: new Fraction("-17.(345)").clone()
       **/
      "clone": function() {
        return new Fraction(this);
      },

      /**
       * Calculates the modulo of two rational numbers - a more precise fmod
       *
       * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
       **/
      "mod": function(a, b) {

        if (isNaN(this['n']) || isNaN(this['d'])) {
          return new Fraction(NaN);
        }

        if (a === undefined) {
          return new Fraction(this["s"] * this["n"] % this["d"], 1);
        }

        parse(a, b);
        if (0 === P["n"] && 0 === this["d"]) {
          Fraction(0, 0); // Throw DivisionByZero
        }

        /*
         * First silly attempt, kinda slow
         *
         return that["sub"]({
         "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
         "d": num["d"],
         "s": this["s"]
         });*/

        /*
         * New attempt: a1 / b1 = a2 / b2 * q + r
         * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
         * => (b2 * a1 % a2 * b1) / (b1 * b2)
         */
        return new Fraction(
                this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]),
                P["d"] * this["d"]
                );
      },

      /**
       * Calculates the fractional gcd of two rational numbers
       *
       * Ex: new Fraction(5,8).gcd(3,7) => 1/56
       */
      "gcd": function(a, b) {

        parse(a, b);

        // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

        return new Fraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
      },

      /**
       * Calculates the fractional lcm of two rational numbers
       *
       * Ex: new Fraction(5,8).lcm(3,7) => 15
       */
      "lcm": function(a, b) {

        parse(a, b);

        // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

        if (P["n"] === 0 && this["n"] === 0) {
          return new Fraction;
        }
        return new Fraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
      },

      /**
       * Calculates the ceil of a rational number
       *
       * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
       **/
      "ceil": function(places) {

        places = Math.pow(10, places || 0);

        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return new Fraction(NaN);
        }
        return new Fraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
      },

      /**
       * Calculates the floor of a rational number
       *
       * Ex: new Fraction('4.(3)').floor() => (4 / 1)
       **/
      "floor": function(places) {

        places = Math.pow(10, places || 0);

        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return new Fraction(NaN);
        }
        return new Fraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
      },

      /**
       * Rounds a rational numbers
       *
       * Ex: new Fraction('4.(3)').round() => (4 / 1)
       **/
      "round": function(places) {

        places = Math.pow(10, places || 0);

        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return new Fraction(NaN);
        }
        return new Fraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
      },

      /**
       * Gets the inverse of the fraction, means numerator and denumerator are exchanged
       *
       * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
       **/
      "inverse": function() {

        return new Fraction(this["s"] * this["d"], this["n"]);
      },

      /**
       * Calculates the fraction to some integer exponent
       *
       * Ex: new Fraction(-1,2).pow(-3) => -8
       */
      "pow": function(m) {

        if (m < 0) {
          return new Fraction(Math.pow(this['s'] * this["d"], -m), Math.pow(this["n"], -m));
        } else {
          return new Fraction(Math.pow(this['s'] * this["n"], m), Math.pow(this["d"], m));
        }
      },

      /**
       * Check if two rational numbers are the same
       *
       * Ex: new Fraction(19.6).equals([98, 5]);
       **/
      "equals": function(a, b) {

        parse(a, b);
        return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
      },

      /**
       * Check if two rational numbers are the same
       *
       * Ex: new Fraction(19.6).equals([98, 5]);
       **/
      "compare": function(a, b) {

        parse(a, b);
        var t = (this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"]);
        return (0 < t) - (t < 0);
      },

      "simplify": function(eps) {

        // First naive implementation, needs improvement

        if (isNaN(this['n']) || isNaN(this['d'])) {
          return this;
        }

        var cont = this['abs']()['toContinued']();

        eps = eps || 0.001;

        function rec(a) {
          if (a.length === 1)
            return new Fraction(a[0]);
          return rec(a.slice(1))['inverse']()['add'](a[0]);
        }

        for (var i = 0; i < cont.length; i++) {
          var tmp = rec(cont.slice(0, i + 1));
          if (tmp['sub'](this['abs']())['abs']().valueOf() < eps) {
            return tmp['mul'](this['s']);
          }
        }
        return this;
      },

      /**
       * Check if two rational numbers are divisible
       *
       * Ex: new Fraction(19.6).divisible(1.5);
       */
      "divisible": function(a, b) {

        parse(a, b);
        return !(!(P["n"] * this["d"]) || ((this["n"] * P["d"]) % (P["n"] * this["d"])));
      },

      /**
       * Returns a decimal representation of the fraction
       *
       * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
       **/
      'valueOf': function() {

        return this["s"] * this["n"] / this["d"];
      },

      /**
       * Returns a string-fraction representation of a Fraction object
       *
       * Ex: new Fraction("1.'3'").toFraction() => "4 1/3"
       **/
      'toFraction': function(excludeWhole) {

        var whole, str = "";
        var n = this["n"];
        var d = this["d"];
        if (this["s"] < 0) {
          str += '-';
        }

        if (d === 1) {
          str += n;
        } else {

          if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
            str += whole;
            str += " ";
            n %= d;
          }

          str += n;
          str += '/';
          str += d;
        }
        return str;
      },

      /**
       * Returns a latex representation of a Fraction object
       *
       * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
       **/
      'toLatex': function(excludeWhole) {

        var whole, str = "";
        var n = this["n"];
        var d = this["d"];
        if (this["s"] < 0) {
          str += '-';
        }

        if (d === 1) {
          str += n;
        } else {

          if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
            str += whole;
            n %= d;
          }

          str += "\\frac{";
          str += n;
          str += '}{';
          str += d;
          str += '}';
        }
        return str;
      },

      /**
       * Returns an array of continued fraction elements
       *
       * Ex: new Fraction("7/8").toContinued() => [0,1,7]
       */
      'toContinued': function() {

        var t;
        var a = this['n'];
        var b = this['d'];
        var res = [];

        if (isNaN(this['n']) || isNaN(this['d'])) {
          return res;
        }

        do {
          res.push(Math.floor(a / b));
          t = a % b;
          a = b;
          b = t;
        } while (a !== 1);

        return res;
      },

      /**
       * Creates a string representation of a fraction with all digits
       *
       * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
       **/
      'toString': function(dec) {

        var g;
        var N = this["n"];
        var D = this["d"];

        if (isNaN(N) || isNaN(D)) {
          return "NaN";
        }

        if (!Fraction['REDUCE']) {
          g = gcd(N, D);
          N /= g;
          D /= g;
        }

        dec = dec || 15; // 15 = decimal places when no repitation

        var cycLen = cycleLen(N, D); // Cycle length
        var cycOff = cycleStart(N, D, cycLen); // Cycle start

        var str = this['s'] === -1 ? "-" : "";

        str += N / D | 0;

        N %= D;
        N *= 10;

        if (N)
          str += ".";

        if (cycLen) {

          for (var i = cycOff; i--; ) {
            str += N / D | 0;
            N %= D;
            N *= 10;
          }
          str += "(";
          for (var i = cycLen; i--; ) {
            str += N / D | 0;
            N %= D;
            N *= 10;
          }
          str += ")";
        } else {
          for (var i = dec; N && i--; ) {
            str += N / D | 0;
            N %= D;
            N *= 10;
          }
        }
        return str;
      }
    };

    {
      Object.defineProperty(exports, "__esModule", {'value': true});
      Fraction['default'] = Fraction;
      Fraction['Fraction'] = Fraction;
      module['exports'] = Fraction;
    }

  })(commonjsGlobal);
  });

  var Fraction = unwrapExports(fraction);

  var name$3 = 'Fraction';
  var dependencies$4 = [];
  var createFractionClass = /* #__PURE__ */factory(name$3, dependencies$4, function () {
    /**
     * Attach type information
     */
    Fraction.prototype.type = 'Fraction';
    Fraction.prototype.isFraction = true;
    /**
     * Get a JSON representation of a Fraction containing type information
     * @returns {Object} Returns a JSON object structured as:
     *                   `{"mathjs": "Fraction", "n": 3, "d": 8}`
     */

    Fraction.prototype.toJSON = function () {
      return {
        mathjs: 'Fraction',
        n: this.s * this.n,
        d: this.d
      };
    };
    /**
     * Instantiate a Fraction from a JSON object
     * @param {Object} json  a JSON object structured as:
     *                       `{"mathjs": "Fraction", "n": 3, "d": 8}`
     * @return {BigNumber}
     */


    Fraction.fromJSON = function (json) {
      return new Fraction(json);
    };

    return Fraction;
  }, {
    isClass: true
  });

  var name$4 = 'Range';
  var dependencies$5 = [];
  var createRangeClass = /* #__PURE__ */factory(name$4, dependencies$5, function () {
    /**
     * Create a range. A range has a start, step, and end, and contains functions
     * to iterate over the range.
     *
     * A range can be constructed as:
     *
     *     const range = new Range(start, end)
     *     const range = new Range(start, end, step)
     *
     * To get the result of the range:
     *     range.forEach(function (x) {
     *         console.log(x)
     *     })
     *     range.map(function (x) {
     *         return math.sin(x)
     *     })
     *     range.toArray()
     *
     * Example usage:
     *
     *     const c = new Range(2, 6)       // 2:1:5
     *     c.toArray()                     // [2, 3, 4, 5]
     *     const d = new Range(2, -3, -1)  // 2:-1:-2
     *     d.toArray()                     // [2, 1, 0, -1, -2]
     *
     * @class Range
     * @constructor Range
     * @param {number} start  included lower bound
     * @param {number} end    excluded upper bound
     * @param {number} [step] step size, default value is 1
     */
    function Range(start, end, step) {
      if (!(this instanceof Range)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      var hasStart = start !== null && start !== undefined;
      var hasEnd = end !== null && end !== undefined;
      var hasStep = step !== null && step !== undefined;

      if (hasStart) {
        if (isBigNumber(start)) {
          start = start.toNumber();
        } else if (typeof start !== 'number') {
          throw new TypeError('Parameter start must be a number');
        }
      }

      if (hasEnd) {
        if (isBigNumber(end)) {
          end = end.toNumber();
        } else if (typeof end !== 'number') {
          throw new TypeError('Parameter end must be a number');
        }
      }

      if (hasStep) {
        if (isBigNumber(step)) {
          step = step.toNumber();
        } else if (typeof step !== 'number') {
          throw new TypeError('Parameter step must be a number');
        }
      }

      this.start = hasStart ? parseFloat(start) : 0;
      this.end = hasEnd ? parseFloat(end) : 0;
      this.step = hasStep ? parseFloat(step) : 1;
    }
    /**
     * Attach type information
     */


    Range.prototype.type = 'Range';
    Range.prototype.isRange = true;
    /**
     * Parse a string into a range,
     * The string contains the start, optional step, and end, separated by a colon.
     * If the string does not contain a valid range, null is returned.
     * For example str='0:2:11'.
     * @memberof Range
     * @param {string} str
     * @return {Range | null} range
     */

    Range.parse = function (str) {
      if (typeof str !== 'string') {
        return null;
      }

      var args = str.split(':');
      var nums = args.map(function (arg) {
        return parseFloat(arg);
      });
      var invalid = nums.some(function (num) {
        return isNaN(num);
      });

      if (invalid) {
        return null;
      }

      switch (nums.length) {
        case 2:
          return new Range(nums[0], nums[1]);

        case 3:
          return new Range(nums[0], nums[2], nums[1]);

        default:
          return null;
      }
    };
    /**
     * Create a clone of the range
     * @return {Range} clone
     */


    Range.prototype.clone = function () {
      return new Range(this.start, this.end, this.step);
    };
    /**
     * Retrieve the size of the range.
     * Returns an array containing one number, the number of elements in the range.
     * @memberof Range
     * @returns {number[]} size
     */


    Range.prototype.size = function () {
      var len = 0;
      var start = this.start;
      var step = this.step;
      var end = this.end;
      var diff = end - start;

      if (sign(step) === sign(diff)) {
        len = Math.ceil(diff / step);
      } else if (diff === 0) {
        len = 0;
      }

      if (isNaN(len)) {
        len = 0;
      }

      return [len];
    };
    /**
     * Calculate the minimum value in the range
     * @memberof Range
     * @return {number | undefined} min
     */


    Range.prototype.min = function () {
      var size = this.size()[0];

      if (size > 0) {
        if (this.step > 0) {
          // positive step
          return this.start;
        } else {
          // negative step
          return this.start + (size - 1) * this.step;
        }
      } else {
        return undefined;
      }
    };
    /**
     * Calculate the maximum value in the range
     * @memberof Range
     * @return {number | undefined} max
     */


    Range.prototype.max = function () {
      var size = this.size()[0];

      if (size > 0) {
        if (this.step > 0) {
          // positive step
          return this.start + (size - 1) * this.step;
        } else {
          // negative step
          return this.start;
        }
      } else {
        return undefined;
      }
    };
    /**
     * Execute a callback function for each value in the range.
     * @memberof Range
     * @param {function} callback   The callback method is invoked with three
     *                              parameters: the value of the element, the index
     *                              of the element, and the Range being traversed.
     */


    Range.prototype.forEach = function (callback) {
      var x = this.start;
      var step = this.step;
      var end = this.end;
      var i = 0;

      if (step > 0) {
        while (x < end) {
          callback(x, [i], this);
          x += step;
          i++;
        }
      } else if (step < 0) {
        while (x > end) {
          callback(x, [i], this);
          x += step;
          i++;
        }
      }
    };
    /**
     * Execute a callback function for each value in the Range, and return the
     * results as an array
     * @memberof Range
     * @param {function} callback   The callback method is invoked with three
     *                              parameters: the value of the element, the index
     *                              of the element, and the Matrix being traversed.
     * @returns {Array} array
     */


    Range.prototype.map = function (callback) {
      var array = [];
      this.forEach(function (value, index, obj) {
        array[index[0]] = callback(value, index, obj);
      });
      return array;
    };
    /**
     * Create an Array with a copy of the Ranges data
     * @memberof Range
     * @returns {Array} array
     */


    Range.prototype.toArray = function () {
      var array = [];
      this.forEach(function (value, index) {
        array[index[0]] = value;
      });
      return array;
    };
    /**
     * Get the primitive value of the Range, a one dimensional array
     * @memberof Range
     * @returns {Array} array
     */


    Range.prototype.valueOf = function () {
      // TODO: implement a caching mechanism for range.valueOf()
      return this.toArray();
    };
    /**
     * Get a string representation of the range, with optional formatting options.
     * Output is formatted as 'start:step:end', for example '2:6' or '0:0.2:11'
     * @memberof Range
     * @param {Object | number | function} [options]  Formatting options. See
     *                                                lib/utils/number:format for a
     *                                                description of the available
     *                                                options.
     * @returns {string} str
     */


    Range.prototype.format = function (options) {
      var str = format(this.start, options);

      if (this.step !== 1) {
        str += ':' + format(this.step, options);
      }

      str += ':' + format(this.end, options);
      return str;
    };
    /**
     * Get a string representation of the range.
     * @memberof Range
     * @returns {string}
     */


    Range.prototype.toString = function () {
      return this.format();
    };
    /**
     * Get a JSON representation of the range
     * @memberof Range
     * @returns {Object} Returns a JSON object structured as:
     *                   `{"mathjs": "Range", "start": 2, "end": 4, "step": 1}`
     */


    Range.prototype.toJSON = function () {
      return {
        mathjs: 'Range',
        start: this.start,
        end: this.end,
        step: this.step
      };
    };
    /**
     * Instantiate a Range from a JSON object
     * @memberof Range
     * @param {Object} json A JSON object structured as:
     *                      `{"mathjs": "Range", "start": 2, "end": 4, "step": 1}`
     * @return {Range}
     */


    Range.fromJSON = function (json) {
      return new Range(json.start, json.end, json.step);
    };

    return Range;
  }, {
    isClass: true
  });

  var name$5 = 'Matrix';
  var dependencies$6 = [];
  var createMatrixClass = /* #__PURE__ */factory(name$5, dependencies$6, function () {
    /**
     * @constructor Matrix
     *
     * A Matrix is a wrapper around an Array. A matrix can hold a multi dimensional
     * array. A matrix can be constructed as:
     *
     *     let matrix = math.matrix(data)
     *
     * Matrix contains the functions to resize, get and set values, get the size,
     * clone the matrix and to convert the matrix to a vector, array, or scalar.
     * Furthermore, one can iterate over the matrix using map and forEach.
     * The internal Array of the Matrix can be accessed using the function valueOf.
     *
     * Example usage:
     *
     *     let matrix = math.matrix([[1, 2], [3, 4]])
     *     matix.size()              // [2, 2]
     *     matrix.resize([3, 2], 5)
     *     matrix.valueOf()          // [[1, 2], [3, 4], [5, 5]]
     *     matrix.subset([1,2])       // 3 (indexes are zero-based)
     *
     */
    function Matrix() {
      if (!(this instanceof Matrix)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }
    }
    /**
     * Attach type information
     */


    Matrix.prototype.type = 'Matrix';
    Matrix.prototype.isMatrix = true;
    /**
     * Get the storage format used by the matrix.
     *
     * Usage:
     *     const format = matrix.storage()   // retrieve storage format
     *
     * @return {string}           The storage format.
     */

    Matrix.prototype.storage = function () {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke storage on a Matrix interface');
    };
    /**
     * Get the datatype of the data stored in the matrix.
     *
     * Usage:
     *     const format = matrix.datatype()    // retrieve matrix datatype
     *
     * @return {string}           The datatype.
     */


    Matrix.prototype.datatype = function () {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke datatype on a Matrix interface');
    };
    /**
     * Create a new Matrix With the type of the current matrix instance
     * @param {Array | Object} data
     * @param {string} [datatype]
     */


    Matrix.prototype.create = function (data, datatype) {
      throw new Error('Cannot invoke create on a Matrix interface');
    };
    /**
     * Get a subset of the matrix, or replace a subset of the matrix.
     *
     * Usage:
     *     const subset = matrix.subset(index)               // retrieve subset
     *     const value = matrix.subset(index, replacement)   // replace subset
     *
     * @param {Index} index
     * @param {Array | Matrix | *} [replacement]
     * @param {*} [defaultValue=0]      Default value, filled in on new entries when
     *                                  the matrix is resized. If not provided,
     *                                  new matrix elements will be filled with zeros.
     */


    Matrix.prototype.subset = function (index, replacement, defaultValue) {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke subset on a Matrix interface');
    };
    /**
     * Get a single element from the matrix.
     * @param {number[]} index   Zero-based index
     * @return {*} value
     */


    Matrix.prototype.get = function (index) {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke get on a Matrix interface');
    };
    /**
     * Replace a single element in the matrix.
     * @param {number[]} index   Zero-based index
     * @param {*} value
     * @param {*} [defaultValue]        Default value, filled in on new entries when
     *                                  the matrix is resized. If not provided,
     *                                  new matrix elements will be left undefined.
     * @return {Matrix} self
     */


    Matrix.prototype.set = function (index, value, defaultValue) {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke set on a Matrix interface');
    };
    /**
     * Resize the matrix to the given size. Returns a copy of the matrix when
     * `copy=true`, otherwise return the matrix itself (resize in place).
     *
     * @param {number[]} size           The new size the matrix should have.
     * @param {*} [defaultValue=0]      Default value, filled in on new entries.
     *                                  If not provided, the matrix elements will
     *                                  be filled with zeros.
     * @param {boolean} [copy]          Return a resized copy of the matrix
     *
     * @return {Matrix}                 The resized matrix
     */


    Matrix.prototype.resize = function (size, defaultValue) {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke resize on a Matrix interface');
    };
    /**
     * Reshape the matrix to the given size. Returns a copy of the matrix when
     * `copy=true`, otherwise return the matrix itself (reshape in place).
     *
     * @param {number[]} size           The new size the matrix should have.
     * @param {boolean} [copy]          Return a reshaped copy of the matrix
     *
     * @return {Matrix}                 The reshaped matrix
     */


    Matrix.prototype.reshape = function (size, defaultValue) {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke reshape on a Matrix interface');
    };
    /**
     * Create a clone of the matrix
     * @return {Matrix} clone
     */


    Matrix.prototype.clone = function () {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke clone on a Matrix interface');
    };
    /**
     * Retrieve the size of the matrix.
     * @returns {number[]} size
     */


    Matrix.prototype.size = function () {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke size on a Matrix interface');
    };
    /**
     * Create a new matrix with the results of the callback function executed on
     * each entry of the matrix.
     * @param {Function} callback   The callback function is invoked with three
     *                              parameters: the value of the element, the index
     *                              of the element, and the Matrix being traversed.
     * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
     *
     * @return {Matrix} matrix
     */


    Matrix.prototype.map = function (callback, skipZeros) {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke map on a Matrix interface');
    };
    /**
     * Execute a callback function on each entry of the matrix.
     * @param {Function} callback   The callback function is invoked with three
     *                              parameters: the value of the element, the index
     *                              of the element, and the Matrix being traversed.
     */


    Matrix.prototype.forEach = function (callback) {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke forEach on a Matrix interface');
    };
    /**
     * Create an Array with a copy of the data of the Matrix
     * @returns {Array} array
     */


    Matrix.prototype.toArray = function () {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke toArray on a Matrix interface');
    };
    /**
     * Get the primitive value of the Matrix: a multidimensional array
     * @returns {Array} array
     */


    Matrix.prototype.valueOf = function () {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke valueOf on a Matrix interface');
    };
    /**
     * Get a string representation of the matrix, with optional formatting options.
     * @param {Object | number | Function} [options]  Formatting options. See
     *                                                lib/utils/number:format for a
     *                                                description of the available
     *                                                options.
     * @returns {string} str
     */


    Matrix.prototype.format = function (options) {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke format on a Matrix interface');
    };
    /**
     * Get a string representation of the matrix
     * @returns {string} str
     */


    Matrix.prototype.toString = function () {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke toString on a Matrix interface');
    };

    return Matrix;
  }, {
    isClass: true
  });

  var name$6 = 'DenseMatrix';
  var dependencies$7 = ['Matrix'];
  var createDenseMatrixClass = /* #__PURE__ */factory(name$6, dependencies$7, function (_ref) {
    var Matrix = _ref.Matrix;

    /**
     * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
     * @class DenseMatrix
     */
    function DenseMatrix(data, datatype) {
      if (!(this instanceof DenseMatrix)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      if (datatype && !isString(datatype)) {
        throw new Error('Invalid datatype: ' + datatype);
      }

      if (isMatrix(data)) {
        // check data is a DenseMatrix
        if (data.type === 'DenseMatrix') {
          // clone data & size
          this._data = clone(data._data);
          this._size = clone(data._size);
          this._datatype = datatype || data._datatype;
        } else {
          // build data from existing matrix
          this._data = data.toArray();
          this._size = data.size();
          this._datatype = datatype || data._datatype;
        }
      } else if (data && isArray(data.data) && isArray(data.size)) {
        // initialize fields from JSON representation
        this._data = data.data;
        this._size = data.size; // verify the dimensions of the array

        validate(this._data, this._size);
        this._datatype = datatype || data.datatype;
      } else if (isArray(data)) {
        // replace nested Matrices with Arrays
        this._data = preprocess(data); // get the dimensions of the array

        this._size = arraySize(this._data); // verify the dimensions of the array, TODO: compute size while processing array

        validate(this._data, this._size); // data type unknown

        this._datatype = datatype;
      } else if (data) {
        // unsupported type
        throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');
      } else {
        // nothing provided
        this._data = [];
        this._size = [0];
        this._datatype = datatype;
      }
    }

    DenseMatrix.prototype = new Matrix();
    /**
     * Create a new DenseMatrix
     */

    DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {
      return new DenseMatrix(data, datatype);
    };
    /**
     * Attach type information
     */


    DenseMatrix.prototype.type = 'DenseMatrix';
    DenseMatrix.prototype.isDenseMatrix = true;
    /**
     * Get the matrix type
     *
     * Usage:
     *    const matrixType = matrix.getDataType()  // retrieves the matrix type
     *
     * @memberOf DenseMatrix
     * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
     */

    DenseMatrix.prototype.getDataType = function () {
      return getArrayDataType(this._data, typeOf);
    };
    /**
     * Get the storage format used by the matrix.
     *
     * Usage:
     *     const format = matrix.storage()  // retrieve storage format
     *
     * @memberof DenseMatrix
     * @return {string}           The storage format.
     */


    DenseMatrix.prototype.storage = function () {
      return 'dense';
    };
    /**
     * Get the datatype of the data stored in the matrix.
     *
     * Usage:
     *     const format = matrix.datatype()   // retrieve matrix datatype
     *
     * @memberof DenseMatrix
     * @return {string}           The datatype.
     */


    DenseMatrix.prototype.datatype = function () {
      return this._datatype;
    };
    /**
     * Create a new DenseMatrix
     * @memberof DenseMatrix
     * @param {Array} data
     * @param {string} [datatype]
     */


    DenseMatrix.prototype.create = function (data, datatype) {
      return new DenseMatrix(data, datatype);
    };
    /**
     * Get a subset of the matrix, or replace a subset of the matrix.
     *
     * Usage:
     *     const subset = matrix.subset(index)               // retrieve subset
     *     const value = matrix.subset(index, replacement)   // replace subset
     *
     * @memberof DenseMatrix
     * @param {Index} index
     * @param {Array | Matrix | *} [replacement]
     * @param {*} [defaultValue=0]      Default value, filled in on new entries when
     *                                  the matrix is resized. If not provided,
     *                                  new matrix elements will be filled with zeros.
     */


    DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {
      switch (arguments.length) {
        case 1:
          return _get(this, index);
        // intentional fall through

        case 2:
        case 3:
          return _set(this, index, replacement, defaultValue);

        default:
          throw new SyntaxError('Wrong number of arguments');
      }
    };
    /**
     * Get a single element from the matrix.
     * @memberof DenseMatrix
     * @param {number[]} index   Zero-based index
     * @return {*} value
     */


    DenseMatrix.prototype.get = function (index) {
      if (!isArray(index)) {
        throw new TypeError('Array expected');
      }

      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      } // check index


      for (var x = 0; x < index.length; x++) {
        validateIndex(index[x], this._size[x]);
      }

      var data = this._data;

      for (var i = 0, ii = index.length; i < ii; i++) {
        var indexI = index[i];
        validateIndex(indexI, data.length);
        data = data[indexI];
      }

      return data;
    };
    /**
     * Replace a single element in the matrix.
     * @memberof DenseMatrix
     * @param {number[]} index   Zero-based index
     * @param {*} value
     * @param {*} [defaultValue]        Default value, filled in on new entries when
     *                                  the matrix is resized. If not provided,
     *                                  new matrix elements will be left undefined.
     * @return {DenseMatrix} self
     */


    DenseMatrix.prototype.set = function (index, value, defaultValue) {
      if (!isArray(index)) {
        throw new TypeError('Array expected');
      }

      if (index.length < this._size.length) {
        throw new DimensionError(index.length, this._size.length, '<');
      }

      var i, ii, indexI; // enlarge matrix when needed

      var size = index.map(function (i) {
        return i + 1;
      });

      _fit(this, size, defaultValue); // traverse over the dimensions


      var data = this._data;

      for (i = 0, ii = index.length - 1; i < ii; i++) {
        indexI = index[i];
        validateIndex(indexI, data.length);
        data = data[indexI];
      } // set new value


      indexI = index[index.length - 1];
      validateIndex(indexI, data.length);
      data[indexI] = value;
      return this;
    };
    /**
     * Get a submatrix of this matrix
     * @memberof DenseMatrix
     * @param {DenseMatrix} matrix
     * @param {Index} index   Zero-based index
     * @private
     */


    function _get(matrix, index) {
      if (!isIndex(index)) {
        throw new TypeError('Invalid index');
      }

      var isScalar = index.isScalar();

      if (isScalar) {
        // return a scalar
        return matrix.get(index.min());
      } else {
        // validate dimensions
        var size = index.size();

        if (size.length !== matrix._size.length) {
          throw new DimensionError(size.length, matrix._size.length);
        } // validate if any of the ranges in the index is out of range


        var min = index.min();
        var max = index.max();

        for (var i = 0, ii = matrix._size.length; i < ii; i++) {
          validateIndex(min[i], matrix._size[i]);
          validateIndex(max[i], matrix._size[i]);
        } // retrieve submatrix
        // TODO: more efficient when creating an empty matrix and setting _data and _size manually


        return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);
      }
    }
    /**
     * Recursively get a submatrix of a multi dimensional matrix.
     * Index is not checked for correct number or length of dimensions.
     * @memberof DenseMatrix
     * @param {Array} data
     * @param {Index} index
     * @param {number} dims   Total number of dimensions
     * @param {number} dim    Current dimension
     * @return {Array} submatrix
     * @private
     */


    function _getSubmatrix(data, index, dims, dim) {
      var last$$1 = dim === dims - 1;
      var range = index.dimension(dim);

      if (last$$1) {
        return range.map(function (i) {
          validateIndex(i, data.length);
          return data[i];
        }).valueOf();
      } else {
        return range.map(function (i) {
          validateIndex(i, data.length);
          var child = data[i];
          return _getSubmatrix(child, index, dims, dim + 1);
        }).valueOf();
      }
    }
    /**
     * Replace a submatrix in this matrix
     * Indexes are zero-based.
     * @memberof DenseMatrix
     * @param {DenseMatrix} matrix
     * @param {Index} index
     * @param {DenseMatrix | Array | *} submatrix
     * @param {*} defaultValue          Default value, filled in on new entries when
     *                                  the matrix is resized.
     * @return {DenseMatrix} matrix
     * @private
     */


    function _set(matrix, index, submatrix, defaultValue) {
      if (!index || index.isIndex !== true) {
        throw new TypeError('Invalid index');
      } // get index size and check whether the index contains a single value


      var iSize = index.size();
      var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed

      var sSize;

      if (isMatrix(submatrix)) {
        sSize = submatrix.size();
        submatrix = submatrix.valueOf();
      } else {
        sSize = arraySize(submatrix);
      }

      if (isScalar) {
        // set a scalar
        // check whether submatrix is a scalar
        if (sSize.length !== 0) {
          throw new TypeError('Scalar expected');
        }

        matrix.set(index.min(), submatrix, defaultValue);
      } else {
        // set a submatrix
        // validate dimensions
        if (iSize.length < matrix._size.length) {
          throw new DimensionError(iSize.length, matrix._size.length, '<');
        }

        if (sSize.length < iSize.length) {
          // calculate number of missing outer dimensions
          var i = 0;
          var outer = 0;

          while (iSize[i] === 1 && sSize[i] === 1) {
            i++;
          }

          while (iSize[i] === 1) {
            outer++;
            i++;
          } // unsqueeze both outer and inner dimensions


          submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
        } // check whether the size of the submatrix matches the index size


        if (!deepStrictEqual(iSize, sSize)) {
          throw new DimensionError(iSize, sSize, '>');
        } // enlarge matrix when needed


        var size = index.max().map(function (i) {
          return i + 1;
        });

        _fit(matrix, size, defaultValue); // insert the sub matrix


        var dims = iSize.length;
        var dim = 0;

        _setSubmatrix(matrix._data, index, submatrix, dims, dim);
      }

      return matrix;
    }
    /**
     * Replace a submatrix of a multi dimensional matrix.
     * @memberof DenseMatrix
     * @param {Array} data
     * @param {Index} index
     * @param {Array} submatrix
     * @param {number} dims   Total number of dimensions
     * @param {number} dim
     * @private
     */


    function _setSubmatrix(data, index, submatrix, dims, dim) {
      var last$$1 = dim === dims - 1;
      var range = index.dimension(dim);

      if (last$$1) {
        range.forEach(function (dataIndex, subIndex) {
          validateIndex(dataIndex);
          data[dataIndex] = submatrix[subIndex[0]];
        });
      } else {
        range.forEach(function (dataIndex, subIndex) {
          validateIndex(dataIndex);

          _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);
        });
      }
    }
    /**
     * Resize the matrix to the given size. Returns a copy of the matrix when
     * `copy=true`, otherwise return the matrix itself (resize in place).
     *
     * @memberof DenseMatrix
     * @param {number[] || Matrix} size The new size the matrix should have.
     * @param {*} [defaultValue=0]      Default value, filled in on new entries.
     *                                  If not provided, the matrix elements will
     *                                  be filled with zeros.
     * @param {boolean} [copy]          Return a resized copy of the matrix
     *
     * @return {Matrix}                 The resized matrix
     */


    DenseMatrix.prototype.resize = function (size, defaultValue, copy) {
      // validate arguments
      if (!isCollection(size)) {
        throw new TypeError('Array or Matrix expected');
      } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector


      var sizeArray = size.valueOf().map(function (value) {
        return Array.isArray(value) && value.length === 1 ? value[0] : value;
      }); // matrix to resize

      var m = copy ? this.clone() : this; // resize matrix

      return _resize(m, sizeArray, defaultValue);
    };

    function _resize(matrix, size, defaultValue) {
      // check size
      if (size.length === 0) {
        // first value in matrix
        var v = matrix._data; // go deep

        while (isArray(v)) {
          v = v[0];
        }

        return v;
      } // resize matrix


      matrix._size = size.slice(0); // copy the array

      matrix._data = resize(matrix._data, matrix._size, defaultValue); // return matrix

      return matrix;
    }
    /**
     * Reshape the matrix to the given size. Returns a copy of the matrix when
     * `copy=true`, otherwise return the matrix itself (reshape in place).
     *
     * NOTE: This might be better suited to copy by default, instead of modifying
     *       in place. For now, it operates in place to remain consistent with
     *       resize().
     *
     * @memberof DenseMatrix
     * @param {number[]} size           The new size the matrix should have.
     * @param {boolean} [copy]          Return a reshaped copy of the matrix
     *
     * @return {Matrix}                 The reshaped matrix
     */


    DenseMatrix.prototype.reshape = function (size, copy) {
      var m = copy ? this.clone() : this;
      m._data = reshape(m._data, size);
      m._size = size.slice(0);
      return m;
    };
    /**
     * Enlarge the matrix when it is smaller than given size.
     * If the matrix is larger or equal sized, nothing is done.
     * @memberof DenseMatrix
     * @param {DenseMatrix} matrix           The matrix to be resized
     * @param {number[]} size
     * @param {*} defaultValue          Default value, filled in on new entries.
     * @private
     */


    function _fit(matrix, size, defaultValue) {
      var // copy the array
      newSize = matrix._size.slice(0);

      var changed = false; // add dimensions when needed

      while (newSize.length < size.length) {
        newSize.push(0);
        changed = true;
      } // enlarge size when needed


      for (var i = 0, ii = size.length; i < ii; i++) {
        if (size[i] > newSize[i]) {
          newSize[i] = size[i];
          changed = true;
        }
      }

      if (changed) {
        // resize only when size is changed
        _resize(matrix, newSize, defaultValue);
      }
    }
    /**
     * Create a clone of the matrix
     * @memberof DenseMatrix
     * @return {DenseMatrix} clone
     */


    DenseMatrix.prototype.clone = function () {
      var m = new DenseMatrix({
        data: clone(this._data),
        size: clone(this._size),
        datatype: this._datatype
      });
      return m;
    };
    /**
     * Retrieve the size of the matrix.
     * @memberof DenseMatrix
     * @returns {number[]} size
     */


    DenseMatrix.prototype.size = function () {
      return this._size.slice(0); // return a clone of _size
    };
    /**
     * Create a new matrix with the results of the callback function executed on
     * each entry of the matrix.
     * @memberof DenseMatrix
     * @param {Function} callback   The callback function is invoked with three
     *                              parameters: the value of the element, the index
     *                              of the element, and the Matrix being traversed.
     *
     * @return {DenseMatrix} matrix
     */


    DenseMatrix.prototype.map = function (callback) {
      // matrix instance
      var me = this;

      var recurse = function recurse(value, index) {
        if (isArray(value)) {
          return value.map(function (child, i) {
            return recurse(child, index.concat(i));
          });
        } else {
          return callback(value, index, me);
        }
      }; // determine the new datatype when the original matrix has datatype defined
      // TODO: should be done in matrix constructor instead


      var data = recurse(this._data, []);
      var datatype = this._datatype !== undefined ? getArrayDataType(data, typeOf) : undefined;
      return new DenseMatrix(data, datatype);
    };
    /**
     * Execute a callback function on each entry of the matrix.
     * @memberof DenseMatrix
     * @param {Function} callback   The callback function is invoked with three
     *                              parameters: the value of the element, the index
     *                              of the element, and the Matrix being traversed.
     */


    DenseMatrix.prototype.forEach = function (callback) {
      // matrix instance
      var me = this;

      var recurse = function recurse(value, index) {
        if (isArray(value)) {
          value.forEach(function (child, i) {
            recurse(child, index.concat(i));
          });
        } else {
          callback(value, index, me);
        }
      };

      recurse(this._data, []);
    };
    /**
     * Create an Array with a copy of the data of the DenseMatrix
     * @memberof DenseMatrix
     * @returns {Array} array
     */


    DenseMatrix.prototype.toArray = function () {
      return clone(this._data);
    };
    /**
     * Get the primitive value of the DenseMatrix: a multidimensional array
     * @memberof DenseMatrix
     * @returns {Array} array
     */


    DenseMatrix.prototype.valueOf = function () {
      return this._data;
    };
    /**
     * Get a string representation of the matrix, with optional formatting options.
     * @memberof DenseMatrix
     * @param {Object | number | Function} [options]  Formatting options. See
     *                                                lib/utils/number:format for a
     *                                                description of the available
     *                                                options.
     * @returns {string} str
     */


    DenseMatrix.prototype.format = function (options) {
      return format$2(this._data, options);
    };
    /**
     * Get a string representation of the matrix
     * @memberof DenseMatrix
     * @returns {string} str
     */


    DenseMatrix.prototype.toString = function () {
      return format$2(this._data);
    };
    /**
     * Get a JSON representation of the matrix
     * @memberof DenseMatrix
     * @returns {Object}
     */


    DenseMatrix.prototype.toJSON = function () {
      return {
        mathjs: 'DenseMatrix',
        data: this._data,
        size: this._size,
        datatype: this._datatype
      };
    };
    /**
     * Get the kth Matrix diagonal.
     *
     * @memberof DenseMatrix
     * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
     *
     * @returns {Matrix}                     The matrix with the diagonal values.
     */


    DenseMatrix.prototype.diagonal = function (k) {
      // validate k if any
      if (k) {
        // convert BigNumber to a number
        if (isBigNumber(k)) {
          k = k.toNumber();
        } // is must be an integer


        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError('The parameter k must be an integer number');
        }
      } else {
        // default value
        k = 0;
      }

      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0; // rows & columns

      var rows = this._size[0];
      var columns = this._size[1]; // number diagonal values

      var n = Math.min(rows - kSub, columns - kSuper); // x is a matrix get diagonal from matrix

      var data = []; // loop rows

      for (var i = 0; i < n; i++) {
        data[i] = this._data[i + kSub][i + kSuper];
      } // create DenseMatrix


      return new DenseMatrix({
        data: data,
        size: [n],
        datatype: this._datatype
      });
    };
    /**
     * Create a diagonal matrix.
     *
     * @memberof DenseMatrix
     * @param {Array} size                     The matrix size.
     * @param {number | Matrix | Array } value The values for the diagonal.
     * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.
     * @param {number} [defaultValue]          The default value for non-diagonal
     * @param {string} [datatype]              The datatype for the diagonal
     *
     * @returns {DenseMatrix}
     */


    DenseMatrix.diagonal = function (size, value, k, defaultValue) {
      if (!isArray(size)) {
        throw new TypeError('Array expected, size parameter');
      }

      if (size.length !== 2) {
        throw new Error('Only two dimensions matrix are supported');
      } // map size & validate


      size = size.map(function (s) {
        // check it is a big number
        if (isBigNumber(s)) {
          // convert it
          s = s.toNumber();
        } // validate arguments


        if (!isNumber(s) || !isInteger(s) || s < 1) {
          throw new Error('Size values must be positive integers');
        }

        return s;
      }); // validate k if any

      if (k) {
        // convert BigNumber to a number
        if (isBigNumber(k)) {
          k = k.toNumber();
        } // is must be an integer


        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError('The parameter k must be an integer number');
        }
      } else {
        // default value
        k = 0;
      }

      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0; // rows and columns

      var rows = size[0];
      var columns = size[1]; // number of non-zero items

      var n = Math.min(rows - kSub, columns - kSuper); // value extraction function

      var _value; // check value


      if (isArray(value)) {
        // validate array
        if (value.length !== n) {
          // number of values in array must be n
          throw new Error('Invalid value array length');
        } // define function


        _value = function _value(i) {
          // return value @ i
          return value[i];
        };
      } else if (isMatrix(value)) {
        // matrix size
        var ms = value.size(); // validate matrix

        if (ms.length !== 1 || ms[0] !== n) {
          // number of values in array must be n
          throw new Error('Invalid matrix length');
        } // define function


        _value = function _value(i) {
          // return value @ i
          return value.get([i]);
        };
      } else {
        // define function
        _value = function _value() {
          // return value
          return value;
        };
      } // discover default value if needed


      if (!defaultValue) {
        // check first value in array
        defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero
        : 0;
      } // empty array


      var data = []; // check we need to resize array

      if (size.length > 0) {
        // resize array
        data = resize(data, size, defaultValue); // fill diagonal

        for (var d = 0; d < n; d++) {
          data[d + kSub][d + kSuper] = _value(d);
        }
      } // create DenseMatrix


      return new DenseMatrix({
        data: data,
        size: [rows, columns]
      });
    };
    /**
     * Generate a matrix from a JSON object
     * @memberof DenseMatrix
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "DenseMatrix", data: [], size: []}`,
     *                       where mathjs is optional
     * @returns {DenseMatrix}
     */


    DenseMatrix.fromJSON = function (json) {
      return new DenseMatrix(json);
    };
    /**
     * Swap rows i and j in Matrix.
     *
     * @memberof DenseMatrix
     * @param {number} i       Matrix row index 1
     * @param {number} j       Matrix row index 2
     *
     * @return {Matrix}        The matrix reference
     */


    DenseMatrix.prototype.swapRows = function (i, j) {
      // check index
      if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
        throw new Error('Row index must be positive integers');
      } // check dimensions


      if (this._size.length !== 2) {
        throw new Error('Only two dimensional matrix is supported');
      } // validate index


      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[0]); // swap rows

      DenseMatrix._swapRows(i, j, this._data); // return current instance


      return this;
    };
    /**
     * Swap rows i and j in Dense Matrix data structure.
     *
     * @param {number} i       Matrix row index 1
     * @param {number} j       Matrix row index 2
     * @param {Array} data     Matrix data
     */


    DenseMatrix._swapRows = function (i, j, data) {
      // swap values i <-> j
      var vi = data[i];
      data[i] = data[j];
      data[j] = vi;
    };
    /**
     * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and
     * Matrices. Replaces all nested Matrices with Arrays
     * @memberof DenseMatrix
     * @param {Array} data
     * @return {Array} data
     */


    function preprocess(data) {
      for (var i = 0, ii = data.length; i < ii; i++) {
        var elem = data[i];

        if (isArray(elem)) {
          data[i] = preprocess(elem);
        } else if (elem && elem.isMatrix === true) {
          data[i] = preprocess(elem.valueOf());
        }
      }

      return data;
    }

    return DenseMatrix;
  }, {
    isClass: true
  });

  var name$7 = 'clone';
  var dependencies$8 = ['typed'];
  var createClone = /* #__PURE__ */factory(name$7, dependencies$8, function (_ref) {
    var typed = _ref.typed;

    /**
     * Clone an object.
     *
     * Syntax:
     *
     *     math.clone(x)
     *
     * Examples:
     *
     *    math.clone(3.5)                   // returns number 3.5
     *    math.clone(math.complex('2-4i') // returns Complex 2 - 4i
     *    math.clone(math.unit(45, 'deg'))  // returns Unit 45 deg
     *    math.clone([[1, 2], [3, 4]])      // returns Array [[1, 2], [3, 4]]
     *    math.clone("hello world")         // returns string "hello world"
     *
     * @param {*} x   Object to be cloned
     * @return {*} A clone of object x
     */
    return typed(name$7, {
      any: clone
    });
  });

  /**
   * Test whether an array contains collections
   * @param {Array} array
   * @returns {boolean} Returns true when the array contains one or multiple
   *                    collections (Arrays or Matrices). Returns false otherwise.
   */

  function containsCollections(array) {
    for (var i = 0; i < array.length; i++) {
      if (isCollection(array[i])) {
        return true;
      }
    }

    return false;
  }
  /**
   * Recursively loop over all elements in a given multi dimensional array
   * and invoke the callback on each of the elements.
   * @param {Array | Matrix} array
   * @param {Function} callback     The callback method is invoked with one
   *                                parameter: the current element in the array
   */

  function deepForEach(array, callback) {
    if (isMatrix(array)) {
      array = array.valueOf();
    }

    for (var i = 0, ii = array.length; i < ii; i++) {
      var value = array[i];

      if (Array.isArray(value)) {
        deepForEach(value, callback);
      } else {
        callback(value);
      }
    }
  }
  /**
   * Execute the callback function element wise for each element in array and any
   * nested array
   * Returns an array with the results
   * @param {Array | Matrix} array
   * @param {Function} callback   The callback is called with two parameters:
   *                              value1 and value2, which contain the current
   *                              element of both arrays.
   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
   *
   * @return {Array | Matrix} res
   */

  function deepMap(array, callback, skipZeros) {
    if (array && typeof array.map === 'function') {
      // TODO: replace array.map with a for loop to improve performance
      return array.map(function (x) {
        return deepMap(x, callback, skipZeros);
      });
    } else {
      return callback(array);
    }
  }
  /**
   * Reduce a given matrix or array to a new matrix or
   * array with one less dimension, applying the given
   * callback in the selected dimension.
   * @param {Array | Matrix} mat
   * @param {number} dim
   * @param {Function} callback
   * @return {Array | Matrix} res
   */

  function reduce(mat, dim, callback) {
    var size = Array.isArray(mat) ? arraySize(mat) : mat.size();

    if (dim < 0 || dim >= size.length) {
      // TODO: would be more clear when throwing a DimensionError here
      throw new IndexError(dim, size.length);
    }

    if (isMatrix(mat)) {
      return mat.create(_reduce(mat.valueOf(), dim, callback));
    } else {
      return _reduce(mat, dim, callback);
    }
  }
  /**
   * Recursively reduce a matrix
   * @param {Array} mat
   * @param {number} dim
   * @param {Function} callback
   * @returns {Array} ret
   * @private
   */

  function _reduce(mat, dim, callback) {
    var i, ret, val, tran;

    if (dim <= 0) {
      if (!Array.isArray(mat[0])) {
        val = mat[0];

        for (i = 1; i < mat.length; i++) {
          val = callback(val, mat[i]);
        }

        return val;
      } else {
        tran = _switch(mat);
        ret = [];

        for (i = 0; i < tran.length; i++) {
          ret[i] = _reduce(tran[i], dim - 1, callback);
        }

        return ret;
      }
    } else {
      ret = [];

      for (i = 0; i < mat.length; i++) {
        ret[i] = _reduce(mat[i], dim - 1, callback);
      }

      return ret;
    }
  }
  /**
   * Transpose a matrix
   * @param {Array} mat
   * @returns {Array} ret
   * @private
   */


  function _switch(mat) {
    var I = mat.length;
    var J = mat[0].length;
    var i, j;
    var ret = [];

    for (j = 0; j < J; j++) {
      var tmp = [];

      for (i = 0; i < I; i++) {
        tmp.push(mat[i][j]);
      }

      ret.push(tmp);
    }

    return ret;
  } // TODO: document function scatter


  function scatter(a, j, w, x, u, mark, cindex, f, inverse, update, value) {
    // a arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr; // vars

    var k, k0, k1, i; // check we need to process values (pattern matrix)

    if (x) {
      // values in j
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        // row
        i = aindex[k]; // check value exists in current j

        if (w[i] !== mark) {
          // i is new entry in j
          w[i] = mark; // add i to pattern of C

          cindex.push(i); // x(i) = A, check we need to call function this time

          if (update) {
            // copy value to workspace calling callback function
            x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]); // function was called on current row

            u[i] = mark;
          } else {
            // copy value to workspace
            x[i] = avalues[k];
          }
        } else {
          // i exists in C already
          x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]); // function was called on current row

          u[i] = mark;
        }
      }
    } else {
      // values in j
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        // row
        i = aindex[k]; // check value exists in current j

        if (w[i] !== mark) {
          // i is new entry in j
          w[i] = mark; // add i to pattern of C

          cindex.push(i);
        } else {
          // indicate function was called on current row
          u[i] = mark;
        }
      }
    }
  }

  var name$8 = 'isInteger';
  var dependencies$9 = ['typed'];
  var createIsInteger = /* #__PURE__ */factory(name$8, dependencies$9, function (_ref) {
    var typed = _ref.typed;

    /**
     * Test whether a value is an integer number.
     * The function supports `number`, `BigNumber`, and `Fraction`.
     *
     * The function is evaluated element-wise in case of Array or Matrix input.
     *
     * Syntax:
     *
     *     math.isInteger(x)
     *
     * Examples:
     *
     *    math.isInteger(2)                     // returns true
     *    math.isInteger(0)                     // returns true
     *    math.isInteger(0.5)                   // returns false
     *    math.isInteger(math.bignumber(500))   // returns true
     *    math.isInteger(math.fraction(4))      // returns true
     *    math.isInteger('3')                   // returns true
     *    math.isInteger([3, 0.5, -2])          // returns [true, false, true]
     *    math.isInteger(math.complex('2-4i')   // throws an error
     *
     * See also:
     *
     *    isNumeric, isPositive, isNegative, isZero
     *
     * @param {number | BigNumber | Fraction | Array | Matrix} x   Value to be tested
     * @return {boolean}  Returns true when `x` contains a numeric, integer value.
     *                    Throws an error in case of an unknown data type.
     */
    return typed(name$8, {
      number: isInteger,
      // TODO: what to do with isInteger(add(0.1, 0.2))  ?
      BigNumber: function BigNumber(x) {
        return x.isInt();
      },
      Fraction: function Fraction(x) {
        return x.d === 1 && isFinite(x.n);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var n1 = 'number';
  var n2 = 'number, number';
  function absNumber(a) {
    return Math.abs(a);
  }
  absNumber.signature = n1;
  function addNumber(a, b) {
    return a + b;
  }
  addNumber.signature = n2;
  function multiplyNumber(a, b) {
    return a * b;
  }
  multiplyNumber.signature = n2;
  function unaryMinusNumber(x) {
    return -x;
  }
  unaryMinusNumber.signature = n1;
  function unaryPlusNumber(x) {
    return x;
  }
  unaryPlusNumber.signature = n1;
  function cbrtNumber(x) {
    return cbrt(x);
  }
  cbrtNumber.signature = n1;
  function ceilNumber(x) {
    return Math.ceil(x);
  }
  ceilNumber.signature = n1;
  function cubeNumber(x) {
    return x * x * x;
  }
  cubeNumber.signature = n1;
  function expNumber(x) {
    return Math.exp(x);
  }
  expNumber.signature = n1;
  function expm1Number(x) {
    return expm1(x);
  }
  expm1Number.signature = n1;
  /**
   * Calculate gcd for numbers
   * @param {number} a
   * @param {number} b
   * @returns {number} Returns the greatest common denominator of a and b
   */

  function gcdNumber(a, b) {
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error('Parameters in function gcd must be integer numbers');
    } // https://en.wikipedia.org/wiki/Euclidean_algorithm


    var r;

    while (b !== 0) {
      r = a % b;
      a = b;
      b = r;
    }

    return a < 0 ? -a : a;
  }
  gcdNumber.signature = n2;
  /**
   * Calculate lcm for two numbers
   * @param {number} a
   * @param {number} b
   * @returns {number} Returns the least common multiple of a and b
   */

  function lcmNumber(a, b) {
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error('Parameters in function lcm must be integer numbers');
    }

    if (a === 0 || b === 0) {
      return 0;
    } // https://en.wikipedia.org/wiki/Euclidean_algorithm
    // evaluate lcm here inline to reduce overhead


    var t;
    var prod = a * b;

    while (b !== 0) {
      t = b;
      b = a % t;
      a = t;
    }

    return Math.abs(prod / a);
  }
  lcmNumber.signature = n2;
  /**
   * Calculate the logarithm of a value.
   * @param {number} x
   * @return {number}
   */

  function logNumber(x) {
    return Math.log(x);
  }
  logNumber.signature = n1;
  /**
   * Calculate the 10-base logarithm of a number
   * @param {number} x
   * @return {number}
   */

  function log10Number(x) {
    return log10(x);
  }
  log10Number.signature = n1;
  /**
   * Calculate the 2-base logarithm of a number
   * @param {number} x
   * @return {number}
   */

  function log2Number(x) {
    return log2(x);
  }
  log2Number.signature = n1;
  /**
   * Calculate the modulus of two numbers
   * @param {number} x
   * @param {number} y
   * @returns {number} res
   * @private
   */

  function modNumber(x, y) {
    if (y > 0) {
      // We don't use JavaScript's % operator here as this doesn't work
      // correctly for x < 0 and x === 0
      // see https://en.wikipedia.org/wiki/Modulo_operation
      return x - y * Math.floor(x / y);
    } else if (y === 0) {
      return x;
    } else {
      // y < 0
      // TODO: implement mod for a negative divisor
      throw new Error('Cannot calculate mod for a negative divisor');
    }
  }
  modNumber.signature = n2;
  /**
   * Calculate the nth root of a, solve x^root == a
   * http://rosettacode.org/wiki/Nth_root#JavaScript
   * @param {number} a
   * @param {number} root
   * @private
   */

  function nthRootNumber(a, root) {
    var inv = root < 0;

    if (inv) {
      root = -root;
    }

    if (root === 0) {
      throw new Error('Root must be non-zero');
    }

    if (a < 0 && Math.abs(root) % 2 !== 1) {
      throw new Error('Root must be odd when a is negative.');
    } // edge cases zero and infinity


    if (a === 0) {
      return inv ? Infinity : 0;
    }

    if (!isFinite(a)) {
      return inv ? 0 : a;
    }

    var x = Math.pow(Math.abs(a), 1 / root); // If a < 0, we require that root is an odd integer,
    // so (-1) ^ (1/root) = -1

    x = a < 0 ? -x : x;
    return inv ? 1 / x : x; // Very nice algorithm, but fails with nthRoot(-2, 3).
    // Newton's method has some well-known problems at times:
    // https://en.wikipedia.org/wiki/Newton%27s_method#Failure_analysis

    /*
    let x = 1 // Initial guess
    let xPrev = 1
    let i = 0
    const iMax = 10000
    do {
      const delta = (a / Math.pow(x, root - 1) - x) / root
      xPrev = x
      x = x + delta
      i++
    }
    while (xPrev !== x && i < iMax)
     if (xPrev !== x) {
      throw new Error('Function nthRoot failed to converge')
    }
     return inv ? 1 / x : x
    */
  }
  nthRootNumber.signature = n2;
  function signNumber(x) {
    return sign(x);
  }
  signNumber.signature = n1;
  function squareNumber(x) {
    return x * x;
  }
  squareNumber.signature = n1;
  /**
   * Calculate xgcd for two numbers
   * @param {number} a
   * @param {number} b
   * @return {number} result
   * @private
   */

  function xgcdNumber(a, b) {
    // source: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
    var t; // used to swap two variables

    var q; // quotient

    var r; // remainder

    var x = 0;
    var lastx = 1;
    var y = 1;
    var lasty = 0;

    if (!isInteger(a) || !isInteger(b)) {
      throw new Error('Parameters in function xgcd must be integer numbers');
    }

    while (b) {
      q = Math.floor(a / b);
      r = a - q * b;
      t = x;
      x = lastx - q * x;
      lastx = t;
      t = y;
      y = lasty - q * y;
      lasty = t;
      a = b;
      b = r;
    }

    var res;

    if (a < 0) {
      res = [-a, -lastx, -lasty];
    } else {
      res = [a, a ? lastx : 0, lasty];
    }

    return res;
  }
  xgcdNumber.signature = n2;
  /**
   * Calculates the power of x to y, x^y, for two numbers.
   * @param {number} x
   * @param {number} y
   * @return {number} res
   */

  function powNumber(x, y) {
    // x^Infinity === 0 if -1 < x < 1
    // A real number 0 is returned instead of complex(0)
    if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
      return 0;
    }

    return Math.pow(x, y);
  }
  powNumber.signature = n2;
  /**
   * round a number to the given number of decimals, or to zero if decimals is
   * not provided
   * @param {number} value
   * @param {number} decimals       number of decimals, between 0 and 15 (0 by default)
   * @return {number} roundedValue
   */

  function roundNumber(value) {
    var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return parseFloat(toFixed(value, decimals));
  }
  roundNumber.signature = n2;

  var n1$1 = 'number';
  var n2$1 = 'number, number';
  function bitAndNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error('Integers expected in function bitAnd');
    }

    return x & y;
  }
  bitAndNumber.signature = n2$1;
  function bitNotNumber(x) {
    if (!isInteger(x)) {
      throw new Error('Integer expected in function bitNot');
    }

    return ~x;
  }
  bitNotNumber.signature = n1$1;
  function bitOrNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error('Integers expected in function bitOr');
    }

    return x | y;
  }
  bitOrNumber.signature = n2$1;
  function bitXorNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error('Integers expected in function bitXor');
    }

    return x ^ y;
  }
  bitXorNumber.signature = n2$1;
  function leftShiftNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error('Integers expected in function leftShift');
    }

    return x << y;
  }
  leftShiftNumber.signature = n2$1;
  function rightArithShiftNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error('Integers expected in function rightArithShift');
    }

    return x >> y;
  }
  rightArithShiftNumber.signature = n2$1;
  function rightLogShiftNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error('Integers expected in function rightLogShift');
    }

    return x >>> y;
  }
  rightLogShiftNumber.signature = n2$1;

  /** @param {number} i
   *  @param {number} n
   *  @returns {number} product of i to n
   */
  function product(i, n) {
    if (n < i) {
      return 1;
    }

    if (n === i) {
      return n;
    }

    var half = n + i >> 1; // divide (n + i) by 2 and truncate to integer

    return product(i, half) * product(half + 1, n);
  }

  function combinationsNumber(n, k) {
    if (!isInteger(n) || n < 0) {
      throw new TypeError('Positive integer value expected in function combinations');
    }

    if (!isInteger(k) || k < 0) {
      throw new TypeError('Positive integer value expected in function combinations');
    }

    if (k > n) {
      throw new TypeError('k must be less than or equal to n');
    }

    var nMinusk = n - k;
    var prodrange;

    if (k < nMinusk) {
      prodrange = product(nMinusk + 1, n);
      return prodrange / product(1, k);
    }

    prodrange = product(k + 1, n);
    return prodrange / product(1, nMinusk);
  }
  combinationsNumber.signature = 'number, number';

  var pi = Math.PI;
  var tau = 2 * Math.PI;
  var e = Math.E;
  var phi = 1.61803398874989484820458683436563811772030917980576286213545;

  var n1$2 = 'number';
  var n2$2 = 'number, number';
  function notNumber(x) {
    return !x;
  }
  notNumber.signature = n1$2;
  function orNumber(x, y) {
    return !!(x || y);
  }
  orNumber.signature = n2$2;
  function xorNumber(x, y) {
    return !!x !== !!y;
  }
  xorNumber.signature = n2$2;
  function andNumber(x, y) {
    return !!(x && y);
  }
  andNumber.signature = n2$2;

  function gammaNumber(n) {
    var x;

    if (isInteger(n)) {
      if (n <= 0) {
        return isFinite(n) ? Infinity : NaN;
      }

      if (n > 171) {
        return Infinity; // Will overflow
      }

      return product(1, n - 1);
    }

    if (n < 0.5) {
      return Math.PI / (Math.sin(Math.PI * n) * gammaNumber(1 - n));
    }

    if (n >= 171.35) {
      return Infinity; // will overflow
    }

    if (n > 85.0) {
      // Extended Stirling Approx
      var twoN = n * n;
      var threeN = twoN * n;
      var fourN = threeN * n;
      var fiveN = fourN * n;
      return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
    }

    --n;
    x = gammaP[0];

    for (var i = 1; i < gammaP.length; ++i) {
      x += gammaP[i] / (n + i);
    }

    var t = n + gammaG + 0.5;
    return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
  }
  gammaNumber.signature = 'number'; // TODO: comment on the variables g and p

  var gammaG = 4.7421875;
  var gammaP = [0.99999999999999709182, 57.156235665862923517, -59.597960355475491248, 14.136097974741747174, -0.49191381609762019978, 0.33994649984811888699e-4, 0.46523628927048575665e-4, -0.98374475304879564677e-4, 0.15808870322491248884e-3, -0.21026444172410488319e-3, 0.21743961811521264320e-3, -0.16431810653676389022e-3, 0.84418223983852743293e-4, -0.26190838401581408670e-4, 0.36899182659531622704e-5];

  var n1$3 = 'number';
  function acoshNumber(x) {
    return acosh(x);
  }
  acoshNumber.signature = n1$3;
  function acotNumber(x) {
    return Math.atan(1 / x);
  }
  acotNumber.signature = n1$3;
  function acothNumber(x) {
    return isFinite(x) ? (Math.log((x + 1) / x) + Math.log(x / (x - 1))) / 2 : 0;
  }
  acothNumber.signature = n1$3;
  function acscNumber(x) {
    return Math.asin(1 / x);
  }
  acscNumber.signature = n1$3;
  function acschNumber(x) {
    var xInv = 1 / x;
    return Math.log(xInv + Math.sqrt(xInv * xInv + 1));
  }
  acschNumber.signature = n1$3;
  function asecNumber(x) {
    return Math.acos(1 / x);
  }
  asecNumber.signature = n1$3;
  function asechNumber(x) {
    var xInv = 1 / x;
    var ret = Math.sqrt(xInv * xInv - 1);
    return Math.log(ret + xInv);
  }
  asechNumber.signature = n1$3;
  function asinhNumber(x) {
    return asinh(x);
  }
  asinhNumber.signature = n1$3;
  function atanhNumber(x) {
    return atanh(x);
  }
  atanhNumber.signature = n1$3;
  function cotNumber(x) {
    return 1 / Math.tan(x);
  }
  cotNumber.signature = n1$3;
  function cothNumber(x) {
    var e = Math.exp(2 * x);
    return (e + 1) / (e - 1);
  }
  cothNumber.signature = n1$3;
  function cscNumber(x) {
    return 1 / Math.sin(x);
  }
  cscNumber.signature = n1$3;
  function cschNumber(x) {
    // consider values close to zero (+/-)
    if (x === 0) {
      return Number.POSITIVE_INFINITY;
    } else {
      return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * sign(x);
    }
  }
  cschNumber.signature = n1$3;
  function secNumber(x) {
    return 1 / Math.cos(x);
  }
  secNumber.signature = n1$3;
  function sechNumber(x) {
    return 2 / (Math.exp(x) + Math.exp(-x));
  }
  sechNumber.signature = n1$3;
  function sinhNumber(x) {
    return sinh(x);
  }
  sinhNumber.signature = n1$3;

  var n1$4 = 'number';
  function isNegativeNumber(x) {
    return x < 0;
  }
  isNegativeNumber.signature = n1$4;
  function isPositiveNumber(x) {
    return x > 0;
  }
  isPositiveNumber.signature = n1$4;
  function isZeroNumber(x) {
    return x === 0;
  }
  isZeroNumber.signature = n1$4;
  function isNaNNumber(x) {
    return Number.isNaN(x);
  }
  isNaNNumber.signature = n1$4;

  var name$9 = 'isNegative';
  var dependencies$a = ['typed'];
  var createIsNegative = /* #__PURE__ */factory(name$9, dependencies$a, function (_ref) {
    var typed = _ref.typed;

    /**
     * Test whether a value is negative: smaller than zero.
     * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
     *
     * The function is evaluated element-wise in case of Array or Matrix input.
     *
     * Syntax:
     *
     *     math.isNegative(x)
     *
     * Examples:
     *
     *    math.isNegative(3)                     // returns false
     *    math.isNegative(-2)                    // returns true
     *    math.isNegative(0)                     // returns false
     *    math.isNegative(-0)                    // returns false
     *    math.isNegative(math.bignumber(2))     // returns false
     *    math.isNegative(math.fraction(-2, 5))  // returns true
     *    math.isNegative('-2')                  // returns true
     *    math.isNegative([2, 0, -3]')           // returns [false, false, true]
     *
     * See also:
     *
     *    isNumeric, isPositive, isZero, isInteger
     *
     * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested
     * @return {boolean}  Returns true when `x` is larger than zero.
     *                    Throws an error in case of an unknown data type.
     */
    return typed(name$9, {
      number: isNegativeNumber,
      BigNumber: function BigNumber(x) {
        return x.isNeg() && !x.isZero() && !x.isNaN();
      },
      Fraction: function Fraction(x) {
        return x.s < 0; // It's enough to decide on the sign
      },
      Unit: function Unit(x) {
        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$a = 'isNumeric';
  var dependencies$b = ['typed'];
  var createIsNumeric = /* #__PURE__ */factory(name$a, dependencies$b, function (_ref) {
    var typed = _ref.typed;

    /**
     * Test whether a value is an numeric value.
     *
     * The function is evaluated element-wise in case of Array or Matrix input.
     *
     * Syntax:
     *
     *     math.isNumeric(x)
     *
     * Examples:
     *
     *    math.isNumeric(2)                     // returns true
     *    math.isNumeric('2')                   // returns false
     *    math.hasNumericValue('2')             // returns true
     *    math.isNumeric(0)                     // returns true
     *    math.isNumeric(math.bignumber(500))   // returns true
     *    math.isNumeric(math.fraction(4))      // returns true
     *    math.isNumeric(math.complex('2-4i')   // returns false
     *    math.isNumeric([2.3, 'foo', false])   // returns [true, false, true]
     *
     * See also:
     *
     *    isZero, isPositive, isNegative, isInteger, hasNumericValue
     *
     * @param {*} x       Value to be tested
     * @return {boolean}  Returns true when `x` is a `number`, `BigNumber`,
     *                    `Fraction`, or `boolean`. Returns false for other types.
     *                    Throws an error in case of unknown types.
     */
    return typed(name$a, {
      'number | BigNumber | Fraction | boolean': function numberBigNumberFractionBoolean() {
        return true;
      },
      'Complex | Unit | string | null | undefined | Node': function ComplexUnitStringNullUndefinedNode() {
        return false;
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$b = 'hasNumericValue';
  var dependencies$c = ['typed', 'isNumeric'];
  var createHasNumericValue = /* #__PURE__ */factory(name$b, dependencies$c, function (_ref) {
    var typed = _ref.typed,
        isNumeric = _ref.isNumeric;

    /**
     * Test whether a value is an numeric value.
     *
     * In case of a string, true is returned if the string contains a numeric value.
     *
     * Syntax:
     *
     *     math.hasNumericValue(x)
     *
     * Examples:
     *
     *    math.hasNumericValue(2)                     // returns true
     *    math.hasNumericValue('2')                   // returns true
     *    math.isNumeric('2')                         // returns false
     *    math.hasNumericValue(0)                     // returns true
     *    math.hasNumericValue(math.bignumber(500))   // returns true
     *    math.hasNumericValue(math.fraction(4))      // returns true
     *    math.hasNumericValue(math.complex('2-4i')   // returns false
     *    math.hasNumericValue([2.3, 'foo', false])   // returns [true, false, true]
     *
     * See also:
     *
     *    isZero, isPositive, isNegative, isInteger, isNumeric
     *
     * @param {*} x       Value to be tested
     * @return {boolean}  Returns true when `x` is a `number`, `BigNumber`,
     *                    `Fraction`, `Boolean`, or a `String` containing number. Returns false for other types.
     *                    Throws an error in case of unknown types.
     */
    return typed(name$b, {
      string: function string(x) {
        return x.trim().length > 0 && !isNaN(Number(x));
      },
      any: function any(x) {
        return isNumeric(x);
      }
    });
  });

  var name$c = 'isPositive';
  var dependencies$d = ['typed'];
  var createIsPositive = /* #__PURE__ */factory(name$c, dependencies$d, function (_ref) {
    var typed = _ref.typed;

    /**
     * Test whether a value is positive: larger than zero.
     * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
     *
     * The function is evaluated element-wise in case of Array or Matrix input.
     *
     * Syntax:
     *
     *     math.isPositive(x)
     *
     * Examples:
     *
     *    math.isPositive(3)                     // returns true
     *    math.isPositive(-2)                    // returns false
     *    math.isPositive(0)                     // returns false
     *    math.isPositive(-0)                    // returns false
     *    math.isPositive(0.5)                   // returns true
     *    math.isPositive(math.bignumber(2))     // returns true
     *    math.isPositive(math.fraction(-2, 5))  // returns false
     *    math.isPositive(math.fraction(1,3))    // returns false
     *    math.isPositive('2')                   // returns true
     *    math.isPositive([2, 0, -3])            // returns [true, false, false]
     *
     * See also:
     *
     *    isNumeric, isZero, isNegative, isInteger
     *
     * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested
     * @return {boolean}  Returns true when `x` is larger than zero.
     *                    Throws an error in case of an unknown data type.
     */
    return typed(name$c, {
      number: isPositiveNumber,
      BigNumber: function BigNumber(x) {
        return !x.isNeg() && !x.isZero() && !x.isNaN();
      },
      Fraction: function Fraction(x) {
        return x.s > 0 && x.n > 0;
      },
      Unit: function Unit(x) {
        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$d = 'isZero';
  var dependencies$e = ['typed'];
  var createIsZero = /* #__PURE__ */factory(name$d, dependencies$e, function (_ref) {
    var typed = _ref.typed;

    /**
     * Test whether a value is zero.
     * The function can check for zero for types `number`, `BigNumber`, `Fraction`,
     * `Complex`, and `Unit`.
     *
     * The function is evaluated element-wise in case of Array or Matrix input.
     *
     * Syntax:
     *
     *     math.isZero(x)
     *
     * Examples:
     *
     *    math.isZero(0)                     // returns true
     *    math.isZero(2)                     // returns false
     *    math.isZero(0.5)                   // returns false
     *    math.isZero(math.bignumber(0))     // returns true
     *    math.isZero(math.fraction(0))      // returns true
     *    math.isZero(math.fraction(1,3))    // returns false
     *    math.isZero(math.complex('2 - 4i') // returns false
     *    math.isZero(math.complex('0i')     // returns true
     *    math.isZero('0')                   // returns true
     *    math.isZero('2')                   // returns false
     *    math.isZero([2, 0, -3]')           // returns [false, true, false]
     *
     * See also:
     *
     *    isNumeric, isPositive, isNegative, isInteger
     *
     * @param {number | BigNumber | Complex | Fraction | Unit | Array | Matrix} x       Value to be tested
     * @return {boolean}  Returns true when `x` is zero.
     *                    Throws an error in case of an unknown data type.
     */
    return typed(name$d, {
      number: isZeroNumber,
      BigNumber: function BigNumber(x) {
        return x.isZero();
      },
      Complex: function Complex(x) {
        return x.re === 0 && x.im === 0;
      },
      Fraction: function Fraction(x) {
        return x.d === 1 && x.n === 0;
      },
      Unit: function Unit(x) {
        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$e = 'isNaN';
  var dependencies$f = ['typed'];
  var createIsNaN = /* #__PURE__ */factory(name$e, dependencies$f, function (_ref) {
    var typed = _ref.typed;

    /**
     * Test whether a value is NaN (not a number).
     * The function supports types `number`, `BigNumber`, `Fraction`, `Unit` and `Complex`.
     *
     * The function is evaluated element-wise in case of Array or Matrix input.
     *
     * Syntax:
     *
     *     math.isNaN(x)
     *
     * Examples:
     *
     *    math.isNaN(3)                     // returns false
     *    math.isNaN(NaN)                   // returns true
     *    math.isNaN(0)                     // returns false
     *    math.isNaN(math.bignumber(NaN))   // returns true
     *    math.isNaN(math.bignumber(0))     // returns false
     *    math.isNaN(math.fraction(-2, 5))  // returns false
     *    math.isNaN('-2')                  // returns false
     *    math.isNaN([2, 0, -3, NaN]')      // returns [false, false, false, true]
     *
     * See also:
     *
     *    isNumeric, isNegative, isPositive, isZero, isInteger
     *
     * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested
     * @return {boolean}  Returns true when `x` is NaN.
     *                    Throws an error in case of an unknown data type.
     */
    return typed(name$e, {
      number: isNaNNumber,
      BigNumber: function BigNumber(x) {
        return x.isNaN();
      },
      Fraction: function Fraction(x) {
        return false;
      },
      Complex: function Complex(x) {
        return x.isNaN();
      },
      Unit: function Unit(x) {
        return Number.isNaN(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, Number.isNaN);
      }
    });
  });

  var name$f = 'typeOf';
  var dependencies$g = ['typed'];
  var createTypeOf = /* #__PURE__ */factory(name$f, dependencies$g, function (_ref) {
    var typed = _ref.typed;

    /**
     * Determine the type of a variable.
     *
     * Function `typeOf` recognizes the following types of objects:
     *
     * Object                 | Returns       | Example
     * ---------------------- | ------------- | ------------------------------------------
     * null                   | `'null'`      | `math.typeOf(null)`
     * number                 | `'number'`    | `math.typeOf(3.5)`
     * boolean                | `'boolean'`   | `math.typeOf(true)`
     * string                 | `'string'`    | `math.typeOf('hello world')`
     * Array                  | `'Array'`     | `math.typeOf([1, 2, 3])`
     * Date                   | `'Date'`      | `math.typeOf(new Date())`
     * Function               | `'Function'`  | `math.typeOf(function () {})`
     * Object                 | `'Object'`    | `math.typeOf({a: 2, b: 3})`
     * RegExp                 | `'RegExp'`    | `math.typeOf(/a regexp/)`
     * undefined              | `'undefined'` | `math.typeOf(undefined)`
     * math.BigNumber         | `'BigNumber'` | `math.typeOf(math.bignumber('2.3e500'))`
     * math.Chain             | `'Chain'`     | `math.typeOf(math.chain(2))`
     * math.Complex           | `'Complex'`   | `math.typeOf(math.complex(2, 3))`
     * math.Fraction          | `'Fraction'`  | `math.typeOf(math.fraction(1, 3))`
     * math.Help              | `'Help'`      | `math.typeOf(math.help('sqrt'))`
     * math.Help              | `'Help'`      | `math.typeOf(math.help('sqrt'))`
     * math.Index             | `'Index'`     | `math.typeOf(math.index(1, 3))`
     * math.Matrix            | `'Matrix'`    | `math.typeOf(math.matrix([[1,2], [3, 4]]))`
     * math.Range             | `'Range'`     | `math.typeOf(math.range(0, 10))`
     * math.ResultSet         | `'ResultSet'` | `math.typeOf(math.evaluate('a=2\nb=3'))`
     * math.Unit              | `'Unit'`      | `math.typeOf(math.unit('45 deg'))`
     * math.AccessorNode            | `'AccessorNode'`            | `math.typeOf(math.parse('A[2]'))`
     * math.ArrayNode               | `'ArrayNode'`               | `math.typeOf(math.parse('[1,2,3]'))`
     * math.AssignmentNode          | `'AssignmentNode'`          | `math.typeOf(math.parse('x=2'))`
     * math.BlockNode               | `'BlockNode'`               | `math.typeOf(math.parse('a=2; b=3'))`
     * math.ConditionalNode         | `'ConditionalNode'`         | `math.typeOf(math.parse('x<0 ? -x : x'))`
     * math.ConstantNode            | `'ConstantNode'`            | `math.typeOf(math.parse('2.3'))`
     * math.FunctionAssignmentNode  | `'FunctionAssignmentNode'`  | `math.typeOf(math.parse('f(x)=x^2'))`
     * math.FunctionNode            | `'FunctionNode'`            | `math.typeOf(math.parse('sqrt(4)'))`
     * math.IndexNode               | `'IndexNode'`               | `math.typeOf(math.parse('A[2]').index)`
     * math.ObjectNode              | `'ObjectNode'`              | `math.typeOf(math.parse('{a:2}'))`
     * math.ParenthesisNode         | `'ParenthesisNode'`         | `math.typeOf(math.parse('(2+3)'))`
     * math.RangeNode               | `'RangeNode'`               | `math.typeOf(math.parse('1:10'))`
     * math.SymbolNode              | `'SymbolNode'`              | `math.typeOf(math.parse('x'))`
     *
     * Syntax:
     *
     *    math.typeOf(x)
     *
     * Examples:
     *
     *    math.typeOf(3.5)                     // returns 'number'
     *    math.typeOf(math.complex('2-4i'))    // returns 'Complex'
     *    math.typeOf(math.unit('45 deg'))     // returns 'Unit'
     *    math.typeOf('hello world')           // returns 'string'
     *
     * @param {*} x     The variable for which to test the type.
     * @return {string} Returns the name of the type. Primitive types are lower case,
     *                  non-primitive types are upper-camel-case.
     *                  For example 'number', 'string', 'Array', 'Date'.
     */
    return typed(name$f, {
      any: typeOf
    });
  });

  /**
   * Compares two BigNumbers.
   * @param {BigNumber} x       First value to compare
   * @param {BigNumber} y       Second value to compare
   * @param {number} [epsilon]  The maximum relative difference between x and y
   *                            If epsilon is undefined or null, the function will
   *                            test whether x and y are exactly equal.
   * @return {boolean} whether the two numbers are nearly equal
   */
  function nearlyEqual$1(x, y, epsilon) {
    // if epsilon is null or undefined, test whether x and y are exactly equal
    if (epsilon === null || epsilon === undefined) {
      return x.eq(y);
    } // use "==" operator, handles infinities


    if (x.eq(y)) {
      return true;
    } // NaN


    if (x.isNaN() || y.isNaN()) {
      return false;
    } // at this point x and y should be finite


    if (x.isFinite() && y.isFinite()) {
      // check numbers are very close, needed when comparing numbers near zero
      var diff = x.minus(y).abs();

      if (diff.isZero()) {
        return true;
      } else {
        // use relative error
        var max = x.constructor.max(x.abs(), y.abs());
        return diff.lte(max.times(epsilon));
      }
    } // Infinite and Number or negative Infinite and positive Infinite cases


    return false;
  }

  /**
   * Test whether two complex values are equal provided a given epsilon.
   * Does not use or change the global Complex.EPSILON setting
   * @param {Complex} x
   * @param {Complex} y
   * @param {number} epsilon
   * @returns {boolean}
   */

  function complexEquals(x, y, epsilon) {
    return nearlyEqual(x.re, y.re, epsilon) && nearlyEqual(x.im, y.im, epsilon);
  }

  var name$g = 'equalScalar';
  var dependencies$h = ['typed', 'config'];
  var createEqualScalar = /* #__PURE__ */factory(name$g, dependencies$h, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config;

    /**
     * Test whether two scalar values are nearly equal.
     *
     * @param  {number | BigNumber | Fraction | boolean | Complex | Unit} x   First value to compare
     * @param  {number | BigNumber | Fraction | boolean | Complex} y          Second value to compare
     * @return {boolean}                                                  Returns true when the compared values are equal, else returns false
     * @private
     */
    return typed(name$g, {
      'boolean, boolean': function booleanBoolean(x, y) {
        return x === y;
      },
      'number, number': function numberNumber(x, y) {
        return nearlyEqual(x, y, config.epsilon);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.eq(y) || nearlyEqual$1(x, y, config.epsilon);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.equals(y);
      },
      'Complex, Complex': function ComplexComplex(x, y) {
        return complexEquals(x, y, config.epsilon);
      },
      'Unit, Unit': function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error('Cannot compare units with different base');
        }

        return this(x.value, y.value);
      }
    });
  });
  var createEqualScalarNumber = factory(name$g, ['typed', 'config'], function (_ref2) {
    var typed = _ref2.typed,
        config = _ref2.config;
    return typed(name$g, {
      'number, number': function numberNumber(x, y) {
        return nearlyEqual(x, y, config.epsilon);
      }
    });
  });

  var name$h = 'SparseMatrix';
  var dependencies$i = ['typed', 'equalScalar', 'Matrix'];
  var createSparseMatrixClass = /* #__PURE__ */factory(name$h, dependencies$i, function (_ref) {
    var typed = _ref.typed,
        equalScalar = _ref.equalScalar,
        Matrix = _ref.Matrix;

    /**
     * Sparse Matrix implementation. This type implements a Compressed Column Storage format
     * for sparse matrices.
     * @class SparseMatrix
     */
    function SparseMatrix(data, datatype) {
      if (!(this instanceof SparseMatrix)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      if (datatype && !isString(datatype)) {
        throw new Error('Invalid datatype: ' + datatype);
      }

      if (isMatrix(data)) {
        // create from matrix
        _createFromMatrix(this, data, datatype);
      } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
        // initialize fields
        this._values = data.values;
        this._index = data.index;
        this._ptr = data.ptr;
        this._size = data.size;
        this._datatype = datatype || data.datatype;
      } else if (isArray(data)) {
        // create from array
        _createFromArray(this, data, datatype);
      } else if (data) {
        // unsupported type
        throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');
      } else {
        // nothing provided
        this._values = [];
        this._index = [];
        this._ptr = [0];
        this._size = [0, 0];
        this._datatype = datatype;
      }
    }

    function _createFromMatrix(matrix, source, datatype) {
      // check matrix type
      if (source.type === 'SparseMatrix') {
        // clone arrays
        matrix._values = source._values ? clone(source._values) : undefined;
        matrix._index = clone(source._index);
        matrix._ptr = clone(source._ptr);
        matrix._size = clone(source._size);
        matrix._datatype = datatype || source._datatype;
      } else {
        // build from matrix data
        _createFromArray(matrix, source.valueOf(), datatype || source._datatype);
      }
    }

    function _createFromArray(matrix, data, datatype) {
      // initialize fields
      matrix._values = [];
      matrix._index = [];
      matrix._ptr = [];
      matrix._datatype = datatype; // discover rows & columns, do not use math.size() to avoid looping array twice

      var rows = data.length;
      var columns = 0; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0;

      if (isString(datatype)) {
        // find signature that matches (datatype, datatype)
        eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype

        zero = typed.convert(0, datatype);
      } // check we have rows (empty array)


      if (rows > 0) {
        // column index
        var j = 0;

        do {
          // store pointer to values index
          matrix._ptr.push(matrix._index.length); // loop rows


          for (var i = 0; i < rows; i++) {
            // current row
            var row = data[i]; // check row is an array

            if (isArray(row)) {
              // update columns if needed (only on first column)
              if (j === 0 && columns < row.length) {
                columns = row.length;
              } // check row has column


              if (j < row.length) {
                // value
                var v = row[j]; // check value != 0

                if (!eq(v, zero)) {
                  // store value
                  matrix._values.push(v); // index


                  matrix._index.push(i);
                }
              }
            } else {
              // update columns if needed (only on first column)
              if (j === 0 && columns < 1) {
                columns = 1;
              } // check value != 0 (row is a scalar)


              if (!eq(row, zero)) {
                // store value
                matrix._values.push(row); // index


                matrix._index.push(i);
              }
            }
          } // increment index


          j++;
        } while (j < columns);
      } // store number of values in ptr


      matrix._ptr.push(matrix._index.length); // size


      matrix._size = [rows, columns];
    }

    SparseMatrix.prototype = new Matrix();
    /**
     * Create a new SparseMatrix
     */

    SparseMatrix.prototype.createSparseMatrix = function (data, datatype) {
      return new SparseMatrix(data, datatype);
    };
    /**
     * Attach type information
     */


    SparseMatrix.prototype.type = 'SparseMatrix';
    SparseMatrix.prototype.isSparseMatrix = true;
    /**
     * Get the matrix type
     *
     * Usage:
     *    const matrixType = matrix.getDataType()  // retrieves the matrix type
     *
     * @memberOf SparseMatrix
     * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
     */

    SparseMatrix.prototype.getDataType = function () {
      return getArrayDataType(this._values, typeOf);
    };
    /**
     * Get the storage format used by the matrix.
     *
     * Usage:
     *     const format = matrix.storage()   // retrieve storage format
     *
     * @memberof SparseMatrix
     * @return {string}           The storage format.
     */


    SparseMatrix.prototype.storage = function () {
      return 'sparse';
    };
    /**
     * Get the datatype of the data stored in the matrix.
     *
     * Usage:
     *     const format = matrix.datatype()    // retrieve matrix datatype
     *
     * @memberof SparseMatrix
     * @return {string}           The datatype.
     */


    SparseMatrix.prototype.datatype = function () {
      return this._datatype;
    };
    /**
     * Create a new SparseMatrix
     * @memberof SparseMatrix
     * @param {Array} data
     * @param {string} [datatype]
     */


    SparseMatrix.prototype.create = function (data, datatype) {
      return new SparseMatrix(data, datatype);
    };
    /**
     * Get the matrix density.
     *
     * Usage:
     *     const density = matrix.density()                   // retrieve matrix density
     *
     * @memberof SparseMatrix
     * @return {number}           The matrix density.
     */


    SparseMatrix.prototype.density = function () {
      // rows & columns
      var rows = this._size[0];
      var columns = this._size[1]; // calculate density

      return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
    };
    /**
     * Get a subset of the matrix, or replace a subset of the matrix.
     *
     * Usage:
     *     const subset = matrix.subset(index)               // retrieve subset
     *     const value = matrix.subset(index, replacement)   // replace subset
     *
     * @memberof SparseMatrix
     * @param {Index} index
     * @param {Array | Matrix | *} [replacement]
     * @param {*} [defaultValue=0]      Default value, filled in on new entries when
     *                                  the matrix is resized. If not provided,
     *                                  new matrix elements will be filled with zeros.
     */


    SparseMatrix.prototype.subset = function (index, replacement, defaultValue) {
      // check it is a pattern matrix
      if (!this._values) {
        throw new Error('Cannot invoke subset on a Pattern only matrix');
      } // check arguments


      switch (arguments.length) {
        case 1:
          return _getsubset(this, index);
        // intentional fall through

        case 2:
        case 3:
          return _setsubset(this, index, replacement, defaultValue);

        default:
          throw new SyntaxError('Wrong number of arguments');
      }
    };

    function _getsubset(matrix, idx) {
      // check idx
      if (!isIndex(idx)) {
        throw new TypeError('Invalid index');
      }

      var isScalar = idx.isScalar();

      if (isScalar) {
        // return a scalar
        return matrix.get(idx.min());
      } // validate dimensions


      var size = idx.size();

      if (size.length !== matrix._size.length) {
        throw new DimensionError(size.length, matrix._size.length);
      } // vars


      var i, ii, k, kk; // validate if any of the ranges in the index is out of range

      var min = idx.min();
      var max = idx.max();

      for (i = 0, ii = matrix._size.length; i < ii; i++) {
        validateIndex(min[i], matrix._size[i]);
        validateIndex(max[i], matrix._size[i]);
      } // matrix arrays


      var mvalues = matrix._values;
      var mindex = matrix._index;
      var mptr = matrix._ptr; // rows & columns dimensions for result matrix

      var rows = idx.dimension(0);
      var columns = idx.dimension(1); // workspace & permutation vector

      var w = [];
      var pv = []; // loop rows in resulting matrix

      rows.forEach(function (i, r) {
        // update permutation vector
        pv[i] = r[0]; // mark i in workspace

        w[i] = true;
      }); // result matrix arrays

      var values$$1 = mvalues ? [] : undefined;
      var index = [];
      var ptr = []; // loop columns in result matrix

      columns.forEach(function (j) {
        // update ptr
        ptr.push(index.length); // loop values in column j

        for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
          // row
          i = mindex[k]; // check row is in result matrix

          if (w[i] === true) {
            // push index
            index.push(pv[i]); // check we need to process values

            if (values$$1) {
              values$$1.push(mvalues[k]);
            }
          }
        }
      }); // update ptr

      ptr.push(index.length); // return matrix

      return new SparseMatrix({
        values: values$$1,
        index: index,
        ptr: ptr,
        size: size,
        datatype: matrix._datatype
      });
    }

    function _setsubset(matrix, index, submatrix, defaultValue) {
      // check index
      if (!index || index.isIndex !== true) {
        throw new TypeError('Invalid index');
      } // get index size and check whether the index contains a single value


      var iSize = index.size();
      var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed

      var sSize;

      if (isMatrix(submatrix)) {
        // submatrix size
        sSize = submatrix.size(); // use array representation

        submatrix = submatrix.toArray();
      } else {
        // get submatrix size (array, scalar)
        sSize = arraySize(submatrix);
      } // check index is a scalar


      if (isScalar) {
        // verify submatrix is a scalar
        if (sSize.length !== 0) {
          throw new TypeError('Scalar expected');
        } // set value


        matrix.set(index.min(), submatrix, defaultValue);
      } else {
        // validate dimensions, index size must be one or two dimensions
        if (iSize.length !== 1 && iSize.length !== 2) {
          throw new DimensionError(iSize.length, matrix._size.length, '<');
        } // check submatrix and index have the same dimensions


        if (sSize.length < iSize.length) {
          // calculate number of missing outer dimensions
          var i = 0;
          var outer = 0;

          while (iSize[i] === 1 && sSize[i] === 1) {
            i++;
          }

          while (iSize[i] === 1) {
            outer++;
            i++;
          } // unsqueeze both outer and inner dimensions


          submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
        } // check whether the size of the submatrix matches the index size


        if (!deepStrictEqual(iSize, sSize)) {
          throw new DimensionError(iSize, sSize, '>');
        } // offsets


        var x0 = index.min()[0];
        var y0 = index.min()[1]; // submatrix rows and columns

        var m = sSize[0];
        var n = sSize[1]; // loop submatrix

        for (var x = 0; x < m; x++) {
          // loop columns
          for (var y = 0; y < n; y++) {
            // value at i, j
            var v = submatrix[x][y]; // invoke set (zero value will remove entry from matrix)

            matrix.set([x + x0, y + y0], v, defaultValue);
          }
        }
      }

      return matrix;
    }
    /**
     * Get a single element from the matrix.
     * @memberof SparseMatrix
     * @param {number[]} index   Zero-based index
     * @return {*} value
     */


    SparseMatrix.prototype.get = function (index) {
      if (!isArray(index)) {
        throw new TypeError('Array expected');
      }

      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      } // check it is a pattern matrix


      if (!this._values) {
        throw new Error('Cannot invoke get on a Pattern only matrix');
      } // row and column


      var i = index[0];
      var j = index[1]; // check i, j are valid

      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[1]); // find value index

      var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row


      if (k < this._ptr[j + 1] && this._index[k] === i) {
        return this._values[k];
      }

      return 0;
    };
    /**
     * Replace a single element in the matrix.
     * @memberof SparseMatrix
     * @param {number[]} index   Zero-based index
     * @param {*} v
     * @param {*} [defaultValue]        Default value, filled in on new entries when
     *                                  the matrix is resized. If not provided,
     *                                  new matrix elements will be set to zero.
     * @return {SparseMatrix} self
     */


    SparseMatrix.prototype.set = function (index, v, defaultValue) {
      if (!isArray(index)) {
        throw new TypeError('Array expected');
      }

      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      } // check it is a pattern matrix


      if (!this._values) {
        throw new Error('Cannot invoke set on a Pattern only matrix');
      } // row and column


      var i = index[0];
      var j = index[1]; // rows & columns

      var rows = this._size[0];
      var columns = this._size[1]; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0;

      if (isString(this._datatype)) {
        // find signature that matches (datatype, datatype)
        eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar; // convert 0 to the same datatype

        zero = typed.convert(0, this._datatype);
      } // check we need to resize matrix


      if (i > rows - 1 || j > columns - 1) {
        // resize matrix
        _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue); // update rows & columns


        rows = this._size[0];
        columns = this._size[1];
      } // check i, j are valid


      validateIndex(i, rows);
      validateIndex(j, columns); // find value index

      var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row


      if (k < this._ptr[j + 1] && this._index[k] === i) {
        // check value != 0
        if (!eq(v, zero)) {
          // update value
          this._values[k] = v;
        } else {
          // remove value from matrix
          _remove(k, j, this._values, this._index, this._ptr);
        }
      } else {
        // insert value @ (i, j)
        _insert(k, i, j, v, this._values, this._index, this._ptr);
      }

      return this;
    };

    function _getValueIndex(i, top, bottom, index) {
      // check row is on the bottom side
      if (bottom - top === 0) {
        return bottom;
      } // loop rows [top, bottom[


      for (var r = top; r < bottom; r++) {
        // check we found value index
        if (index[r] === i) {
          return r;
        }
      } // we did not find row


      return top;
    }

    function _remove(k, j, values$$1, index, ptr) {
      // remove value @ k
      values$$1.splice(k, 1);
      index.splice(k, 1); // update pointers

      for (var x = j + 1; x < ptr.length; x++) {
        ptr[x]--;
      }
    }

    function _insert(k, i, j, v, values$$1, index, ptr) {
      // insert value
      values$$1.splice(k, 0, v); // update row for k

      index.splice(k, 0, i); // update column pointers

      for (var x = j + 1; x < ptr.length; x++) {
        ptr[x]++;
      }
    }
    /**
     * Resize the matrix to the given size. Returns a copy of the matrix when
     * `copy=true`, otherwise return the matrix itself (resize in place).
     *
     * @memberof SparseMatrix
     * @param {number[] | Matrix} size  The new size the matrix should have.
     * @param {*} [defaultValue=0]      Default value, filled in on new entries.
     *                                  If not provided, the matrix elements will
     *                                  be filled with zeros.
     * @param {boolean} [copy]          Return a resized copy of the matrix
     *
     * @return {Matrix}                 The resized matrix
     */


    SparseMatrix.prototype.resize = function (size, defaultValue, copy) {
      // validate arguments
      if (!isCollection(size)) {
        throw new TypeError('Array or Matrix expected');
      } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector


      var sizeArray = size.valueOf().map(function (value) {
        return Array.isArray(value) && value.length === 1 ? value[0] : value;
      });

      if (sizeArray.length !== 2) {
        throw new Error('Only two dimensions matrix are supported');
      } // check sizes


      sizeArray.forEach(function (value) {
        if (!isNumber(value) || !isInteger(value) || value < 0) {
          throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format$2(sizeArray) + ')');
        }
      }); // matrix to resize

      var m = copy ? this.clone() : this; // resize matrix

      return _resize(m, sizeArray[0], sizeArray[1], defaultValue);
    };

    function _resize(matrix, rows, columns, defaultValue) {
      // value to insert at the time of growing matrix
      var value = defaultValue || 0; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0;

      if (isString(matrix._datatype)) {
        // find signature that matches (datatype, datatype)
        eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype

        zero = typed.convert(0, matrix._datatype); // convert value to the same datatype

        value = typed.convert(value, matrix._datatype);
      } // should we insert the value?


      var ins = !eq(value, zero); // old columns and rows

      var r = matrix._size[0];
      var c = matrix._size[1];
      var i, j, k; // check we need to increase columns

      if (columns > c) {
        // loop new columns
        for (j = c; j < columns; j++) {
          // update matrix._ptr for current column
          matrix._ptr[j] = matrix._values.length; // check we need to insert matrix._values

          if (ins) {
            // loop rows
            for (i = 0; i < r; i++) {
              // add new matrix._values
              matrix._values.push(value); // update matrix._index


              matrix._index.push(i);
            }
          }
        } // store number of matrix._values in matrix._ptr


        matrix._ptr[columns] = matrix._values.length;
      } else if (columns < c) {
        // truncate matrix._ptr
        matrix._ptr.splice(columns + 1, c - columns); // truncate matrix._values and matrix._index


        matrix._values.splice(matrix._ptr[columns], matrix._values.length);

        matrix._index.splice(matrix._ptr[columns], matrix._index.length);
      } // update columns


      c = columns; // check we need to increase rows

      if (rows > r) {
        // check we have to insert values
        if (ins) {
          // inserts
          var n = 0; // loop columns

          for (j = 0; j < c; j++) {
            // update matrix._ptr for current column
            matrix._ptr[j] = matrix._ptr[j] + n; // where to insert matrix._values

            k = matrix._ptr[j + 1] + n; // pointer

            var p = 0; // loop new rows, initialize pointer

            for (i = r; i < rows; i++, p++) {
              // add value
              matrix._values.splice(k + p, 0, value); // update matrix._index


              matrix._index.splice(k + p, 0, i); // increment inserts


              n++;
            }
          } // store number of matrix._values in matrix._ptr


          matrix._ptr[c] = matrix._values.length;
        }
      } else if (rows < r) {
        // deletes
        var d = 0; // loop columns

        for (j = 0; j < c; j++) {
          // update matrix._ptr for current column
          matrix._ptr[j] = matrix._ptr[j] - d; // where matrix._values start for next column

          var k0 = matrix._ptr[j];
          var k1 = matrix._ptr[j + 1] - d; // loop matrix._index

          for (k = k0; k < k1; k++) {
            // row
            i = matrix._index[k]; // check we need to delete value and matrix._index

            if (i > rows - 1) {
              // remove value
              matrix._values.splice(k, 1); // remove item from matrix._index


              matrix._index.splice(k, 1); // increase deletes


              d++;
            }
          }
        } // update matrix._ptr for current column


        matrix._ptr[j] = matrix._values.length;
      } // update matrix._size


      matrix._size[0] = rows;
      matrix._size[1] = columns; // return matrix

      return matrix;
    }
    /**
     * Reshape the matrix to the given size. Returns a copy of the matrix when
     * `copy=true`, otherwise return the matrix itself (reshape in place).
     *
     * NOTE: This might be better suited to copy by default, instead of modifying
     *       in place. For now, it operates in place to remain consistent with
     *       resize().
     *
     * @memberof SparseMatrix
     * @param {number[]} size           The new size the matrix should have.
     * @param {boolean} [copy]          Return a reshaped copy of the matrix
     *
     * @return {Matrix}                 The reshaped matrix
     */


    SparseMatrix.prototype.reshape = function (size, copy) {
      // validate arguments
      if (!isArray(size)) {
        throw new TypeError('Array expected');
      }

      if (size.length !== 2) {
        throw new Error('Sparse matrices can only be reshaped in two dimensions');
      } // check sizes


      size.forEach(function (value) {
        if (!isNumber(value) || !isInteger(value) || value < 0) {
          throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format$2(size) + ')');
        }
      }); // m * n must not change

      if (this._size[0] * this._size[1] !== size[0] * size[1]) {
        throw new Error('Reshaping sparse matrix will result in the wrong number of elements');
      } // matrix to reshape


      var m = copy ? this.clone() : this; // return unchanged if the same shape

      if (this._size[0] === size[0] && this._size[1] === size[1]) {
        return m;
      } // Convert to COO format (generate a column index)


      var colIndex = [];

      for (var i = 0; i < m._ptr.length; i++) {
        for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {
          colIndex.push(i);
        }
      } // Clone the values array


      var values$$1 = m._values.slice(); // Clone the row index array


      var rowIndex = m._index.slice(); // Transform the (row, column) indices


      for (var _i = 0; _i < m._index.length; _i++) {
        var r1 = rowIndex[_i];
        var c1 = colIndex[_i];
        var flat = r1 * m._size[1] + c1;
        colIndex[_i] = flat % size[1];
        rowIndex[_i] = Math.floor(flat / size[1]);
      } // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored
      // in column-major order, so we have to reorder the value array now. One option is to use a multisort,
      // sorting several arrays based on some other array.
      // OR, we could easily just:
      // 1. Remove all values from the matrix


      m._values.length = 0;
      m._index.length = 0;
      m._ptr.length = size[1] + 1;
      m._size = size.slice();

      for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
        m._ptr[_i2] = 0;
      } // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)
      // This step is probably the most time-consuming


      for (var h = 0; h < values$$1.length; h++) {
        var _i3 = rowIndex[h];
        var _j = colIndex[h];
        var v = values$$1[h];

        var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);

        _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
      } // The value indices are inserted out of order, but apparently that's... still OK?


      return m;
    };
    /**
     * Create a clone of the matrix
     * @memberof SparseMatrix
     * @return {SparseMatrix} clone
     */


    SparseMatrix.prototype.clone = function () {
      var m = new SparseMatrix({
        values: this._values ? clone(this._values) : undefined,
        index: clone(this._index),
        ptr: clone(this._ptr),
        size: clone(this._size),
        datatype: this._datatype
      });
      return m;
    };
    /**
     * Retrieve the size of the matrix.
     * @memberof SparseMatrix
     * @returns {number[]} size
     */


    SparseMatrix.prototype.size = function () {
      return this._size.slice(0); // copy the Array
    };
    /**
     * Create a new matrix with the results of the callback function executed on
     * each entry of the matrix.
     * @memberof SparseMatrix
     * @param {Function} callback   The callback function is invoked with three
     *                              parameters: the value of the element, the index
     *                              of the element, and the Matrix being traversed.
     * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
     *
     * @return {SparseMatrix} matrix
     */


    SparseMatrix.prototype.map = function (callback, skipZeros) {
      // check it is a pattern matrix
      if (!this._values) {
        throw new Error('Cannot invoke map on a Pattern only matrix');
      } // matrix instance


      var me = this; // rows and columns

      var rows = this._size[0];
      var columns = this._size[1]; // invoke callback

      var invoke = function invoke(v, i, j) {
        // invoke callback
        return callback(v, [i, j], me);
      }; // invoke _map


      return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
    };
    /**
     * Create a new matrix with the results of the callback function executed on the interval
     * [minRow..maxRow, minColumn..maxColumn].
     */


    function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
      // result arrays
      var values$$1 = [];
      var index = [];
      var ptr = []; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0;

      if (isString(matrix._datatype)) {
        // find signature that matches (datatype, datatype)
        eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype

        zero = typed.convert(0, matrix._datatype);
      } // invoke callback


      var invoke = function invoke(v, x, y) {
        // invoke callback
        v = callback(v, x, y); // check value != 0

        if (!eq(v, zero)) {
          // store value
          values$$1.push(v); // index

          index.push(x);
        }
      }; // loop columns


      for (var j = minColumn; j <= maxColumn; j++) {
        // store pointer to values index
        ptr.push(values$$1.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]

        var k0 = matrix._ptr[j];
        var k1 = matrix._ptr[j + 1];

        if (skipZeros) {
          // loop k within [k0, k1[
          for (var k = k0; k < k1; k++) {
            // row index
            var i = matrix._index[k]; // check i is in range

            if (i >= minRow && i <= maxRow) {
              // value @ k
              invoke(matrix._values[k], i - minRow, j - minColumn);
            }
          }
        } else {
          // create a cache holding all defined values
          var _values = {};

          for (var _k = k0; _k < k1; _k++) {
            var _i4 = matrix._index[_k];
            _values[_i4] = matrix._values[_k];
          } // loop over all rows (indexes can be unordered so we can't use that),
          // and either read the value or zero


          for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
            var value = _i5 in _values ? _values[_i5] : 0;
            invoke(value, _i5 - minRow, j - minColumn);
          }
        }
      } // store number of values in ptr


      ptr.push(values$$1.length); // return sparse matrix

      return new SparseMatrix({
        values: values$$1,
        index: index,
        ptr: ptr,
        size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
      });
    }
    /**
     * Execute a callback function on each entry of the matrix.
     * @memberof SparseMatrix
     * @param {Function} callback   The callback function is invoked with three
     *                              parameters: the value of the element, the index
     *                              of the element, and the Matrix being traversed.
     * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
     */


    SparseMatrix.prototype.forEach = function (callback, skipZeros) {
      // check it is a pattern matrix
      if (!this._values) {
        throw new Error('Cannot invoke forEach on a Pattern only matrix');
      } // matrix instance


      var me = this; // rows and columns

      var rows = this._size[0];
      var columns = this._size[1]; // loop columns

      for (var j = 0; j < columns; j++) {
        // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];

        if (skipZeros) {
          // loop k within [k0, k1[
          for (var k = k0; k < k1; k++) {
            // row index
            var i = this._index[k]; // value @ k

            callback(this._values[k], [i, j], me);
          }
        } else {
          // create a cache holding all defined values
          var values$$1 = {};

          for (var _k2 = k0; _k2 < k1; _k2++) {
            var _i6 = this._index[_k2];
            values$$1[_i6] = this._values[_k2];
          } // loop over all rows (indexes can be unordered so we can't use that),
          // and either read the value or zero


          for (var _i7 = 0; _i7 < rows; _i7++) {
            var value = _i7 in values$$1 ? values$$1[_i7] : 0;
            callback(value, [_i7, j], me);
          }
        }
      }
    };
    /**
     * Create an Array with a copy of the data of the SparseMatrix
     * @memberof SparseMatrix
     * @returns {Array} array
     */


    SparseMatrix.prototype.toArray = function () {
      return _toArray(this._values, this._index, this._ptr, this._size, true);
    };
    /**
     * Get the primitive value of the SparseMatrix: a two dimensions array
     * @memberof SparseMatrix
     * @returns {Array} array
     */


    SparseMatrix.prototype.valueOf = function () {
      return _toArray(this._values, this._index, this._ptr, this._size, false);
    };

    function _toArray(values$$1, index, ptr, size, copy) {
      // rows and columns
      var rows = size[0];
      var columns = size[1]; // result

      var a = []; // vars

      var i, j; // initialize array

      for (i = 0; i < rows; i++) {
        a[i] = [];

        for (j = 0; j < columns; j++) {
          a[i][j] = 0;
        }
      } // loop columns


      for (j = 0; j < columns; j++) {
        // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
        var k0 = ptr[j];
        var k1 = ptr[j + 1]; // loop k within [k0, k1[

        for (var k = k0; k < k1; k++) {
          // row index
          i = index[k]; // set value (use one for pattern matrix)

          a[i][j] = values$$1 ? copy ? clone(values$$1[k]) : values$$1[k] : 1;
        }
      }

      return a;
    }
    /**
     * Get a string representation of the matrix, with optional formatting options.
     * @memberof SparseMatrix
     * @param {Object | number | Function} [options]  Formatting options. See
     *                                                lib/utils/number:format for a
     *                                                description of the available
     *                                                options.
     * @returns {string} str
     */


    SparseMatrix.prototype.format = function (options) {
      // rows and columns
      var rows = this._size[0];
      var columns = this._size[1]; // density

      var density = this.density(); // rows & columns

      var str = 'Sparse Matrix [' + format$2(rows, options) + ' x ' + format$2(columns, options) + '] density: ' + format$2(density, options) + '\n'; // loop columns

      for (var j = 0; j < columns; j++) {
        // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1]; // loop k within [k0, k1[

        for (var k = k0; k < k1; k++) {
          // row index
          var i = this._index[k]; // append value

          str += '\n    (' + format$2(i, options) + ', ' + format$2(j, options) + ') ==> ' + (this._values ? format$2(this._values[k], options) : 'X');
        }
      }

      return str;
    };
    /**
     * Get a string representation of the matrix
     * @memberof SparseMatrix
     * @returns {string} str
     */


    SparseMatrix.prototype.toString = function () {
      return format$2(this.toArray());
    };
    /**
     * Get a JSON representation of the matrix
     * @memberof SparseMatrix
     * @returns {Object}
     */


    SparseMatrix.prototype.toJSON = function () {
      return {
        mathjs: 'SparseMatrix',
        values: this._values,
        index: this._index,
        ptr: this._ptr,
        size: this._size,
        datatype: this._datatype
      };
    };
    /**
     * Get the kth Matrix diagonal.
     *
     * @memberof SparseMatrix
     * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
     *
     * @returns {Matrix}                     The matrix vector with the diagonal values.
     */


    SparseMatrix.prototype.diagonal = function (k) {
      // validate k if any
      if (k) {
        // convert BigNumber to a number
        if (isBigNumber(k)) {
          k = k.toNumber();
        } // is must be an integer


        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError('The parameter k must be an integer number');
        }
      } else {
        // default value
        k = 0;
      }

      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0; // rows & columns

      var rows = this._size[0];
      var columns = this._size[1]; // number diagonal values

      var n = Math.min(rows - kSub, columns - kSuper); // diagonal arrays

      var values$$1 = [];
      var index = [];
      var ptr = []; // initial ptr value

      ptr[0] = 0; // loop columns

      for (var j = kSuper; j < columns && values$$1.length < n; j++) {
        // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1]; // loop x within [k0, k1[

        for (var x = k0; x < k1; x++) {
          // row index
          var i = this._index[x]; // check row

          if (i === j - kSuper + kSub) {
            // value on this column
            values$$1.push(this._values[x]); // store row

            index[values$$1.length - 1] = i - kSub; // exit loop

            break;
          }
        }
      } // close ptr


      ptr.push(values$$1.length); // return matrix

      return new SparseMatrix({
        values: values$$1,
        index: index,
        ptr: ptr,
        size: [n, 1]
      });
    };
    /**
     * Generate a matrix from a JSON object
     * @memberof SparseMatrix
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "SparseMatrix", "values": [], "index": [], "ptr": [], "size": []}`,
     *                       where mathjs is optional
     * @returns {SparseMatrix}
     */


    SparseMatrix.fromJSON = function (json) {
      return new SparseMatrix(json);
    };
    /**
     * Create a diagonal matrix.
     *
     * @memberof SparseMatrix
     * @param {Array} size                       The matrix size.
     * @param {number | Array | Matrix } value   The values for the diagonal.
     * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.
     * @param {number} [defaultValue]            The default value for non-diagonal
     * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.
     *
     * @returns {SparseMatrix}
     */


    SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {
      if (!isArray(size)) {
        throw new TypeError('Array expected, size parameter');
      }

      if (size.length !== 2) {
        throw new Error('Only two dimensions matrix are supported');
      } // map size & validate


      size = size.map(function (s) {
        // check it is a big number
        if (isBigNumber(s)) {
          // convert it
          s = s.toNumber();
        } // validate arguments


        if (!isNumber(s) || !isInteger(s) || s < 1) {
          throw new Error('Size values must be positive integers');
        }

        return s;
      }); // validate k if any

      if (k) {
        // convert BigNumber to a number
        if (isBigNumber(k)) {
          k = k.toNumber();
        } // is must be an integer


        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError('The parameter k must be an integer number');
        }
      } else {
        // default value
        k = 0;
      } // equal signature to use


      var eq = equalScalar; // zero value

      var zero = 0;

      if (isString(datatype)) {
        // find signature that matches (datatype, datatype)
        eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype

        zero = typed.convert(0, datatype);
      }

      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0; // rows and columns

      var rows = size[0];
      var columns = size[1]; // number of non-zero items

      var n = Math.min(rows - kSub, columns - kSuper); // value extraction function

      var _value; // check value


      if (isArray(value)) {
        // validate array
        if (value.length !== n) {
          // number of values in array must be n
          throw new Error('Invalid value array length');
        } // define function


        _value = function _value(i) {
          // return value @ i
          return value[i];
        };
      } else if (isMatrix(value)) {
        // matrix size
        var ms = value.size(); // validate matrix

        if (ms.length !== 1 || ms[0] !== n) {
          // number of values in array must be n
          throw new Error('Invalid matrix length');
        } // define function


        _value = function _value(i) {
          // return value @ i
          return value.get([i]);
        };
      } else {
        // define function
        _value = function _value() {
          // return value
          return value;
        };
      } // create arrays


      var values$$1 = [];
      var index = [];
      var ptr = []; // loop items

      for (var j = 0; j < columns; j++) {
        // number of rows with value
        ptr.push(values$$1.length); // diagonal index

        var i = j - kSuper; // check we need to set diagonal value

        if (i >= 0 && i < n) {
          // get value @ i
          var v = _value(i); // check for zero


          if (!eq(v, zero)) {
            // column
            index.push(i + kSub); // add value

            values$$1.push(v);
          }
        }
      } // last value should be number of values


      ptr.push(values$$1.length); // create SparseMatrix

      return new SparseMatrix({
        values: values$$1,
        index: index,
        ptr: ptr,
        size: [rows, columns]
      });
    };
    /**
     * Swap rows i and j in Matrix.
     *
     * @memberof SparseMatrix
     * @param {number} i       Matrix row index 1
     * @param {number} j       Matrix row index 2
     *
     * @return {Matrix}        The matrix reference
     */


    SparseMatrix.prototype.swapRows = function (i, j) {
      // check index
      if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
        throw new Error('Row index must be positive integers');
      } // check dimensions


      if (this._size.length !== 2) {
        throw new Error('Only two dimensional matrix is supported');
      } // validate index


      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[0]); // swap rows

      SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr); // return current instance


      return this;
    };
    /**
     * Loop rows with data in column j.
     *
     * @param {number} j            Column
     * @param {Array} values        Matrix values
     * @param {Array} index         Matrix row indeces
     * @param {Array} ptr           Matrix column pointers
     * @param {Function} callback   Callback function invoked for every row in column j
     */


    SparseMatrix._forEachRow = function (j, values$$1, index, ptr, callback) {
      // indeces for column j
      var k0 = ptr[j];
      var k1 = ptr[j + 1]; // loop

      for (var k = k0; k < k1; k++) {
        // invoke callback
        callback(index[k], values$$1[k]);
      }
    };
    /**
     * Swap rows x and y in Sparse Matrix data structures.
     *
     * @param {number} x         Matrix row index 1
     * @param {number} y         Matrix row index 2
     * @param {number} columns   Number of columns in matrix
     * @param {Array} values     Matrix values
     * @param {Array} index      Matrix row indeces
     * @param {Array} ptr        Matrix column pointers
     */


    SparseMatrix._swapRows = function (x, y, columns, values$$1, index, ptr) {
      // loop columns
      for (var j = 0; j < columns; j++) {
        // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
        var k0 = ptr[j];
        var k1 = ptr[j + 1]; // find value index @ x

        var kx = _getValueIndex(x, k0, k1, index); // find value index @ x


        var ky = _getValueIndex(y, k0, k1, index); // check both rows exist in matrix


        if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
          // swap values (check for pattern matrix)
          if (values$$1) {
            var v = values$$1[kx];
            values$$1[kx] = values$$1[ky];
            values$$1[ky] = v;
          } // next column


          continue;
        } // check x row exist & no y row


        if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
          // value @ x (check for pattern matrix)
          var vx = values$$1 ? values$$1[kx] : undefined; // insert value @ y

          index.splice(ky, 0, y);

          if (values$$1) {
            values$$1.splice(ky, 0, vx);
          } // remove value @ x (adjust array index if needed)


          index.splice(ky <= kx ? kx + 1 : kx, 1);

          if (values$$1) {
            values$$1.splice(ky <= kx ? kx + 1 : kx, 1);
          } // next column


          continue;
        } // check y row exist & no x row


        if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
          // value @ y (check for pattern matrix)
          var vy = values$$1 ? values$$1[ky] : undefined; // insert value @ x

          index.splice(kx, 0, x);

          if (values$$1) {
            values$$1.splice(kx, 0, vy);
          } // remove value @ y (adjust array index if needed)


          index.splice(kx <= ky ? ky + 1 : ky, 1);

          if (values$$1) {
            values$$1.splice(kx <= ky ? ky + 1 : ky, 1);
          }
        }
      }
    };

    return SparseMatrix;
  }, {
    isClass: true
  });

  var name$i = 'number';
  var dependencies$j = ['typed'];
  var createNumber = /* #__PURE__ */factory(name$i, dependencies$j, function (_ref) {
    var typed = _ref.typed;

    /**
     * Create a number or convert a string, boolean, or unit to a number.
     * When value is a matrix, all elements will be converted to number.
     *
     * Syntax:
     *
     *    math.number(value)
     *    math.number(unit, valuelessUnit)
     *
     * Examples:
     *
     *    math.number(2)                         // returns number 2
     *    math.number('7.2')                     // returns number 7.2
     *    math.number(true)                      // returns number 1
     *    math.number([true, false, true, true]) // returns [1, 0, 1, 1]
     *    math.number(math.unit('52cm'), 'm')    // returns 0.52
     *
     * See also:
     *
     *    bignumber, boolean, complex, index, matrix, string, unit
     *
     * @param {string | number | BigNumber | Fraction | boolean | Array | Matrix | Unit | null} [value]  Value to be converted
     * @param {Unit | string} [valuelessUnit] A valueless unit, used to convert a unit to a number
     * @return {number | Array | Matrix} The created number
     */
    var number = typed('number', {
      '': function _() {
        return 0;
      },
      number: function number(x) {
        return x;
      },
      string: function string(x) {
        if (x === 'NaN') return NaN;
        var num = Number(x);

        if (isNaN(num)) {
          throw new SyntaxError('String "' + x + '" is no valid number');
        }

        return num;
      },
      BigNumber: function BigNumber(x) {
        return x.toNumber();
      },
      Fraction: function Fraction(x) {
        return x.valueOf();
      },
      Unit: function Unit(x) {
        throw new Error('Second argument with valueless unit expected');
      },
      "null": function _null(x) {
        return 0;
      },
      'Unit, string | Unit': function UnitStringUnit(unit, valuelessUnit) {
        return unit.toNumber(valuelessUnit);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    }); // reviver function to parse a JSON object like:
    //
    //     {"mathjs":"number","value":"2.3"}
    //
    // into a number 2.3

    number.fromJSON = function (json) {
      return parseFloat(json.value);
    };

    return number;
  });

  var name$j = 'string';
  var dependencies$k = ['typed'];
  var createString = /* #__PURE__ */factory(name$j, dependencies$k, function (_ref) {
    var typed = _ref.typed;

    /**
     * Create a string or convert any object into a string.
     * Elements of Arrays and Matrices are processed element wise.
     *
     * Syntax:
     *
     *    math.string(value)
     *
     * Examples:
     *
     *    math.string(4.2)               // returns string '4.2'
     *    math.string(math.complex(3, 2) // returns string '3 + 2i'
     *
     *    const u = math.unit(5, 'km')
     *    math.string(u.to('m'))         // returns string '5000 m'
     *
     *    math.string([true, false])     // returns ['true', 'false']
     *
     * See also:
     *
     *    bignumber, boolean, complex, index, matrix, number, unit
     *
     * @param {* | Array | Matrix | null} [value]  A value to convert to a string
     * @return {string | Array | Matrix} The created string
     */
    return typed(name$j, {
      '': function _() {
        return '';
      },
      number: format,
      "null": function _null(x) {
        return 'null';
      },
      "boolean": function boolean(x) {
        return x + '';
      },
      string: function string(x) {
        return x;
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      },
      any: function any(x) {
        return String(x);
      }
    });
  });

  var name$k = 'boolean';
  var dependencies$l = ['typed'];
  var createBoolean = /* #__PURE__ */factory(name$k, dependencies$l, function (_ref) {
    var typed = _ref.typed;

    /**
     * Create a boolean or convert a string or number to a boolean.
     * In case of a number, `true` is returned for non-zero numbers, and `false` in
     * case of zero.
     * Strings can be `'true'` or `'false'`, or can contain a number.
     * When value is a matrix, all elements will be converted to boolean.
     *
     * Syntax:
     *
     *    math.boolean(x)
     *
     * Examples:
     *
     *    math.boolean(0)     // returns false
     *    math.boolean(1)     // returns true
     *    math.boolean(-3)     // returns true
     *    math.boolean('true')     // returns true
     *    math.boolean('false')     // returns false
     *    math.boolean([1, 0, 1, 1])     // returns [true, false, true, true]
     *
     * See also:
     *
     *    bignumber, complex, index, matrix, string, unit
     *
     * @param {string | number | boolean | Array | Matrix | null} value  A value of any type
     * @return {boolean | Array | Matrix} The boolean value
     */
    return typed(name$k, {
      '': function _() {
        return false;
      },
      "boolean": function boolean(x) {
        return x;
      },
      number: function number(x) {
        return !!x;
      },
      "null": function _null(x) {
        return false;
      },
      BigNumber: function BigNumber(x) {
        return !x.isZero();
      },
      string: function string(x) {
        // try case insensitive
        var lcase = x.toLowerCase();

        if (lcase === 'true') {
          return true;
        } else if (lcase === 'false') {
          return false;
        } // test whether value is a valid number


        var num = Number(x);

        if (x !== '' && !isNaN(num)) {
          return !!num;
        }

        throw new Error('Cannot convert "' + x + '" to a boolean');
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$l = 'bignumber';
  var dependencies$m = ['typed', 'BigNumber'];
  var createBignumber = /* #__PURE__ */factory(name$l, dependencies$m, function (_ref) {
    var typed = _ref.typed,
        BigNumber = _ref.BigNumber;

    /**
     * Create a BigNumber, which can store numbers with arbitrary precision.
     * When a matrix is provided, all elements will be converted to BigNumber.
     *
     * Syntax:
     *
     *    math.bignumber(x)
     *
     * Examples:
     *
     *    0.1 + 0.2                                  // returns number 0.30000000000000004
     *    math.bignumber(0.1) + math.bignumber(0.2)  // returns BigNumber 0.3
     *
     *
     *    7.2e500                                    // returns number Infinity
     *    math.bignumber('7.2e500')                  // returns BigNumber 7.2e500
     *
     * See also:
     *
     *    boolean, complex, index, matrix, string, unit
     *
     * @param {number | string | Fraction | BigNumber | Array | Matrix | boolean | null} [value]  Value for the big number,
     *                                                    0 by default.
     * @returns {BigNumber} The created bignumber
     */
    return typed('bignumber', {
      '': function _() {
        return new BigNumber(0);
      },
      number: function number(x) {
        // convert to string to prevent errors in case of >15 digits
        return new BigNumber(x + '');
      },
      string: function string(x) {
        return new BigNumber(x);
      },
      BigNumber: function BigNumber(x) {
        // we assume a BigNumber is immutable
        return x;
      },
      Fraction: function Fraction(x) {
        return new BigNumber(x.n).div(x.d).times(x.s);
      },
      "null": function _null(x) {
        return new BigNumber(0);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$m = 'complex';
  var dependencies$n = ['typed', 'Complex'];
  var createComplex = /* #__PURE__ */factory(name$m, dependencies$n, function (_ref) {
    var typed = _ref.typed,
        Complex = _ref.Complex;

    /**
     * Create a complex value or convert a value to a complex value.
     *
     * Syntax:
     *
     *     math.complex()                           // creates a complex value with zero
     *                                              // as real and imaginary part.
     *     math.complex(re : number, im : string)   // creates a complex value with provided
     *                                              // values for real and imaginary part.
     *     math.complex(re : number)                // creates a complex value with provided
     *                                              // real value and zero imaginary part.
     *     math.complex(complex : Complex)          // clones the provided complex value.
     *     math.complex(arg : string)               // parses a string into a complex value.
     *     math.complex(array : Array)              // converts the elements of the array
     *                                              // or matrix element wise into a
     *                                              // complex value.
     *     math.complex({re: number, im: number})   // creates a complex value with provided
     *                                              // values for real an imaginary part.
     *     math.complex({r: number, phi: number})   // creates a complex value with provided
     *                                              // polar coordinates
     *
     * Examples:
     *
     *    const a = math.complex(3, -4)     // a = Complex 3 - 4i
     *    a.re = 5                          // a = Complex 5 - 4i
     *    const i = a.im                    // Number -4
     *    const b = math.complex('2 + 6i')  // Complex 2 + 6i
     *    const c = math.complex()          // Complex 0 + 0i
     *    const d = math.add(a, b)          // Complex 5 + 2i
     *
     * See also:
     *
     *    bignumber, boolean, index, matrix, number, string, unit
     *
     * @param {* | Array | Matrix} [args]
     *            Arguments specifying the real and imaginary part of the complex number
     * @return {Complex | Array | Matrix} Returns a complex value
     */
    return typed('complex', {
      '': function _() {
        return Complex.ZERO;
      },
      number: function number(x) {
        return new Complex(x, 0);
      },
      'number, number': function numberNumber(re, im) {
        return new Complex(re, im);
      },
      // TODO: this signature should be redundant
      'BigNumber, BigNumber': function BigNumberBigNumber(re, im) {
        return new Complex(re.toNumber(), im.toNumber());
      },
      Fraction: function Fraction(x) {
        return new Complex(x.valueOf(), 0);
      },
      Complex: function Complex(x) {
        return x.clone();
      },
      string: function string(x) {
        return Complex(x); // for example '2 + 3i'
      },
      "null": function _null(x) {
        return Complex(0);
      },
      Object: function Object(x) {
        if ('re' in x && 'im' in x) {
          return new Complex(x.re, x.im);
        }

        if ('r' in x && 'phi' in x || 'abs' in x && 'arg' in x) {
          return new Complex(x);
        }

        throw new Error('Expected object with properties (re and im) or (r and phi) or (abs and arg)');
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$n = 'fraction';
  var dependencies$o = ['typed', 'Fraction'];
  var createFraction = /* #__PURE__ */factory(name$n, dependencies$o, function (_ref) {
    var typed = _ref.typed,
        Fraction = _ref.Fraction;

    /**
     * Create a fraction convert a value to a fraction.
     *
     * Syntax:
     *     math.fraction(numerator, denominator)
     *     math.fraction({n: numerator, d: denominator})
     *     math.fraction(matrix: Array | Matrix)         Turn all matrix entries
     *                                                   into fractions
     *
     * Examples:
     *
     *     math.fraction(1, 3)
     *     math.fraction('2/3')
     *     math.fraction({n: 2, d: 3})
     *     math.fraction([0.2, 0.25, 1.25])
     *
     * See also:
     *
     *    bignumber, number, string, unit
     *
     * @param {number | string | Fraction | BigNumber | Array | Matrix} [args]
     *            Arguments specifying the numerator and denominator of
     *            the fraction
     * @return {Fraction | Array | Matrix} Returns a fraction
     */
    return typed('fraction', {
      number: function number(x) {
        if (!isFinite(x) || isNaN(x)) {
          throw new Error(x + ' cannot be represented as a fraction');
        }

        return new Fraction(x);
      },
      string: function string(x) {
        return new Fraction(x);
      },
      'number, number': function numberNumber(numerator, denominator) {
        return new Fraction(numerator, denominator);
      },
      "null": function _null(x) {
        return new Fraction(0);
      },
      BigNumber: function BigNumber(x) {
        return new Fraction(x.toString());
      },
      Fraction: function Fraction(x) {
        return x; // fractions are immutable
      },
      Object: function Object(x) {
        return new Fraction(x);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$o = 'matrix';
  var dependencies$p = ['typed', 'Matrix', 'DenseMatrix', 'SparseMatrix'];
  var createMatrix = /* #__PURE__ */factory(name$o, dependencies$p, function (_ref) {
    var typed = _ref.typed,
        Matrix = _ref.Matrix,
        DenseMatrix = _ref.DenseMatrix,
        SparseMatrix = _ref.SparseMatrix;

    /**
     * Create a Matrix. The function creates a new `math.Matrix` object from
     * an `Array`. A Matrix has utility functions to manipulate the data in the
     * matrix, like getting the size and getting or setting values in the matrix.
     * Supported storage formats are 'dense' and 'sparse'.
     *
     * Syntax:
     *
     *    math.matrix()                         // creates an empty matrix using default storage format (dense).
     *    math.matrix(data)                     // creates a matrix with initial data using default storage format (dense).
     *    math.matrix('dense')                  // creates an empty matrix using the given storage format.
     *    math.matrix(data, 'dense')            // creates a matrix with initial data using the given storage format.
     *    math.matrix(data, 'sparse')           // creates a sparse matrix with initial data.
     *    math.matrix(data, 'sparse', 'number') // creates a sparse matrix with initial data, number data type.
     *
     * Examples:
     *
     *    let m = math.matrix([[1, 2], [3, 4]])
     *    m.size()                        // Array [2, 2]
     *    m.resize([3, 2], 5)
     *    m.valueOf()                     // Array [[1, 2], [3, 4], [5, 5]]
     *    m.get([1, 0])                    // number 3
     *
     * See also:
     *
     *    bignumber, boolean, complex, index, number, string, unit, sparse
     *
     * @param {Array | Matrix} [data]    A multi dimensional array
     * @param {string} [format]          The Matrix storage format
     *
     * @return {Matrix} The created matrix
     */
    return typed(name$o, {
      '': function _() {
        return _create([]);
      },
      string: function string(format) {
        return _create([], format);
      },
      'string, string': function stringString(format, datatype) {
        return _create([], format, datatype);
      },
      Array: function Array(data) {
        return _create(data);
      },
      Matrix: function Matrix(data) {
        return _create(data, data.storage());
      },
      'Array | Matrix, string': _create,
      'Array | Matrix, string, string': _create
    });
    /**
     * Create a new Matrix with given storage format
     * @param {Array} data
     * @param {string} [format]
     * @param {string} [datatype]
     * @returns {Matrix} Returns a new Matrix
     * @private
     */

    function _create(data, format, datatype) {
      // get storage format constructor
      if (format === 'dense' || format === 'default' || format === undefined) {
        return new DenseMatrix(data, datatype);
      }

      if (format === 'sparse') {
        return new SparseMatrix(data, datatype);
      }

      throw new TypeError('Unknown matrix type ' + JSON.stringify(format) + '.');
    }
  });

  var name$p = 'splitUnit';
  var dependencies$q = ['typed'];
  var createSplitUnit = /* #__PURE__ */factory(name$p, dependencies$q, function (_ref) {
    var typed = _ref.typed;

    /**
     * Split a unit in an array of units whose sum is equal to the original unit.
     *
     * Syntax:
     *
     *     splitUnit(unit: Unit, parts: Array.<Unit>)
     *
     * Example:
     *
     *     math.splitUnit(new Unit(1, 'm'), ['feet', 'inch'])
     *     // [ 3 feet, 3.3700787401575 inch ]
     *
     * See also:
     *
     *     unit
     *
     * @param {Array} [parts] An array of strings or valueless units.
     * @return {Array} An array of units.
     */
    return typed(name$p, {
      'Unit, Array': function UnitArray(unit, parts) {
        return unit.splitUnit(parts);
      }
    });
  });

  var name$q = 'unaryMinus';
  var dependencies$r = ['typed'];
  var createUnaryMinus = /* #__PURE__ */factory(name$q, dependencies$r, function (_ref) {
    var typed = _ref.typed;

    /**
     * Inverse the sign of a value, apply a unary minus operation.
     *
     * For matrices, the function is evaluated element wise. Boolean values and
     * strings will be converted to a number. For complex numbers, both real and
     * complex value are inverted.
     *
     * Syntax:
     *
     *    math.unaryMinus(x)
     *
     * Examples:
     *
     *    math.unaryMinus(3.5)      // returns -3.5
     *    math.unaryMinus(-4.2)     // returns 4.2
     *
     * See also:
     *
     *    add, subtract, unaryPlus
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Number to be inverted.
     * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Returns the value with inverted sign.
     */
    return typed(name$q, {
      number: unaryMinusNumber,
      Complex: function Complex(x) {
        return x.neg();
      },
      BigNumber: function BigNumber(x) {
        return x.neg();
      },
      Fraction: function Fraction(x) {
        return x.neg();
      },
      Unit: function Unit(x) {
        var res = x.clone();
        res.value = this(x.value);
        return res;
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since unaryMinus(0) = 0
        return deepMap(x, this, true);
      } // TODO: add support for string

    });
  });

  var name$r = 'unaryPlus';
  var dependencies$s = ['typed', 'config', 'BigNumber'];
  var createUnaryPlus = /* #__PURE__ */factory(name$r, dependencies$s, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        BigNumber = _ref.BigNumber;

    /**
     * Unary plus operation.
     * Boolean values and strings will be converted to a number, numeric values will be returned as is.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.unaryPlus(x)
     *
     * Examples:
     *
     *    math.unaryPlus(3.5)      // returns 3.5
     *    math.unaryPlus(1)     // returns 1
     *
     * See also:
     *
     *    unaryMinus, add, subtract
     *
     * @param  {number | BigNumber | Fraction | string | Complex | Unit | Array | Matrix} x
     *            Input value
     * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
     *            Returns the input value when numeric, converts to a number when input is non-numeric.
     */
    return typed(name$r, {
      number: unaryPlusNumber,
      Complex: function Complex(x) {
        return x; // complex numbers are immutable
      },
      BigNumber: function BigNumber(x) {
        return x; // bignumbers are immutable
      },
      Fraction: function Fraction(x) {
        return x; // fractions are immutable
      },
      Unit: function Unit(x) {
        return x.clone();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since unaryPlus(0) = 0
        return deepMap(x, this, true);
      },
      'boolean | string': function booleanString(x) {
        // convert to a number or bignumber
        return config.number === 'BigNumber' ? new BigNumber(+x) : +x;
      }
    });
  });

  var name$s = 'abs';
  var dependencies$t = ['typed'];
  var createAbs = /* #__PURE__ */factory(name$s, dependencies$t, function (_ref) {
    var typed = _ref.typed;

    /**
     * Calculate the absolute value of a number. For matrices, the function is
     * evaluated element wise.
     *
     * Syntax:
     *
     *    math.abs(x)
     *
     * Examples:
     *
     *    math.abs(3.5)                // returns number 3.5
     *    math.abs(-4.2)               // returns number 4.2
     *
     *    math.abs([3, -5, -1, 0, 2])  // returns Array [3, 5, 1, 0, 2]
     *
     * See also:
     *
     *    sign
     *
     * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
     *            A number or matrix for which to get the absolute value
     * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}
     *            Absolute value of `x`
     */
    return typed(name$s, {
      number: absNumber,
      Complex: function Complex(x) {
        return x.abs();
      },
      BigNumber: function BigNumber(x) {
        return x.abs();
      },
      Fraction: function Fraction(x) {
        return x.abs();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since abs(0) = 0
        return deepMap(x, this, true);
      },
      Unit: function Unit(x) {
        return x.abs();
      }
    });
  });

  var name$t = 'apply';
  var dependencies$u = ['typed', 'isInteger'];
  var createApply = /* #__PURE__ */factory(name$t, dependencies$u, function (_ref) {
    var typed = _ref.typed,
        isInteger = _ref.isInteger;

    /**
     * Apply a function that maps an array to a scalar
     * along a given axis of a matrix or array.
     * Returns a new matrix or array with one less dimension than the input.
     *
     * Syntax:
     *
     *     math.apply(A, dim, callback)
     *
     * Where:
     *
     * - `dim: number` is a zero-based dimension over which to concatenate the matrices.
     *
     * Examples:
     *
     *    const A = [[1, 2], [3, 4]]
     *    const sum = math.sum
     *
     *    math.apply(A, 0, sum)             // returns [4, 6]
     *    math.apply(A, 1, sum)             // returns [3, 7]
     *
     * See also:
     *
     *    map, filter, forEach
     *
     * @param {Array | Matrix} array   The input Matrix
     * @param {number} dim             The dimension along which the callback is applied
     * @param {Function} callback      The callback function that is applied. This Function
     *                                 should take an array or 1-d matrix as an input and
     *                                 return a number.
     * @return {Array | Matrix} res    The residual matrix with the function applied over some dimension.
     */
    return typed(name$t, {
      'Array | Matrix, number | BigNumber, function': function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {
        if (!isInteger(dim)) {
          throw new TypeError('Integer number expected for dimension');
        }

        var size = Array.isArray(mat) ? arraySize(mat) : mat.size();

        if (dim < 0 || dim >= size.length) {
          throw new IndexError(dim, size.length);
        }

        if (isMatrix(mat)) {
          return mat.create(_apply(mat.valueOf(), dim, callback));
        } else {
          return _apply(mat, dim, callback);
        }
      }
    });
  });
  /**
   * Recursively reduce a matrix
   * @param {Array} mat
   * @param {number} dim
   * @param {Function} callback
   * @returns {Array} ret
   * @private
   */

  function _apply(mat, dim, callback) {
    var i, ret, tran;

    if (dim <= 0) {
      if (!Array.isArray(mat[0])) {
        return callback(mat);
      } else {
        tran = _switch$1(mat);
        ret = [];

        for (i = 0; i < tran.length; i++) {
          ret[i] = _apply(tran[i], dim - 1, callback);
        }

        return ret;
      }
    } else {
      ret = [];

      for (i = 0; i < mat.length; i++) {
        ret[i] = _apply(mat[i], dim - 1, callback);
      }

      return ret;
    }
  }
  /**
   * Transpose a matrix
   * @param {Array} mat
   * @returns {Array} ret
   * @private
   */


  function _switch$1(mat) {
    var I = mat.length;
    var J = mat[0].length;
    var i, j;
    var ret = [];

    for (j = 0; j < J; j++) {
      var tmp = [];

      for (i = 0; i < I; i++) {
        tmp.push(mat[i][j]);
      }

      ret.push(tmp);
    }

    return ret;
  }

  var name$u = 'addScalar';
  var dependencies$v = ['typed'];
  var createAddScalar = /* #__PURE__ */factory(name$u, dependencies$v, function (_ref) {
    var typed = _ref.typed;

    /**
     * Add two scalar values, `x + y`.
     * This function is meant for internal use: it is used by the public function
     * `add`
     *
     * This function does not support collections (Array or Matrix).
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to add
     * @param  {number | BigNumber | Fraction | Complex} y          Second value to add
     * @return {number | BigNumber | Fraction | Complex | Unit}     Sum of `x` and `y`
     * @private
     */
    return typed(name$u, {
      'number, number': addNumber,
      'Complex, Complex': function ComplexComplex(x, y) {
        return x.add(y);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.plus(y);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.add(y);
      },
      'Unit, Unit': function UnitUnit(x, y) {
        if (x.value === null || x.value === undefined) throw new Error('Parameter x contains a unit with undefined value');
        if (y.value === null || y.value === undefined) throw new Error('Parameter y contains a unit with undefined value');
        if (!x.equalBase(y)) throw new Error('Units do not match');
        var res = x.clone();
        res.value = this(res.value, y.value);
        res.fixPrefix = false;
        return res;
      }
    });
  });

  var name$v = 'cbrt';
  var dependencies$w = ['config', 'typed', 'isNegative', 'unaryMinus', 'matrix', 'Complex', 'BigNumber', 'Fraction'];
  var createCbrt = /* #__PURE__ */factory(name$v, dependencies$w, function (_ref) {
    var config = _ref.config,
        typed = _ref.typed,
        isNegative = _ref.isNegative,
        unaryMinus = _ref.unaryMinus,
        matrix = _ref.matrix,
        Complex = _ref.Complex,
        BigNumber = _ref.BigNumber,
        Fraction = _ref.Fraction;

    /**
     * Calculate the cubic root of a value.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.cbrt(x)
     *    math.cbrt(x, allRoots)
     *
     * Examples:
     *
     *    math.cbrt(27)                  // returns 3
     *    math.cube(3)                   // returns 27
     *    math.cbrt(-64)                 // returns -4
     *    math.cbrt(math.unit('27 m^3')) // returns Unit 3 m
     *    math.cbrt([27, 64, 125])       // returns [3, 4, 5]
     *
     *    const x = math.complex('8i')
     *    math.cbrt(x)                   // returns Complex 1.7320508075689 + i
     *    math.cbrt(x, true)             // returns Matrix [
     *                                    //    1.7320508075689 + i
     *                                    //   -1.7320508075689 + i
     *                                    //   -2i
     *                                    // ]
     *
     * See also:
     *
     *    square, sqrt, cube
     *
     * @param {number | BigNumber | Complex | Unit | Array | Matrix} x
     *            Value for which to calculate the cubic root.
     * @param {boolean} [allRoots]  Optional, false by default. Only applicable
     *            when `x` is a number or complex number. If true, all complex
     *            roots are returned, if false (default) the principal root is
     *            returned.
     * @return {number | BigNumber | Complex | Unit | Array | Matrix}
     *            Returns the cubic root of `x`
     */
    return typed(name$v, {
      number: cbrtNumber,
      // note: signature 'number, boolean' is also supported,
      //       created by typed as it knows how to convert number to Complex
      Complex: _cbrtComplex,
      'Complex, boolean': _cbrtComplex,
      BigNumber: function BigNumber(x) {
        return x.cbrt();
      },
      Unit: _cbrtUnit,
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since cbrt(0) = 0
        return deepMap(x, this, true);
      }
    });
    /**
     * Calculate the cubic root for a complex number
     * @param {Complex} x
     * @param {boolean} [allRoots]   If true, the function will return an array
     *                               with all three roots. If false or undefined,
     *                               the principal root is returned.
     * @returns {Complex | Array.<Complex> | Matrix.<Complex>} Returns the cubic root(s) of x
     * @private
     */

    function _cbrtComplex(x, allRoots) {
      // https://www.wikiwand.com/en/Cube_root#/Complex_numbers
      var arg3 = x.arg() / 3;
      var abs = x.abs(); // principal root:

      var principal = new Complex(cbrtNumber(abs), 0).mul(new Complex(0, arg3).exp());

      if (allRoots) {
        var all = [principal, new Complex(cbrtNumber(abs), 0).mul(new Complex(0, arg3 + Math.PI * 2 / 3).exp()), new Complex(cbrtNumber(abs), 0).mul(new Complex(0, arg3 - Math.PI * 2 / 3).exp())];
        return config.matrix === 'Array' ? all : matrix(all);
      } else {
        return principal;
      }
    }
    /**
     * Calculate the cubic root for a Unit
     * @param {Unit} x
     * @return {Unit} Returns the cubic root of x
     * @private
     */


    function _cbrtUnit(x) {
      if (x.value && isComplex(x.value)) {
        var result = x.clone();
        result.value = 1.0;
        result = result.pow(1.0 / 3); // Compute the units

        result.value = _cbrtComplex(x.value); // Compute the value

        return result;
      } else {
        var negate = isNegative(x.value);

        if (negate) {
          x.value = unaryMinus(x.value);
        } // TODO: create a helper function for this


        var third;

        if (isBigNumber(x.value)) {
          third = new BigNumber(1).div(3);
        } else if (isFraction(x.value)) {
          third = new Fraction(1, 3);
        } else {
          third = 1 / 3;
        }

        var _result = x.pow(third);

        if (negate) {
          _result.value = unaryMinus(_result.value);
        }

        return _result;
      }
    }
  });

  var name$w = 'ceil';
  var dependencies$x = ['typed', 'config', 'round'];
  var createCeil = /* #__PURE__ */factory(name$w, dependencies$x, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        round = _ref.round;

    /**
     * Round a value towards plus infinity
     * If `x` is complex, both real and imaginary part are rounded towards plus infinity.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.ceil(x)
     *
     * Examples:
     *
     *    math.ceil(3.2)               // returns number 4
     *    math.ceil(3.8)               // returns number 4
     *    math.ceil(-4.2)              // returns number -4
     *    math.ceil(-4.7)              // returns number -4
     *
     *    const c = math.complex(3.2, -2.7)
     *    math.ceil(c)                 // returns Complex 4 - 2i
     *
     *    math.ceil([3.2, 3.8, -4.7])  // returns Array [4, 4, -4]
     *
     * See also:
     *
     *    floor, fix, round
     *
     * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
     * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
     */
    return typed('ceil', {
      number: function number(x) {
        if (nearlyEqual(x, round(x), config.epsilon)) {
          return round(x);
        } else {
          return ceilNumber(x);
        }
      },
      Complex: function Complex(x) {
        return x.ceil();
      },
      BigNumber: function BigNumber(x) {
        if (nearlyEqual$1(x, round(x), config.epsilon)) {
          return round(x);
        } else {
          return x.ceil();
        }
      },
      Fraction: function Fraction(x) {
        return x.ceil();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since ceil(0) = 0
        return deepMap(x, this, true);
      }
    });
  });

  var name$x = 'cube';
  var dependencies$y = ['typed'];
  var createCube = /* #__PURE__ */factory(name$x, dependencies$y, function (_ref) {
    var typed = _ref.typed;

    /**
     * Compute the cube of a value, `x * x * x`.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.cube(x)
     *
     * Examples:
     *
     *    math.cube(2)            // returns number 8
     *    math.pow(2, 3)          // returns number 8
     *    math.cube(4)            // returns number 64
     *    4 * 4 * 4               // returns number 64
     *
     *    math.cube([1, 2, 3, 4]) // returns Array [1, 8, 27, 64]
     *
     * See also:
     *
     *    multiply, square, pow, cbrt
     *
     * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x  Number for which to calculate the cube
     * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} Cube of x
     */
    return typed(name$x, {
      number: cubeNumber,
      Complex: function Complex(x) {
        return x.mul(x).mul(x); // Is faster than pow(x, 3)
      },
      BigNumber: function BigNumber(x) {
        return x.times(x).times(x);
      },
      Fraction: function Fraction(x) {
        return x.pow(3); // Is faster than mul()mul()mul()
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since cube(0) = 0
        return deepMap(x, this, true);
      },
      Unit: function Unit(x) {
        return x.pow(3);
      }
    });
  });

  var name$y = 'exp';
  var dependencies$z = ['typed'];
  var createExp = /* #__PURE__ */factory(name$y, dependencies$z, function (_ref) {
    var typed = _ref.typed;

    /**
     * Calculate the exponent of a value.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.exp(x)
     *
     * Examples:
     *
     *    math.exp(2)                  // returns number 7.3890560989306495
     *    math.pow(math.e, 2)          // returns number 7.3890560989306495
     *    math.log(math.exp(2))        // returns number 2
     *
     *    math.exp([1, 2, 3])
     *    // returns Array [
     *    //   2.718281828459045,
     *    //   7.3890560989306495,
     *    //   20.085536923187668
     *    // ]
     *
     * See also:
     *
     *    expm1, log, pow
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x  A number or matrix to exponentiate
     * @return {number | BigNumber | Complex | Array | Matrix} Exponent of `x`
     */
    return typed(name$y, {
      number: expNumber,
      Complex: function Complex(x) {
        return x.exp();
      },
      BigNumber: function BigNumber(x) {
        return x.exp();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // TODO: exp(sparse) should return a dense matrix since exp(0)==1
        return deepMap(x, this);
      }
    });
  });

  var name$z = 'expm1';
  var dependencies$A = ['typed', 'Complex'];
  var createExpm1 = /* #__PURE__ */factory(name$z, dependencies$A, function (_ref) {
    var typed = _ref.typed,
        _Complex = _ref.Complex;

    /**
     * Calculate the value of subtracting 1 from the exponential value.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.expm1(x)
     *
     * Examples:
     *
     *    math.expm1(2)                      // returns number 6.38905609893065
     *    math.pow(math.e, 2) - 1            // returns number 6.3890560989306495
     *    math.log(math.expm1(2) + 1)        // returns number 2
     *
     *    math.expm1([1, 2, 3])
     *    // returns Array [
     *    //   1.718281828459045,
     *    //   6.3890560989306495,
     *    //   19.085536923187668
     *    // ]
     *
     * See also:
     *
     *    exp, log, pow
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x  A number or matrix to apply expm1
     * @return {number | BigNumber | Complex | Array | Matrix} Exponent of `x`
     */
    return typed(name$z, {
      number: expm1Number,
      Complex: function Complex(x) {
        var r = Math.exp(x.re);
        return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
      },
      BigNumber: function BigNumber(x) {
        return x.exp().minus(1);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$A = 'fix';
  var dependencies$B = ['typed', 'Complex', 'ceil', 'floor'];
  var createFix = /* #__PURE__ */factory(name$A, dependencies$B, function (_ref) {
    var typed = _ref.typed,
        _Complex = _ref.Complex,
        ceil = _ref.ceil,
        floor = _ref.floor;

    /**
     * Round a value towards zero.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.fix(x)
     *
     * Examples:
     *
     *    math.fix(3.2)                // returns number 3
     *    math.fix(3.8)                // returns number 3
     *    math.fix(-4.2)               // returns number -4
     *    math.fix(-4.7)               // returns number -4
     *
     *    const c = math.complex(3.2, -2.7)
     *    math.fix(c)                  // returns Complex 3 - 2i
     *
     *    math.fix([3.2, 3.8, -4.7])   // returns Array [3, 3, -4]
     *
     * See also:
     *
     *    ceil, floor, round
     *
     * @param {number | BigNumber | Fraction | Complex | Array | Matrix} x Number to be rounded
     * @return {number | BigNumber | Fraction | Complex | Array | Matrix}            Rounded value
     */
    return typed('fix', {
      number: function number(x) {
        return x > 0 ? floor(x) : ceil(x);
      },
      Complex: function Complex(x) {
        return new _Complex(x.re > 0 ? Math.floor(x.re) : Math.ceil(x.re), x.im > 0 ? Math.floor(x.im) : Math.ceil(x.im));
      },
      BigNumber: function BigNumber(x) {
        return x.isNegative() ? ceil(x) : floor(x);
      },
      Fraction: function Fraction(x) {
        return x.s < 0 ? x.ceil() : x.floor();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since fix(0) = 0
        return deepMap(x, this, true);
      }
    });
  });

  var name$B = 'floor';
  var dependencies$C = ['typed', 'config', 'round'];
  var createFloor = /* #__PURE__ */factory(name$B, dependencies$C, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        round = _ref.round;

    /**
     * Round a value towards minus infinity.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.floor(x)
     *
     * Examples:
     *
     *    math.floor(3.2)              // returns number 3
     *    math.floor(3.8)              // returns number 3
     *    math.floor(-4.2)             // returns number -5
     *    math.floor(-4.7)             // returns number -5
     *
     *    const c = math.complex(3.2, -2.7)
     *    math.floor(c)                // returns Complex 3 - 3i
     *
     *    math.floor([3.2, 3.8, -4.7]) // returns Array [3, 3, -5]
     *
     * See also:
     *
     *    ceil, fix, round
     *
     * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
     * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
     */
    return typed('floor', {
      number: function number(x) {
        if (nearlyEqual(x, round(x), config.epsilon)) {
          return round(x);
        } else {
          return Math.floor(x);
        }
      },
      Complex: function Complex(x) {
        return x.floor();
      },
      BigNumber: function BigNumber(x) {
        if (nearlyEqual$1(x, round(x), config.epsilon)) {
          return round(x);
        } else {
          return x.floor();
        }
      },
      Fraction: function Fraction(x) {
        return x.floor();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since floor(0) = 0
        return deepMap(x, this, true);
      }
    });
  });

  var name$C = 'algorithm01';
  var dependencies$D = ['typed'];
  var createAlgorithm01 = /* #__PURE__ */factory(name$C, dependencies$D, function (_ref) {
    var typed = _ref.typed;

    /**
     * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij).
     * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).
     *
     *
     *            f(Dij, Sij)  ; S(i,j) !== 0
     * C(i,j) = 
     *            Dij          ; otherwise
     *
     *
     * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
     * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)
     * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
     * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
     *
     * @return {Matrix}                    DenseMatrix (C)
     *
     * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
     */
    return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
      // dense matrix arrays
      var adata = denseMatrix._data;
      var asize = denseMatrix._size;
      var adt = denseMatrix._datatype; // sparse matrix arrays

      var bvalues = sparseMatrix._values;
      var bindex = sparseMatrix._index;
      var bptr = sparseMatrix._ptr;
      var bsize = sparseMatrix._size;
      var bdt = sparseMatrix._datatype; // validate dimensions

      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      } // check rows & columns


      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
      } // sparse matrix cannot be a Pattern matrix


      if (!bvalues) {
        throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');
      } // rows & columns


      var rows = asize[0];
      var columns = asize[1]; // process data types

      var dt = typeof adt === 'string' && adt === bdt ? adt : undefined; // callback function

      var cf = dt ? typed.find(callback, [dt, dt]) : callback; // vars

      var i, j; // result (DenseMatrix)

      var cdata = []; // initialize c

      for (i = 0; i < rows; i++) {
        cdata[i] = [];
      } // workspace


      var x = []; // marks indicating we have a value in x for a given column

      var w = []; // loop columns in b

      for (j = 0; j < columns; j++) {
        // column mark
        var mark = j + 1; // values in column j

        for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          // row
          i = bindex[k]; // update workspace

          x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]); // mark i as updated

          w[i] = mark;
        } // loop rows


        for (i = 0; i < rows; i++) {
          // check row is in workspace
          if (w[i] === mark) {
            // c[i][j] was already calculated
            cdata[i][j] = x[i];
          } else {
            // item does not exist in S
            cdata[i][j] = adata[i][j];
          }
        }
      } // return dense matrix


      return denseMatrix.createDenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$D = 'algorithm04';
  var dependencies$E = ['typed', 'equalScalar'];
  var createAlgorithm04 = /* #__PURE__ */factory(name$D, dependencies$E, function (_ref) {
    var typed = _ref.typed,
        equalScalar = _ref.equalScalar;

    /**
     * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
     * Callback function invoked MAX(NNZA, NNZB) times
     *
     *
     *            f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
     * C(i,j) =   A(i,j)       ; A(i,j) !== 0
     *            B(i,j)       ; B(i,j) !== 0
     *
     *
     * @param {Matrix}   a                 The SparseMatrix instance (A)
     * @param {Matrix}   b                 The SparseMatrix instance (B)
     * @param {Function} callback          The f(Aij,Bij) operation to invoke
     *
     * @return {Matrix}                    SparseMatrix (C)
     *
     * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
     */
    return function algorithm04(a, b, callback) {
      // sparse matrix arrays
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype; // sparse matrix arrays

      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype; // validate dimensions

      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      } // check rows & columns


      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
      } // rows & columns


      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string' && adt === bdt) {
        // datatype
        dt = adt; // find signature that matches (dt, dt)

        eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

        zero = typed.convert(0, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // result arrays


      var cvalues = avalues && bvalues ? [] : undefined;
      var cindex = [];
      var cptr = []; // workspace

      var xa = avalues && bvalues ? [] : undefined;
      var xb = avalues && bvalues ? [] : undefined; // marks indicating we have a value in x for a given column

      var wa = [];
      var wb = []; // vars

      var i, j, k, k0, k1; // loop columns

      for (j = 0; j < columns; j++) {
        // update cptr
        cptr[j] = cindex.length; // columns mark

        var mark = j + 1; // loop A(:,j)

        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          // row
          i = aindex[k]; // update c

          cindex.push(i); // update workspace

          wa[i] = mark; // check we need to process values

          if (xa) {
            xa[i] = avalues[k];
          }
        } // loop B(:,j)


        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          // row
          i = bindex[k]; // check row exists in A

          if (wa[i] === mark) {
            // update record in xa @ i
            if (xa) {
              // invoke callback
              var v = cf(xa[i], bvalues[k]); // check for zero

              if (!eq(v, zero)) {
                // update workspace
                xa[i] = v;
              } else {
                // remove mark (index will be removed later)
                wa[i] = null;
              }
            }
          } else {
            // update c
            cindex.push(i); // update workspace

            wb[i] = mark; // check we need to process values

            if (xb) {
              xb[i] = bvalues[k];
            }
          }
        } // check we need to process values (non pattern matrix)


        if (xa && xb) {
          // initialize first index in j
          k = cptr[j]; // loop index in j

          while (k < cindex.length) {
            // row
            i = cindex[k]; // check workspace has value @ i

            if (wa[i] === mark) {
              // push value (Aij != 0 || (Aij != 0 && Bij != 0))
              cvalues[k] = xa[i]; // increment pointer

              k++;
            } else if (wb[i] === mark) {
              // push value (bij != 0)
              cvalues[k] = xb[i]; // increment pointer

              k++;
            } else {
              // remove index @ k
              cindex.splice(k, 1);
            }
          }
        }
      } // update cptr


      cptr[columns] = cindex.length; // return sparse matrix

      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$E = 'algorithm10';
  var dependencies$F = ['typed', 'DenseMatrix'];
  var createAlgorithm10 = /* #__PURE__ */factory(name$E, dependencies$F, function (_ref) {
    var typed = _ref.typed,
        DenseMatrix = _ref.DenseMatrix;

    /**
     * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
     * Callback function invoked NZ times (number of nonzero items in S).
     *
     *
     *            f(Sij, b)  ; S(i,j) !== 0
     * C(i,j) = 
     *            b          ; otherwise
     *
     *
     * @param {Matrix}   s                 The SparseMatrix instance (S)
     * @param {Scalar}   b                 The Scalar value
     * @param {Function} callback          The f(Aij,b) operation to invoke
     * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
     *
     * @return {Matrix}                    DenseMatrix (C)
     *
     * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
     */
    return function algorithm10(s, b, callback, inverse) {
      // sparse matrix arrays
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype; // sparse matrix cannot be a Pattern matrix

      if (!avalues) {
        throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
      } // rows & columns


      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string') {
        // datatype
        dt = adt; // convert b to the same datatype

        b = typed.convert(b, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // result arrays


      var cdata = []; // workspaces

      var x = []; // marks indicating we have a value in x for a given column

      var w = []; // loop columns

      for (var j = 0; j < columns; j++) {
        // columns mark
        var mark = j + 1; // values in j

        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          // row
          var r = aindex[k]; // update workspace

          x[r] = avalues[k];
          w[r] = mark;
        } // loop rows


        for (var i = 0; i < rows; i++) {
          // initialize C on first column
          if (j === 0) {
            // create row array
            cdata[i] = [];
          } // check sparse matrix has a value @ i,j


          if (w[i] === mark) {
            // invoke callback, update C
            cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
          } else {
            // dense matrix value @ i, j
            cdata[i][j] = b;
          }
        }
      } // return dense matrix


      return new DenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$F = 'algorithm13';
  var dependencies$G = ['typed'];
  var createAlgorithm13 = /* #__PURE__ */factory(name$F, dependencies$G, function (_ref) {
    var typed = _ref.typed;

    /**
     * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, Bij..z).
     * Callback function invoked MxN times.
     *
     * C(i,j,...z) = f(Aij..z, Bij..z)
     *
     * @param {Matrix}   a                 The DenseMatrix instance (A)
     * @param {Matrix}   b                 The DenseMatrix instance (B)
     * @param {Function} callback          The f(Aij..z,Bij..z) operation to invoke
     *
     * @return {Matrix}                    DenseMatrix (C)
     *
     * https://github.com/josdejong/mathjs/pull/346#issuecomment-97658658
     */
    return function algorithm13(a, b, callback) {
      // a arrays
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype; // b arrays

      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype; // c arrays

      var csize = []; // validate dimensions

      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      } // validate each one of the dimension sizes


      for (var s = 0; s < asize.length; s++) {
        // must match
        if (asize[s] !== bsize[s]) {
          throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
        } // update dimension in c


        csize[s] = asize[s];
      } // datatype


      var dt; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string' && adt === bdt) {
        // datatype
        dt = adt; // callback

        cf = typed.find(callback, [dt, dt]);
      } // populate cdata, iterate through dimensions


      var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : []; // c matrix

      return a.createDenseMatrix({
        data: cdata,
        size: csize,
        datatype: dt
      });
    }; // recursive function

    function _iterate(f, level, s, n, av, bv) {
      // initialize array for this level
      var cv = []; // check we reach the last level

      if (level === s.length - 1) {
        // loop arrays in last level
        for (var i = 0; i < n; i++) {
          // invoke callback and store value
          cv[i] = f(av[i], bv[i]);
        }
      } else {
        // iterate current level
        for (var j = 0; j < n; j++) {
          // iterate next level
          cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
        }
      }

      return cv;
    }
  });

  var name$G = 'algorithm14';
  var dependencies$H = ['typed'];
  var createAlgorithm14 = /* #__PURE__ */factory(name$G, dependencies$H, function (_ref) {
    var typed = _ref.typed;

    /**
     * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, b).
     * Callback function invoked MxN times.
     *
     * C(i,j,...z) = f(Aij..z, b)
     *
     * @param {Matrix}   a                 The DenseMatrix instance (A)
     * @param {Scalar}   b                 The Scalar value
     * @param {Function} callback          The f(Aij..z,b) operation to invoke
     * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Aij..z)
     *
     * @return {Matrix}                    DenseMatrix (C)
     *
     * https://github.com/josdejong/mathjs/pull/346#issuecomment-97659042
     */
    return function algorithm14(a, b, callback, inverse) {
      // a arrays
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype; // datatype

      var dt; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string') {
        // datatype
        dt = adt; // convert b to the same datatype

        b = typed.convert(b, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // populate cdata, iterate through dimensions


      var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : []; // c matrix

      return a.createDenseMatrix({
        data: cdata,
        size: clone(asize),
        datatype: dt
      });
    }; // recursive function

    function _iterate(f, level, s, n, av, bv, inverse) {
      // initialize array for this level
      var cv = []; // check we reach the last level

      if (level === s.length - 1) {
        // loop arrays in last level
        for (var i = 0; i < n; i++) {
          // invoke callback and store value
          cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
        }
      } else {
        // iterate current level
        for (var j = 0; j < n; j++) {
          // iterate next level
          cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
        }
      }

      return cv;
    }
  });

  var name$H = 'gcd';
  var dependencies$I = ['typed', 'matrix', 'equalScalar', 'BigNumber', 'DenseMatrix'];
  var createGcd = /* #__PURE__ */factory(name$H, dependencies$I, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar,
        BigNumber = _ref.BigNumber,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm01 = createAlgorithm01({
      typed: typed
    });
    var algorithm04 = createAlgorithm04({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm10 = createAlgorithm10({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Calculate the greatest common divisor for two or more values or arrays.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.gcd(a, b)
     *    math.gcd(a, b, c, ...)
     *
     * Examples:
     *
     *    math.gcd(8, 12)              // returns 4
     *    math.gcd(-4, 6)              // returns 2
     *    math.gcd(25, 15, -10)        // returns 5
     *
     *    math.gcd([8, -4], [12, 6])   // returns [4, 2]
     *
     * See also:
     *
     *    lcm, xgcd
     *
     * @param {... number | BigNumber | Fraction | Array | Matrix} args  Two or more integer numbers
     * @return {number | BigNumber | Fraction | Array | Matrix}                           The greatest common divisor
     */

    return typed(name$H, {
      'number, number': gcdNumber,
      'BigNumber, BigNumber': _gcdBigNumber,
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.gcd(y);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm04(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm01(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm01(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, number | BigNumber': function SparseMatrixNumberBigNumber(x, y) {
        return algorithm10(x, y, this, false);
      },
      'DenseMatrix, number | BigNumber': function DenseMatrixNumberBigNumber(x, y) {
        return algorithm14(x, y, this, false);
      },
      'number | BigNumber, SparseMatrix': function numberBigNumberSparseMatrix(x, y) {
        return algorithm10(y, x, this, true);
      },
      'number | BigNumber, DenseMatrix': function numberBigNumberDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, number | BigNumber': function ArrayNumberBigNumber(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'number | BigNumber, Array': function numberBigNumberArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      },
      // TODO: need a smarter notation here
      'Array | Matrix | number | BigNumber, Array | Matrix | number | BigNumber, ...Array | Matrix | number | BigNumber': function ArrayMatrixNumberBigNumberArrayMatrixNumberBigNumberArrayMatrixNumberBigNumber(a, b, args) {
        var res = this(a, b);

        for (var i = 0; i < args.length; i++) {
          res = this(res, args[i]);
        }

        return res;
      }
    });
    /**
     * Calculate gcd for BigNumbers
     * @param {BigNumber} a
     * @param {BigNumber} b
     * @returns {BigNumber} Returns greatest common denominator of a and b
     * @private
     */

    function _gcdBigNumber(a, b) {
      if (!a.isInt() || !b.isInt()) {
        throw new Error('Parameters in function gcd must be integer numbers');
      } // https://en.wikipedia.org/wiki/Euclidean_algorithm


      var zero = new BigNumber(0);

      while (!b.isZero()) {
        var r = a.mod(b);
        a = b;
        b = r;
      }

      return a.lt(zero) ? a.neg() : a;
    }
  });

  var name$I = 'algorithm02';
  var dependencies$J = ['typed', 'equalScalar'];
  var createAlgorithm02 = /* #__PURE__ */factory(name$I, dependencies$J, function (_ref) {
    var typed = _ref.typed,
        equalScalar = _ref.equalScalar;

    /**
     * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij).
     * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).
     *
     *
     *            f(Dij, Sij)  ; S(i,j) !== 0
     * C(i,j) = 
     *            0            ; otherwise
     *
     *
     * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
     * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)
     * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
     * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
     *
     * @return {Matrix}                    SparseMatrix (C)
     *
     * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
     */
    return function algorithm02(denseMatrix, sparseMatrix, callback, inverse) {
      // dense matrix arrays
      var adata = denseMatrix._data;
      var asize = denseMatrix._size;
      var adt = denseMatrix._datatype; // sparse matrix arrays

      var bvalues = sparseMatrix._values;
      var bindex = sparseMatrix._index;
      var bptr = sparseMatrix._ptr;
      var bsize = sparseMatrix._size;
      var bdt = sparseMatrix._datatype; // validate dimensions

      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      } // check rows & columns


      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
      } // sparse matrix cannot be a Pattern matrix


      if (!bvalues) {
        throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');
      } // rows & columns


      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string' && adt === bdt) {
        // datatype
        dt = adt; // find signature that matches (dt, dt)

        eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

        zero = typed.convert(0, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // result (SparseMatrix)


      var cvalues = [];
      var cindex = [];
      var cptr = []; // loop columns in b

      for (var j = 0; j < columns; j++) {
        // update cptr
        cptr[j] = cindex.length; // values in column j

        for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          // row
          var i = bindex[k]; // update C(i,j)

          var cij = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]); // check for nonzero

          if (!eq(cij, zero)) {
            // push i & v
            cindex.push(i);
            cvalues.push(cij);
          }
        }
      } // update cptr


      cptr[columns] = cindex.length; // return sparse matrix

      return sparseMatrix.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$J = 'algorithm06';
  var dependencies$K = ['typed', 'equalScalar'];
  var createAlgorithm06 = /* #__PURE__ */factory(name$J, dependencies$K, function (_ref) {
    var typed = _ref.typed,
        equalScalar = _ref.equalScalar;

    /**
     * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
     * Callback function invoked (Anz U Bnz) times, where Anz and Bnz are the nonzero elements in both matrices.
     *
     *
     *            f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
     * C(i,j) = 
     *            0            ; otherwise
     *
     *
     * @param {Matrix}   a                 The SparseMatrix instance (A)
     * @param {Matrix}   b                 The SparseMatrix instance (B)
     * @param {Function} callback          The f(Aij,Bij) operation to invoke
     *
     * @return {Matrix}                    SparseMatrix (C)
     *
     * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
     */
    return function algorithm06(a, b, callback) {
      // sparse matrix arrays
      var avalues = a._values;
      var asize = a._size;
      var adt = a._datatype; // sparse matrix arrays

      var bvalues = b._values;
      var bsize = b._size;
      var bdt = b._datatype; // validate dimensions

      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      } // check rows & columns


      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
      } // rows & columns


      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string' && adt === bdt) {
        // datatype
        dt = adt; // find signature that matches (dt, dt)

        eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

        zero = typed.convert(0, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // result arrays


      var cvalues = avalues && bvalues ? [] : undefined;
      var cindex = [];
      var cptr = []; // workspaces

      var x = cvalues ? [] : undefined; // marks indicating we have a value in x for a given column

      var w = []; // marks indicating value in a given row has been updated

      var u = []; // loop columns

      for (var j = 0; j < columns; j++) {
        // update cptr
        cptr[j] = cindex.length; // columns mark

        var mark = j + 1; // scatter the values of A(:,j) into workspace

        scatter(a, j, w, x, u, mark, cindex, cf); // scatter the values of B(:,j) into workspace

        scatter(b, j, w, x, u, mark, cindex, cf); // check we need to process values (non pattern matrix)

        if (x) {
          // initialize first index in j
          var k = cptr[j]; // loop index in j

          while (k < cindex.length) {
            // row
            var i = cindex[k]; // check function was invoked on current row (Aij !=0 && Bij != 0)

            if (u[i] === mark) {
              // value @ i
              var v = x[i]; // check for zero value

              if (!eq(v, zero)) {
                // push value
                cvalues.push(v); // increment pointer

                k++;
              } else {
                // remove value @ i, do not increment pointer
                cindex.splice(k, 1);
              }
            } else {
              // remove value @ i, do not increment pointer
              cindex.splice(k, 1);
            }
          }
        } else {
          // initialize first index in j
          var p = cptr[j]; // loop index in j

          while (p < cindex.length) {
            // row
            var r = cindex[p]; // check function was invoked on current row (Aij !=0 && Bij != 0)

            if (u[r] !== mark) {
              // remove value @ i, do not increment pointer
              cindex.splice(p, 1);
            } else {
              // increment pointer
              p++;
            }
          }
        }
      } // update cptr


      cptr[columns] = cindex.length; // return sparse matrix

      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$K = 'algorithm11';
  var dependencies$L = ['typed', 'equalScalar'];
  var createAlgorithm11 = /* #__PURE__ */factory(name$K, dependencies$L, function (_ref) {
    var typed = _ref.typed,
        equalScalar = _ref.equalScalar;

    /**
     * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
     * Callback function invoked NZ times (number of nonzero items in S).
     *
     *
     *            f(Sij, b)  ; S(i,j) !== 0
     * C(i,j) = 
     *            0          ; otherwise
     *
     *
     * @param {Matrix}   s                 The SparseMatrix instance (S)
     * @param {Scalar}   b                 The Scalar value
     * @param {Function} callback          The f(Aij,b) operation to invoke
     * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
     *
     * @return {Matrix}                    SparseMatrix (C)
     *
     * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
     */
    return function algorithm11(s, b, callback, inverse) {
      // sparse matrix arrays
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype; // sparse matrix cannot be a Pattern matrix

      if (!avalues) {
        throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
      } // rows & columns


      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string') {
        // datatype
        dt = adt; // find signature that matches (dt, dt)

        eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

        zero = typed.convert(0, dt); // convert b to the same datatype

        b = typed.convert(b, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // result arrays


      var cvalues = [];
      var cindex = [];
      var cptr = []; // loop columns

      for (var j = 0; j < columns; j++) {
        // initialize ptr
        cptr[j] = cindex.length; // values in j

        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          // row
          var i = aindex[k]; // invoke callback

          var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b); // check value is zero

          if (!eq(v, zero)) {
            // push index & value
            cindex.push(i);
            cvalues.push(v);
          }
        }
      } // update ptr


      cptr[columns] = cindex.length; // return sparse matrix

      return s.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$L = 'lcm';
  var dependencies$M = ['typed', 'matrix', 'equalScalar'];
  var createLcm = /* #__PURE__ */factory(name$L, dependencies$M, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar;
    var algorithm02 = createAlgorithm02({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm06 = createAlgorithm06({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm11 = createAlgorithm11({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Calculate the least common multiple for two or more values or arrays.
     *
     * lcm is defined as:
     *
     *     lcm(a, b) = abs(a * b) / gcd(a, b)
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.lcm(a, b)
     *    math.lcm(a, b, c, ...)
     *
     * Examples:
     *
     *    math.lcm(4, 6)               // returns 12
     *    math.lcm(6, 21)              // returns 42
     *    math.lcm(6, 21, 5)           // returns 210
     *
     *    math.lcm([4, 6], [6, 21])    // returns [12, 42]
     *
     * See also:
     *
     *    gcd, xgcd
     *
     * @param {... number | BigNumber | Array | Matrix} args  Two or more integer numbers
     * @return {number | BigNumber | Array | Matrix}                           The least common multiple
     */

    return typed(name$L, {
      'number, number': lcmNumber,
      'BigNumber, BigNumber': _lcmBigNumber,
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.lcm(y);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm06(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm02(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, number | BigNumber': function SparseMatrixNumberBigNumber(x, y) {
        return algorithm11(x, y, this, false);
      },
      'DenseMatrix, number | BigNumber': function DenseMatrixNumberBigNumber(x, y) {
        return algorithm14(x, y, this, false);
      },
      'number | BigNumber, SparseMatrix': function numberBigNumberSparseMatrix(x, y) {
        return algorithm11(y, x, this, true);
      },
      'number | BigNumber, DenseMatrix': function numberBigNumberDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, number | BigNumber': function ArrayNumberBigNumber(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'number | BigNumber, Array': function numberBigNumberArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      },
      // TODO: need a smarter notation here
      'Array | Matrix | number | BigNumber, Array | Matrix | number | BigNumber, ...Array | Matrix | number | BigNumber': function ArrayMatrixNumberBigNumberArrayMatrixNumberBigNumberArrayMatrixNumberBigNumber(a, b, args) {
        var res = this(a, b);

        for (var i = 0; i < args.length; i++) {
          res = this(res, args[i]);
        }

        return res;
      }
    });
    /**
     * Calculate lcm for two BigNumbers
     * @param {BigNumber} a
     * @param {BigNumber} b
     * @returns {BigNumber} Returns the least common multiple of a and b
     * @private
     */

    function _lcmBigNumber(a, b) {
      if (!a.isInt() || !b.isInt()) {
        throw new Error('Parameters in function lcm must be integer numbers');
      }

      if (a.isZero()) {
        return a;
      }

      if (b.isZero()) {
        return b;
      } // https://en.wikipedia.org/wiki/Euclidean_algorithm
      // evaluate lcm here inline to reduce overhead


      var prod = a.times(b);

      while (!b.isZero()) {
        var t = b;
        b = a.mod(t);
        a = t;
      }

      return prod.div(a).abs();
    }
  });

  var name$M = 'log10';
  var dependencies$N = ['typed', 'config', 'Complex'];
  var createLog10 = /* #__PURE__ */factory(name$M, dependencies$N, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        _Complex = _ref.Complex;

    /**
     * Calculate the 10-base logarithm of a value. This is the same as calculating `log(x, 10)`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.log10(x)
     *
     * Examples:
     *
     *    math.log10(0.00001)            // returns -5
     *    math.log10(10000)              // returns 4
     *    math.log(10000) / math.log(10) // returns 4
     *    math.pow(10, 4)                // returns 10000
     *
     * See also:
     *
     *    exp, log, log1p, log2
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x
     *            Value for which to calculate the logarithm.
     * @return {number | BigNumber | Complex | Array | Matrix}
     *            Returns the 10-base logarithm of `x`
     */
    return typed(name$M, {
      number: function number(x) {
        if (x >= 0 || config.predictable) {
          return log10Number(x);
        } else {
          // negative value -> complex value computation
          return new _Complex(x, 0).log().div(Math.LN10);
        }
      },
      Complex: function Complex(x) {
        return new _Complex(x).log().div(Math.LN10);
      },
      BigNumber: function BigNumber(x) {
        if (!x.isNegative() || config.predictable) {
          return x.log();
        } else {
          // downgrade to number, return Complex valued result
          return new _Complex(x.toNumber(), 0).log().div(Math.LN10);
        }
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$N = 'log2';
  var dependencies$O = ['typed', 'config', 'Complex'];
  var createLog2 = /* #__PURE__ */factory(name$N, dependencies$O, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        Complex = _ref.Complex;

    /**
     * Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.log2(x)
     *
     * Examples:
     *
     *    math.log2(0.03125)           // returns -5
     *    math.log2(16)                // returns 4
     *    math.log2(16) / math.log2(2) // returns 4
     *    math.pow(2, 4)               // returns 16
     *
     * See also:
     *
     *    exp, log, log1p, log10
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x
     *            Value for which to calculate the logarithm.
     * @return {number | BigNumber | Complex | Array | Matrix}
     *            Returns the 2-base logarithm of `x`
     */
    return typed(name$N, {
      number: function number(x) {
        if (x >= 0 || config.predictable) {
          return log2Number(x);
        } else {
          // negative value -> complex value computation
          return _log2Complex(new Complex(x, 0));
        }
      },
      Complex: _log2Complex,
      BigNumber: function BigNumber(x) {
        if (!x.isNegative() || config.predictable) {
          return x.log(2);
        } else {
          // downgrade to number, return Complex valued result
          return _log2Complex(new Complex(x.toNumber(), 0));
        }
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
    /**
     * Calculate log2 for a complex value
     * @param {Complex} x
     * @returns {Complex}
     * @private
     */

    function _log2Complex(x) {
      var newX = Math.sqrt(x.re * x.re + x.im * x.im);
      return new Complex(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);
    }
  });

  var name$O = 'algorithm03';
  var dependencies$P = ['typed'];
  var createAlgorithm03 = /* #__PURE__ */factory(name$O, dependencies$P, function (_ref) {
    var typed = _ref.typed;

    /**
     * Iterates over SparseMatrix items and invokes the callback function f(Dij, Sij).
     * Callback function invoked M*N times.
     *
     *
     *            f(Dij, Sij)  ; S(i,j) !== 0
     * C(i,j) = 
     *            f(Dij, 0)    ; otherwise
     *
     *
     * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
     * @param {Matrix}   sparseMatrix      The SparseMatrix instance (C)
     * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
     * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
     *
     * @return {Matrix}                    DenseMatrix (C)
     *
     * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
     */
    return function algorithm03(denseMatrix, sparseMatrix, callback, inverse) {
      // dense matrix arrays
      var adata = denseMatrix._data;
      var asize = denseMatrix._size;
      var adt = denseMatrix._datatype; // sparse matrix arrays

      var bvalues = sparseMatrix._values;
      var bindex = sparseMatrix._index;
      var bptr = sparseMatrix._ptr;
      var bsize = sparseMatrix._size;
      var bdt = sparseMatrix._datatype; // validate dimensions

      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      } // check rows & columns


      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
      } // sparse matrix cannot be a Pattern matrix


      if (!bvalues) {
        throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');
      } // rows & columns


      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // zero value

      var zero = 0; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string' && adt === bdt) {
        // datatype
        dt = adt; // convert 0 to the same datatype

        zero = typed.convert(0, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // result (DenseMatrix)


      var cdata = []; // initialize dense matrix

      for (var z = 0; z < rows; z++) {
        // initialize row
        cdata[z] = [];
      } // workspace


      var x = []; // marks indicating we have a value in x for a given column

      var w = []; // loop columns in b

      for (var j = 0; j < columns; j++) {
        // column mark
        var mark = j + 1; // values in column j

        for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          // row
          var i = bindex[k]; // update workspace

          x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
          w[i] = mark;
        } // process workspace


        for (var y = 0; y < rows; y++) {
          // check we have a calculated value for current row
          if (w[y] === mark) {
            // use calculated value
            cdata[y][j] = x[y];
          } else {
            // calculate value
            cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
          }
        }
      } // return dense matrix


      return denseMatrix.createDenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$P = 'algorithm05';
  var dependencies$Q = ['typed', 'equalScalar'];
  var createAlgorithm05 = /* #__PURE__ */factory(name$P, dependencies$Q, function (_ref) {
    var typed = _ref.typed,
        equalScalar = _ref.equalScalar;

    /**
     * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
     * Callback function invoked MAX(NNZA, NNZB) times
     *
     *
     *            f(Aij, Bij)  ; A(i,j) !== 0 || B(i,j) !== 0
     * C(i,j) = 
     *            0            ; otherwise
     *
     *
     * @param {Matrix}   a                 The SparseMatrix instance (A)
     * @param {Matrix}   b                 The SparseMatrix instance (B)
     * @param {Function} callback          The f(Aij,Bij) operation to invoke
     *
     * @return {Matrix}                    SparseMatrix (C)
     *
     * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
     */
    return function algorithm05(a, b, callback) {
      // sparse matrix arrays
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype; // sparse matrix arrays

      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype; // validate dimensions

      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      } // check rows & columns


      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
      } // rows & columns


      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string' && adt === bdt) {
        // datatype
        dt = adt; // find signature that matches (dt, dt)

        eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

        zero = typed.convert(0, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // result arrays


      var cvalues = avalues && bvalues ? [] : undefined;
      var cindex = [];
      var cptr = []; // workspaces

      var xa = cvalues ? [] : undefined;
      var xb = cvalues ? [] : undefined; // marks indicating we have a value in x for a given column

      var wa = [];
      var wb = []; // vars

      var i, j, k, k1; // loop columns

      for (j = 0; j < columns; j++) {
        // update cptr
        cptr[j] = cindex.length; // columns mark

        var mark = j + 1; // loop values A(:,j)

        for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
          // row
          i = aindex[k]; // push index

          cindex.push(i); // update workspace

          wa[i] = mark; // check we need to process values

          if (xa) {
            xa[i] = avalues[k];
          }
        } // loop values B(:,j)


        for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
          // row
          i = bindex[k]; // check row existed in A

          if (wa[i] !== mark) {
            // push index
            cindex.push(i);
          } // update workspace


          wb[i] = mark; // check we need to process values

          if (xb) {
            xb[i] = bvalues[k];
          }
        } // check we need to process values (non pattern matrix)


        if (cvalues) {
          // initialize first index in j
          k = cptr[j]; // loop index in j

          while (k < cindex.length) {
            // row
            i = cindex[k]; // marks

            var wai = wa[i];
            var wbi = wb[i]; // check Aij or Bij are nonzero

            if (wai === mark || wbi === mark) {
              // matrix values @ i,j
              var va = wai === mark ? xa[i] : zero;
              var vb = wbi === mark ? xb[i] : zero; // Cij

              var vc = cf(va, vb); // check for zero

              if (!eq(vc, zero)) {
                // push value
                cvalues.push(vc); // increment pointer

                k++;
              } else {
                // remove value @ i, do not increment pointer
                cindex.splice(k, 1);
              }
            }
          }
        }
      } // update cptr


      cptr[columns] = cindex.length; // return sparse matrix

      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$Q = 'algorithm12';
  var dependencies$R = ['typed', 'DenseMatrix'];
  var createAlgorithm12 = /* #__PURE__ */factory(name$Q, dependencies$R, function (_ref) {
    var typed = _ref.typed,
        DenseMatrix = _ref.DenseMatrix;

    /**
     * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
     * Callback function invoked MxN times.
     *
     *
     *            f(Sij, b)  ; S(i,j) !== 0
     * C(i,j) = 
     *            f(0, b)    ; otherwise
     *
     *
     * @param {Matrix}   s                 The SparseMatrix instance (S)
     * @param {Scalar}   b                 The Scalar value
     * @param {Function} callback          The f(Aij,b) operation to invoke
     * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
     *
     * @return {Matrix}                    DenseMatrix (C)
     *
     * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
     */
    return function algorithm12(s, b, callback, inverse) {
      // sparse matrix arrays
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype; // sparse matrix cannot be a Pattern matrix

      if (!avalues) {
        throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
      } // rows & columns


      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string') {
        // datatype
        dt = adt; // convert b to the same datatype

        b = typed.convert(b, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // result arrays


      var cdata = []; // workspaces

      var x = []; // marks indicating we have a value in x for a given column

      var w = []; // loop columns

      for (var j = 0; j < columns; j++) {
        // columns mark
        var mark = j + 1; // values in j

        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          // row
          var r = aindex[k]; // update workspace

          x[r] = avalues[k];
          w[r] = mark;
        } // loop rows


        for (var i = 0; i < rows; i++) {
          // initialize C on first column
          if (j === 0) {
            // create row array
            cdata[i] = [];
          } // check sparse matrix has a value @ i,j


          if (w[i] === mark) {
            // invoke callback, update C
            cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
          } else {
            // dense matrix value @ i, j
            cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
          }
        }
      } // return dense matrix


      return new DenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$R = 'mod';
  var dependencies$S = ['typed', 'matrix', 'equalScalar', 'DenseMatrix'];
  var createMod = /* #__PURE__ */factory(name$R, dependencies$S, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm02 = createAlgorithm02({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm03 = createAlgorithm03({
      typed: typed
    });
    var algorithm05 = createAlgorithm05({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm11 = createAlgorithm11({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm12 = createAlgorithm12({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Calculates the modulus, the remainder of an integer division.
     *
     * For matrices, the function is evaluated element wise.
     *
     * The modulus is defined as:
     *
     *     x - y * floor(x / y)
     *
     * See https://en.wikipedia.org/wiki/Modulo_operation.
     *
     * Syntax:
     *
     *    math.mod(x, y)
     *
     * Examples:
     *
     *    math.mod(8, 3)                // returns 2
     *    math.mod(11, 2)               // returns 1
     *
     *    function isOdd(x) {
     *      return math.mod(x, 2) != 0
     *    }
     *
     *    isOdd(2)                      // returns false
     *    isOdd(3)                      // returns true
     *
     * See also:
     *
     *    divide
     *
     * @param  {number | BigNumber | Fraction | Array | Matrix} x Dividend
     * @param  {number | BigNumber | Fraction | Array | Matrix} y Divisor
     * @return {number | BigNumber | Fraction | Array | Matrix} Returns the remainder of `x` divided by `y`.
     */

    return typed(name$R, {
      'number, number': modNumber,
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return y.isZero() ? x : x.mod(y);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.mod(y);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm05(x, y, this, false);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm11(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  var name$S = 'multiplyScalar';
  var dependencies$T = ['typed'];
  var createMultiplyScalar = /* #__PURE__ */factory(name$S, dependencies$T, function (_ref) {
    var typed = _ref.typed;

    /**
     * Multiply two scalar values, `x * y`.
     * This function is meant for internal use: it is used by the public function
     * `multiply`
     *
     * This function does not support collections (Array or Matrix).
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to multiply
     * @param  {number | BigNumber | Fraction | Complex} y          Second value to multiply
     * @return {number | BigNumber | Fraction | Complex | Unit}     Multiplication of `x` and `y`
     * @private
     */
    return typed('multiplyScalar', {
      'number, number': multiplyNumber,
      'Complex, Complex': function ComplexComplex(x, y) {
        return x.mul(y);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.times(y);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.mul(y);
      },
      'number | Fraction | BigNumber | Complex, Unit': function numberFractionBigNumberComplexUnit(x, y) {
        var res = y.clone();
        res.value = res.value === null ? res._normalize(x) : this(res.value, x);
        return res;
      },
      'Unit, number | Fraction | BigNumber | Complex': function UnitNumberFractionBigNumberComplex(x, y) {
        var res = x.clone();
        res.value = res.value === null ? res._normalize(y) : this(res.value, y);
        return res;
      },
      'Unit, Unit': function UnitUnit(x, y) {
        return x.multiply(y);
      }
    });
  });

  var name$T = 'multiply';
  var dependencies$U = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'equalScalar', 'dot'];
  var createMultiply = /* #__PURE__ */factory(name$T, dependencies$U, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        addScalar = _ref.addScalar,
        multiplyScalar = _ref.multiplyScalar,
        equalScalar = _ref.equalScalar,
        dot = _ref.dot;
    var algorithm11 = createAlgorithm11({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });

    function _validateMatrixDimensions(size1, size2) {
      // check left operand dimensions
      switch (size1.length) {
        case 1:
          // check size2
          switch (size2.length) {
            case 1:
              // Vector x Vector
              if (size1[0] !== size2[0]) {
                // throw error
                throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');
              }

              break;

            case 2:
              // Vector x Matrix
              if (size1[0] !== size2[0]) {
                // throw error
                throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');
              }

              break;

            default:
              throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
          }

          break;

        case 2:
          // check size2
          switch (size2.length) {
            case 1:
              // Matrix x Vector
              if (size1[1] !== size2[0]) {
                // throw error
                throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');
              }

              break;

            case 2:
              // Matrix x Matrix
              if (size1[1] !== size2[0]) {
                // throw error
                throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');
              }

              break;

            default:
              throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
          }

          break;

        default:
          throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');
      }
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            Dense Vector   (N)
     * @param {Matrix} b            Dense Vector   (N)
     *
     * @return {number}             Scalar value
     */


    function _multiplyVectorVector(a, b, n) {
      // check empty vector
      if (n === 0) {
        throw new Error('Cannot multiply two empty vectors');
      }

      return dot(a, b);
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            Dense Vector   (M)
     * @param {Matrix} b            Matrix         (MxN)
     *
     * @return {Matrix}             Dense Vector   (N)
     */


    function _multiplyVectorMatrix(a, b) {
      // process storage
      if (b.storage() !== 'dense') {
        throw new Error('Support for SparseMatrix not implemented');
      }

      return _multiplyVectorDenseMatrix(a, b);
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            Dense Vector   (M)
     * @param {Matrix} b            Dense Matrix   (MxN)
     *
     * @return {Matrix}             Dense Vector   (N)
     */


    function _multiplyVectorDenseMatrix(a, b) {
      // a dense
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype; // b dense

      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype; // rows & columns

      var alength = asize[0];
      var bcolumns = bsize[1]; // datatype

      var dt; // addScalar signature to use

      var af = addScalar; // multiplyScalar signature to use

      var mf = multiplyScalar; // process data types

      if (adt && bdt && adt === bdt && typeof adt === 'string') {
        // datatype
        dt = adt; // find signatures that matches (dt, dt)

        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
      } // result


      var c = []; // loop matrix columns

      for (var j = 0; j < bcolumns; j++) {
        // sum (do not initialize it with zero)
        var sum = mf(adata[0], bdata[0][j]); // loop vector

        for (var i = 1; i < alength; i++) {
          // multiply & accumulate
          sum = af(sum, mf(adata[i], bdata[i][j]));
        }

        c[j] = sum;
      } // return matrix


      return a.createDenseMatrix({
        data: c,
        size: [bcolumns],
        datatype: dt
      });
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            Matrix         (MxN)
     * @param {Matrix} b            Dense Vector   (N)
     *
     * @return {Matrix}             Dense Vector   (M)
     */


    var _multiplyMatrixVector = typed('_multiplyMatrixVector', {
      'DenseMatrix, any': _multiplyDenseMatrixVector,
      'SparseMatrix, any': _multiplySparseMatrixVector
    });
    /**
     * C = A * B
     *
     * @param {Matrix} a            Matrix         (MxN)
     * @param {Matrix} b            Matrix         (NxC)
     *
     * @return {Matrix}             Matrix         (MxC)
     */


    var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {
      'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,
      'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,
      'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,
      'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix
    });
    /**
     * C = A * B
     *
     * @param {Matrix} a            DenseMatrix  (MxN)
     * @param {Matrix} b            Dense Vector (N)
     *
     * @return {Matrix}             Dense Vector (M)
     */


    function _multiplyDenseMatrixVector(a, b) {
      // a dense
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype; // b dense

      var bdata = b._data;
      var bdt = b._datatype; // rows & columns

      var arows = asize[0];
      var acolumns = asize[1]; // datatype

      var dt; // addScalar signature to use

      var af = addScalar; // multiplyScalar signature to use

      var mf = multiplyScalar; // process data types

      if (adt && bdt && adt === bdt && typeof adt === 'string') {
        // datatype
        dt = adt; // find signatures that matches (dt, dt)

        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
      } // result


      var c = []; // loop matrix a rows

      for (var i = 0; i < arows; i++) {
        // current row
        var row = adata[i]; // sum (do not initialize it with zero)

        var sum = mf(row[0], bdata[0]); // loop matrix a columns

        for (var j = 1; j < acolumns; j++) {
          // multiply & accumulate
          sum = af(sum, mf(row[j], bdata[j]));
        }

        c[i] = sum;
      } // return matrix


      return a.createDenseMatrix({
        data: c,
        size: [arows],
        datatype: dt
      });
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            DenseMatrix    (MxN)
     * @param {Matrix} b            DenseMatrix    (NxC)
     *
     * @return {Matrix}             DenseMatrix    (MxC)
     */


    function _multiplyDenseMatrixDenseMatrix(a, b) {
      // a dense
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype; // b dense

      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype; // rows & columns

      var arows = asize[0];
      var acolumns = asize[1];
      var bcolumns = bsize[1]; // datatype

      var dt; // addScalar signature to use

      var af = addScalar; // multiplyScalar signature to use

      var mf = multiplyScalar; // process data types

      if (adt && bdt && adt === bdt && typeof adt === 'string') {
        // datatype
        dt = adt; // find signatures that matches (dt, dt)

        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
      } // result


      var c = []; // loop matrix a rows

      for (var i = 0; i < arows; i++) {
        // current row
        var row = adata[i]; // initialize row array

        c[i] = []; // loop matrix b columns

        for (var j = 0; j < bcolumns; j++) {
          // sum (avoid initializing sum to zero)
          var sum = mf(row[0], bdata[0][j]); // loop matrix a columns

          for (var x = 1; x < acolumns; x++) {
            // multiply & accumulate
            sum = af(sum, mf(row[x], bdata[x][j]));
          }

          c[i][j] = sum;
        }
      } // return matrix


      return a.createDenseMatrix({
        data: c,
        size: [arows, bcolumns],
        datatype: dt
      });
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            DenseMatrix    (MxN)
     * @param {Matrix} b            SparseMatrix   (NxC)
     *
     * @return {Matrix}             SparseMatrix   (MxC)
     */


    function _multiplyDenseMatrixSparseMatrix(a, b) {
      // a dense
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype; // b sparse

      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype; // validate b matrix

      if (!bvalues) {
        throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');
      } // rows & columns


      var arows = asize[0];
      var bcolumns = bsize[1]; // datatype

      var dt; // addScalar signature to use

      var af = addScalar; // multiplyScalar signature to use

      var mf = multiplyScalar; // equalScalar signature to use

      var eq = equalScalar; // zero value

      var zero = 0; // process data types

      if (adt && bdt && adt === bdt && typeof adt === 'string') {
        // datatype
        dt = adt; // find signatures that matches (dt, dt)

        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
        eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

        zero = typed.convert(0, dt);
      } // result


      var cvalues = [];
      var cindex = [];
      var cptr = []; // c matrix

      var c = b.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      }); // loop b columns

      for (var jb = 0; jb < bcolumns; jb++) {
        // update ptr
        cptr[jb] = cindex.length; // indeces in column jb

        var kb0 = bptr[jb];
        var kb1 = bptr[jb + 1]; // do not process column jb if no data exists

        if (kb1 > kb0) {
          // last row mark processed
          var last$$1 = 0; // loop a rows

          for (var i = 0; i < arows; i++) {
            // column mark
            var mark = i + 1; // C[i, jb]

            var cij = void 0; // values in b column j

            for (var kb = kb0; kb < kb1; kb++) {
              // row
              var ib = bindex[kb]; // check value has been initialized

              if (last$$1 !== mark) {
                // first value in column jb
                cij = mf(adata[i][ib], bvalues[kb]); // update mark

                last$$1 = mark;
              } else {
                // accumulate value
                cij = af(cij, mf(adata[i][ib], bvalues[kb]));
              }
            } // check column has been processed and value != 0


            if (last$$1 === mark && !eq(cij, zero)) {
              // push row & value
              cindex.push(i);
              cvalues.push(cij);
            }
          }
        }
      } // update ptr


      cptr[bcolumns] = cindex.length; // return sparse matrix

      return c;
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            SparseMatrix    (MxN)
     * @param {Matrix} b            Dense Vector (N)
     *
     * @return {Matrix}             SparseMatrix    (M, 1)
     */


    function _multiplySparseMatrixVector(a, b) {
      // a sparse
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype; // validate a matrix

      if (!avalues) {
        throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
      } // b dense


      var bdata = b._data;
      var bdt = b._datatype; // rows & columns

      var arows = a._size[0];
      var brows = b._size[0]; // result

      var cvalues = [];
      var cindex = [];
      var cptr = []; // datatype

      var dt; // addScalar signature to use

      var af = addScalar; // multiplyScalar signature to use

      var mf = multiplyScalar; // equalScalar signature to use

      var eq = equalScalar; // zero value

      var zero = 0; // process data types

      if (adt && bdt && adt === bdt && typeof adt === 'string') {
        // datatype
        dt = adt; // find signatures that matches (dt, dt)

        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
        eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

        zero = typed.convert(0, dt);
      } // workspace


      var x = []; // vector with marks indicating a value x[i] exists in a given column

      var w = []; // update ptr

      cptr[0] = 0; // rows in b

      for (var ib = 0; ib < brows; ib++) {
        // b[ib]
        var vbi = bdata[ib]; // check b[ib] != 0, avoid loops

        if (!eq(vbi, zero)) {
          // A values & index in ib column
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            // a row
            var ia = aindex[ka]; // check value exists in current j

            if (!w[ia]) {
              // ia is new entry in j
              w[ia] = true; // add i to pattern of C

              cindex.push(ia); // x(ia) = A

              x[ia] = mf(vbi, avalues[ka]);
            } else {
              // i exists in C already
              x[ia] = af(x[ia], mf(vbi, avalues[ka]));
            }
          }
        }
      } // copy values from x to column jb of c


      for (var p1 = cindex.length, p = 0; p < p1; p++) {
        // row
        var ic = cindex[p]; // copy value

        cvalues[p] = x[ic];
      } // update ptr


      cptr[1] = cindex.length; // return sparse matrix

      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, 1],
        datatype: dt
      });
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            SparseMatrix      (MxN)
     * @param {Matrix} b            DenseMatrix       (NxC)
     *
     * @return {Matrix}             SparseMatrix      (MxC)
     */


    function _multiplySparseMatrixDenseMatrix(a, b) {
      // a sparse
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype; // validate a matrix

      if (!avalues) {
        throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
      } // b dense


      var bdata = b._data;
      var bdt = b._datatype; // rows & columns

      var arows = a._size[0];
      var brows = b._size[0];
      var bcolumns = b._size[1]; // datatype

      var dt; // addScalar signature to use

      var af = addScalar; // multiplyScalar signature to use

      var mf = multiplyScalar; // equalScalar signature to use

      var eq = equalScalar; // zero value

      var zero = 0; // process data types

      if (adt && bdt && adt === bdt && typeof adt === 'string') {
        // datatype
        dt = adt; // find signatures that matches (dt, dt)

        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
        eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

        zero = typed.convert(0, dt);
      } // result


      var cvalues = [];
      var cindex = [];
      var cptr = []; // c matrix

      var c = a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      }); // workspace

      var x = []; // vector with marks indicating a value x[i] exists in a given column

      var w = []; // loop b columns

      for (var jb = 0; jb < bcolumns; jb++) {
        // update ptr
        cptr[jb] = cindex.length; // mark in workspace for current column

        var mark = jb + 1; // rows in jb

        for (var ib = 0; ib < brows; ib++) {
          // b[ib, jb]
          var vbij = bdata[ib][jb]; // check b[ib, jb] != 0, avoid loops

          if (!eq(vbij, zero)) {
            // A values & index in ib column
            for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              // a row
              var ia = aindex[ka]; // check value exists in current j

              if (w[ia] !== mark) {
                // ia is new entry in j
                w[ia] = mark; // add i to pattern of C

                cindex.push(ia); // x(ia) = A

                x[ia] = mf(vbij, avalues[ka]);
              } else {
                // i exists in C already
                x[ia] = af(x[ia], mf(vbij, avalues[ka]));
              }
            }
          }
        } // copy values from x to column jb of c


        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
          // row
          var ic = cindex[p]; // copy value

          cvalues[p] = x[ic];
        }
      } // update ptr


      cptr[bcolumns] = cindex.length; // return sparse matrix

      return c;
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            SparseMatrix      (MxN)
     * @param {Matrix} b            SparseMatrix      (NxC)
     *
     * @return {Matrix}             SparseMatrix      (MxC)
     */


    function _multiplySparseMatrixSparseMatrix(a, b) {
      // a sparse
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype; // b sparse

      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bdt = b._datatype; // rows & columns

      var arows = a._size[0];
      var bcolumns = b._size[1]; // flag indicating both matrices (a & b) contain data

      var values$$1 = avalues && bvalues; // datatype

      var dt; // addScalar signature to use

      var af = addScalar; // multiplyScalar signature to use

      var mf = multiplyScalar; // process data types

      if (adt && bdt && adt === bdt && typeof adt === 'string') {
        // datatype
        dt = adt; // find signatures that matches (dt, dt)

        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
      } // result


      var cvalues = values$$1 ? [] : undefined;
      var cindex = [];
      var cptr = []; // c matrix

      var c = a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      }); // workspace

      var x = values$$1 ? [] : undefined; // vector with marks indicating a value x[i] exists in a given column

      var w = []; // variables

      var ka, ka0, ka1, kb, kb0, kb1, ia, ib; // loop b columns

      for (var jb = 0; jb < bcolumns; jb++) {
        // update ptr
        cptr[jb] = cindex.length; // mark in workspace for current column

        var mark = jb + 1; // B values & index in j

        for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
          // b row
          ib = bindex[kb]; // check we need to process values

          if (values$$1) {
            // loop values in a[:,ib]
            for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              // row
              ia = aindex[ka]; // check value exists in current j

              if (w[ia] !== mark) {
                // ia is new entry in j
                w[ia] = mark; // add i to pattern of C

                cindex.push(ia); // x(ia) = A

                x[ia] = mf(bvalues[kb], avalues[ka]);
              } else {
                // i exists in C already
                x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
              }
            }
          } else {
            // loop values in a[:,ib]
            for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              // row
              ia = aindex[ka]; // check value exists in current j

              if (w[ia] !== mark) {
                // ia is new entry in j
                w[ia] = mark; // add i to pattern of C

                cindex.push(ia);
              }
            }
          }
        } // check we need to process matrix values (pattern matrix)


        if (values$$1) {
          // copy values from x to column jb of c
          for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
            // row
            var ic = cindex[p]; // copy value

            cvalues[p] = x[ic];
          }
        }
      } // update ptr


      cptr[bcolumns] = cindex.length; // return sparse matrix

      return c;
    }
    /**
     * Multiply two or more values, `x * y`.
     * For matrices, the matrix product is calculated.
     *
     * Syntax:
     *
     *    math.multiply(x, y)
     *    math.multiply(x, y, z, ...)
     *
     * Examples:
     *
     *    math.multiply(4, 5.2)        // returns number 20.8
     *    math.multiply(2, 3, 4)       // returns number 24
     *
     *    const a = math.complex(2, 3)
     *    const b = math.complex(4, 1)
     *    math.multiply(a, b)          // returns Complex 5 + 14i
     *
     *    const c = [[1, 2], [4, 3]]
     *    const d = [[1, 2, 3], [3, -4, 7]]
     *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]
     *
     *    const e = math.unit('2.1 km')
     *    math.multiply(3, e)          // returns Unit 6.3 km
     *
     * See also:
     *
     *    divide, prod, cross, dot
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to multiply
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply
     * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`
     */


    return typed(name$T, extend({
      // we extend the signatures of multiplyScalar with signatures dealing with matrices
      'Array, Array': function ArrayArray(x, y) {
        // check dimensions
        _validateMatrixDimensions(arraySize(x), arraySize(y)); // use dense matrix implementation


        var m = this(matrix(x), matrix(y)); // return array or scalar

        return isMatrix(m) ? m.valueOf() : m;
      },
      'Matrix, Matrix': function MatrixMatrix(x, y) {
        // dimensions
        var xsize = x.size();
        var ysize = y.size(); // check dimensions

        _validateMatrixDimensions(xsize, ysize); // process dimensions


        if (xsize.length === 1) {
          // process y dimensions
          if (ysize.length === 1) {
            // Vector * Vector
            return _multiplyVectorVector(x, y, xsize[0]);
          } // Vector * Matrix


          return _multiplyVectorMatrix(x, y);
        } // process y dimensions


        if (ysize.length === 1) {
          // Matrix * Vector
          return _multiplyMatrixVector(x, y);
        } // Matrix * Matrix


        return _multiplyMatrixMatrix(x, y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use Matrix * Matrix implementation
        return this(x, matrix(y));
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use Matrix * Matrix implementation
        return this(matrix(x, y.storage()), y);
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm11(x, y, multiplyScalar, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, multiplyScalar, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm11(y, x, multiplyScalar, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, multiplyScalar, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();
      },
      'any, any': multiplyScalar,
      'any, any, ...any': function anyAnyAny(x, y, rest) {
        var result = this(x, y);

        for (var i = 0; i < rest.length; i++) {
          result = this(result, rest[i]);
        }

        return result;
      }
    }, multiplyScalar.signatures));
  });

  var name$U = 'nthRoot';
  var dependencies$V = ['typed', 'matrix', 'equalScalar', 'BigNumber'];
  var createNthRoot = /* #__PURE__ */factory(name$U, dependencies$V, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar,
        _BigNumber = _ref.BigNumber;
    var algorithm01 = createAlgorithm01({
      typed: typed
    });
    var algorithm02 = createAlgorithm02({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm06 = createAlgorithm06({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm11 = createAlgorithm11({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Calculate the nth root of a value.
     * The principal nth root of a positive real number A, is the positive real
     * solution of the equation
     *
     *     x^root = A
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *     math.nthRoot(a)
     *     math.nthRoot(a, root)
     *
     * Examples:
     *
     *     math.nthRoot(9, 2)    // returns 3, as 3^2 == 9
     *     math.sqrt(9)          // returns 3, as 3^2 == 9
     *     math.nthRoot(64, 3)   // returns 4, as 4^3 == 64
     *
     * See also:
     *
     *     sqrt, pow
     *
     * @param {number | BigNumber | Array | Matrix | Complex} a
     *              Value for which to calculate the nth root
     * @param {number | BigNumber} [root=2]    The root.
     * @return {number | Complex | Array | Matrix} Returns the nth root of `a`
     */

    var complexErr = '' + 'Complex number not supported in function nthRoot. ' + 'Use nthRoots instead.';
    return typed(name$U, {
      number: function number(x) {
        return nthRootNumber(x, 2);
      },
      'number, number': nthRootNumber,
      BigNumber: function BigNumber(x) {
        return _bigNthRoot(x, new _BigNumber(2));
      },
      Complex: function Complex(x) {
        throw new Error(complexErr);
      },
      'Complex, number': function ComplexNumber(x, y) {
        throw new Error(complexErr);
      },
      'BigNumber, BigNumber': _bigNthRoot,
      'Array | Matrix': function ArrayMatrix(x) {
        return this(x, 2);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        // density must be one (no zeros in matrix)
        if (y.density() === 1) {
          // sparse + sparse
          return algorithm06(x, y, this);
        } else {
          // throw exception
          throw new Error('Root must be non-zero');
        }
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        // density must be one (no zeros in matrix)
        if (y.density() === 1) {
          // dense + sparse
          return algorithm01(x, y, this, false);
        } else {
          // throw exception
          throw new Error('Root must be non-zero');
        }
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, number | BigNumber': function SparseMatrixNumberBigNumber(x, y) {
        return algorithm11(x, y, this, false);
      },
      'DenseMatrix, number | BigNumber': function DenseMatrixNumberBigNumber(x, y) {
        return algorithm14(x, y, this, false);
      },
      'number | BigNumber, SparseMatrix': function numberBigNumberSparseMatrix(x, y) {
        // density must be one (no zeros in matrix)
        if (y.density() === 1) {
          // sparse - scalar
          return algorithm11(y, x, this, true);
        } else {
          // throw exception
          throw new Error('Root must be non-zero');
        }
      },
      'number | BigNumber, DenseMatrix': function numberBigNumberDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, number | BigNumber': function ArrayNumberBigNumber(x, y) {
        // use matrix implementation
        return this(matrix(x), y).valueOf();
      },
      'number | BigNumber, Array': function numberBigNumberArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y)).valueOf();
      }
    });
    /**
     * Calculate the nth root of a for BigNumbers, solve x^root == a
     * https://rosettacode.org/wiki/Nth_root#JavaScript
     * @param {BigNumber} a
     * @param {BigNumber} root
     * @private
     */

    function _bigNthRoot(a, root) {
      var precision = _BigNumber.precision;

      var Big = _BigNumber.clone({
        precision: precision + 2
      });

      var zero = new _BigNumber(0);
      var one = new Big(1);
      var inv = root.isNegative();

      if (inv) {
        root = root.neg();
      }

      if (root.isZero()) {
        throw new Error('Root must be non-zero');
      }

      if (a.isNegative() && !root.abs().mod(2).equals(1)) {
        throw new Error('Root must be odd when a is negative.');
      } // edge cases zero and infinity


      if (a.isZero()) {
        return inv ? new Big(Infinity) : 0;
      }

      if (!a.isFinite()) {
        return inv ? zero : a;
      }

      var x = a.abs().pow(one.div(root)); // If a < 0, we require that root is an odd integer,
      // so (-1) ^ (1/root) = -1

      x = a.isNeg() ? x.neg() : x;
      return new _BigNumber((inv ? one.div(x) : x).toPrecision(precision));
    }
  });
  var createNthRootNumber = /* #__PURE__ */factory(name$U, ['typed'], function (_ref2) {
    var typed = _ref2.typed;
    return typed(name$U, {
      number: nthRootNumber,
      'number, number': nthRootNumber
    });
  });

  var name$V = 'sign';
  var dependencies$W = ['typed', 'BigNumber', 'Fraction', 'complex'];
  var createSign = /* #__PURE__ */factory(name$V, dependencies$W, function (_ref) {
    var typed = _ref.typed,
        _BigNumber = _ref.BigNumber,
        complex = _ref.complex,
        _Fraction = _ref.Fraction;

    /**
     * Compute the sign of a value. The sign of a value x is:
     *
     * -  1 when x > 0
     * - -1 when x < 0
     * -  0 when x == 0
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.sign(x)
     *
     * Examples:
     *
     *    math.sign(3.5)               // returns 1
     *    math.sign(-4.2)              // returns -1
     *    math.sign(0)                 // returns 0
     *
     *    math.sign([3, 5, -2, 0, 2])  // returns [1, 1, -1, 0, 1]
     *
     * See also:
     *
     *    abs
     *
     * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
     *            The number for which to determine the sign
     * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}e
     *            The sign of `x`
     */
    return typed(name$V, {
      number: signNumber,
      Complex: function Complex(x) {
        return x.im === 0 ? complex(signNumber(x.re)) : x.sign();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(x.cmp(0));
      },
      Fraction: function Fraction(x) {
        return new _Fraction(x.s, 1);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since sign(0) = 0
        return deepMap(x, this, true);
      },
      Unit: function Unit(x) {
        return this(x.value);
      }
    });
  });

  var name$W = 'sqrt';
  var dependencies$X = ['config', 'typed', 'Complex'];
  var createSqrt = /* #__PURE__ */factory(name$W, dependencies$X, function (_ref) {
    var config = _ref.config,
        typed = _ref.typed,
        Complex = _ref.Complex;

    /**
     * Calculate the square root of a value.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.sqrt(x)
     *
     * Examples:
     *
     *    math.sqrt(25)                // returns 5
     *    math.square(5)               // returns 25
     *    math.sqrt(-4)                // returns Complex 2i
     *
     * See also:
     *
     *    square, multiply, cube, cbrt, sqrtm
     *
     * @param {number | BigNumber | Complex | Array | Matrix | Unit} x
     *            Value for which to calculate the square root.
     * @return {number | BigNumber | Complex | Array | Matrix | Unit}
     *            Returns the square root of `x`
     */
    return typed('sqrt', {
      number: _sqrtNumber,
      Complex: function Complex(x) {
        return x.sqrt();
      },
      BigNumber: function BigNumber(x) {
        if (!x.isNegative() || config.predictable) {
          return x.sqrt();
        } else {
          // negative value -> downgrade to number to do complex value computation
          return _sqrtNumber(x.toNumber());
        }
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since sqrt(0) = 0
        return deepMap(x, this, true);
      },
      Unit: function Unit(x) {
        // Someday will work for complex units when they are implemented
        return x.pow(0.5);
      }
    });
    /**
     * Calculate sqrt for a number
     * @param {number} x
     * @returns {number | Complex} Returns the square root of x
     * @private
     */

    function _sqrtNumber(x) {
      if (isNaN(x)) {
        return NaN;
      } else if (x >= 0 || config.predictable) {
        return Math.sqrt(x);
      } else {
        return new Complex(x, 0).sqrt();
      }
    }
  });

  var name$X = 'square';
  var dependencies$Y = ['typed'];
  var createSquare = /* #__PURE__ */factory(name$X, dependencies$Y, function (_ref) {
    var typed = _ref.typed;

    /**
     * Compute the square of a value, `x * x`.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.square(x)
     *
     * Examples:
     *
     *    math.square(2)           // returns number 4
     *    math.square(3)           // returns number 9
     *    math.pow(3, 2)           // returns number 9
     *    math.multiply(3, 3)      // returns number 9
     *
     *    math.square([1, 2, 3, 4])  // returns Array [1, 4, 9, 16]
     *
     * See also:
     *
     *    multiply, cube, sqrt, pow
     *
     * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
     *            Number for which to calculate the square
     * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}
     *            Squared value
     */
    return typed(name$X, {
      number: squareNumber,
      Complex: function Complex(x) {
        return x.mul(x);
      },
      BigNumber: function BigNumber(x) {
        return x.times(x);
      },
      Fraction: function Fraction(x) {
        return x.mul(x);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since square(0) = 0
        return deepMap(x, this, true);
      },
      Unit: function Unit(x) {
        return x.pow(2);
      }
    });
  });

  var name$Y = 'subtract';
  var dependencies$Z = ['typed', 'matrix', 'equalScalar', 'addScalar', 'unaryMinus', 'DenseMatrix'];
  var createSubtract = /* #__PURE__ */factory(name$Y, dependencies$Z, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar,
        addScalar = _ref.addScalar,
        unaryMinus = _ref.unaryMinus,
        DenseMatrix = _ref.DenseMatrix;
    // TODO: split function subtract in two: subtract and subtractScalar
    var algorithm01 = createAlgorithm01({
      typed: typed
    });
    var algorithm03 = createAlgorithm03({
      typed: typed
    });
    var algorithm05 = createAlgorithm05({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm10 = createAlgorithm10({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Subtract two values, `x - y`.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.subtract(x, y)
     *
     * Examples:
     *
     *    math.subtract(5.3, 2)        // returns number 3.3
     *
     *    const a = math.complex(2, 3)
     *    const b = math.complex(4, 1)
     *    math.subtract(a, b)          // returns Complex -2 + 2i
     *
     *    math.subtract([5, 7, 4], 4)  // returns Array [1, 3, 0]
     *
     *    const c = math.unit('2.1 km')
     *    const d = math.unit('500m')
     *    math.subtract(c, d)          // returns Unit 1.6 km
     *
     * See also:
     *
     *    add
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x
     *            Initial value
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y
     *            Value to subtract from `x`
     * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
     *            Subtraction of `x` and `y`
     */

    return typed(name$Y, {
      'number, number': function numberNumber(x, y) {
        return x - y;
      },
      'Complex, Complex': function ComplexComplex(x, y) {
        return x.sub(y);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.minus(y);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.sub(y);
      },
      'Unit, Unit': function UnitUnit(x, y) {
        if (x.value === null) {
          throw new Error('Parameter x contains a unit with undefined value');
        }

        if (y.value === null) {
          throw new Error('Parameter y contains a unit with undefined value');
        }

        if (!x.equalBase(y)) {
          throw new Error('Units do not match');
        }

        var res = x.clone();
        res.value = this(res.value, y.value);
        res.fixPrefix = false;
        return res;
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        checkEqualDimensions(x, y);
        return algorithm05(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        checkEqualDimensions(x, y);
        return algorithm03(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        checkEqualDimensions(x, y);
        return algorithm01(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        checkEqualDimensions(x, y);
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm10(x, unaryMinus(y), addScalar);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm10(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });
  /**
   * Check whether matrix x and y have the same number of dimensions.
   * Throws a DimensionError when dimensions are not equal
   * @param {Matrix} x
   * @param {Matrix} y
   */

  function checkEqualDimensions(x, y) {
    var xsize = x.size();
    var ysize = y.size();

    if (xsize.length !== ysize.length) {
      throw new DimensionError(xsize.length, ysize.length);
    }
  }

  var name$Z = 'xgcd';
  var dependencies$_ = ['typed', 'config', 'matrix', 'BigNumber'];
  var createXgcd = /* #__PURE__ */factory(name$Z, dependencies$_, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        matrix = _ref.matrix,
        BigNumber = _ref.BigNumber;

    /**
     * Calculate the extended greatest common divisor for two values.
     * See https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.
     *
     * Syntax:
     *
     *    math.xgcd(a, b)
     *
     * Examples:
     *
     *    math.xgcd(8, 12)             // returns [4, -1, 1]
     *    math.gcd(8, 12)              // returns 4
     *    math.xgcd(36163, 21199)      // returns [1247, -7, 12]
     *
     * See also:
     *
     *    gcd, lcm
     *
     * @param {number | BigNumber} a  An integer number
     * @param {number | BigNumber} b  An integer number
     * @return {Array}              Returns an array containing 3 integers `[div, m, n]`
     *                              where `div = gcd(a, b)` and `a*m + b*n = div`
     */
    return typed(name$Z, {
      'number, number': function numberNumber(a, b) {
        var res = xgcdNumber(a, b);
        return config.matrix === 'Array' ? res : matrix(res);
      },
      'BigNumber, BigNumber': _xgcdBigNumber // TODO: implement support for Fraction

    });
    /**
     * Calculate xgcd for two BigNumbers
     * @param {BigNumber} a
     * @param {BigNumber} b
     * @return {BigNumber[]} result
     * @private
     */

    function _xgcdBigNumber(a, b) {
      // source: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
      var // used to swap two variables
      t;
      var // quotient
      q;
      var // remainder
      r;
      var zero = new BigNumber(0);
      var one = new BigNumber(1);
      var x = zero;
      var lastx = one;
      var y = one;
      var lasty = zero;

      if (!a.isInt() || !b.isInt()) {
        throw new Error('Parameters in function xgcd must be integer numbers');
      }

      while (!b.isZero()) {
        q = a.div(b).floor();
        r = a.mod(b);
        t = x;
        x = lastx.minus(q.times(x));
        lastx = t;
        t = y;
        y = lasty.minus(q.times(y));
        lasty = t;
        a = b;
        b = r;
      }

      var res;

      if (a.lt(zero)) {
        res = [a.neg(), lastx.neg(), lasty.neg()];
      } else {
        res = [a, !a.isZero() ? lastx : 0, lasty];
      }

      return config.matrix === 'Array' ? res : matrix(res);
    }
  });

  var name$_ = 'algorithm09';
  var dependencies$10 = ['typed', 'equalScalar'];
  var createAlgorithm09 = /* #__PURE__ */factory(name$_, dependencies$10, function (_ref) {
    var typed = _ref.typed,
        equalScalar = _ref.equalScalar;

    /**
     * Iterates over SparseMatrix A and invokes the callback function f(Aij, Bij).
     * Callback function invoked NZA times, number of nonzero elements in A.
     *
     *
     *            f(Aij, Bij)  ; A(i,j) !== 0
     * C(i,j) = 
     *            0            ; otherwise
     *
     *
     * @param {Matrix}   a                 The SparseMatrix instance (A)
     * @param {Matrix}   b                 The SparseMatrix instance (B)
     * @param {Function} callback          The f(Aij,Bij) operation to invoke
     *
     * @return {Matrix}                    SparseMatrix (C)
     *
     * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
     */
    return function algorithm09(a, b, callback) {
      // sparse matrix arrays
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype; // sparse matrix arrays

      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype; // validate dimensions

      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      } // check rows & columns


      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
      } // rows & columns


      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string' && adt === bdt) {
        // datatype
        dt = adt; // find signature that matches (dt, dt)

        eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

        zero = typed.convert(0, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // result arrays


      var cvalues = avalues && bvalues ? [] : undefined;
      var cindex = [];
      var cptr = []; // workspaces

      var x = cvalues ? [] : undefined; // marks indicating we have a value in x for a given column

      var w = []; // vars

      var i, j, k, k0, k1; // loop columns

      for (j = 0; j < columns; j++) {
        // update cptr
        cptr[j] = cindex.length; // column mark

        var mark = j + 1; // check we need to process values

        if (x) {
          // loop B(:,j)
          for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
            // row
            i = bindex[k]; // update workspace

            w[i] = mark;
            x[i] = bvalues[k];
          }
        } // loop A(:,j)


        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          // row
          i = aindex[k]; // check we need to process values

          if (x) {
            // b value @ i,j
            var vb = w[i] === mark ? x[i] : zero; // invoke f

            var vc = cf(avalues[k], vb); // check zero value

            if (!eq(vc, zero)) {
              // push index
              cindex.push(i); // push value

              cvalues.push(vc);
            }
          } else {
            // push index
            cindex.push(i);
          }
        }
      } // update cptr


      cptr[columns] = cindex.length; // return sparse matrix

      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$10 = 'dotMultiply';
  var dependencies$11 = ['typed', 'matrix', 'equalScalar', 'multiplyScalar'];
  var createDotMultiply = /* #__PURE__ */factory(name$10, dependencies$11, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar,
        multiplyScalar = _ref.multiplyScalar;
    var algorithm02 = createAlgorithm02({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm09 = createAlgorithm09({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm11 = createAlgorithm11({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Multiply two matrices element wise. The function accepts both matrices and
     * scalar values.
     *
     * Syntax:
     *
     *    math.dotMultiply(x, y)
     *
     * Examples:
     *
     *    math.dotMultiply(2, 4) // returns 8
     *
     *    a = [[9, 5], [6, 1]]
     *    b = [[3, 2], [5, 2]]
     *
     *    math.dotMultiply(a, b) // returns [[27, 10], [30, 2]]
     *    math.multiply(a, b)    // returns [[52, 28], [23, 14]]
     *
     * See also:
     *
     *    multiply, divide, dotDivide
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Left hand value
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Right hand value
     * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Multiplication of `x` and `y`
     */

    return typed(name$10, {
      'any, any': multiplyScalar,
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm09(x, y, multiplyScalar, false);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, multiplyScalar, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm02(x, y, multiplyScalar, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, multiplyScalar);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm11(x, y, multiplyScalar, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, multiplyScalar, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm11(y, x, multiplyScalar, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, multiplyScalar, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();
      }
    });
  });

  /**
   * Bitwise and for Bignumbers
   *
   * Special Cases:
   *   N &  n =  N
   *   n &  0 =  0
   *   n & -1 =  n
   *   n &  n =  n
   *   I &  I =  I
   *  -I & -I = -I
   *   I & -I =  0
   *   I &  n =  n
   *   I & -n =  I
   *  -I &  n =  0
   *  -I & -n = -I
   *
   * @param {BigNumber} x
   * @param {BigNumber} y
   * @return {BigNumber} Result of `x` & `y`, is fully precise
   * @private
   */
  function bitAndBigNumber(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
      throw new Error('Integers expected in function bitAnd');
    }

    var BigNumber = x.constructor;

    if (x.isNaN() || y.isNaN()) {
      return new BigNumber(NaN);
    }

    if (x.isZero() || y.eq(-1) || x.eq(y)) {
      return x;
    }

    if (y.isZero() || x.eq(-1)) {
      return y;
    }

    if (!x.isFinite() || !y.isFinite()) {
      if (!x.isFinite() && !y.isFinite()) {
        if (x.isNegative() === y.isNegative()) {
          return x;
        }

        return new BigNumber(0);
      }

      if (!x.isFinite()) {
        if (y.isNegative()) {
          return x;
        }

        if (x.isNegative()) {
          return new BigNumber(0);
        }

        return y;
      }

      if (!y.isFinite()) {
        if (x.isNegative()) {
          return y;
        }

        if (y.isNegative()) {
          return new BigNumber(0);
        }

        return x;
      }
    }

    return bitwise(x, y, function (a, b) {
      return a & b;
    });
  }
  /**
   * Bitwise not
   * @param {BigNumber} x
   * @return {BigNumber} Result of ~`x`, fully precise
   *
   */

  function bitNotBigNumber(x) {
    if (x.isFinite() && !x.isInteger()) {
      throw new Error('Integer expected in function bitNot');
    }

    var BigNumber = x.constructor;
    var prevPrec = BigNumber.precision;
    BigNumber.config({
      precision: 1E9
    });
    var result = x.plus(new BigNumber(1));
    result.s = -result.s || null;
    BigNumber.config({
      precision: prevPrec
    });
    return result;
  }
  /**
   * Bitwise OR for BigNumbers
   *
   * Special Cases:
   *   N |  n =  N
   *   n |  0 =  n
   *   n | -1 = -1
   *   n |  n =  n
   *   I |  I =  I
   *  -I | -I = -I
   *   I | -n = -1
   *   I | -I = -1
   *   I |  n =  I
   *  -I |  n = -I
   *  -I | -n = -n
   *
   * @param {BigNumber} x
   * @param {BigNumber} y
   * @return {BigNumber} Result of `x` | `y`, fully precise
   */

  function bitOrBigNumber(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
      throw new Error('Integers expected in function bitOr');
    }

    var BigNumber = x.constructor;

    if (x.isNaN() || y.isNaN()) {
      return new BigNumber(NaN);
    }

    var negOne = new BigNumber(-1);

    if (x.isZero() || y.eq(negOne) || x.eq(y)) {
      return y;
    }

    if (y.isZero() || x.eq(negOne)) {
      return x;
    }

    if (!x.isFinite() || !y.isFinite()) {
      if (!x.isFinite() && !x.isNegative() && y.isNegative() || x.isNegative() && !y.isNegative() && !y.isFinite()) {
        return negOne;
      }

      if (x.isNegative() && y.isNegative()) {
        return x.isFinite() ? x : y;
      }

      return x.isFinite() ? y : x;
    }

    return bitwise(x, y, function (a, b) {
      return a | b;
    });
  }
  /**
   * Applies bitwise function to numbers
   * @param {BigNumber} x
   * @param {BigNumber} y
   * @param {function (a, b)} func
   * @return {BigNumber}
   */

  function bitwise(x, y, func) {
    var BigNumber = x.constructor;
    var xBits, yBits;
    var xSign = +(x.s < 0);
    var ySign = +(y.s < 0);

    if (xSign) {
      xBits = decCoefficientToBinaryString(bitNotBigNumber(x));

      for (var i = 0; i < xBits.length; ++i) {
        xBits[i] ^= 1;
      }
    } else {
      xBits = decCoefficientToBinaryString(x);
    }

    if (ySign) {
      yBits = decCoefficientToBinaryString(bitNotBigNumber(y));

      for (var _i = 0; _i < yBits.length; ++_i) {
        yBits[_i] ^= 1;
      }
    } else {
      yBits = decCoefficientToBinaryString(y);
    }

    var minBits, maxBits, minSign;

    if (xBits.length <= yBits.length) {
      minBits = xBits;
      maxBits = yBits;
      minSign = xSign;
    } else {
      minBits = yBits;
      maxBits = xBits;
      minSign = ySign;
    }

    var shortLen = minBits.length;
    var longLen = maxBits.length;
    var expFuncVal = func(xSign, ySign) ^ 1;
    var outVal = new BigNumber(expFuncVal ^ 1);
    var twoPower = new BigNumber(1);
    var two = new BigNumber(2);
    var prevPrec = BigNumber.precision;
    BigNumber.config({
      precision: 1E9
    });

    while (shortLen > 0) {
      if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
        outVal = outVal.plus(twoPower);
      }

      twoPower = twoPower.times(two);
    }

    while (longLen > 0) {
      if (func(minSign, maxBits[--longLen]) === expFuncVal) {
        outVal = outVal.plus(twoPower);
      }

      twoPower = twoPower.times(two);
    }

    BigNumber.config({
      precision: prevPrec
    });

    if (expFuncVal === 0) {
      outVal.s = -outVal.s;
    }

    return outVal;
  }
  /* Extracted from decimal.js, and edited to specialize. */

  function decCoefficientToBinaryString(x) {
    // Convert to string
    var a = x.d; // array with digits

    var r = a[0] + '';

    for (var i = 1; i < a.length; ++i) {
      var s = a[i] + '';

      for (var z = 7 - s.length; z--;) {
        s = '0' + s;
      }

      r += s;
    }

    var j = r.length;

    while (r.charAt(j) === '0') {
      j--;
    }

    var xe = x.e;
    var str = r.slice(0, j + 1 || 1);
    var strL = str.length;

    if (xe > 0) {
      if (++xe > strL) {
        // Append zeros.
        xe -= strL;

        while (xe--) {
          str += '0';
        }
      } else if (xe < strL) {
        str = str.slice(0, xe) + '.' + str.slice(xe);
      }
    } // Convert from base 10 (decimal) to base 2


    var arr = [0];

    for (var _i2 = 0; _i2 < str.length;) {
      var arrL = arr.length;

      while (arrL--) {
        arr[arrL] *= 10;
      }

      arr[0] += parseInt(str.charAt(_i2++)); // convert to int

      for (var _j = 0; _j < arr.length; ++_j) {
        if (arr[_j] > 1) {
          if (arr[_j + 1] === null || arr[_j + 1] === undefined) {
            arr[_j + 1] = 0;
          }

          arr[_j + 1] += arr[_j] >> 1;
          arr[_j] &= 1;
        }
      }
    }

    return arr.reverse();
  }
  /**
   * Bitwise XOR for BigNumbers
   *
   * Special Cases:
   *   N ^  n =  N
   *   n ^  0 =  n
   *   n ^  n =  0
   *   n ^ -1 = ~n
   *   I ^  n =  I
   *   I ^ -n = -I
   *   I ^ -I = -1
   *  -I ^  n = -I
   *  -I ^ -n =  I
   *
   * @param {BigNumber} x
   * @param {BigNumber} y
   * @return {BigNumber} Result of `x` ^ `y`, fully precise
   *
   */


  function bitXor(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
      throw new Error('Integers expected in function bitXor');
    }

    var BigNumber = x.constructor;

    if (x.isNaN() || y.isNaN()) {
      return new BigNumber(NaN);
    }

    if (x.isZero()) {
      return y;
    }

    if (y.isZero()) {
      return x;
    }

    if (x.eq(y)) {
      return new BigNumber(0);
    }

    var negOne = new BigNumber(-1);

    if (x.eq(negOne)) {
      return bitNotBigNumber(y);
    }

    if (y.eq(negOne)) {
      return bitNotBigNumber(x);
    }

    if (!x.isFinite() || !y.isFinite()) {
      if (!x.isFinite() && !y.isFinite()) {
        return negOne;
      }

      return new BigNumber(x.isNegative() === y.isNegative() ? Infinity : -Infinity);
    }

    return bitwise(x, y, function (a, b) {
      return a ^ b;
    });
  }
  /**
   * Bitwise left shift
   *
   * Special Cases:
   *  n << -n = N
   *  n <<  N = N
   *  N <<  n = N
   *  n <<  0 = n
   *  0 <<  n = 0
   *  I <<  I = N
   *  I <<  n = I
   *  n <<  I = I
   *
   * @param {BigNumber} x
   * @param {BigNumber} y
   * @return {BigNumber} Result of `x` << `y`
   *
   */

  function leftShiftBigNumber(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
      throw new Error('Integers expected in function leftShift');
    }

    var BigNumber = x.constructor;

    if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
      return new BigNumber(NaN);
    }

    if (x.isZero() || y.isZero()) {
      return x;
    }

    if (!x.isFinite() && !y.isFinite()) {
      return new BigNumber(NaN);
    } // Math.pow(2, y) is fully precise for y < 55, and fast


    if (y.lt(55)) {
      return x.times(Math.pow(2, y.toNumber()) + '');
    }

    return x.times(new BigNumber(2).pow(y));
  }
  /*
   * Special Cases:
   *   n >> -n =  N
   *   n >>  N =  N
   *   N >>  n =  N
   *   I >>  I =  N
   *   n >>  0 =  n
   *   I >>  n =  I
   *  -I >>  n = -I
   *  -I >>  I = -I
   *   n >>  I =  I
   *  -n >>  I = -1
   *   0 >>  n =  0
   *
   * @param {BigNumber} value
   * @param {BigNumber} value
   * @return {BigNumber} Result of `x` >> `y`
   *
   */

  function rightArithShiftBigNumber(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
      throw new Error('Integers expected in function rightArithShift');
    }

    var BigNumber = x.constructor;

    if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
      return new BigNumber(NaN);
    }

    if (x.isZero() || y.isZero()) {
      return x;
    }

    if (!y.isFinite()) {
      if (x.isNegative()) {
        return new BigNumber(-1);
      }

      if (!x.isFinite()) {
        return new BigNumber(NaN);
      }

      return new BigNumber(0);
    } // Math.pow(2, y) is fully precise for y < 55, and fast


    if (y.lt(55)) {
      return x.div(Math.pow(2, y.toNumber()) + '').floor();
    }

    return x.div(new BigNumber(2).pow(y)).floor();
  }

  var name$11 = 'bitAnd';
  var dependencies$12 = ['typed', 'matrix', 'equalScalar'];
  var createBitAnd = /* #__PURE__ */factory(name$11, dependencies$12, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar;
    var algorithm02 = createAlgorithm02({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm06 = createAlgorithm06({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm11 = createAlgorithm11({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Bitwise AND two values, `x & y`.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.bitAnd(x, y)
     *
     * Examples:
     *
     *    math.bitAnd(53, 131)               // returns number 1
     *
     *    math.bitAnd([1, 12, 31], 42)       // returns Array [0, 8, 10]
     *
     * See also:
     *
     *    bitNot, bitOr, bitXor, leftShift, rightArithShift, rightLogShift
     *
     * @param  {number | BigNumber | Array | Matrix} x First value to and
     * @param  {number | BigNumber | Array | Matrix} y Second value to and
     * @return {number | BigNumber | Array | Matrix} AND of `x` and `y`
     */

    return typed(name$11, {
      'number, number': bitAndNumber,
      'BigNumber, BigNumber': bitAndBigNumber,
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm06(x, y, this, false);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm02(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm11(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm11(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  var name$12 = 'bitNot';
  var dependencies$13 = ['typed'];
  var createBitNot = /* #__PURE__ */factory(name$12, dependencies$13, function (_ref) {
    var typed = _ref.typed;

    /**
     * Bitwise NOT value, `~x`.
     * For matrices, the function is evaluated element wise.
     * For units, the function is evaluated on the best prefix base.
     *
     * Syntax:
     *
     *    math.bitNot(x)
     *
     * Examples:
     *
     *    math.bitNot(1)               // returns number -2
     *
     *    math.bitNot([2, -3, 4])      // returns Array [-3, 2, 5]
     *
     * See also:
     *
     *    bitAnd, bitOr, bitXor, leftShift, rightArithShift, rightLogShift
     *
     * @param  {number | BigNumber | Array | Matrix} x Value to not
     * @return {number | BigNumber | Array | Matrix} NOT of `x`
     */
    return typed(name$12, {
      number: bitNotNumber,
      BigNumber: bitNotBigNumber,
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$13 = 'bitOr';
  var dependencies$14 = ['typed', 'matrix', 'equalScalar', 'DenseMatrix'];
  var createBitOr = /* #__PURE__ */factory(name$13, dependencies$14, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm01 = createAlgorithm01({
      typed: typed
    });
    var algorithm04 = createAlgorithm04({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm10 = createAlgorithm10({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Bitwise OR two values, `x | y`.
     * For matrices, the function is evaluated element wise.
     * For units, the function is evaluated on the lowest print base.
     *
     * Syntax:
     *
     *    math.bitOr(x, y)
     *
     * Examples:
     *
     *    math.bitOr(1, 2)               // returns number 3
     *
     *    math.bitOr([1, 2, 3], 4)       // returns Array [5, 6, 7]
     *
     * See also:
     *
     *    bitAnd, bitNot, bitXor, leftShift, rightArithShift, rightLogShift
     *
     * @param  {number | BigNumber | Array | Matrix} x First value to or
     * @param  {number | BigNumber | Array | Matrix} y Second value to or
     * @return {number | BigNumber | Array | Matrix} OR of `x` and `y`
     */

    return typed(name$13, {
      'number, number': bitOrNumber,
      'BigNumber, BigNumber': bitOrBigNumber,
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm04(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm01(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm01(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm10(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm10(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  var name$14 = 'algorithm07';
  var dependencies$15 = ['typed', 'DenseMatrix'];
  var createAlgorithm07 = /* #__PURE__ */factory(name$14, dependencies$15, function (_ref) {
    var typed = _ref.typed,
        DenseMatrix = _ref.DenseMatrix;

    /**
     * Iterates over SparseMatrix A and SparseMatrix B items (zero and nonzero) and invokes the callback function f(Aij, Bij).
     * Callback function invoked MxN times.
     *
     * C(i,j) = f(Aij, Bij)
     *
     * @param {Matrix}   a                 The SparseMatrix instance (A)
     * @param {Matrix}   b                 The SparseMatrix instance (B)
     * @param {Function} callback          The f(Aij,Bij) operation to invoke
     *
     * @return {Matrix}                    DenseMatrix (C)
     *
     * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
     */
    return function algorithm07(a, b, callback) {
      // sparse matrix arrays
      var asize = a._size;
      var adt = a._datatype; // sparse matrix arrays

      var bsize = b._size;
      var bdt = b._datatype; // validate dimensions

      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      } // check rows & columns


      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
      } // rows & columns


      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // zero value

      var zero = 0; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string' && adt === bdt) {
        // datatype
        dt = adt; // convert 0 to the same datatype

        zero = typed.convert(0, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // vars


      var i, j; // result arrays

      var cdata = []; // initialize c

      for (i = 0; i < rows; i++) {
        cdata[i] = [];
      } // workspaces


      var xa = [];
      var xb = []; // marks indicating we have a value in x for a given column

      var wa = [];
      var wb = []; // loop columns

      for (j = 0; j < columns; j++) {
        // columns mark
        var mark = j + 1; // scatter the values of A(:,j) into workspace

        _scatter(a, j, wa, xa, mark); // scatter the values of B(:,j) into workspace


        _scatter(b, j, wb, xb, mark); // loop rows


        for (i = 0; i < rows; i++) {
          // matrix values @ i,j
          var va = wa[i] === mark ? xa[i] : zero;
          var vb = wb[i] === mark ? xb[i] : zero; // invoke callback

          cdata[i][j] = cf(va, vb);
        }
      } // return dense matrix


      return new DenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };

    function _scatter(m, j, w, x, mark) {
      // a arrays
      var values = m._values;
      var index = m._index;
      var ptr = m._ptr; // loop values in column j

      for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
        // row
        var i = index[k]; // update workspace

        w[i] = mark;
        x[i] = values[k];
      }
    }
  });

  var name$15 = 'bitXor';
  var dependencies$16 = ['typed', 'matrix', 'DenseMatrix'];
  var createBitXor = /* #__PURE__ */factory(name$15, dependencies$16, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm03 = createAlgorithm03({
      typed: typed
    });
    var algorithm07 = createAlgorithm07({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Bitwise XOR two values, `x ^ y`.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.bitXor(x, y)
     *
     * Examples:
     *
     *    math.bitXor(1, 2)               // returns number 3
     *
     *    math.bitXor([2, 3, 4], 4)       // returns Array [6, 7, 0]
     *
     * See also:
     *
     *    bitAnd, bitNot, bitOr, leftShift, rightArithShift, rightLogShift
     *
     * @param  {number | BigNumber | Array | Matrix} x First value to xor
     * @param  {number | BigNumber | Array | Matrix} y Second value to xor
     * @return {number | BigNumber | Array | Matrix} XOR of `x` and `y`
     */

    return typed(name$15, {
      'number, number': bitXorNumber,
      'BigNumber, BigNumber': bitXor,
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  var name$16 = 'arg';
  var dependencies$17 = ['typed'];
  var createArg = /* #__PURE__ */factory(name$16, dependencies$17, function (_ref) {
    var typed = _ref.typed;

    /**
     * Compute the argument of a complex value.
     * For a complex number `a + bi`, the argument is computed as `atan2(b, a)`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.arg(x)
     *
     * Examples:
     *
     *    const a = math.complex(2, 2)
     *    math.arg(a) / math.pi          // returns number 0.25
     *
     *    const b = math.complex('2 + 3i')
     *    math.arg(b)                    // returns number 0.982793723247329
     *    math.atan2(3, 2)               // returns number 0.982793723247329
     *
     * See also:
     *
     *    re, im, conj, abs
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x
     *            A complex number or array with complex numbers
     * @return {number | BigNumber | Array | Matrix} The argument of x
     */
    return typed(name$16, {
      number: function number(x) {
        return Math.atan2(0, x);
      },
      BigNumber: function BigNumber(x) {
        return x.constructor.atan2(0, x);
      },
      Complex: function Complex(x) {
        return x.arg();
      },
      // TODO: implement BigNumber support for function arg
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$17 = 'conj';
  var dependencies$18 = ['typed'];
  var createConj = /* #__PURE__ */factory(name$17, dependencies$18, function (_ref) {
    var typed = _ref.typed;

    /**
     * Compute the complex conjugate of a complex value.
     * If `x = a+bi`, the complex conjugate of `x` is `a - bi`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.conj(x)
     *
     * Examples:
     *
     *    math.conj(math.complex('2 + 3i'))  // returns Complex 2 - 3i
     *    math.conj(math.complex('2 - 3i'))  // returns Complex 2 + 3i
     *    math.conj(math.complex('-5.2i'))  // returns Complex 5.2i
     *
     * See also:
     *
     *    re, im, arg, abs
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x
     *            A complex number or array with complex numbers
     * @return {number | BigNumber | Complex | Array | Matrix}
     *            The complex conjugate of x
     */
    return typed(name$17, {
      number: function number(x) {
        return x;
      },
      BigNumber: function BigNumber(x) {
        return x;
      },
      Complex: function Complex(x) {
        return x.conjugate();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$18 = 'im';
  var dependencies$19 = ['typed'];
  var createIm = /* #__PURE__ */factory(name$18, dependencies$19, function (_ref) {
    var typed = _ref.typed;

    /**
     * Get the imaginary part of a complex number.
     * For a complex number `a + bi`, the function returns `b`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.im(x)
     *
     * Examples:
     *
     *    const a = math.complex(2, 3)
     *    math.re(a)                     // returns number 2
     *    math.im(a)                     // returns number 3
     *
     *    math.re(math.complex('-5.2i')) // returns number -5.2
     *    math.re(math.complex(2.4))     // returns number 0
     *
     * See also:
     *
     *    re, conj, abs, arg
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x
     *            A complex number or array with complex numbers
     * @return {number | BigNumber | Array | Matrix} The imaginary part of x
     */
    return typed(name$18, {
      number: function number(x) {
        return 0;
      },
      BigNumber: function BigNumber(x) {
        return x.mul(0);
      },
      Complex: function Complex(x) {
        return x.im;
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$19 = 're';
  var dependencies$1a = ['typed'];
  var createRe = /* #__PURE__ */factory(name$19, dependencies$1a, function (_ref) {
    var typed = _ref.typed;

    /**
     * Get the real part of a complex number.
     * For a complex number `a + bi`, the function returns `a`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.re(x)
     *
     * Examples:
     *
     *    const a = math.complex(2, 3)
     *    math.re(a)                     // returns number 2
     *    math.im(a)                     // returns number 3
     *
     *    math.re(math.complex('-5.2i')) // returns number 0
     *    math.re(math.complex(2.4))     // returns number 2.4
     *
     * See also:
     *
     *    im, conj, abs, arg
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x
     *            A complex number or array with complex numbers
     * @return {number | BigNumber | Array | Matrix} The real part of x
     */
    return typed(name$19, {
      number: function number(x) {
        return x;
      },
      BigNumber: function BigNumber(x) {
        return x;
      },
      Complex: function Complex(x) {
        return x.re;
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$1a = 'not';
  var dependencies$1b = ['typed'];
  var createNot = /* #__PURE__ */factory(name$1a, dependencies$1b, function (_ref) {
    var typed = _ref.typed;

    /**
     * Logical `not`. Flips boolean value of a given parameter.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.not(x)
     *
     * Examples:
     *
     *    math.not(2)      // returns false
     *    math.not(0)      // returns true
     *    math.not(true)   // returns false
     *
     *    a = [2, -7, 0]
     *    math.not(a)      // returns [false, false, true]
     *
     * See also:
     *
     *    and, or, xor
     *
     * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
     * @return {boolean | Array | Matrix}
     *            Returns true when input is a zero or empty value.
     */
    return typed(name$1a, {
      number: notNumber,
      Complex: function Complex(x) {
        return x.re === 0 && x.im === 0;
      },
      BigNumber: function BigNumber(x) {
        return x.isZero() || x.isNaN();
      },
      Unit: function Unit(x) {
        return x.value !== null ? this(x.value) : true;
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$1b = 'or';
  var dependencies$1c = ['typed', 'matrix', 'equalScalar', 'DenseMatrix'];
  var createOr = /* #__PURE__ */factory(name$1b, dependencies$1c, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm03 = createAlgorithm03({
      typed: typed
    });
    var algorithm05 = createAlgorithm05({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm12 = createAlgorithm12({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Logical `or`. Test if at least one value is defined with a nonzero/nonempty value.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.or(x, y)
     *
     * Examples:
     *
     *    math.or(2, 4)   // returns true
     *
     *    a = [2, 5, 0]
     *    b = [0, 22, 0]
     *    c = 0
     *
     *    math.or(a, b)   // returns [true, true, false]
     *    math.or(b, c)   // returns [false, true, false]
     *
     * See also:
     *
     *    and, not, xor
     *
     * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
     * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y Second value to check
     * @return {boolean | Array | Matrix}
     *            Returns true when one of the inputs is defined with a nonzero/nonempty value.
     */

    return typed(name$1b, {
      'number, number': orNumber,
      'Complex, Complex': function ComplexComplex(x, y) {
        return x.re !== 0 || x.im !== 0 || y.re !== 0 || y.im !== 0;
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return !x.isZero() && !x.isNaN() || !y.isZero() && !y.isNaN();
      },
      'Unit, Unit': function UnitUnit(x, y) {
        return this(x.value || 0, y.value || 0);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm05(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  var name$1c = 'xor';
  var dependencies$1d = ['typed', 'matrix', 'DenseMatrix'];
  var createXor = /* #__PURE__ */factory(name$1c, dependencies$1d, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm03 = createAlgorithm03({
      typed: typed
    });
    var algorithm07 = createAlgorithm07({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Logical `xor`. Test whether one and only one value is defined with a nonzero/nonempty value.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.xor(x, y)
     *
     * Examples:
     *
     *    math.xor(2, 4)   // returns false
     *
     *    a = [2, 0, 0]
     *    b = [2, 7, 0]
     *    c = 0
     *
     *    math.xor(a, b)   // returns [false, true, false]
     *    math.xor(a, c)   // returns [true, false, false]
     *
     * See also:
     *
     *    and, not, or
     *
     * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
     * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y Second value to check
     * @return {boolean | Array | Matrix}
     *            Returns true when one and only one input is defined with a nonzero/nonempty value.
     */

    return typed(name$1c, {
      'number, number': xorNumber,
      'Complex, Complex': function ComplexComplex(x, y) {
        return (x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return (!x.isZero() && !x.isNaN()) !== (!y.isZero() && !y.isNaN());
      },
      'Unit, Unit': function UnitUnit(x, y) {
        return this(x.value || 0, y.value || 0);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  var name$1d = 'concat';
  var dependencies$1e = ['typed', 'matrix', 'isInteger'];
  var createConcat = /* #__PURE__ */factory(name$1d, dependencies$1e, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        isInteger = _ref.isInteger;

    /**
     * Concatenate two or more matrices.
     *
     * Syntax:
     *
     *     math.concat(A, B, C, ...)
     *     math.concat(A, B, C, ..., dim)
     *
     * Where:
     *
     * - `dim: number` is a zero-based dimension over which to concatenate the matrices.
     *   By default the last dimension of the matrices.
     *
     * Examples:
     *
     *    const A = [[1, 2], [5, 6]]
     *    const B = [[3, 4], [7, 8]]
     *
     *    math.concat(A, B)                  // returns [[1, 2, 3, 4], [5, 6, 7, 8]]
     *    math.concat(A, B, 0)               // returns [[1, 2], [5, 6], [3, 4], [7, 8]]
     *    math.concat('hello', ' ', 'world') // returns 'hello world'
     *
     * See also:
     *
     *    size, squeeze, subset, transpose
     *
     * @param {... Array | Matrix} args     Two or more matrices
     * @return {Array | Matrix} Concatenated matrix
     */
    return typed(name$1d, {
      // TODO: change signature to '...Array | Matrix, dim?' when supported
      '...Array | Matrix | number | BigNumber': function ArrayMatrixNumberBigNumber(args) {
        var i;
        var len = args.length;
        var dim = -1; // zero-based dimension

        var prevDim;
        var asMatrix = false;
        var matrices = []; // contains multi dimensional arrays

        for (i = 0; i < len; i++) {
          var arg = args[i]; // test whether we need to return a Matrix (if not we return an Array)

          if (isMatrix(arg)) {
            asMatrix = true;
          }

          if (isNumber(arg) || isBigNumber(arg)) {
            if (i !== len - 1) {
              throw new Error('Dimension must be specified as last argument');
            } // last argument contains the dimension on which to concatenate


            prevDim = dim;
            dim = arg.valueOf(); // change BigNumber to number

            if (!isInteger(dim)) {
              throw new TypeError('Integer number expected for dimension');
            }

            if (dim < 0 || i > 0 && dim > prevDim) {
              // TODO: would be more clear when throwing a DimensionError here
              throw new IndexError(dim, prevDim + 1);
            }
          } else {
            // this is a matrix or array
            var m = clone(arg).valueOf();
            var size = arraySize(m);
            matrices[i] = m;
            prevDim = dim;
            dim = size.length - 1; // verify whether each of the matrices has the same number of dimensions

            if (i > 0 && dim !== prevDim) {
              throw new DimensionError(prevDim + 1, dim + 1);
            }
          }
        }

        if (matrices.length === 0) {
          throw new SyntaxError('At least one matrix expected');
        }

        var res = matrices.shift();

        while (matrices.length) {
          res = _concat(res, matrices.shift(), dim, 0);
        }

        return asMatrix ? matrix(res) : res;
      },
      '...string': function string(args) {
        return args.join('');
      }
    });
  });
  /**
   * Recursively concatenate two matrices.
   * The contents of the matrices is not cloned.
   * @param {Array} a             Multi dimensional array
   * @param {Array} b             Multi dimensional array
   * @param {number} concatDim    The dimension on which to concatenate (zero-based)
   * @param {number} dim          The current dim (zero-based)
   * @return {Array} c            The concatenated matrix
   * @private
   */

  function _concat(a, b, concatDim, dim) {
    if (dim < concatDim) {
      // recurse into next dimension
      if (a.length !== b.length) {
        throw new DimensionError(a.length, b.length);
      }

      var c = [];

      for (var i = 0; i < a.length; i++) {
        c[i] = _concat(a[i], b[i], concatDim, dim + 1);
      }

      return c;
    } else {
      // concatenate this dimension
      return a.concat(b);
    }
  }

  var name$1e = 'column';
  var dependencies$1f = ['typed', 'Index', 'matrix', 'range'];
  var createColumn = /* #__PURE__ */factory(name$1e, dependencies$1f, function (_ref) {
    var typed = _ref.typed,
        Index = _ref.Index,
        matrix = _ref.matrix,
        range = _ref.range;

    /**
     * Return a column from a Matrix.
     *
     * Syntax:
     *
     *     math.column(value, index)
     *
     * Example:
     *
     *     // get a column
     *     const d = [[1, 2], [3, 4]]
     *     math.column(d, 1) // returns [[2], [4]]
     *
     * See also:
     *
     *     row
     *
     * @param {Array | Matrix } value   An array or matrix
     * @param {number} column           The index of the column
     * @return {Array | Matrix}         The retrieved column
     */
    return typed(name$1e, {
      'Matrix, number': _column,
      'Array, number': function ArrayNumber(value, column) {
        return _column(matrix(clone(value)), column).valueOf();
      }
    });
    /**
     * Retrieve a column of a matrix
     * @param {Matrix } value  A matrix
     * @param {number} column  The index of the column
     * @return {Matrix}        The retrieved column
     */

    function _column(value, column) {
      // check dimensions
      if (value.size().length !== 2) {
        throw new Error('Only two dimensional matrix is supported');
      }

      validateIndex(column, value.size()[1]);
      var rowRange = range(0, value.size()[0]);
      var index = new Index(rowRange, column);
      return value.subset(index);
    }
  });

  var name$1f = 'cross';
  var dependencies$1g = ['typed', 'matrix', 'subtract', 'multiply'];
  var createCross = /* #__PURE__ */factory(name$1f, dependencies$1g, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        subtract = _ref.subtract,
        multiply = _ref.multiply;

    /**
     * Calculate the cross product for two vectors in three dimensional space.
     * The cross product of `A = [a1, a2, a3]` and `B = [b1, b2, b3]` is defined
     * as:
     *
     *    cross(A, B) = [
     *      a2 * b3 - a3 * b2,
     *      a3 * b1 - a1 * b3,
     *      a1 * b2 - a2 * b1
     *    ]
     *
     * If one of the input vectors has a dimension greater than 1, the output
     * vector will be a 1x3 (2-dimensional) matrix.
     *
     * Syntax:
     *
     *    math.cross(x, y)
     *
     * Examples:
     *
     *    math.cross([1, 1, 0],   [0, 1, 1])       // Returns [1, -1, 1]
     *    math.cross([3, -3, 1],  [4, 9, 2])       // Returns [-15, -2, 39]
     *    math.cross([2, 3, 4],   [5, 6, 7])       // Returns [-3, 6, -3]
     *    math.cross([[1, 2, 3]], [[4], [5], [6]]) // Returns [[-3, 6, -3]]
     *
     * See also:
     *
     *    dot, multiply
     *
     * @param  {Array | Matrix} x   First vector
     * @param  {Array | Matrix} y   Second vector
     * @return {Array | Matrix}     Returns the cross product of `x` and `y`
     */
    return typed(name$1f, {
      'Matrix, Matrix': function MatrixMatrix(x, y) {
        return matrix(_cross(x.toArray(), y.toArray()));
      },
      'Matrix, Array': function MatrixArray(x, y) {
        return matrix(_cross(x.toArray(), y));
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        return matrix(_cross(x, y.toArray()));
      },
      'Array, Array': _cross
    });
    /**
     * Calculate the cross product for two arrays
     * @param {Array} x  First vector
     * @param {Array} y  Second vector
     * @returns {Array} Returns the cross product of x and y
     * @private
     */

    function _cross(x, y) {
      var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);
      x = squeeze(x);
      y = squeeze(y);
      var xSize = arraySize(x);
      var ySize = arraySize(y);

      if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
        throw new RangeError('Vectors with length 3 expected ' + '(Size A = [' + xSize.join(', ') + '], B = [' + ySize.join(', ') + '])');
      }

      var product = [subtract(multiply(x[1], y[2]), multiply(x[2], y[1])), subtract(multiply(x[2], y[0]), multiply(x[0], y[2])), subtract(multiply(x[0], y[1]), multiply(x[1], y[0]))];

      if (highestDimension > 1) {
        return [product];
      } else {
        return product;
      }
    }
  });

  var name$1g = 'diag';
  var dependencies$1h = ['typed', 'matrix', 'DenseMatrix', 'SparseMatrix'];
  var createDiag = /* #__PURE__ */factory(name$1g, dependencies$1h, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        DenseMatrix = _ref.DenseMatrix,
        SparseMatrix = _ref.SparseMatrix;

    /**
     * Create a diagonal matrix or retrieve the diagonal of a matrix
     *
     * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.
     * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.
     * When k is positive, the values are placed on the super diagonal.
     * When k is negative, the values are placed on the sub diagonal.
     *
     * Syntax:
     *
     *     math.diag(X)
     *     math.diag(X, format)
     *     math.diag(X, k)
     *     math.diag(X, k, format)
     *
     * Examples:
     *
     *     // create a diagonal matrix
     *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
     *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]
     *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]
     *
     *    // retrieve the diagonal from a matrix
     *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
     *    math.diag(a)   // returns [1, 5, 9]
     *
     * See also:
     *
     *     ones, zeros, identity
     *
     * @param {Matrix | Array} x          A two dimensional matrix or a vector
     * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled
     *                                    in or retrieved.
     * @param {string} [format='dense']   The matrix storage format.
     *
     * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.
     */
    return typed(name$1g, {
      // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
      Array: function Array(x) {
        return _diag(x, 0, arraySize(x), null);
      },
      'Array, number': function ArrayNumber(x, k) {
        return _diag(x, k, arraySize(x), null);
      },
      'Array, BigNumber': function ArrayBigNumber(x, k) {
        return _diag(x, k.toNumber(), arraySize(x), null);
      },
      'Array, string': function ArrayString(x, format$$1) {
        return _diag(x, 0, arraySize(x), format$$1);
      },
      'Array, number, string': function ArrayNumberString(x, k, format$$1) {
        return _diag(x, k, arraySize(x), format$$1);
      },
      'Array, BigNumber, string': function ArrayBigNumberString(x, k, format$$1) {
        return _diag(x, k.toNumber(), arraySize(x), format$$1);
      },
      Matrix: function Matrix(x) {
        return _diag(x, 0, x.size(), x.storage());
      },
      'Matrix, number': function MatrixNumber(x, k) {
        return _diag(x, k, x.size(), x.storage());
      },
      'Matrix, BigNumber': function MatrixBigNumber(x, k) {
        return _diag(x, k.toNumber(), x.size(), x.storage());
      },
      'Matrix, string': function MatrixString(x, format$$1) {
        return _diag(x, 0, x.size(), format$$1);
      },
      'Matrix, number, string': function MatrixNumberString(x, k, format$$1) {
        return _diag(x, k, x.size(), format$$1);
      },
      'Matrix, BigNumber, string': function MatrixBigNumberString(x, k, format$$1) {
        return _diag(x, k.toNumber(), x.size(), format$$1);
      }
    });
    /**
     * Creeate diagonal matrix from a vector or vice versa
     * @param {Array | Matrix} x
     * @param {number} k
     * @param {string} format Storage format for matrix. If null,
     *                          an Array is returned
     * @returns {Array | Matrix}
     * @private
     */

    function _diag(x, k, size, format$$1) {
      if (!isInteger(k)) {
        throw new TypeError('Second parameter in function diag must be an integer');
      }

      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0; // check dimensions

      switch (size.length) {
        case 1:
          return _createDiagonalMatrix(x, k, format$$1, size[0], kSub, kSuper);

        case 2:
          return _getDiagonal(x, k, format$$1, size, kSub, kSuper);
      }

      throw new RangeError('Matrix for function diag must be 2 dimensional');
    }

    function _createDiagonalMatrix(x, k, format$$1, l, kSub, kSuper) {
      // matrix size
      var ms = [l + kSub, l + kSuper];

      if (format$$1 && format$$1 !== 'sparse' && format$$1 !== 'dense') {
        throw new TypeError("Unknown matrix type ".concat(format$$1, "\""));
      } // create diagonal matrix


      var m = format$$1 === 'sparse' ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k); // check we need to return a matrix

      return format$$1 !== null ? m : m.valueOf();
    }

    function _getDiagonal(x, k, format$$1, s, kSub, kSuper) {
      // check x is a Matrix
      if (isMatrix(x)) {
        // get diagonal matrix
        var dm = x.diagonal(k); // check we need to return a matrix

        if (format$$1 !== null) {
          // check we need to change matrix format
          if (format$$1 !== dm.storage()) {
            return matrix(dm, format$$1);
          }

          return dm;
        }

        return dm.valueOf();
      } // vector size


      var n = Math.min(s[0] - kSub, s[1] - kSuper); // diagonal values

      var vector = []; // loop diagonal

      for (var i = 0; i < n; i++) {
        vector[i] = x[i + kSub][i + kSuper];
      } // check we need to return a matrix


      return format$$1 !== null ? matrix(vector) : vector;
    }
  });

  function _typeof$4(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$4 = function _typeof(obj) { return typeof obj; }; } else { _typeof$4 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$4(obj); }

  // function utils

  /**
   * Memoize a given function by caching the computed result.
   * The cache of a memoized function can be cleared by deleting the `cache`
   * property of the function.
   *
   * @param {function} fn                     The function to be memoized.
   *                                          Must be a pure function.
   * @param {function(args: Array)} [hasher]  A custom hash builder.
   *                                          Is JSON.stringify by default.
   * @return {function}                       Returns the memoized function
   */
  function memoize(fn, hasher) {
    return function memoize() {
      if (_typeof$4(memoize.cache) !== 'object') {
        memoize.cache = {};
      }

      var args = [];

      for (var i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      var hash = hasher ? hasher(args) : JSON.stringify(args);

      if (!(hash in memoize.cache)) {
        memoize.cache[hash] = fn.apply(fn, args);
      }

      return memoize.cache[hash];
    };
  }
  /**
   * Find the maximum number of arguments expected by a typed function.
   * @param {function} fn   A typed function
   * @return {number} Returns the maximum number of expected arguments.
   *                  Returns -1 when no signatures where found on the function.
   */

  function maxArgumentCount(fn) {
    return Object.keys(fn.signatures || {}).reduce(function (args, signature) {
      var count = (signature.match(/,/g) || []).length + 1;
      return Math.max(args, count);
    }, -1);
  }

  var name$1h = 'filter';
  var dependencies$1i = ['typed'];
  var createFilter = /* #__PURE__ */factory(name$1h, dependencies$1i, function (_ref) {
    var typed = _ref.typed;

    /**
     * Filter the items in an array or one dimensional matrix.
     *
     * Syntax:
     *
     *    math.filter(x, test)
     *
     * Examples:
     *
     *    function isPositive (x) {
     *      return x > 0
     *    }
     *    math.filter([6, -2, -1, 4, 3], isPositive) // returns [6, 4, 3]
     *
     *    math.filter(["23", "foo", "100", "55", "bar"], /[0-9]+/) // returns ["23", "100", "55"]
     *
     * See also:
     *
     *    forEach, map, sort
     *
     * @param {Matrix | Array} x    A one dimensional matrix or array to filter
     * @param {Function | RegExp} test
     *        A function or regular expression to test items.
     *        All entries for which `test` returns true are returned.
     *        When `test` is a function, it is invoked with three parameters:
     *        the value of the element, the index of the element, and the
     *        matrix/array being traversed. The function must return a boolean.
     * @return {Matrix | Array} Returns the filtered matrix.
     */
    return typed('filter', {
      'Array, function': _filterCallback,
      'Matrix, function': function MatrixFunction(x, test) {
        return x.create(_filterCallback(x.toArray(), test));
      },
      'Array, RegExp': filterRegExp,
      'Matrix, RegExp': function MatrixRegExp(x, test) {
        return x.create(filterRegExp(x.toArray(), test));
      }
    });
  });
  /**
   * Filter values in a callback given a callback function
   * @param {Array} x
   * @param {Function} callback
   * @return {Array} Returns the filtered array
   * @private
   */

  function _filterCallback(x, callback) {
    // figure out what number of arguments the callback function expects
    var args = maxArgumentCount(callback);
    return filter(x, function (value, index, array) {
      // invoke the callback function with the right number of arguments
      if (args === 1) {
        return callback(value);
      } else if (args === 2) {
        return callback(value, [index]);
      } else {
        // 3 or -1
        return callback(value, [index], array);
      }
    });
  }

  var name$1i = 'flatten';
  var dependencies$1j = ['typed', 'matrix'];
  var createFlatten = /* #__PURE__ */factory(name$1i, dependencies$1j, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix;

    /**
     * Flatten a multi dimensional matrix into a single dimensional matrix.
     *
     * Syntax:
     *
     *    math.flatten(x)
     *
     * Examples:
     *
     *    math.flatten([[1,2], [3,4]])   // returns [1, 2, 3, 4]
     *
     * See also:
     *
     *    concat, resize, size, squeeze
     *
     * @param {Matrix | Array} x   Matrix to be flattened
     * @return {Matrix | Array} Returns the flattened matrix
     */
    return typed(name$1i, {
      Array: function Array(x) {
        return flatten(clone(x));
      },
      Matrix: function Matrix(x) {
        var flat = flatten(clone(x.toArray())); // TODO: return the same matrix type as x

        return matrix(flat);
      }
    });
  });

  var name$1j = 'forEach';
  var dependencies$1k = ['typed'];
  var createForEach = /* #__PURE__ */factory(name$1j, dependencies$1k, function (_ref) {
    var typed = _ref.typed;

    /**
     * Iterate over all elements of a matrix/array, and executes the given callback function.
     *
     * Syntax:
     *
     *    math.forEach(x, callback)
     *
     * Examples:
     *
     *    math.forEach([1, 2, 3], function(value) {
     *      console.log(value)
     *    })
     *    // outputs 1, 2, 3
     *
     * See also:
     *
     *    filter, map, sort
     *
     * @param {Matrix | Array} x    The matrix to iterate on.
     * @param {Function} callback   The callback function is invoked with three
     *                              parameters: the value of the element, the index
     *                              of the element, and the Matrix/array being traversed.
     */
    return typed(name$1j, {
      'Array, function': _forEach,
      'Matrix, function': function MatrixFunction(x, callback) {
        return x.forEach(callback);
      }
    });
  });
  /**
   * forEach for a multi dimensional array
   * @param {Array} array
   * @param {Function} callback
   * @private
   */

  function _forEach(array, callback) {
    // figure out what number of arguments the callback function expects
    var args = maxArgumentCount(callback);

    var recurse = function recurse(value, index) {
      if (Array.isArray(value)) {
        forEach(value, function (child, i) {
          // we create a copy of the index array and append the new index value
          recurse(child, index.concat(i));
        });
      } else {
        // invoke the callback function with the right number of arguments
        if (args === 1) {
          callback(value);
        } else if (args === 2) {
          callback(value, index);
        } else {
          // 3 or -1
          callback(value, index, array);
        }
      }
    };

    recurse(array, []);
  }

  var name$1k = 'getMatrixDataType';
  var dependencies$1l = ['typed'];
  var createGetMatrixDataType = /* #__PURE__ */factory(name$1k, dependencies$1l, function (_ref) {
    var typed = _ref.typed;

    /**
     * Find the data type of all elements in a matrix or array,
     * for example 'number' if all items are a number and 'Complex' if all values
     * are complex numbers.
     * If a matrix contains more than one data type, it will return 'mixed'.
     *
     * Syntax:
     *
     *    math.getMatrixDataType(x)
     *
     * Examples:
     *
     *    const x = [ [1, 2, 3], [4, 5, 6] ]
     *    const mixedX = [ [1, true], [2, 3] ]
     *    const fractionX = [ [math.fraction(1, 3)], [math.fraction(1, 3] ]
     *    const unitX = [ [math.unit('5cm')], [math.unit('5cm')] ]
     *    const bigNumberX = [ [math.bignumber(1)], [math.bignumber(0)] ]
     *    const sparse = math.sparse(x)
     *    const dense = math.matrix(x)
     *    math.getMatrixDataType(x)   // returns 'number'
     *    math.getMatrixDataType(sparse)   // returns 'number'
     *    math.getMatrixDataType(dense)   // returns 'number'
     *    math.getMatrixDataType(mixedX) // returns 'mixed'
     *    math.getMatrixDataType(fractionX) // returns 'Fraction'
     *    math.getMatrixDataType(unitX) // returns 'Unit'
     *    math.getMatrixDataType(bigNumberX) // return 'BigNumber'
     *
     * See also:
     *  SparseMatrix, DenseMatrix
     *
     * @param {...Matrix | Array} x   The Matrix with values.
     *
     * @return {string} A string representation of the matrix type
     */
    return typed(name$1k, {
      Array: function Array(x) {
        return getArrayDataType(x, typeOf);
      },
      Matrix: function Matrix(x) {
        return x.getDataType();
      }
    });
  });

  var name$1l = 'identity';
  var dependencies$1m = ['typed', 'config', 'matrix', 'BigNumber', 'DenseMatrix', 'SparseMatrix'];
  var createIdentity = /* #__PURE__ */factory(name$1l, dependencies$1m, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        matrix = _ref.matrix,
        BigNumber = _ref.BigNumber,
        DenseMatrix = _ref.DenseMatrix,
        SparseMatrix = _ref.SparseMatrix;

    /**
     * Create a 2-dimensional identity matrix with size m x n or n x n.
     * The matrix has ones on the diagonal and zeros elsewhere.
     *
     * Syntax:
     *
     *    math.identity(n)
     *    math.identity(n, format)
     *    math.identity(m, n)
     *    math.identity(m, n, format)
     *    math.identity([m, n])
     *    math.identity([m, n], format)
     *
     * Examples:
     *
     *    math.identity(3)                    // returns [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
     *    math.identity(3, 2)                 // returns [[1, 0], [0, 1], [0, 0]]
     *
     *    const A = [[1, 2, 3], [4, 5, 6]]
     *    math.identity(math.size(A))         // returns [[1, 0, 0], [0, 1, 0]]
     *
     * See also:
     *
     *    diag, ones, zeros, size, range
     *
     * @param {...number | Matrix | Array} size   The size for the matrix
     * @param {string} [format]                   The Matrix storage format
     *
     * @return {Matrix | Array | number} A matrix with ones on the diagonal.
     */
    return typed(name$1l, {
      '': function _() {
        return config.matrix === 'Matrix' ? matrix([]) : [];
      },
      string: function string(format$$1) {
        return matrix(format$$1);
      },
      'number | BigNumber': function numberBigNumber(rows) {
        return _identity(rows, rows, config.matrix === 'Matrix' ? 'dense' : undefined);
      },
      'number | BigNumber, string': function numberBigNumberString(rows, format$$1) {
        return _identity(rows, rows, format$$1);
      },
      'number | BigNumber, number | BigNumber': function numberBigNumberNumberBigNumber(rows, cols) {
        return _identity(rows, cols, config.matrix === 'Matrix' ? 'dense' : undefined);
      },
      'number | BigNumber, number | BigNumber, string': function numberBigNumberNumberBigNumberString(rows, cols, format$$1) {
        return _identity(rows, cols, format$$1);
      },
      Array: function Array(size) {
        return _identityVector(size);
      },
      'Array, string': function ArrayString(size, format$$1) {
        return _identityVector(size, format$$1);
      },
      Matrix: function Matrix(size) {
        return _identityVector(size.valueOf(), size.storage());
      },
      'Matrix, string': function MatrixString(size, format$$1) {
        return _identityVector(size.valueOf(), format$$1);
      }
    });

    function _identityVector(size, format$$1) {
      switch (size.length) {
        case 0:
          return format$$1 ? matrix(format$$1) : [];

        case 1:
          return _identity(size[0], size[0], format$$1);

        case 2:
          return _identity(size[0], size[1], format$$1);

        default:
          throw new Error('Vector containing two values expected');
      }
    }
    /**
     * Create an identity matrix
     * @param {number | BigNumber} rows
     * @param {number | BigNumber} cols
     * @param {string} [format]
     * @returns {Matrix}
     * @private
     */


    function _identity(rows, cols, format$$1) {
      // BigNumber constructor with the right precision
      var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber : null;
      if (isBigNumber(rows)) rows = rows.toNumber();
      if (isBigNumber(cols)) cols = cols.toNumber();

      if (!isInteger(rows) || rows < 1) {
        throw new Error('Parameters in function identity must be positive integers');
      }

      if (!isInteger(cols) || cols < 1) {
        throw new Error('Parameters in function identity must be positive integers');
      }

      var one = Big ? new BigNumber(1) : 1;
      var defaultValue = Big ? new Big(0) : 0;
      var size = [rows, cols]; // check we need to return a matrix

      if (format$$1) {
        // create diagonal matrix (use optimized implementation for storage format)
        if (format$$1 === 'sparse') {
          return SparseMatrix.diagonal(size, one, 0, defaultValue);
        }

        if (format$$1 === 'dense') {
          return DenseMatrix.diagonal(size, one, 0, defaultValue);
        }

        throw new TypeError("Unknown matrix type \"".concat(format$$1, "\""));
      } // create and resize array


      var res = resize([], size, defaultValue); // fill in ones on the diagonal

      var minimum = rows < cols ? rows : cols; // fill diagonal

      for (var d = 0; d < minimum; d++) {
        res[d][d] = one;
      }

      return res;
    }
  });

  var name$1m = 'kron';
  var dependencies$1n = ['typed', 'matrix', 'multiplyScalar'];
  var createKron = /* #__PURE__ */factory(name$1m, dependencies$1n, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        multiplyScalar = _ref.multiplyScalar;

    /**
       * Calculates the kronecker product of 2 matrices or vectors.
       *
       * NOTE: If a one dimensional vector / matrix is given, it will be
       * wrapped so its two dimensions.
       * See the examples.
       *
       * Syntax:
       *
       *    math.kron(x, y)
       *
       * Examples:
       *
       *    math.kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])
       *    // returns [ [ 1, 2, 0, 0 ], [ 3, 4, 0, 0 ], [ 0, 0, 1, 2 ], [ 0, 0, 3, 4 ] ]
       *
       *    math.kron([1,1], [2,3,4])
       *    // returns [ [ 2, 3, 4, 2, 3, 4 ] ]
       *
       * See also:
       *
       *    multiply, dot, cross
       *
       * @param  {Array | Matrix} x     First vector
       * @param  {Array | Matrix} y     Second vector
       * @return {Array | Matrix}       Returns the kronecker product of `x` and `y`
       */
    return typed(name$1m, {
      'Matrix, Matrix': function MatrixMatrix(x, y) {
        return matrix(_kron(x.toArray(), y.toArray()));
      },
      'Matrix, Array': function MatrixArray(x, y) {
        return matrix(_kron(x.toArray(), y));
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        return matrix(_kron(x, y.toArray()));
      },
      'Array, Array': _kron
    });
    /**
       * Calculate the kronecker product of two matrices / vectors
       * @param {Array} a  First vector
       * @param {Array} b  Second vector
       * @returns {Array} Returns the kronecker product of x and y
       * @private
       */

    function _kron(a, b) {
      // Deal with the dimensions of the matricies.
      if (arraySize(a).length === 1) {
        // Wrap it in a 2D Matrix
        a = [a];
      }

      if (arraySize(b).length === 1) {
        // Wrap it in a 2D Matrix
        b = [b];
      }

      if (arraySize(a).length > 2 || arraySize(b).length > 2) {
        throw new RangeError('Vectors with dimensions greater then 2 are not supported expected ' + '(Size x = ' + JSON.stringify(a.length) + ', y = ' + JSON.stringify(b.length) + ')');
      }

      var t = [];
      var r = [];
      return a.map(function (a) {
        return b.map(function (b) {
          r = [];
          t.push(r);
          return a.map(function (y) {
            return b.map(function (x) {
              return r.push(multiplyScalar(y, x));
            });
          });
        });
      }) && t;
    }
  });

  var name$1n = 'map';
  var dependencies$1o = ['typed'];
  var createMap = /* #__PURE__ */factory(name$1n, dependencies$1o, function (_ref) {
    var typed = _ref.typed;

    /**
     * Create a new matrix or array with the results of the callback function executed on
     * each entry of the matrix/array.
     *
     * Syntax:
     *
     *    math.map(x, callback)
     *
     * Examples:
     *
     *    math.map([1, 2, 3], function(value) {
     *      return value * value
     *    })  // returns [1, 4, 9]
     *
     * See also:
     *
     *    filter, forEach, sort
     *
     * @param {Matrix | Array} x    The matrix to iterate on.
     * @param {Function} callback   The callback method is invoked with three
     *                              parameters: the value of the element, the index
     *                              of the element, and the matrix being traversed.
     * @return {Matrix | array}     Transformed map of x
     */
    return typed(name$1n, {
      'Array, function': _map,
      'Matrix, function': function MatrixFunction(x, callback) {
        return x.map(callback);
      }
    });
  });
  /**
   * Map for a multi dimensional array
   * @param {Array} array
   * @param {Function} callback
   * @return {Array}
   * @private
   */

  function _map(array, callback) {
    // figure out what number of arguments the callback function expects
    var args = maxArgumentCount(callback);

    var recurse = function recurse(value, index) {
      if (Array.isArray(value)) {
        return value.map(function (child, i) {
          // we create a copy of the index array and append the new index value
          return recurse(child, index.concat(i));
        });
      } else {
        // invoke the callback function with the right number of arguments
        if (args === 1) {
          return callback(value);
        } else if (args === 2) {
          return callback(value, index);
        } else {
          // 3 or -1
          return callback(value, index, array);
        }
      }
    };

    return recurse(array, []);
  }

  var name$1o = 'ones';
  var dependencies$1p = ['typed', 'config', 'matrix', 'BigNumber'];
  var createOnes = /* #__PURE__ */factory(name$1o, dependencies$1p, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        matrix = _ref.matrix,
        BigNumber = _ref.BigNumber;

    /**
     * Create a matrix filled with ones. The created matrix can have one or
     * multiple dimensions.
     *
     * Syntax:
     *
     *    math.ones(m)
     *    math.ones(m, format)
     *    math.ones(m, n)
     *    math.ones(m, n, format)
     *    math.ones([m, n])
     *    math.ones([m, n], format)
     *    math.ones([m, n, p, ...])
     *    math.ones([m, n, p, ...], format)
     *
     * Examples:
     *
     *    math.ones(3)                   // returns [1, 1, 1]
     *    math.ones(3, 2)                // returns [[1, 1], [1, 1], [1, 1]]
     *    math.ones(3, 2, 'dense')       // returns Dense Matrix [[1, 1], [1, 1], [1, 1]]
     *
     *    const A = [[1, 2, 3], [4, 5, 6]]
     *    math.ones(math.size(A))       // returns [[1, 1, 1], [1, 1, 1]]
     *
     * See also:
     *
     *    zeros, identity, size, range
     *
     * @param {...number | Array} size    The size of each dimension of the matrix
     * @param {string} [format]           The Matrix storage format
     *
     * @return {Array | Matrix | number}  A matrix filled with ones
     */
    return typed('ones', {
      '': function _() {
        return config.matrix === 'Array' ? _ones([]) : _ones([], 'default');
      },
      // math.ones(m, n, p, ..., format)
      // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
      '...number | BigNumber | string': function numberBigNumberString(size) {
        var last$$1 = size[size.length - 1];

        if (typeof last$$1 === 'string') {
          var format$$1 = size.pop();
          return _ones(size, format$$1);
        } else if (config.matrix === 'Array') {
          return _ones(size);
        } else {
          return _ones(size, 'default');
        }
      },
      Array: _ones,
      Matrix: function Matrix(size) {
        var format$$1 = size.storage();
        return _ones(size.valueOf(), format$$1);
      },
      'Array | Matrix, string': function ArrayMatrixString(size, format$$1) {
        return _ones(size.valueOf(), format$$1);
      }
    });
    /**
     * Create an Array or Matrix with ones
     * @param {Array} size
     * @param {string} [format='default']
     * @return {Array | Matrix}
     * @private
     */

    function _ones(size, format$$1) {
      var hasBigNumbers = _normalize(size);

      var defaultValue = hasBigNumbers ? new BigNumber(1) : 1;

      _validate(size);

      if (format$$1) {
        // return a matrix
        var m = matrix(format$$1);

        if (size.length > 0) {
          return m.resize(size, defaultValue);
        }

        return m;
      } else {
        // return an Array
        var arr = [];

        if (size.length > 0) {
          return resize(arr, size, defaultValue);
        }

        return arr;
      }
    } // replace BigNumbers with numbers, returns true if size contained BigNumbers


    function _normalize(size) {
      var hasBigNumbers = false;
      size.forEach(function (value, index, arr) {
        if (isBigNumber(value)) {
          hasBigNumbers = true;
          arr[index] = value.toNumber();
        }
      });
      return hasBigNumbers;
    } // validate arguments


    function _validate(size) {
      size.forEach(function (value) {
        if (typeof value !== 'number' || !isInteger(value) || value < 0) {
          throw new Error('Parameters in function ones must be positive integers');
        }
      });
    }
  });

  function noBignumber() {
    throw new Error('No "bignumber" implementation available');
  }
  function noFraction() {
    throw new Error('No "fraction" implementation available');
  }
  function noMatrix() {
    throw new Error('No "matrix" implementation available');
  }

  var name$1p = 'range';
  var dependencies$1q = ['typed', 'config', '?matrix', '?bignumber', 'smaller', 'smallerEq', 'larger', 'largerEq'];
  var createRange = /* #__PURE__ */factory(name$1p, dependencies$1q, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        matrix = _ref.matrix,
        bignumber = _ref.bignumber,
        smaller = _ref.smaller,
        smallerEq = _ref.smallerEq,
        larger = _ref.larger,
        largerEq = _ref.largerEq;

    /**
     * Create an array from a range.
     * By default, the range end is excluded. This can be customized by providing
     * an extra parameter `includeEnd`.
     *
     * Syntax:
     *
     *     math.range(str [, includeEnd])               // Create a range from a string,
     *                                                  // where the string contains the
     *                                                  // start, optional step, and end,
     *                                                  // separated by a colon.
     *     math.range(start, end [, includeEnd])        // Create a range with start and
     *                                                  // end and a step size of 1.
     *     math.range(start, end, step [, includeEnd])  // Create a range with start, step,
     *                                                  // and end.
     *
     * Where:
     *
     * - `str: string`
     *   A string 'start:end' or 'start:step:end'
     * - `start: {number | BigNumber}`
     *   Start of the range
     * - `end: number | BigNumber`
     *   End of the range, excluded by default, included when parameter includeEnd=true
     * - `step: number | BigNumber`
     *   Step size. Default value is 1.
     * - `includeEnd: boolean`
     *   Option to specify whether to include the end or not. False by default.
     *
     * Examples:
     *
     *     math.range(2, 6)        // [2, 3, 4, 5]
     *     math.range(2, -3, -1)   // [2, 1, 0, -1, -2]
     *     math.range('2:1:6')     // [2, 3, 4, 5]
     *     math.range(2, 6, true)  // [2, 3, 4, 5, 6]
     *
     * See also:
     *
     *     ones, zeros, size, subset
     *
     * @param {*} args   Parameters describing the ranges `start`, `end`, and optional `step`.
     * @return {Array | Matrix} range
     */
    return typed(name$1p, {
      // TODO: simplify signatures when typed-function supports default values and optional arguments
      // TODO: a number or boolean should not be converted to string here
      string: _strRange,
      'string, boolean': _strRange,
      'number, number': function numberNumber(start, end) {
        return _out(_rangeEx(start, end, 1));
      },
      'number, number, number': function numberNumberNumber(start, end, step) {
        return _out(_rangeEx(start, end, step));
      },
      'number, number, boolean': function numberNumberBoolean(start, end, includeEnd) {
        return includeEnd ? _out(_rangeInc(start, end, 1)) : _out(_rangeEx(start, end, 1));
      },
      'number, number, number, boolean': function numberNumberNumberBoolean(start, end, step, includeEnd) {
        return includeEnd ? _out(_rangeInc(start, end, step)) : _out(_rangeEx(start, end, step));
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(start, end) {
        var BigNumber = start.constructor;
        return _out(_bigRangeEx(start, end, new BigNumber(1)));
      },
      'BigNumber, BigNumber, BigNumber': function BigNumberBigNumberBigNumber(start, end, step) {
        return _out(_bigRangeEx(start, end, step));
      },
      'BigNumber, BigNumber, boolean': function BigNumberBigNumberBoolean(start, end, includeEnd) {
        var BigNumber = start.constructor;
        return includeEnd ? _out(_bigRangeInc(start, end, new BigNumber(1))) : _out(_bigRangeEx(start, end, new BigNumber(1)));
      },
      'BigNumber, BigNumber, BigNumber, boolean': function BigNumberBigNumberBigNumberBoolean(start, end, step, includeEnd) {
        return includeEnd ? _out(_bigRangeInc(start, end, step)) : _out(_bigRangeEx(start, end, step));
      }
    });

    function _out(arr) {
      if (config.matrix === 'Matrix') {
        return matrix ? matrix(arr) : noMatrix();
      }

      return arr;
    }

    function _strRange(str, includeEnd) {
      var r = _parse(str);

      if (!r) {
        throw new SyntaxError('String "' + str + '" is no valid range');
      }

      var fn;

      if (config.number === 'BigNumber') {
        if (bignumber === undefined) {
          noBignumber();
        }

        fn = includeEnd ? _bigRangeInc : _bigRangeEx;
        return _out(fn(bignumber(r.start), bignumber(r.end), bignumber(r.step)));
      } else {
        fn = includeEnd ? _rangeInc : _rangeEx;
        return _out(fn(r.start, r.end, r.step));
      }
    }
    /**
     * Create a range with numbers. End is excluded
     * @param {number} start
     * @param {number} end
     * @param {number} step
     * @returns {Array} range
     * @private
     */


    function _rangeEx(start, end, step) {
      var array = [];
      var x = start;

      if (step > 0) {
        while (smaller(x, end)) {
          array.push(x);
          x += step;
        }
      } else if (step < 0) {
        while (larger(x, end)) {
          array.push(x);
          x += step;
        }
      }

      return array;
    }
    /**
     * Create a range with numbers. End is included
     * @param {number} start
     * @param {number} end
     * @param {number} step
     * @returns {Array} range
     * @private
     */


    function _rangeInc(start, end, step) {
      var array = [];
      var x = start;

      if (step > 0) {
        while (smallerEq(x, end)) {
          array.push(x);
          x += step;
        }
      } else if (step < 0) {
        while (largerEq(x, end)) {
          array.push(x);
          x += step;
        }
      }

      return array;
    }
    /**
     * Create a range with big numbers. End is excluded
     * @param {BigNumber} start
     * @param {BigNumber} end
     * @param {BigNumber} step
     * @returns {Array} range
     * @private
     */


    function _bigRangeEx(start, end, step) {
      var zero = bignumber(0);
      var array = [];
      var x = start;

      if (step.gt(zero)) {
        while (smaller(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      } else if (step.lt(zero)) {
        while (larger(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      }

      return array;
    }
    /**
     * Create a range with big numbers. End is included
     * @param {BigNumber} start
     * @param {BigNumber} end
     * @param {BigNumber} step
     * @returns {Array} range
     * @private
     */


    function _bigRangeInc(start, end, step) {
      var zero = bignumber(0);
      var array = [];
      var x = start;

      if (step.gt(zero)) {
        while (smallerEq(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      } else if (step.lt(zero)) {
        while (largerEq(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      }

      return array;
    }
    /**
     * Parse a string into a range,
     * The string contains the start, optional step, and end, separated by a colon.
     * If the string does not contain a valid range, null is returned.
     * For example str='0:2:11'.
     * @param {string} str
     * @return {{start: number, end: number, step: number} | null} range Object containing properties start, end, step
     * @private
     */


    function _parse(str) {
      var args = str.split(':'); // number

      var nums = args.map(function (arg) {
        // use Number and not parseFloat as Number returns NaN on invalid garbage in the string
        return Number(arg);
      });
      var invalid = nums.some(function (num) {
        return isNaN(num);
      });

      if (invalid) {
        return null;
      }

      switch (nums.length) {
        case 2:
          return {
            start: nums[0],
            end: nums[1],
            step: 1
          };

        case 3:
          return {
            start: nums[0],
            end: nums[2],
            step: nums[1]
          };

        default:
          return null;
      }
    }
  });

  var name$1q = 'reshape';
  var dependencies$1r = ['typed', 'isInteger', 'matrix'];
  var createReshape = /* #__PURE__ */factory(name$1q, dependencies$1r, function (_ref) {
    var typed = _ref.typed,
        isInteger = _ref.isInteger,
        matrix = _ref.matrix;

    /**
     * Reshape a multi dimensional array to fit the specified dimensions
     *
     * Syntax:
     *
     *     math.reshape(x, sizes)
     *
     * Examples:
     *
     *     math.reshape([1, 2, 3, 4, 5, 6], [2, 3])
     *     // returns Array  [[1, 2, 3], [4, 5, 6]]
     *
     *     math.reshape([[1, 2], [3, 4]], [1, 4])
     *     // returns Array  [[1, 2, 3, 4]]
     *
     *     math.reshape([[1, 2], [3, 4]], [4])
     *     // returns Array [1, 2, 3, 4]
     *
     *     const x = math.matrix([1, 2, 3, 4, 5, 6, 7, 8])
     *     math.reshape(x, [2, 2, 2])
     *     // returns Matrix [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
     *
     * See also:
     *
     *     size, squeeze, resize
     *
     * @param {Array | Matrix | *} x  Matrix to be reshaped
     * @param {number[]} sizes        One dimensional array with integral sizes for
     *                                each dimension
     *
     * @return {* | Array | Matrix}   A reshaped clone of matrix `x`
     *
     * @throws {TypeError}            If `sizes` does not contain solely integers
     * @throws {DimensionError}       If the product of the new dimension sizes does
     *                                not equal that of the old ones
     */
    return typed(name$1q, {
      'Matrix, Array': function MatrixArray(x, sizes) {
        if (x.reshape) {
          return x.reshape(sizes);
        } else {
          return matrix(reshape(x.valueOf(), sizes));
        }
      },
      'Array, Array': function ArrayArray(x, sizes) {
        sizes.forEach(function (size) {
          if (!isInteger(size)) {
            throw new TypeError('Invalid size for dimension: ' + size);
          }
        });
        return reshape(x, sizes);
      }
    });
  });

  /**
   * Create a syntax error with the message:
   *     'Wrong number of arguments in function <fn> (<count> provided, <min>-<max> expected)'
   * @param {string} fn     Function name
   * @param {number} count  Actual argument count
   * @param {number} min    Minimum required argument count
   * @param {number} [max]  Maximum required argument count
   * @extends Error
   */
  function ArgumentsError(fn, count, min, max) {
    if (!(this instanceof ArgumentsError)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.fn = fn;
    this.count = count;
    this.min = min;
    this.max = max;
    this.message = 'Wrong number of arguments in function ' + fn + ' (' + count + ' provided, ' + min + (max !== undefined && max !== null ? '-' + max : '') + ' expected)';
    this.stack = new Error().stack;
  }
  ArgumentsError.prototype = new Error();
  ArgumentsError.prototype.constructor = Error;
  ArgumentsError.prototype.name = 'ArgumentsError';
  ArgumentsError.prototype.isArgumentsError = true;

  var name$1r = 'resize';
  var dependencies$1s = ['config', 'matrix'];
  var createResize = /* #__PURE__ */factory(name$1r, dependencies$1s, function (_ref) {
    var config = _ref.config,
        matrix = _ref.matrix;

    /**
     * Resize a matrix
     *
     * Syntax:
     *
     *     math.resize(x, size)
     *     math.resize(x, size, defaultValue)
     *
     * Examples:
     *
     *     math.resize([1, 2, 3, 4, 5], [3]) // returns Array  [1, 2, 3]
     *     math.resize([1, 2, 3], [5], 0)    // returns Array  [1, 2, 3, 0, 0]
     *     math.resize(2, [2, 3], 0)         // returns Matrix [[2, 0, 0], [0, 0, 0]]
     *     math.resize("hello", [8], "!")    // returns string 'hello!!!'
     *
     * See also:
     *
     *     size, squeeze, subset, reshape
     *
     * @param {Array | Matrix | *} x             Matrix to be resized
     * @param {Array | Matrix} size              One dimensional array with numbers
     * @param {number | string} [defaultValue=0] Zero by default, except in
     *                                           case of a string, in that case
     *                                           defaultValue = ' '
     * @return {* | Array | Matrix} A resized clone of matrix `x`
     */
    // TODO: rework resize to a typed-function
    return function resize$$1(x, size, defaultValue) {
      if (arguments.length !== 2 && arguments.length !== 3) {
        throw new ArgumentsError('resize', arguments.length, 2, 3);
      }

      if (isMatrix(size)) {
        size = size.valueOf(); // get Array
      }

      if (isBigNumber(size[0])) {
        // convert bignumbers to numbers
        size = size.map(function (value) {
          return !isBigNumber(value) ? value : value.toNumber();
        });
      } // check x is a Matrix


      if (isMatrix(x)) {
        // use optimized matrix implementation, return copy
        return x.resize(size, defaultValue, true);
      }

      if (typeof x === 'string') {
        // resize string
        return _resizeString(x, size, defaultValue);
      } // check result should be a matrix


      var asMatrix = Array.isArray(x) ? false : config.matrix !== 'Array';

      if (size.length === 0) {
        // output a scalar
        while (Array.isArray(x)) {
          x = x[0];
        }

        return clone(x);
      } else {
        // output an array/matrix
        if (!Array.isArray(x)) {
          x = [x];
        }

        x = clone(x);
        var res = resize(x, size, defaultValue);
        return asMatrix ? matrix(res) : res;
      }
    };
    /**
     * Resize a string
     * @param {string} str
     * @param {number[]} size
     * @param {string} [defaultChar=' ']
     * @private
     */

    function _resizeString(str, size, defaultChar) {
      if (defaultChar !== undefined) {
        if (typeof defaultChar !== 'string' || defaultChar.length !== 1) {
          throw new TypeError('Single character expected as defaultValue');
        }
      } else {
        defaultChar = ' ';
      }

      if (size.length !== 1) {
        throw new DimensionError(size.length, 1);
      }

      var len = size[0];

      if (typeof len !== 'number' || !isInteger(len)) {
        throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format$2(size) + ')');
      }

      if (str.length > len) {
        return str.substring(0, len);
      } else if (str.length < len) {
        var res = str;

        for (var i = 0, ii = len - str.length; i < ii; i++) {
          res += defaultChar;
        }

        return res;
      } else {
        return str;
      }
    }
  });

  var name$1s = 'row';
  var dependencies$1t = ['typed', 'Index', 'matrix', 'range'];
  var createRow = /* #__PURE__ */factory(name$1s, dependencies$1t, function (_ref) {
    var typed = _ref.typed,
        Index = _ref.Index,
        matrix = _ref.matrix,
        range = _ref.range;

    /**
     * Return a row from a Matrix.
     *
     * Syntax:
     *
     *     math.row(value, index)
     *
     * Example:
     *
     *     // get a row
     *     const d = [[1, 2], [3, 4]]
     *     math.row(d, 1) // returns [[3, 4]]
     *
     * See also:
     *
     *     column
     *
     * @param {Array | Matrix } value   An array or matrix
     * @param {number} row              The index of the row
     * @return {Array | Matrix}         The retrieved row
     */
    return typed(name$1s, {
      'Matrix, number': _row,
      'Array, number': function ArrayNumber(value, row) {
        return _row(matrix(clone(value)), row).valueOf();
      }
    });
    /**
     * Retrieve a row of a matrix
     * @param {Matrix } value  A matrix
     * @param {number} row     The index of the row
     * @return {Matrix}        The retrieved row
     */

    function _row(value, row) {
      // check dimensions
      if (value.size().length !== 2) {
        throw new Error('Only two dimensional matrix is supported');
      }

      validateIndex(row, value.size()[0]);
      var columnRange = range(0, value.size()[1]);
      var index = new Index(row, columnRange);
      return value.subset(index);
    }
  });

  var name$1t = 'size';
  var dependencies$1u = ['typed', 'config', '?matrix'];
  var createSize = /* #__PURE__ */factory(name$1t, dependencies$1u, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        matrix = _ref.matrix;

    /**
     * Calculate the size of a matrix or scalar.
     *
     * Syntax:
     *
     *     math.size(x)
     *
     * Examples:
     *
     *     math.size(2.3)                  // returns []
     *     math.size('hello world')        // returns [11]
     *
     *     const A = [[1, 2, 3], [4, 5, 6]]
     *     math.size(A)                    // returns [2, 3]
     *     math.size(math.range(1,6))      // returns [5]
     *
     * See also:
     *
     *     resize, squeeze, subset
     *
     * @param {boolean | number | Complex | Unit | string | Array | Matrix} x  A matrix
     * @return {Array | Matrix} A vector with size of `x`.
     */
    return typed(name$1t, {
      Matrix: function Matrix(x) {
        return x.create(x.size());
      },
      Array: arraySize,
      string: function string(x) {
        return config.matrix === 'Array' ? [x.length] : matrix([x.length]);
      },
      'number | Complex | BigNumber | Unit | boolean | null': function numberComplexBigNumberUnitBooleanNull(x) {
        // scalar
        return config.matrix === 'Array' ? [] : matrix ? matrix([]) : noMatrix();
      }
    });
  });

  var name$1u = 'squeeze';
  var dependencies$1v = ['typed', 'matrix'];
  var createSqueeze = /* #__PURE__ */factory(name$1u, dependencies$1v, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix;

    /**
     * Squeeze a matrix, remove inner and outer singleton dimensions from a matrix.
     *
     * Syntax:
     *
     *     math.squeeze(x)
     *
     * Examples:
     *
     *     math.squeeze([3])           // returns 3
     *     math.squeeze([[3]])         // returns 3
     *
     *     const A = math.zeros(3, 1)    // returns [[0], [0], [0]] (size 3x1)
     *     math.squeeze(A)             // returns [0, 0, 0] (size 3)
     *
     *     const B = math.zeros(1, 3)    // returns [[0, 0, 0]] (size 1x3)
     *     math.squeeze(B)             // returns [0, 0, 0] (size 3)
     *
     *     // only inner and outer dimensions are removed
     *     const C = math.zeros(2, 1, 3) // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
     *     math.squeeze(C)             // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
     *
     * See also:
     *
     *     subset
     *
     * @param {Matrix | Array} x      Matrix to be squeezed
     * @return {Matrix | Array} Squeezed matrix
     */
    return typed(name$1u, {
      Array: function Array(x) {
        return squeeze(clone(x));
      },
      Matrix: function Matrix(x) {
        var res = squeeze(x.toArray()); // FIXME: return the same type of matrix as the input

        return Array.isArray(res) ? matrix(res) : res;
      },
      any: function any(x) {
        // scalar
        return clone(x);
      }
    });
  });

  function _typeof$5(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$5 = function _typeof(obj) { return typeof obj; }; } else { _typeof$5 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$5(obj); }
  /**
   * Get a property of a plain object
   * Throws an error in case the object is not a plain object or the
   * property is not defined on the object itself
   * @param {Object} object
   * @param {string} prop
   * @return {*} Returns the property value when safe
   */

  function getSafeProperty(object, prop) {
    // only allow getting safe properties of a plain object
    if (isPlainObject(object) && isSafeProperty(object, prop)) {
      return object[prop];
    }

    if (typeof object[prop] === 'function' && isSafeMethod(object, prop)) {
      throw new Error('Cannot access method "' + prop + '" as a property');
    }

    throw new Error('No access to property "' + prop + '"');
  }
  /**
   * Set a property on a plain object.
   * Throws an error in case the object is not a plain object or the
   * property would override an inherited property like .constructor or .toString
   * @param {Object} object
   * @param {string} prop
   * @param {*} value
   * @return {*} Returns the value
   */
  // TODO: merge this function into access.js?


  function setSafeProperty(object, prop, value) {
    // only allow setting safe properties of a plain object
    if (isPlainObject(object) && isSafeProperty(object, prop)) {
      object[prop] = value;
      return value;
    }

    throw new Error('No access to property "' + prop + '"');
  }
  /**
   * Test whether a property is safe to use for an object.
   * For example .toString and .constructor are not safe
   * @param {string} prop
   * @return {boolean} Returns true when safe
   */


  function isSafeProperty(object, prop) {
    if (!object || _typeof$5(object) !== 'object') {
      return false;
    } // SAFE: whitelisted
    // e.g length


    if (hasOwnProperty(safeNativeProperties, prop)) {
      return true;
    } // UNSAFE: inherited from Object prototype
    // e.g constructor


    if (prop in Object.prototype) {
      // 'in' is used instead of hasOwnProperty for nodejs v0.10
      // which is inconsistent on root prototypes. It is safe
      // here because Object.prototype is a root object
      return false;
    } // UNSAFE: inherited from Function prototype
    // e.g call, apply


    if (prop in Function.prototype) {
      // 'in' is used instead of hasOwnProperty for nodejs v0.10
      // which is inconsistent on root prototypes. It is safe
      // here because Function.prototype is a root object
      return false;
    }

    return true;
  }
  /**
   * Validate whether a method is safe.
   * Throws an error when that's not the case.
   * @param {Object} object
   * @param {string} method
   */
  // TODO: merge this function into assign.js?


  function validateSafeMethod(object, method) {
    if (!isSafeMethod(object, method)) {
      throw new Error('No access to method "' + method + '"');
    }
  }
  /**
   * Check whether a method is safe.
   * Throws an error when that's not the case (for example for `constructor`).
   * @param {Object} object
   * @param {string} method
   * @return {boolean} Returns true when safe, false otherwise
   */


  function isSafeMethod(object, method) {
    if (object === null || object === undefined || typeof object[method] !== 'function') {
      return false;
    } // UNSAFE: ghosted
    // e.g overridden toString
    // Note that IE10 doesn't support __proto__ and we can't do this check there.


    if (hasOwnProperty(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
      return false;
    } // SAFE: whitelisted
    // e.g toString


    if (hasOwnProperty(safeNativeMethods, method)) {
      return true;
    } // UNSAFE: inherited from Object prototype
    // e.g constructor


    if (method in Object.prototype) {
      // 'in' is used instead of hasOwnProperty for nodejs v0.10
      // which is inconsistent on root prototypes. It is safe
      // here because Object.prototype is a root object
      return false;
    } // UNSAFE: inherited from Function prototype
    // e.g call, apply


    if (method in Function.prototype) {
      // 'in' is used instead of hasOwnProperty for nodejs v0.10
      // which is inconsistent on root prototypes. It is safe
      // here because Function.prototype is a root object
      return false;
    }

    return true;
  }

  function isPlainObject(object) {
    return _typeof$5(object) === 'object' && object && object.constructor === Object;
  }

  var safeNativeProperties = {
    length: true,
    name: true
  };
  var safeNativeMethods = {
    toString: true,
    valueOf: true,
    toLocaleString: true
  };

  var name$1v = 'subset';
  var dependencies$1w = ['typed', 'matrix'];
  var createSubset = /* #__PURE__ */factory(name$1v, dependencies$1w, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix;

    /**
     * Get or set a subset of a matrix or string.
     *
     * Syntax:
     *     math.subset(value, index)                                // retrieve a subset
     *     math.subset(value, index, replacement [, defaultValue])  // replace a subset
     *
     * Examples:
     *
     *     // get a subset
     *     const d = [[1, 2], [3, 4]]
     *     math.subset(d, math.index(1, 0))        // returns 3
     *     math.subset(d, math.index([0, 1], 1))   // returns [[2], [4]]
     *
     *     // replace a subset
     *     const e = []
     *     const f = math.subset(e, math.index(0, [0, 2]), [5, 6])  // f = [[5, 6]]
     *     const g = math.subset(f, math.index(1, 1), 7, 0)         // g = [[5, 6], [0, 7]]
     *
     * See also:
     *
     *     size, resize, squeeze, index
     *
     * @param {Array | Matrix | string} matrix  An array, matrix, or string
     * @param {Index} index                     An index containing ranges for each
     *                                          dimension
     * @param {*} [replacement]                 An array, matrix, or scalar.
     *                                          If provided, the subset is replaced with replacement.
     *                                          If not provided, the subset is returned
     * @param {*} [defaultValue=undefined]      Default value, filled in on new entries when
     *                                          the matrix is resized. If not provided,
     *                                          math.matrix elements will be left undefined.
     * @return {Array | Matrix | string} Either the retrieved subset or the updated matrix.
     */
    return typed(name$1v, {
      // get subset
      'Array, Index': function ArrayIndex(value, index) {
        var m = matrix(value);
        var subset = m.subset(index); // returns a Matrix

        return index.isScalar() ? subset : subset.valueOf(); // return an Array (like the input)
      },
      'Matrix, Index': function MatrixIndex(value, index) {
        return value.subset(index);
      },
      'Object, Index': _getObjectProperty,
      'string, Index': _getSubstring,
      // set subset
      'Array, Index, any': function ArrayIndexAny(value, index, replacement) {
        return matrix(clone(value)).subset(index, replacement, undefined).valueOf();
      },
      'Array, Index, any, any': function ArrayIndexAnyAny(value, index, replacement, defaultValue) {
        return matrix(clone(value)).subset(index, replacement, defaultValue).valueOf();
      },
      'Matrix, Index, any': function MatrixIndexAny(value, index, replacement) {
        return value.clone().subset(index, replacement);
      },
      'Matrix, Index, any, any': function MatrixIndexAnyAny(value, index, replacement, defaultValue) {
        return value.clone().subset(index, replacement, defaultValue);
      },
      'string, Index, string': _setSubstring,
      'string, Index, string, string': _setSubstring,
      'Object, Index, any': _setObjectProperty
    });
  });
  /**
   * Retrieve a subset of a string
   * @param {string} str            string from which to get a substring
   * @param {Index} index           An index containing ranges for each dimension
   * @returns {string} substring
   * @private
   */

  function _getSubstring(str, index) {
    if (!isIndex(index)) {
      // TODO: better error message
      throw new TypeError('Index expected');
    }

    if (index.size().length !== 1) {
      throw new DimensionError(index.size().length, 1);
    } // validate whether the range is out of range


    var strLen = str.length;
    validateIndex(index.min()[0], strLen);
    validateIndex(index.max()[0], strLen);
    var range = index.dimension(0);
    var substr = '';
    range.forEach(function (v) {
      substr += str.charAt(v);
    });
    return substr;
  }
  /**
   * Replace a substring in a string
   * @param {string} str            string to be replaced
   * @param {Index} index           An index containing ranges for each dimension
   * @param {string} replacement    Replacement string
   * @param {string} [defaultValue] Default value to be uses when resizing
   *                                the string. is ' ' by default
   * @returns {string} result
   * @private
   */


  function _setSubstring(str, index, replacement, defaultValue) {
    if (!index || index.isIndex !== true) {
      // TODO: better error message
      throw new TypeError('Index expected');
    }

    if (index.size().length !== 1) {
      throw new DimensionError(index.size().length, 1);
    }

    if (defaultValue !== undefined) {
      if (typeof defaultValue !== 'string' || defaultValue.length !== 1) {
        throw new TypeError('Single character expected as defaultValue');
      }
    } else {
      defaultValue = ' ';
    }

    var range = index.dimension(0);
    var len = range.size()[0];

    if (len !== replacement.length) {
      throw new DimensionError(range.size()[0], replacement.length);
    } // validate whether the range is out of range


    var strLen = str.length;
    validateIndex(index.min()[0]);
    validateIndex(index.max()[0]); // copy the string into an array with characters

    var chars = [];

    for (var i = 0; i < strLen; i++) {
      chars[i] = str.charAt(i);
    }

    range.forEach(function (v, i) {
      chars[v] = replacement.charAt(i[0]);
    }); // initialize undefined characters with a space

    if (chars.length > strLen) {
      for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {
        if (!chars[_i]) {
          chars[_i] = defaultValue;
        }
      }
    }

    return chars.join('');
  }
  /**
   * Retrieve a property from an object
   * @param {Object} object
   * @param {Index} index
   * @return {*} Returns the value of the property
   * @private
   */


  function _getObjectProperty(object, index) {
    if (index.size().length !== 1) {
      throw new DimensionError(index.size(), 1);
    }

    var key = index.dimension(0);

    if (typeof key !== 'string') {
      throw new TypeError('String expected as index to retrieve an object property');
    }

    return getSafeProperty(object, key);
  }
  /**
   * Set a property on an object
   * @param {Object} object
   * @param {Index} index
   * @param {*} replacement
   * @return {*} Returns the updated object
   * @private
   */


  function _setObjectProperty(object, index, replacement) {
    if (index.size().length !== 1) {
      throw new DimensionError(index.size(), 1);
    }

    var key = index.dimension(0);

    if (typeof key !== 'string') {
      throw new TypeError('String expected as index to retrieve an object property');
    } // clone the object, and apply the property to the clone


    var updated = clone(object);
    setSafeProperty(updated, key, replacement);
    return updated;
  }

  var name$1w = 'transpose';
  var dependencies$1x = ['typed', 'matrix'];
  var createTranspose = /* #__PURE__ */factory(name$1w, dependencies$1x, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix;

    /**
     * Transpose a matrix. All values of the matrix are reflected over its
     * main diagonal. Only applicable to two dimensional matrices containing
     * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional
     * vectors and scalars return the input unchanged.
     *
     * Syntax:
     *
     *     math.transpose(x)
     *
     * Examples:
     *
     *     const A = [[1, 2, 3], [4, 5, 6]]
     *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]
     *
     * See also:
     *
     *     diag, inv, subset, squeeze
     *
     * @param {Array | Matrix} x  Matrix to be transposed
     * @return {Array | Matrix}   The transposed matrix
     */
    return typed('transpose', {
      Array: function Array(x) {
        // use dense matrix implementation
        return this(matrix(x)).valueOf();
      },
      Matrix: function Matrix(x) {
        // matrix size
        var size = x.size(); // result

        var c; // process dimensions

        switch (size.length) {
          case 1:
            // vector
            c = x.clone();
            break;

          case 2:
            {
              // rows and columns
              var rows = size[0];
              var columns = size[1]; // check columns

              if (columns === 0) {
                // throw exception
                throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format$2(size) + ')');
              } // process storage format


              switch (x.storage()) {
                case 'dense':
                  c = _denseTranspose(x, rows, columns);
                  break;

                case 'sparse':
                  c = _sparseTranspose(x, rows, columns);
                  break;
              }
            }
            break;

          default:
            // multi dimensional
            throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format$2(this._size) + ')');
        }

        return c;
      },
      // scalars
      any: function any(x) {
        return clone(x);
      }
    });

    function _denseTranspose(m, rows, columns) {
      // matrix array
      var data = m._data; // transposed matrix data

      var transposed = [];
      var transposedRow; // loop columns

      for (var j = 0; j < columns; j++) {
        // initialize row
        transposedRow = transposed[j] = []; // loop rows

        for (var i = 0; i < rows; i++) {
          // set data
          transposedRow[i] = clone(data[i][j]);
        }
      } // return matrix


      return m.createDenseMatrix({
        data: transposed,
        size: [columns, rows],
        datatype: m._datatype
      });
    }

    function _sparseTranspose(m, rows, columns) {
      // matrix arrays
      var values$$1 = m._values;
      var index = m._index;
      var ptr = m._ptr; // result matrices

      var cvalues = values$$1 ? [] : undefined;
      var cindex = [];
      var cptr = []; // row counts

      var w = [];

      for (var x = 0; x < rows; x++) {
        w[x] = 0;
      } // vars


      var p, l, j; // loop values in matrix

      for (p = 0, l = index.length; p < l; p++) {
        // number of values in row
        w[index[p]]++;
      } // cumulative sum


      var sum = 0; // initialize cptr with the cummulative sum of row counts

      for (var i = 0; i < rows; i++) {
        // update cptr
        cptr.push(sum); // update sum

        sum += w[i]; // update w

        w[i] = cptr[i];
      } // update cptr


      cptr.push(sum); // loop columns

      for (j = 0; j < columns; j++) {
        // values & index in column
        for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
          // C values & index
          var q = w[index[k]]++; // C[j, i] = A[i, j]

          cindex[q] = j; // check we need to process values (pattern matrix)

          if (values$$1) {
            cvalues[q] = clone(values$$1[k]);
          }
        }
      } // return matrix


      return m.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [columns, rows],
        datatype: m._datatype
      });
    }
  });

  var name$1x = 'ctranspose';
  var dependencies$1y = ['typed', 'transpose', 'conj'];
  var createCtranspose = /* #__PURE__ */factory(name$1x, dependencies$1y, function (_ref) {
    var typed = _ref.typed,
        transpose = _ref.transpose,
        conj = _ref.conj;

    /**
     * Transpose and complex conjugate a matrix. All values of the matrix are
     * reflected over its main diagonal and then the complex conjugate is
     * taken. This is equivalent to complex conjugation for scalars and
     * vectors.
     *
     * Syntax:
     *
     *     math.ctranspose(x)
     *
     * Examples:
     *
     *     const A = [[1, 2, 3], [4, 5, math.complex(6,7)]]
     *     math.ctranspose(A)               // returns [[1, 4], [2, 5], [3, {re:6,im:7}]]
     *
     * See also:
     *
     *     transpose, diag, inv, subset, squeeze
     *
     * @param {Array | Matrix} x  Matrix to be ctransposed
     * @return {Array | Matrix}   The ctransposed matrix
     */
    return typed(name$1x, {
      any: function any(x) {
        return conj(transpose(x));
      }
    });
  });

  var name$1y = 'zeros';
  var dependencies$1z = ['typed', 'config', 'matrix', 'BigNumber'];
  var createZeros = /* #__PURE__ */factory(name$1y, dependencies$1z, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        matrix = _ref.matrix,
        BigNumber = _ref.BigNumber;

    /**
     * Create a matrix filled with zeros. The created matrix can have one or
     * multiple dimensions.
     *
     * Syntax:
     *
     *    math.zeros(m)
     *    math.zeros(m, format)
     *    math.zeros(m, n)
     *    math.zeros(m, n, format)
     *    math.zeros([m, n])
     *    math.zeros([m, n], format)
     *
     * Examples:
     *
     *    math.zeros(3)                  // returns [0, 0, 0]
     *    math.zeros(3, 2)               // returns [[0, 0], [0, 0], [0, 0]]
     *    math.zeros(3, 'dense')         // returns [0, 0, 0]
     *
     *    const A = [[1, 2, 3], [4, 5, 6]]
     *    math.zeros(math.size(A))       // returns [[0, 0, 0], [0, 0, 0]]
     *
     * See also:
     *
     *    ones, identity, size, range
     *
     * @param {...number | Array} size    The size of each dimension of the matrix
     * @param {string} [format]           The Matrix storage format
     *
     * @return {Array | Matrix}           A matrix filled with zeros
     */
    return typed(name$1y, {
      '': function _() {
        return config.matrix === 'Array' ? _zeros([]) : _zeros([], 'default');
      },
      // math.zeros(m, n, p, ..., format)
      // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
      '...number | BigNumber | string': function numberBigNumberString(size) {
        var last$$1 = size[size.length - 1];

        if (typeof last$$1 === 'string') {
          var format$$1 = size.pop();
          return _zeros(size, format$$1);
        } else if (config.matrix === 'Array') {
          return _zeros(size);
        } else {
          return _zeros(size, 'default');
        }
      },
      Array: _zeros,
      Matrix: function Matrix(size) {
        var format$$1 = size.storage();
        return _zeros(size.valueOf(), format$$1);
      },
      'Array | Matrix, string': function ArrayMatrixString(size, format$$1) {
        return _zeros(size.valueOf(), format$$1);
      }
    });
    /**
     * Create an Array or Matrix with zeros
     * @param {Array} size
     * @param {string} [format='default']
     * @return {Array | Matrix}
     * @private
     */

    function _zeros(size, format$$1) {
      var hasBigNumbers = _normalize(size);

      var defaultValue = hasBigNumbers ? new BigNumber(0) : 0;

      _validate(size);

      if (format$$1) {
        // return a matrix
        var m = matrix(format$$1);

        if (size.length > 0) {
          return m.resize(size, defaultValue);
        }

        return m;
      } else {
        // return an Array
        var arr = [];

        if (size.length > 0) {
          return resize(arr, size, defaultValue);
        }

        return arr;
      }
    } // replace BigNumbers with numbers, returns true if size contained BigNumbers


    function _normalize(size) {
      var hasBigNumbers = false;
      size.forEach(function (value, index, arr) {
        if (isBigNumber(value)) {
          hasBigNumbers = true;
          arr[index] = value.toNumber();
        }
      });
      return hasBigNumbers;
    } // validate arguments


    function _validate(size) {
      size.forEach(function (value) {
        if (typeof value !== 'number' || !isInteger(value) || value < 0) {
          throw new Error('Parameters in function zeros must be positive integers');
        }
      });
    }
  }); // TODO: zeros contains almost the same code as ones. Reuse this?

  var name$1z = 'erf';
  var dependencies$1A = ['typed'];
  var createErf = /* #__PURE__ */factory(name$1z, dependencies$1A, function (_ref) {
    var typed = _ref.typed;

    /**
     * Compute the erf function of a value using a rational Chebyshev
     * approximations for different intervals of x.
     *
     * This is a translation of W. J. Cody's Fortran implementation from 1987
     * ( https://www.netlib.org/specfun/erf ). See the AMS publication
     * "Rational Chebyshev Approximations for the Error Function" by W. J. Cody
     * for an explanation of this process.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.erf(x)
     *
     * Examples:
     *
     *    math.erf(0.2)    // returns 0.22270258921047847
     *    math.erf(-0.5)   // returns -0.5204998778130465
     *    math.erf(4)      // returns 0.9999999845827421
     *
     * @param {number | Array | Matrix} x   A real number
     * @return {number | Array | Matrix}    The erf of `x`
     */
    return typed('name', {
      number: function number(x) {
        var y = Math.abs(x);

        if (y >= MAX_NUM) {
          return sign(x);
        }

        if (y <= THRESH) {
          return sign(x) * erf1(y);
        }

        if (y <= 4.0) {
          return sign(x) * (1 - erfc2(y));
        }

        return sign(x) * (1 - erfc3(y));
      },
      'Array | Matrix': function ArrayMatrix(n) {
        return deepMap(n, this);
      } // TODO: For complex numbers, use the approximation for the Faddeeva function
      //  from "More Efficient Computation of the Complex Error Function" (AMS)

    });
    /**
     * Approximates the error function erf() for x <= 0.46875 using this function:
     *               n
     * erf(x) = x * sum (p_j * x^(2j)) / (q_j * x^(2j))
     *              j=0
     */

    function erf1(y) {
      var ysq = y * y;
      var xnum = P[0][4] * ysq;
      var xden = ysq;
      var i;

      for (i = 0; i < 3; i += 1) {
        xnum = (xnum + P[0][i]) * ysq;
        xden = (xden + Q[0][i]) * ysq;
      }

      return y * (xnum + P[0][3]) / (xden + Q[0][3]);
    }
    /**
     * Approximates the complement of the error function erfc() for
     * 0.46875 <= x <= 4.0 using this function:
     *                       n
     * erfc(x) = e^(-x^2) * sum (p_j * x^j) / (q_j * x^j)
     *                      j=0
     */


    function erfc2(y) {
      var xnum = P[1][8] * y;
      var xden = y;
      var i;

      for (i = 0; i < 7; i += 1) {
        xnum = (xnum + P[1][i]) * y;
        xden = (xden + Q[1][i]) * y;
      }

      var result = (xnum + P[1][7]) / (xden + Q[1][7]);
      var ysq = parseInt(y * 16) / 16;
      var del = (y - ysq) * (y + ysq);
      return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
    }
    /**
     * Approximates the complement of the error function erfc() for x > 4.0 using
     * this function:
     *
     * erfc(x) = (e^(-x^2) / x) * [ 1/sqrt(pi) +
     *               n
     *    1/(x^2) * sum (p_j * x^(-2j)) / (q_j * x^(-2j)) ]
     *              j=0
     */


    function erfc3(y) {
      var ysq = 1 / (y * y);
      var xnum = P[2][5] * ysq;
      var xden = ysq;
      var i;

      for (i = 0; i < 4; i += 1) {
        xnum = (xnum + P[2][i]) * ysq;
        xden = (xden + Q[2][i]) * ysq;
      }

      var result = ysq * (xnum + P[2][4]) / (xden + Q[2][4]);
      result = (SQRPI - result) / y;
      ysq = parseInt(y * 16) / 16;
      var del = (y - ysq) * (y + ysq);
      return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
    }
  });
  /**
   * Upper bound for the first approximation interval, 0 <= x <= THRESH
   * @constant
   */

  var THRESH = 0.46875;
  /**
   * Constant used by W. J. Cody's Fortran77 implementation to denote sqrt(pi)
   * @constant
   */

  var SQRPI = 5.6418958354775628695e-1;
  /**
   * Coefficients for each term of the numerator sum (p_j) for each approximation
   * interval (see W. J. Cody's paper for more details)
   * @constant
   */

  var P = [[3.16112374387056560e00, 1.13864154151050156e02, 3.77485237685302021e02, 3.20937758913846947e03, 1.85777706184603153e-1], [5.64188496988670089e-1, 8.88314979438837594e00, 6.61191906371416295e01, 2.98635138197400131e02, 8.81952221241769090e02, 1.71204761263407058e03, 2.05107837782607147e03, 1.23033935479799725e03, 2.15311535474403846e-8], [3.05326634961232344e-1, 3.60344899949804439e-1, 1.25781726111229246e-1, 1.60837851487422766e-2, 6.58749161529837803e-4, 1.63153871373020978e-2]];
  /**
   * Coefficients for each term of the denominator sum (q_j) for each approximation
   * interval (see W. J. Cody's paper for more details)
   * @constant
   */

  var Q = [[2.36012909523441209e01, 2.44024637934444173e02, 1.28261652607737228e03, 2.84423683343917062e03], [1.57449261107098347e01, 1.17693950891312499e02, 5.37181101862009858e02, 1.62138957456669019e03, 3.29079923573345963e03, 4.36261909014324716e03, 3.43936767414372164e03, 1.23033935480374942e03], [2.56852019228982242e00, 1.87295284992346047e00, 5.27905102951428412e-1, 6.05183413124413191e-2, 2.33520497626869185e-3]];
  /**
   * Maximum/minimum safe numbers to input to erf() (in ES6+, this number is
   * Number.[MAX|MIN]_SAFE_INTEGER). erf() for all numbers beyond this limit will
   * return 1
   */

  var MAX_NUM = Math.pow(2, 53);

  var name$1A = 'mode';
  var dependencies$1B = ['typed', 'isNaN', 'isNumeric'];
  var createMode = /* #__PURE__ */factory(name$1A, dependencies$1B, function (_ref) {
    var typed = _ref.typed,
        isNaN = _ref.isNaN,
        isNumeric = _ref.isNumeric;

    /**
    * Computes the mode of a set of numbers or a list with values(numbers or characters).
    * If there are more than one modes, it returns a list of those values.
    *
    * Syntax:
    *
    *     math.mode(a, b, c, ...)
    *     math.mode(A)
    *
    * Examples:
    *
    *     math.mode(2, 1, 4, 3, 1)                            // returns [1]
    *     math.mode([1, 2.7, 3.2, 4, 2.7])                    // returns [2.7]
    *     math.mode(1, 4, 6, 1, 6)                             // returns [1, 6]
    *     math.mode('a','a','b','c')                           // returns ["a"]
    *     math.mode(1, 1.5, 'abc')                             // returns [1, 1.5, "abc"]
    *
    * See also:
    *
    *     median,
    *     mean
    *
    * @param {... *} args  A single matrix
    * @return {*} The mode of all values
    */
    return typed(name$1A, {
      'Array | Matrix': _mode,
      '...': function _(args) {
        return _mode(args);
      }
    });
    /**
     * Calculates the mode in an 1-dimensional array
     * @param {Array} values
     * @return {Array} mode
     * @private
     */

    function _mode(values) {
      values = flatten(values.valueOf());
      var num = values.length;

      if (num === 0) {
        throw new Error('Cannot calculate mode of an empty array');
      }

      var count = {};
      var mode = [];
      var max = 0;

      for (var i = 0; i < values.length; i++) {
        var value = values[i];

        if (isNumeric(value) && isNaN(value)) {
          throw new Error('Cannot calculate mode of an array containing NaN values');
        }

        if (!(value in count)) {
          count[value] = 0;
        }

        count[value]++;

        if (count[value] === max) {
          mode.push(value);
        } else if (count[value] > max) {
          max = count[value];
          mode = [value];
        }
      }

      return mode;
    }
  });

  /**
   * Improve error messages for statistics functions. Errors are typically
   * thrown in an internally used function like larger, causing the error
   * not to mention the function (like max) which is actually used by the user.
   *
   * @param {Error} err
   * @param {String} fnName
   * @param {*} [value]
   * @return {Error}
   */

  function improveErrorMessage(err, fnName, value) {
    // TODO: add information with the index (also needs transform in expression parser)
    var details;

    if (String(err).indexOf('Unexpected type') !== -1) {
      details = arguments.length > 2 ? ' (type: ' + typeOf(value) + ', value: ' + JSON.stringify(value) + ')' : ' (type: ' + err.data.actual + ')';
      return new TypeError('Cannot calculate ' + fnName + ', unexpected type of argument' + details);
    }

    if (String(err).indexOf('complex numbers') !== -1) {
      details = arguments.length > 2 ? ' (type: ' + typeOf(value) + ', value: ' + JSON.stringify(value) + ')' : '';
      return new TypeError('Cannot calculate ' + fnName + ', no ordering relation is defined for complex numbers' + details);
    }

    return err;
  }

  var name$1B = 'prod';
  var dependencies$1C = ['typed', 'config', 'multiplyScalar', 'numeric'];
  var createProd = /* #__PURE__ */factory(name$1B, dependencies$1C, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        multiplyScalar = _ref.multiplyScalar,
        numeric = _ref.numeric;

    /**
     * Compute the product of a matrix or a list with values.
     * In case of a (multi dimensional) array or matrix, the sum of all
     * elements will be calculated.
     *
     * Syntax:
     *
     *     math.prod(a, b, c, ...)
     *     math.prod(A)
     *
     * Examples:
     *
     *     math.multiply(2, 3)           // returns 6
     *     math.prod(2, 3)               // returns 6
     *     math.prod(2, 3, 4)            // returns 24
     *     math.prod([2, 3, 4])          // returns 24
     *     math.prod([[2, 5], [4, 3]])   // returns 120
     *
     * See also:
     *
     *    mean, median, min, max, sum, std, variance
     *
     * @param {... *} args  A single matrix or or multiple scalar values
     * @return {*} The product of all values
     */
    return typed(name$1B, {
      // prod([a, b, c, d, ...])
      'Array | Matrix': _prod,
      // prod([a, b, c, d, ...], dim)
      'Array | Matrix, number | BigNumber': function ArrayMatrixNumberBigNumber(array, dim) {
        // TODO: implement prod(A, dim)
        throw new Error('prod(A, dim) is not yet supported'); // return reduce(arguments[0], arguments[1], math.prod)
      },
      // prod(a, b, c, d, ...)
      '...': function _(args) {
        return _prod(args);
      }
    });
    /**
     * Recursively calculate the product of an n-dimensional array
     * @param {Array} array
     * @return {number} prod
     * @private
     */

    function _prod(array) {
      var prod;
      deepForEach(array, function (value) {
        try {
          prod = prod === undefined ? value : multiplyScalar(prod, value);
        } catch (err) {
          throw improveErrorMessage(err, 'prod', value);
        }
      }); // make sure returning numeric value: parse a string into a numeric value

      if (typeof prod === 'string') {
        prod = numeric(prod, config.number);
      }

      if (prod === undefined) {
        throw new Error('Cannot calculate prod of an empty array');
      }

      return prod;
    }
  });

  var name$1C = 'format';
  var dependencies$1D = ['typed'];
  var createFormat = /* #__PURE__ */factory(name$1C, dependencies$1D, function (_ref) {
    var typed = _ref.typed;

    /**
     * Format a value of any type into a string.
     *
     * Syntax:
     *
     *    math.format(value)
     *    math.format(value, options)
     *    math.format(value, precision)
     *    math.format(value, callback)
     *
     * Where:
     *
     *  - `value: *`
     *    The value to be formatted
     *  - `options: Object`
     *    An object with formatting options. Available options:
     *    - `notation: string`
     *      Number notation. Choose from:
     *      - 'fixed'
     *        Always use regular number notation.
     *        For example '123.40' and '14000000'
     *      - 'exponential'
     *        Always use exponential notation.
     *        For example '1.234e+2' and '1.4e+7'
     *      - 'engineering'
     *        Always use engineering notation: always have exponential notation,
     *        and select the exponent to be a multiple of 3.
     *        For example '123.4e+0' and '14.0e+6'
     *      - 'auto' (default)
     *        Regular number notation for numbers having an absolute value between
     *        `lower` and `upper` bounds, and uses exponential notation elsewhere.
     *        Lower bound is included, upper bound is excluded.
     *        For example '123.4' and '1.4e7'.
     *    - `precision: number`
     *      A number between 0 and 16 to round the digits of the number. In case
     *      of notations 'exponential', 'engineering', and 'auto', `precision`
     *      defines the total number of significant digits returned.
     *      In case of notation 'fixed', `precision` defines the number of
     *      significant digits after the decimal point.
     *      `precision` is undefined by default.
     *    - `lowerExp: number`
     *      Exponent determining the lower boundary for formatting a value with
     *      an exponent when `notation='auto`. Default value is `-3`.
     *    - `upperExp: number`
     *      Exponent determining the upper boundary for formatting a value with
     *      an exponent when `notation='auto`. Default value is `5`.
     *    - `fraction: string`. Available values: 'ratio' (default) or 'decimal'.
     *      For example `format(fraction(1, 3))` will output '1/3' when 'ratio' is
     *      configured, and will output `0.(3)` when 'decimal' is configured.
     * - `callback: function`
     *   A custom formatting function, invoked for all numeric elements in `value`,
     *   for example all elements of a matrix, or the real and imaginary
     *   parts of a complex number. This callback can be used to override the
     *   built-in numeric notation with any type of formatting. Function `callback`
     *   is called with `value` as parameter and must return a string.
     *
     * When `value` is an Object:
     *
     * - When the object contains a property `format` being a function, this function
     *   is invoked as `value.format(options)` and the result is returned.
     * - When the object has its own `toString` method, this method is invoked
     *   and the result is returned.
     * - In other cases the function will loop over all object properties and
     *   return JSON object notation like '{"a": 2, "b": 3}'.
     *
     * When value is a function:
     *
     * - When the function has a property `syntax`, it returns this
     *   syntax description.
     * - In other cases, a string `'function'` is returned.
     *
     * Examples:
     *
     *    math.format(6.4)                                        // returns '6.4'
     *    math.format(1240000)                                    // returns '1.24e6'
     *    math.format(1/3)                                        // returns '0.3333333333333333'
     *    math.format(1/3, 3)                                     // returns '0.333'
     *    math.format(21385, 2)                                   // returns '21000'
     *    math.format(12e8, {notation: 'fixed'})                  // returns '1200000000'
     *    math.format(2.3,  {notation: 'fixed', precision: 4})    // returns '2.3000'
     *    math.format(52.8, {notation: 'exponential'})            // returns '5.28e+1'
     *    math.format(12400,{notation: 'engineering'})            // returns '12.400e+3'
     *    math.format(2000, {lowerExp: -2, upperExp: 2})          // returns '2e+3'
     *
     *    function formatCurrency(value) {
     *      // return currency notation with two digits:
     *      return '$' + value.toFixed(2)
     *
     *      // you could also use math.format inside the callback:
     *      // return '$' + math.format(value, {notation: 'fixed', precision: 2})
     *    }
     *    math.format([2.1, 3, 0.016], formatCurrency}            // returns '[$2.10, $3.00, $0.02]'
     *
     * See also:
     *
     *    print
     *
     * @param {*} value                               Value to be stringified
     * @param {Object | Function | number} [options]  Formatting options
     * @return {string} The formatted value
     */
    return typed(name$1C, {
      any: format$2,
      'any, Object | function | number': format$2
    });
  });

  var name$1D = 'print';
  var dependencies$1E = ['typed'];
  var createPrint = /* #__PURE__ */factory(name$1D, dependencies$1E, function (_ref) {
    var typed = _ref.typed;

    /**
     * Interpolate values into a string template.
     *
     * Syntax:
     *
     *     math.print(template, values)
     *     math.print(template, values, precision)
     *     math.print(template, values, options)
     *
     * Example usage:
     *
     *     // the following outputs: 'Lucy is 5 years old'
     *     math.print('Lucy is $age years old', {age: 5})
     *
     *     // the following outputs: 'The value of pi is 3.141592654'
     *     math.print('The value of pi is $pi', {pi: math.pi}, 10)
     *
     *     // the following outputs: 'hello Mary! The date is 2013-03-23'
     *     math.print('Hello $user.name! The date is $date', {
     *       user: {
     *         name: 'Mary',
     *       },
     *       date: new Date(2013, 2, 23).toISOString().substring(0, 10)
     *     })
     *
     *     // the following outputs: 'My favorite fruits are apples and bananas !'
     *     math.print('My favorite fruits are $0 and $1 !', [
     *       'apples',
     *       'bananas'
     *     ])
     *
     * See also:
     *
     *     format
     *
     * @param {string} template           A string containing variable placeholders.
     * @param {Object | Array | Matrix}   values An object or array containing variables
     *                                    which will be filled in in the template.
     * @param {number | Object} [options] Formatting options,
     *                                    or the number of digits to format numbers.
     *                                    See function math.format for a description
     *                                    of all options.
     * @return {string} Interpolated string
     */
    return typed(name$1D, {
      // note: Matrix will be converted automatically to an Array
      'string, Object | Array': _print,
      'string, Object | Array, number | Object': _print
    });
  });
  /**
   * Interpolate values into a string template.
   * @param {string} template
   * @param {Object} values
   * @param {number | Object} [options]
   * @returns {string} Interpolated string
   * @private
   */

  function _print(template, values, options) {
    return template.replace(/\$([\w.]+)/g, function (original, key) {
      var keys = key.split('.');
      var value = values[keys.shift()];

      while (keys.length && value !== undefined) {
        var k = keys.shift();
        value = k ? value[k] : value + '.';
      }

      if (value !== undefined) {
        if (!isString(value)) {
          return format$2(value, options);
        } else {
          return value;
        }
      }

      return original;
    });
  }

  var name$1E = 'to';
  var dependencies$1F = ['typed', 'matrix'];
  var createTo = /* #__PURE__ */factory(name$1E, dependencies$1F, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix;
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Change the unit of a value.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.to(x, unit)
     *
     * Examples:
     *
     *    math.to(math.unit('2 inch'), 'cm')                   // returns Unit 5.08 cm
     *    math.to(math.unit('2 inch'), math.unit(null, 'cm'))  // returns Unit 5.08 cm
     *    math.to(math.unit(16, 'bytes'), 'bits')              // returns Unit 128 bits
     *
     * See also:
     *
     *    unit
     *
     * @param {Unit | Array | Matrix} x     The unit to be converted.
     * @param {Unit | Array | Matrix} unit  New unit. Can be a string like "cm"
     *                                      or a unit without value.
     * @return {Unit | Array | Matrix} value with changed, fixed unit.
     */

    return typed(name$1E, {
      'Unit, Unit | string': function UnitUnitString(x, unit) {
        return x.to(unit);
      },
      'Matrix, Matrix': function MatrixMatrix(x, y) {
        // SparseMatrix does not support Units
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'Matrix, any': function MatrixAny(x, y) {
        // SparseMatrix does not support Units
        return algorithm14(x, y, this, false);
      },
      'any, Matrix': function anyMatrix(x, y) {
        // SparseMatrix does not support Units
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  var name$1F = 'isPrime';
  var dependencies$1G = ['typed'];
  var createIsPrime = /* #__PURE__ */factory(name$1F, dependencies$1G, function (_ref) {
    var typed = _ref.typed;

    /**
     * Test whether a value is prime: has no divisors other than itself and one.
     * The function supports type `number`, `bignumber`.
     *
     * The function is evaluated element-wise in case of Array or Matrix input.
     *
     * Syntax:
     *
     *     math.isPrime(x)
     *
     * Examples:
     *
     *    math.isPrime(3)                     // returns true
     *    math.isPrime(-2)                    // returns false
     *    math.isPrime(0)                     // returns false
     *    math.isPrime(-0)                    // returns false
     *    math.isPrime(0.5)                   // returns false
     *    math.isPrime('2')                   // returns true
     *    math.isPrime([2, 17, 100])           // returns [true, true, false]
     *
     * See also:
     *
     *    isNumeric, isZero, isNegative, isInteger
     *
     * @param {number | BigNumber | Array | Matrix} x  Value to be tested
     * @return {boolean}  Returns true when `x` is larger than zero.
     *                    Throws an error in case of an unknown data type.
     */
    return typed(name$1F, {
      number: function number(x) {
        if (x * 0 !== 0) {
          return false;
        }

        if (x <= 3) {
          return x > 1;
        }

        if (x % 2 === 0 || x % 3 === 0) {
          return false;
        }

        for (var i = 5; i * i <= x; i += 6) {
          if (x % i === 0 || x % (i + 2) === 0) {
            return false;
          }
        }

        return true;
      },
      BigNumber: function BigNumber(n) {
        if (n.toNumber() * 0 !== 0) {
          return false;
        }

        if (n.lte(3)) return n.gt(1);
        if (n.mod(2).eq(0) || n.mod(3).eq(0)) return false;

        for (var i = 5; n.gte(i * i); i += 6) {
          if (n.mod(i).eq(0) || n.mod(i + 2).eq(0)) {
            return false;
          }
        }

        return true;
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$1G = 'numeric';
  var dependencies$1H = ['number', '?bignumber', '?fraction'];
  var createNumeric = /* #__PURE__ */factory(name$1G, dependencies$1H, function (_ref) {
    var _number = _ref.number,
        bignumber = _ref.bignumber,
        fraction = _ref.fraction;
    var validInputTypes = {
      string: true,
      number: true,
      BigNumber: true,
      Fraction: true
    }; // Load the conversion functions for each output type

    var validOutputTypes = {
      number: function number(x) {
        return _number(x);
      },
      BigNumber: bignumber ? function (x) {
        return bignumber(x);
      } : noBignumber,
      Fraction: fraction ? function (x) {
        return fraction(x);
      } : noFraction
    };
    /**
     * Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.
     *
     * Syntax:
     *
     *    math.numeric(x)
     *
     * Examples:
     *
     *    math.numeric('4')                           // returns number 4
     *    math.numeric('4', 'number')                 // returns number 4
     *    math.numeric('4', 'BigNumber')              // returns BigNumber 4
     *    math.numeric('4', 'Fraction')               // returns Fraction 4
     *    math.numeric(4, 'Fraction')                 // returns Fraction 4
     *    math.numeric(math.fraction(2, 5), 'number') // returns number 0.4
     *
     * See also:
     *
     *    number, fraction, bignumber, string, format
     *
     * @param {string | number | BigNumber | Fraction } value
     *              A numeric value or a string containing a numeric value
     * @param {string} outputType
     *              Desired numeric output type.
     *              Available values: 'number', 'BigNumber', or 'Fraction'
     * @return {number | BigNumber | Fraction}
     *              Returns an instance of the numeric in the requested type
     */

    return function numeric(value, outputType) {
      var inputType = typeOf(value);

      if (!(inputType in validInputTypes)) {
        throw new TypeError('Cannot convert ' + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(', '));
      }

      if (!(outputType in validOutputTypes)) {
        throw new TypeError('Cannot convert ' + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(', '));
      }

      if (outputType === inputType) {
        return value;
      } else {
        return validOutputTypes[outputType](value);
      }
    };
  });

  var name$1H = 'divideScalar';
  var dependencies$1I = ['typed', 'numeric'];
  var createDivideScalar = /* #__PURE__ */factory(name$1H, dependencies$1I, function (_ref) {
    var typed = _ref.typed,
        numeric = _ref.numeric;

    /**
     * Divide two scalar values, `x / y`.
     * This function is meant for internal use: it is used by the public functions
     * `divide` and `inv`.
     *
     * This function does not support collections (Array or Matrix).
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit} x   Numerator
     * @param  {number | BigNumber | Fraction | Complex} y          Denominator
     * @return {number | BigNumber | Fraction | Complex | Unit}     Quotient, `x / y`
     * @private
     */
    return typed(name$1H, {
      'number, number': function numberNumber(x, y) {
        return x / y;
      },
      'Complex, Complex': function ComplexComplex(x, y) {
        return x.div(y);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.div(y);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.div(y);
      },
      'Unit, number | Fraction | BigNumber': function UnitNumberFractionBigNumber(x, y) {
        var res = x.clone(); // TODO: move the divide function to Unit.js, it uses internals of Unit

        var one = numeric(1, typeOf(y));
        res.value = this(res.value === null ? res._normalize(one) : res.value, y);
        return res;
      },
      'number | Fraction | BigNumber, Unit': function numberFractionBigNumberUnit(x, y) {
        var res = y.clone();
        res = res.pow(-1); // TODO: move the divide function to Unit.js, it uses internals of Unit

        var one = numeric(1, typeOf(x));
        res.value = this(x, y.value === null ? y._normalize(one) : y.value);
        return res;
      },
      'Unit, Unit': function UnitUnit(x, y) {
        return x.divide(y);
      }
    });
  });

  var name$1I = 'pow';
  var dependencies$1J = ['typed', 'config', 'identity', 'multiply', 'matrix', 'fraction', 'number', 'Complex'];
  var createPow = /* #__PURE__ */factory(name$1I, dependencies$1J, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        identity = _ref.identity,
        multiply = _ref.multiply,
        matrix = _ref.matrix,
        number = _ref.number,
        fraction = _ref.fraction,
        Complex = _ref.Complex;

    /**
     * Calculates the power of x to y, `x ^ y`.
     * Matrix exponentiation is supported for square matrices `x`, and positive
     * integer exponents `y`.
     *
     * For cubic roots of negative numbers, the function returns the principal
     * root by default. In order to let the function return the real root,
     * math.js can be configured with `math.config({predictable: true})`.
     * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.
     *
     * Syntax:
     *
     *    math.pow(x, y)
     *
     * Examples:
     *
     *    math.pow(2, 3)               // returns number 8
     *
     *    const a = math.complex(2, 3)
     *    math.pow(a, 2)                // returns Complex -5 + 12i
     *
     *    const b = [[1, 2], [4, 3]]
     *    math.pow(b, 2)               // returns Array [[9, 8], [16, 17]]
     *
     * See also:
     *
     *    multiply, sqrt, cbrt, nthRoot
     *
     * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base
     * @param  {number | BigNumber | Complex} y                          The exponent
     * @return {number | BigNumber | Complex | Array | Matrix} The value of `x` to the power `y`
     */
    return typed(name$1I, {
      'number, number': _pow,
      'Complex, Complex': function ComplexComplex(x, y) {
        return x.pow(y);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        if (y.isInteger() || x >= 0 || config.predictable) {
          return x.pow(y);
        } else {
          return new Complex(x.toNumber(), 0).pow(y.toNumber(), 0);
        }
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        if (y.d !== 1) {
          if (config.predictable) {
            throw new Error('Function pow does not support non-integer exponents for fractions.');
          } else {
            return _pow(x.valueOf(), y.valueOf());
          }
        } else {
          return x.pow(y);
        }
      },
      'Array, number': _powArray,
      'Array, BigNumber': function ArrayBigNumber(x, y) {
        return _powArray(x, y.toNumber());
      },
      'Matrix, number': _powMatrix,
      'Matrix, BigNumber': function MatrixBigNumber(x, y) {
        return _powMatrix(x, y.toNumber());
      },
      'Unit, number | BigNumber': function UnitNumberBigNumber(x, y) {
        return x.pow(y);
      }
    });
    /**
     * Calculates the power of x to y, x^y, for two numbers.
     * @param {number} x
     * @param {number} y
     * @return {number | Complex} res
     * @private
     */

    function _pow(x, y) {
      // Alternatively could define a 'realmode' config option or something, but
      // 'predictable' will work for now
      if (config.predictable && !isInteger(y) && x < 0) {
        // Check to see if y can be represented as a fraction
        try {
          var yFrac = fraction(y);
          var yNum = number(yFrac);

          if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
            if (yFrac.d % 2 === 1) {
              return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
            }
          }
        } catch (ex) {// fraction() throws an error if y is Infinity, etc.
        } // Unable to express y as a fraction, so continue on

      } // **for predictable mode** x^Infinity === NaN if x < -1
      // N.B. this behavour is different from `Math.pow` which gives
      // (-2)^Infinity === Infinity


      if (config.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
        return NaN;
      }

      if (isInteger(y) || x >= 0 || config.predictable) {
        return powNumber(x, y);
      } else {
        // TODO: the following infinity checks are duplicated from powNumber. Deduplicate this somehow
        // x^Infinity === 0 if -1 < x < 1
        // A real number 0 is returned instead of complex(0)
        if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
          return 0;
        }

        return new Complex(x, 0).pow(y, 0);
      }
    }
    /**
     * Calculate the power of a 2d array
     * @param {Array} x     must be a 2 dimensional, square matrix
     * @param {number} y    a positive, integer value
     * @returns {Array}
     * @private
     */


    function _powArray(x, y) {
      if (!isInteger(y) || y < 0) {
        throw new TypeError('For A^b, b must be a positive integer (value is ' + y + ')');
      } // verify that A is a 2 dimensional square matrix


      var s = arraySize(x);

      if (s.length !== 2) {
        throw new Error('For A^b, A must be 2 dimensional (A has ' + s.length + ' dimensions)');
      }

      if (s[0] !== s[1]) {
        throw new Error('For A^b, A must be square (size is ' + s[0] + 'x' + s[1] + ')');
      }

      var res = identity(s[0]).valueOf();
      var px = x;

      while (y >= 1) {
        if ((y & 1) === 1) {
          res = multiply(px, res);
        }

        y >>= 1;
        px = multiply(px, px);
      }

      return res;
    }
    /**
     * Calculate the power of a 2d matrix
     * @param {Matrix} x     must be a 2 dimensional, square matrix
     * @param {number} y    a positive, integer value
     * @returns {Matrix}
     * @private
     */


    function _powMatrix(x, y) {
      return matrix(_powArray(x.valueOf(), y));
    }
  });

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  var NO_INT = 'Number of decimals in function round must be an integer';
  var name$1J = 'round';
  var dependencies$1K = ['typed', 'matrix', 'equalScalar', 'zeros', 'BigNumber', 'DenseMatrix'];
  var createRound = /* #__PURE__ */factory(name$1J, dependencies$1K, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar,
        zeros = _ref.zeros,
        BigNumber = _ref.BigNumber,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm11 = createAlgorithm11({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm12 = createAlgorithm12({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Round a value towards the nearest integer.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.round(x)
     *    math.round(x, n)
     *
     * Examples:
     *
     *    math.round(3.2)              // returns number 3
     *    math.round(3.8)              // returns number 4
     *    math.round(-4.2)             // returns number -4
     *    math.round(-4.7)             // returns number -5
     *    math.round(math.pi, 3)       // returns number 3.142
     *    math.round(123.45678, 2)     // returns number 123.46
     *
     *    const c = math.complex(3.2, -2.7)
     *    math.round(c)                // returns Complex 3 - 3i
     *
     *    math.round([3.2, 3.8, -4.7]) // returns Array [3, 4, -5]
     *
     * See also:
     *
     *    ceil, fix, floor
     *
     * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
     * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
     * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
     */

    return typed(name$1J, _objectSpread(_objectSpread({}, roundNumberSignatures), {}, {
      Complex: function Complex(x) {
        return x.round();
      },
      'Complex, number': function ComplexNumber(x, n) {
        if (n % 1) {
          throw new TypeError(NO_INT);
        }

        return x.round(n);
      },
      'Complex, BigNumber': function ComplexBigNumber(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }

        var _n = n.toNumber();

        return x.round(_n);
      },
      'number, BigNumber': function numberBigNumber(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }

        return new BigNumber(x).toDecimalPlaces(n.toNumber());
      },
      BigNumber: function BigNumber(x) {
        return x.toDecimalPlaces(0);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }

        return x.toDecimalPlaces(n.toNumber());
      },
      Fraction: function Fraction(x) {
        return x.round();
      },
      'Fraction, number': function FractionNumber(x, n) {
        if (n % 1) {
          throw new TypeError(NO_INT);
        }

        return x.round(n);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since round(0) = 0
        return deepMap(x, this, true);
      },
      'SparseMatrix, number | BigNumber': function SparseMatrixNumberBigNumber(x, y) {
        return algorithm11(x, y, this, false);
      },
      'DenseMatrix, number | BigNumber': function DenseMatrixNumberBigNumber(x, y) {
        return algorithm14(x, y, this, false);
      },
      'number | Complex | BigNumber, SparseMatrix': function numberComplexBigNumberSparseMatrix(x, y) {
        // check scalar is zero
        if (equalScalar(x, 0)) {
          // do not execute algorithm, result will be a zero matrix
          return zeros(y.size(), y.storage());
        }

        return algorithm12(y, x, this, true);
      },
      'number | Complex | BigNumber, DenseMatrix': function numberComplexBigNumberDenseMatrix(x, y) {
        // check scalar is zero
        if (equalScalar(x, 0)) {
          // do not execute algorithm, result will be a zero matrix
          return zeros(y.size(), y.storage());
        }

        return algorithm14(y, x, this, true);
      },
      'Array, number | BigNumber': function ArrayNumberBigNumber(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'number | Complex | BigNumber, Array': function numberComplexBigNumberArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    }));
  });
  var roundNumberSignatures = {
    number: roundNumber,
    'number, number': function numberNumber(x, n) {
      if (!isInteger(n)) {
        throw new TypeError(NO_INT);
      }

      if (n < 0 || n > 15) {
        throw new Error('Number of decimals in function round must be in te range of 0-15');
      }

      return roundNumber(x, n);
    }
  };
  var createRoundNumber = /* #__PURE__ */factory(name$1J, ['typed'], function (_ref2) {
    var typed = _ref2.typed;
    return typed(name$1J, roundNumberSignatures);
  });

  var name$1K = 'log';
  var dependencies$1L = ['config', 'typed', 'divideScalar', 'Complex'];
  var createLog = /* #__PURE__ */factory(name$1K, dependencies$1L, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        divideScalar = _ref.divideScalar,
        Complex = _ref.Complex;

    /**
     * Calculate the logarithm of a value.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.log(x)
     *    math.log(x, base)
     *
     * Examples:
     *
     *    math.log(3.5)                  // returns 1.252762968495368
     *    math.exp(math.log(2.4))        // returns 2.4
     *
     *    math.pow(10, 4)                // returns 10000
     *    math.log(10000, 10)            // returns 4
     *    math.log(10000) / math.log(10) // returns 4
     *
     *    math.log(1024, 2)              // returns 10
     *    math.pow(2, 10)                // returns 1024
     *
     * See also:
     *
     *    exp, log2, log10, log1p
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x
     *            Value for which to calculate the logarithm.
     * @param {number | BigNumber | Complex} [base=e]
     *            Optional base for the logarithm. If not provided, the natural
     *            logarithm of `x` is calculated.
     * @return {number | BigNumber | Complex | Array | Matrix}
     *            Returns the logarithm of `x`
     */
    return typed(name$1K, {
      number: function number(x) {
        if (x >= 0 || config.predictable) {
          return logNumber(x);
        } else {
          // negative value -> complex value computation
          return new Complex(x, 0).log();
        }
      },
      Complex: function Complex(x) {
        return x.log();
      },
      BigNumber: function BigNumber(x) {
        if (!x.isNegative() || config.predictable) {
          return x.ln();
        } else {
          // downgrade to number, return Complex valued result
          return new Complex(x.toNumber(), 0).log();
        }
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      },
      'any, any': function anyAny(x, base) {
        // calculate logarithm for a specified base, log(x, base)
        return divideScalar(this(x), this(base));
      }
    });
  });

  var name$1L = 'log1p';
  var dependencies$1M = ['typed', 'config', 'divideScalar', 'log', 'Complex'];
  var createLog1p = /* #__PURE__ */factory(name$1L, dependencies$1M, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        divideScalar = _ref.divideScalar,
        log = _ref.log,
        Complex = _ref.Complex;

    /**
     * Calculate the logarithm of a `value+1`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.log1p(x)
     *    math.log1p(x, base)
     *
     * Examples:
     *
     *    math.log1p(2.5)                 // returns 1.252762968495368
     *    math.exp(math.log1p(1.4))       // returns 2.4
     *
     *    math.pow(10, 4)                 // returns 10000
     *    math.log1p(9999, 10)            // returns 4
     *    math.log1p(9999) / math.log(10) // returns 4
     *
     * See also:
     *
     *    exp, log, log2, log10
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x
     *            Value for which to calculate the logarithm of `x+1`.
     * @param {number | BigNumber | Complex} [base=e]
     *            Optional base for the logarithm. If not provided, the natural
     *            logarithm of `x+1` is calculated.
     * @return {number | BigNumber | Complex | Array | Matrix}
     *            Returns the logarithm of `x+1`
     */
    return typed(name$1L, {
      number: function number(x) {
        if (x >= -1 || config.predictable) {
          return log1p(x);
        } else {
          // negative value -> complex value computation
          return _log1pComplex(new Complex(x, 0));
        }
      },
      Complex: _log1pComplex,
      BigNumber: function BigNumber(x) {
        var y = x.plus(1);

        if (!y.isNegative() || config.predictable) {
          return y.ln();
        } else {
          // downgrade to number, return Complex valued result
          return _log1pComplex(new Complex(x.toNumber(), 0));
        }
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      },
      'any, any': function anyAny(x, base) {
        // calculate logarithm for a specified base, log1p(x, base)
        return divideScalar(this(x), log(base));
      }
    });
    /**
     * Calculate the natural logarithm of a complex number + 1
     * @param {Complex} x
     * @returns {Complex}
     * @private
     */

    function _log1pComplex(x) {
      var xRe1p = x.re + 1;
      return new Complex(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));
    }
  });

  var name$1M = 'nthRoots';
  var dependencies$1N = ['config', 'typed', 'divideScalar', 'Complex'];
  var createNthRoots = /* #__PURE__ */factory(name$1M, dependencies$1N, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        divideScalar = _ref.divideScalar,
        Complex = _ref.Complex;

    /**
     * Each function here returns a real multiple of i as a Complex value.
     * @param  {number} val
     * @return {Complex} val, i*val, -val or -i*val for index 0, 1, 2, 3
     */
    // This is used to fix float artifacts for zero-valued components.
    var _calculateExactResult = [function realPos(val) {
      return new Complex(val, 0);
    }, function imagPos(val) {
      return new Complex(0, val);
    }, function realNeg(val) {
      return new Complex(-val, 0);
    }, function imagNeg(val) {
      return new Complex(0, -val);
    }];
    /**
     * Calculate the nth root of a Complex Number a using De Movire's Theorem.
     * @param  {Complex} a
     * @param  {number} root
     * @return {Array} array of n Complex Roots
     */

    function _nthComplexRoots(a, root) {
      if (root < 0) throw new Error('Root must be greater than zero');
      if (root === 0) throw new Error('Root must be non-zero');
      if (root % 1 !== 0) throw new Error('Root must be an integer');
      if (a === 0 || a.abs() === 0) return [new Complex(0, 0)];
      var aIsNumeric = typeof a === 'number';
      var offset; // determine the offset (argument of a)/(pi/2)

      if (aIsNumeric || a.re === 0 || a.im === 0) {
        if (aIsNumeric) {
          offset = 2 * +(a < 0); // numeric value on the real axis
        } else if (a.im === 0) {
          offset = 2 * +(a.re < 0); // complex value on the real axis
        } else {
          offset = 2 * +(a.im < 0) + 1; // complex value on the imaginary axis
        }
      }

      var arg = a.arg();
      var abs = a.abs();
      var roots = [];
      var r = Math.pow(abs, 1 / root);

      for (var k = 0; k < root; k++) {
        var halfPiFactor = (offset + 4 * k) / root;
        /**
         * If (offset + 4*k)/root is an integral multiple of pi/2
         * then we can produce a more exact result.
         */

        if (halfPiFactor === Math.round(halfPiFactor)) {
          roots.push(_calculateExactResult[halfPiFactor % 4](r));
          continue;
        }

        roots.push(new Complex({
          r: r,
          phi: (arg + 2 * Math.PI * k) / root
        }));
      }

      return roots;
    }
    /**
     * Calculate the nth roots of a value.
     * An nth root of a positive real number A,
     * is a positive real solution of the equation "x^root = A".
     * This function returns an array of complex values.
     *
     * Syntax:
     *
     *    math.nthRoots(x)
     *    math.nthRoots(x, root)
     *
     * Examples:
     *
     *    math.nthRoots(1)
     *    // returns [
     *    //   {re: 1, im: 0},
     *    //   {re: -1, im: 0}
     *    // ]
     *    nthRoots(1, 3)
     *    // returns [
     *    //   { re: 1, im: 0 },
     *    //   { re: -0.4999999999999998, im: 0.8660254037844387 },
     *    //   { re: -0.5000000000000004, im: -0.8660254037844385 }
     *    ]
     *
     * See also:
     *
     *    nthRoot, pow, sqrt
     *
     * @param {number | BigNumber | Fraction | Complex} x Number to be rounded
     * @return {number | BigNumber | Fraction | Complex}            Rounded value
     */


    return typed(name$1M, {
      Complex: function Complex(x) {
        return _nthComplexRoots(x, 2);
      },
      'Complex, number': _nthComplexRoots
    });
  });

  var name$1N = 'dotPow';
  var dependencies$1O = ['typed', 'equalScalar', 'matrix', 'pow', 'DenseMatrix'];
  var createDotPow = /* #__PURE__ */factory(name$1N, dependencies$1O, function (_ref) {
    var typed = _ref.typed,
        equalScalar = _ref.equalScalar,
        matrix = _ref.matrix,
        pow = _ref.pow,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm03 = createAlgorithm03({
      typed: typed
    });
    var algorithm07 = createAlgorithm07({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm11 = createAlgorithm11({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm12 = createAlgorithm12({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Calculates the power of x to y element wise.
     *
     * Syntax:
     *
     *    math.dotPow(x, y)
     *
     * Examples:
     *
     *    math.dotPow(2, 3)            // returns number 8
     *
     *    const a = [[1, 2], [4, 3]]
     *    math.dotPow(a, 2)            // returns Array [[1, 4], [16, 9]]
     *    math.pow(a, 2)               // returns Array [[9, 8], [16, 17]]
     *
     * See also:
     *
     *    pow, sqrt, multiply
     *
     * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base
     * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y  The exponent
     * @return {number | BigNumber | Complex | Unit | Array | Matrix}                     The value of `x` to the power `y`
     */

    return typed(name$1N, {
      'any, any': pow,
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, pow, false);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, pow, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, pow, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, pow);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm11(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  var name$1O = 'dotDivide';
  var dependencies$1P = ['typed', 'matrix', 'equalScalar', 'divideScalar', 'DenseMatrix'];
  var createDotDivide = /* #__PURE__ */factory(name$1O, dependencies$1P, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar,
        divideScalar = _ref.divideScalar,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm02 = createAlgorithm02({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm03 = createAlgorithm03({
      typed: typed
    });
    var algorithm07 = createAlgorithm07({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm11 = createAlgorithm11({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm12 = createAlgorithm12({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Divide two matrices element wise. The function accepts both matrices and
     * scalar values.
     *
     * Syntax:
     *
     *    math.dotDivide(x, y)
     *
     * Examples:
     *
     *    math.dotDivide(2, 4)   // returns 0.5
     *
     *    a = [[9, 5], [6, 1]]
     *    b = [[3, 2], [5, 2]]
     *
     *    math.dotDivide(a, b)   // returns [[3, 2.5], [1.2, 0.5]]
     *    math.divide(a, b)      // returns [[1.75, 0.75], [-1.75, 2.25]]
     *
     * See also:
     *
     *    divide, multiply, dotMultiply
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Numerator
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Denominator
     * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Quotient, `x ./ y`
     */

    return typed(name$1O, {
      'any, any': divideScalar,
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, divideScalar, false);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, divideScalar, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, divideScalar, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, divideScalar);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm11(x, y, divideScalar, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, divideScalar, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, divideScalar, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, divideScalar, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, divideScalar, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, divideScalar, true).valueOf();
      }
    });
  });

  function createSolveValidation(_ref) {
    var DenseMatrix = _ref.DenseMatrix;

    /**
     * Validates matrix and column vector b for backward/forward substitution algorithms.
     *
     * @param {Matrix} m            An N x N matrix
     * @param {Array | Matrix} b    A column vector
     * @param {Boolean} copy        Return a copy of vector b
     *
     * @return {DenseMatrix}        Dense column vector b
     */
    return function solveValidation(m, b, copy) {
      // matrix size
      var size = m.size(); // validate matrix dimensions

      if (size.length !== 2) {
        throw new RangeError('Matrix must be two dimensional (size: ' + format$2(size) + ')');
      } // rows & columns


      var rows = size[0];
      var columns = size[1]; // validate rows & columns

      if (rows !== columns) {
        throw new RangeError('Matrix must be square (size: ' + format$2(size) + ')');
      } // vars


      var data, i, bdata; // check b is matrix

      if (isMatrix(b)) {
        // matrix size
        var msize = b.size(); // vector

        if (msize.length === 1) {
          // check vector length
          if (msize[0] !== rows) {
            throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
          } // create data array


          data = []; // matrix data (DenseMatrix)

          bdata = b._data; // loop b data

          for (i = 0; i < rows; i++) {
            // row array
            data[i] = [bdata[i]];
          } // return Dense Matrix


          return new DenseMatrix({
            data: data,
            size: [rows, 1],
            datatype: b._datatype
          });
        } // two dimensions


        if (msize.length === 2) {
          // array must be a column vector
          if (msize[0] !== rows || msize[1] !== 1) {
            throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
          } // check matrix type


          if (isDenseMatrix(b)) {
            // check a copy is needed
            if (copy) {
              // create data array
              data = []; // matrix data (DenseMatrix)

              bdata = b._data; // loop b data

              for (i = 0; i < rows; i++) {
                // row array
                data[i] = [bdata[i][0]];
              } // return Dense Matrix


              return new DenseMatrix({
                data: data,
                size: [rows, 1],
                datatype: b._datatype
              });
            } // b is already a column vector


            return b;
          } // create data array


          data = [];

          for (i = 0; i < rows; i++) {
            data[i] = [0];
          } // sparse matrix arrays


          var values = b._values;
          var index = b._index;
          var ptr = b._ptr; // loop values in column 0

          for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
            // row
            i = index[k]; // add to data

            data[i][0] = values[k];
          } // return Dense Matrix


          return new DenseMatrix({
            data: data,
            size: [rows, 1],
            datatype: b._datatype
          });
        } // throw error


        throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
      } // check b is array


      if (isArray(b)) {
        // size
        var asize = arraySize(b); // check matrix dimensions, vector

        if (asize.length === 1) {
          // check vector length
          if (asize[0] !== rows) {
            throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
          } // create data array


          data = []; // loop b

          for (i = 0; i < rows; i++) {
            // row array
            data[i] = [b[i]];
          } // return Dense Matrix


          return new DenseMatrix({
            data: data,
            size: [rows, 1]
          });
        }

        if (asize.length === 2) {
          // array must be a column vector
          if (asize[0] !== rows || asize[1] !== 1) {
            throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
          } // create data array


          data = []; // loop b data

          for (i = 0; i < rows; i++) {
            // row array
            data[i] = [b[i][0]];
          } // return Dense Matrix


          return new DenseMatrix({
            data: data,
            size: [rows, 1]
          });
        } // throw error


        throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
      }
    };
  }

  var name$1P = 'lsolve';
  var dependencies$1Q = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];
  var createLsolve = /* #__PURE__ */factory(name$1P, dependencies$1Q, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        divideScalar = _ref.divideScalar,
        multiplyScalar = _ref.multiplyScalar,
        subtract = _ref.subtract,
        equalScalar = _ref.equalScalar,
        DenseMatrix = _ref.DenseMatrix;
    var solveValidation = createSolveValidation({
      DenseMatrix: DenseMatrix
    });
    /**
     * Solves the linear equation system by forwards substitution. Matrix must be a lower triangular matrix.
     *
     * `L * x = b`
     *
     * Syntax:
     *
     *    math.lsolve(L, b)
     *
     * Examples:
     *
     *    const a = [[-2, 3], [2, 1]]
     *    const b = [11, 9]
     *    const x = lsolve(a, b)  // [[-5.5], [20]]
     *
     * See also:
     *
     *    lup, slu, usolve, lusolve
     *
     * @param {Matrix, Array} L       A N x N matrix or array (L)
     * @param {Matrix, Array} b       A column vector with the b values
     *
     * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)
     */

    return typed(name$1P, {
      'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {
        // process matrix
        return _sparseForwardSubstitution(m, b);
      },
      'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {
        // process matrix
        return _denseForwardSubstitution(m, b);
      },
      'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {
        // create dense matrix from array
        var m = matrix(a); // use matrix implementation

        var r = _denseForwardSubstitution(m, b); // result


        return r.valueOf();
      }
    });

    function _denseForwardSubstitution(m, b) {
      // validate matrix and vector, return copy of column vector b
      b = solveValidation(m, b, true); // column vector data

      var bdata = b._data; // rows & columns

      var rows = m._size[0];
      var columns = m._size[1]; // result

      var x = []; // data

      var data = m._data; // forward solve m * x = b, loop columns

      for (var j = 0; j < columns; j++) {
        // b[j]
        var bj = bdata[j][0] || 0; // x[j]

        var xj = void 0; // forward substitution (outer product) avoids inner looping when bj === 0

        if (!equalScalar(bj, 0)) {
          // value @ [j, j]
          var vjj = data[j][j]; // check vjj

          if (equalScalar(vjj, 0)) {
            // system cannot be solved
            throw new Error('Linear system cannot be solved since matrix is singular');
          } // calculate xj


          xj = divideScalar(bj, vjj); // loop rows

          for (var i = j + 1; i < rows; i++) {
            // update copy of b
            bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, data[i][j]))];
          }
        } else {
          // zero @ j
          xj = 0;
        } // update x


        x[j] = [xj];
      } // return vector


      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }

    function _sparseForwardSubstitution(m, b) {
      // validate matrix and vector, return copy of column vector b
      b = solveValidation(m, b, true); // column vector data

      var bdata = b._data; // rows & columns

      var rows = m._size[0];
      var columns = m._size[1]; // matrix arrays

      var values = m._values;
      var index = m._index;
      var ptr = m._ptr; // vars

      var i, k; // result

      var x = []; // forward solve m * x = b, loop columns

      for (var j = 0; j < columns; j++) {
        // b[j]
        var bj = bdata[j][0] || 0; // forward substitution (outer product) avoids inner looping when bj === 0

        if (!equalScalar(bj, 0)) {
          // value @ [j, j]
          var vjj = 0; // lower triangular matrix values & index (column j)

          var jvalues = [];
          var jindex = []; // last index in column

          var l = ptr[j + 1]; // values in column, find value @ [j, j]

          for (k = ptr[j]; k < l; k++) {
            // row
            i = index[k]; // check row (rows are not sorted!)

            if (i === j) {
              // update vjj
              vjj = values[k];
            } else if (i > j) {
              // store lower triangular
              jvalues.push(values[k]);
              jindex.push(i);
            }
          } // at this point we must have a value @ [j, j]


          if (equalScalar(vjj, 0)) {
            // system cannot be solved, there is no value @ [j, j]
            throw new Error('Linear system cannot be solved since matrix is singular');
          } // calculate xj


          var xj = divideScalar(bj, vjj); // loop lower triangular

          for (k = 0, l = jindex.length; k < l; k++) {
            // row
            i = jindex[k]; // update copy of b

            bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, jvalues[k]))];
          } // update x


          x[j] = [xj];
        } else {
          // update x
          x[j] = [0];
        }
      } // return vector


      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }
  });

  var name$1Q = 'usolve';
  var dependencies$1R = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];
  var createUsolve = /* #__PURE__ */factory(name$1Q, dependencies$1R, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        divideScalar = _ref.divideScalar,
        multiplyScalar = _ref.multiplyScalar,
        subtract = _ref.subtract,
        equalScalar = _ref.equalScalar,
        DenseMatrix = _ref.DenseMatrix;
    var solveValidation = createSolveValidation({
      DenseMatrix: DenseMatrix
    });
    /**
     * Solves the linear equation system by backward substitution. Matrix must be an upper triangular matrix.
     *
     * `U * x = b`
     *
     * Syntax:
     *
     *    math.usolve(U, b)
     *
     * Examples:
     *
     *    const a = [[-2, 3], [2, 1]]
     *    const b = [11, 9]
     *    const x = usolve(a, b)  // [[8], [9]]
     *
     * See also:
     *
     *    lup, slu, usolve, lusolve
     *
     * @param {Matrix, Array} U       A N x N matrix or array (U)
     * @param {Matrix, Array} b       A column vector with the b values
     *
     * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)
     */

    return typed(name$1Q, {
      'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {
        // process matrix
        return _sparseBackwardSubstitution(m, b);
      },
      'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {
        // process matrix
        return _denseBackwardSubstitution(m, b);
      },
      'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {
        // create dense matrix from array
        var m = matrix(a); // use matrix implementation

        var r = _denseBackwardSubstitution(m, b); // result


        return r.valueOf();
      }
    });

    function _denseBackwardSubstitution(m, b) {
      // validate matrix and vector, return copy of column vector b
      b = solveValidation(m, b, true); // column vector data

      var bdata = b._data; // rows & columns

      var rows = m._size[0];
      var columns = m._size[1]; // result

      var x = []; // arrays

      var data = m._data; // backward solve m * x = b, loop columns (backwards)

      for (var j = columns - 1; j >= 0; j--) {
        // b[j]
        var bj = bdata[j][0] || 0; // x[j]

        var xj = void 0; // backward substitution (outer product) avoids inner looping when bj === 0

        if (!equalScalar(bj, 0)) {
          // value @ [j, j]
          var vjj = data[j][j]; // check vjj

          if (equalScalar(vjj, 0)) {
            // system cannot be solved
            throw new Error('Linear system cannot be solved since matrix is singular');
          } // calculate xj


          xj = divideScalar(bj, vjj); // loop rows

          for (var i = j - 1; i >= 0; i--) {
            // update copy of b
            bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, data[i][j]))];
          }
        } else {
          // zero value @ j
          xj = 0;
        } // update x


        x[j] = [xj];
      } // return column vector


      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }

    function _sparseBackwardSubstitution(m, b) {
      // validate matrix and vector, return copy of column vector b
      b = solveValidation(m, b, true); // column vector data

      var bdata = b._data; // rows & columns

      var rows = m._size[0];
      var columns = m._size[1]; // matrix arrays

      var values = m._values;
      var index = m._index;
      var ptr = m._ptr; // vars

      var i, k; // result

      var x = []; // backward solve m * x = b, loop columns (backwards)

      for (var j = columns - 1; j >= 0; j--) {
        // b[j]
        var bj = bdata[j][0] || 0; // backward substitution (outer product) avoids inner looping when bj === 0

        if (!equalScalar(bj, 0)) {
          // value @ [j, j]
          var vjj = 0; // upper triangular matrix values & index (column j)

          var jvalues = [];
          var jindex = []; // first & last indeces in column

          var f = ptr[j];
          var l = ptr[j + 1]; // values in column, find value @ [j, j], loop backwards

          for (k = l - 1; k >= f; k--) {
            // row
            i = index[k]; // check row

            if (i === j) {
              // update vjj
              vjj = values[k];
            } else if (i < j) {
              // store upper triangular
              jvalues.push(values[k]);
              jindex.push(i);
            }
          } // at this point we must have a value @ [j, j]


          if (equalScalar(vjj, 0)) {
            // system cannot be solved, there is no value @ [j, j]
            throw new Error('Linear system cannot be solved since matrix is singular');
          } // calculate xj


          var xj = divideScalar(bj, vjj); // loop upper triangular

          for (k = 0, l = jindex.length; k < l; k++) {
            // row
            i = jindex[k]; // update copy of b

            bdata[i] = [subtract(bdata[i][0], multiplyScalar(xj, jvalues[k]))];
          } // update x


          x[j] = [xj];
        } else {
          // update x
          x[j] = [0];
        }
      } // return vector


      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }
  });

  var name$1R = 'algorithm08';
  var dependencies$1S = ['typed', 'equalScalar'];
  var createAlgorithm08 = /* #__PURE__ */factory(name$1R, dependencies$1S, function (_ref) {
    var typed = _ref.typed,
        equalScalar = _ref.equalScalar;

    /**
     * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
     * Callback function invoked MAX(NNZA, NNZB) times
     *
     *
     *            f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
     * C(i,j) =   A(i,j)       ; A(i,j) !== 0
     *            0            ; otherwise
     *
     *
     * @param {Matrix}   a                 The SparseMatrix instance (A)
     * @param {Matrix}   b                 The SparseMatrix instance (B)
     * @param {Function} callback          The f(Aij,Bij) operation to invoke
     *
     * @return {Matrix}                    SparseMatrix (C)
     *
     * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
     */
    return function algorithm08(a, b, callback) {
      // sparse matrix arrays
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype; // sparse matrix arrays

      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype; // validate dimensions

      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      } // check rows & columns


      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
      } // sparse matrix cannot be a Pattern matrix


      if (!avalues || !bvalues) {
        throw new Error('Cannot perform operation on Pattern Sparse Matrices');
      } // rows & columns


      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string' && adt === bdt) {
        // datatype
        dt = adt; // find signature that matches (dt, dt)

        eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

        zero = typed.convert(0, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // result arrays


      var cvalues = [];
      var cindex = [];
      var cptr = []; // workspace

      var x = []; // marks indicating we have a value in x for a given column

      var w = []; // vars

      var k, k0, k1, i; // loop columns

      for (var j = 0; j < columns; j++) {
        // update cptr
        cptr[j] = cindex.length; // columns mark

        var mark = j + 1; // loop values in a

        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          // row
          i = aindex[k]; // mark workspace

          w[i] = mark; // set value

          x[i] = avalues[k]; // add index

          cindex.push(i);
        } // loop values in b


        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          // row
          i = bindex[k]; // check value exists in workspace

          if (w[i] === mark) {
            // evaluate callback
            x[i] = cf(x[i], bvalues[k]);
          }
        } // initialize first index in j


        k = cptr[j]; // loop index in j

        while (k < cindex.length) {
          // row
          i = cindex[k]; // value @ i

          var v = x[i]; // check for zero value

          if (!eq(v, zero)) {
            // push value
            cvalues.push(v); // increment pointer

            k++;
          } else {
            // remove value @ i, do not increment pointer
            cindex.splice(k, 1);
          }
        }
      } // update cptr


      cptr[columns] = cindex.length; // return sparse matrix

      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$1S = 'leftShift';
  var dependencies$1T = ['typed', 'matrix', 'equalScalar', 'zeros', 'DenseMatrix'];
  var createLeftShift = /* #__PURE__ */factory(name$1S, dependencies$1T, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar,
        zeros = _ref.zeros,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm01 = createAlgorithm01({
      typed: typed
    });
    var algorithm02 = createAlgorithm02({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm08 = createAlgorithm08({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm10 = createAlgorithm10({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm11 = createAlgorithm11({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Bitwise left logical shift of a value x by y number of bits, `x << y`.
     * For matrices, the function is evaluated element wise.
     * For units, the function is evaluated on the best prefix base.
     *
     * Syntax:
     *
     *    math.leftShift(x, y)
     *
     * Examples:
     *
     *    math.leftShift(1, 2)               // returns number 4
     *
     *    math.leftShift([1, 2, 3], 4)       // returns Array [16, 32, 64]
     *
     * See also:
     *
     *    leftShift, bitNot, bitOr, bitXor, rightArithShift, rightLogShift
     *
     * @param  {number | BigNumber | Array | Matrix} x Value to be shifted
     * @param  {number | BigNumber} y Amount of shifts
     * @return {number | BigNumber | Array | Matrix} `x` shifted left `y` times
     */

    return typed(name$1S, {
      'number, number': leftShiftNumber,
      'BigNumber, BigNumber': leftShiftBigNumber,
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm08(x, y, this, false);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm01(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, number | BigNumber': function SparseMatrixNumberBigNumber(x, y) {
        // check scalar
        if (equalScalar(y, 0)) {
          return x.clone();
        }

        return algorithm11(x, y, this, false);
      },
      'DenseMatrix, number | BigNumber': function DenseMatrixNumberBigNumber(x, y) {
        // check scalar
        if (equalScalar(y, 0)) {
          return x.clone();
        }

        return algorithm14(x, y, this, false);
      },
      'number | BigNumber, SparseMatrix': function numberBigNumberSparseMatrix(x, y) {
        // check scalar
        if (equalScalar(x, 0)) {
          return zeros(y.size(), y.storage());
        }

        return algorithm10(y, x, this, true);
      },
      'number | BigNumber, DenseMatrix': function numberBigNumberDenseMatrix(x, y) {
        // check scalar
        if (equalScalar(x, 0)) {
          return zeros(y.size(), y.storage());
        }

        return algorithm14(y, x, this, true);
      },
      'Array, number | BigNumber': function ArrayNumberBigNumber(x, y) {
        // use matrix implementation
        return this(matrix(x), y).valueOf();
      },
      'number | BigNumber, Array': function numberBigNumberArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y)).valueOf();
      }
    });
  });

  var name$1T = 'rightArithShift';
  var dependencies$1U = ['typed', 'matrix', 'equalScalar', 'zeros', 'DenseMatrix'];
  var createRightArithShift = /* #__PURE__ */factory(name$1T, dependencies$1U, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar,
        zeros = _ref.zeros,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm01 = createAlgorithm01({
      typed: typed
    });
    var algorithm02 = createAlgorithm02({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm08 = createAlgorithm08({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm10 = createAlgorithm10({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm11 = createAlgorithm11({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Bitwise right arithmetic shift of a value x by y number of bits, `x >> y`.
     * For matrices, the function is evaluated element wise.
     * For units, the function is evaluated on the best prefix base.
     *
     * Syntax:
     *
     *    math.rightArithShift(x, y)
     *
     * Examples:
     *
     *    math.rightArithShift(4, 2)               // returns number 1
     *
     *    math.rightArithShift([16, -32, 64], 4)   // returns Array [1, -2, 3]
     *
     * See also:
     *
     *    bitAnd, bitNot, bitOr, bitXor, rightArithShift, rightLogShift
     *
     * @param  {number | BigNumber | Array | Matrix} x Value to be shifted
     * @param  {number | BigNumber} y Amount of shifts
     * @return {number | BigNumber | Array | Matrix} `x` sign-filled shifted right `y` times
     */

    return typed(name$1T, {
      'number, number': rightArithShiftNumber,
      'BigNumber, BigNumber': rightArithShiftBigNumber,
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm08(x, y, this, false);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm01(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, number | BigNumber': function SparseMatrixNumberBigNumber(x, y) {
        // check scalar
        if (equalScalar(y, 0)) {
          return x.clone();
        }

        return algorithm11(x, y, this, false);
      },
      'DenseMatrix, number | BigNumber': function DenseMatrixNumberBigNumber(x, y) {
        // check scalar
        if (equalScalar(y, 0)) {
          return x.clone();
        }

        return algorithm14(x, y, this, false);
      },
      'number | BigNumber, SparseMatrix': function numberBigNumberSparseMatrix(x, y) {
        // check scalar
        if (equalScalar(x, 0)) {
          return zeros(y.size(), y.storage());
        }

        return algorithm10(y, x, this, true);
      },
      'number | BigNumber, DenseMatrix': function numberBigNumberDenseMatrix(x, y) {
        // check scalar
        if (equalScalar(x, 0)) {
          return zeros(y.size(), y.storage());
        }

        return algorithm14(y, x, this, true);
      },
      'Array, number | BigNumber': function ArrayNumberBigNumber(x, y) {
        // use matrix implementation
        return this(matrix(x), y).valueOf();
      },
      'number | BigNumber, Array': function numberBigNumberArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y)).valueOf();
      }
    });
  });

  var name$1U = 'rightLogShift';
  var dependencies$1V = ['typed', 'matrix', 'equalScalar', 'zeros', 'DenseMatrix'];
  var createRightLogShift = /* #__PURE__ */factory(name$1U, dependencies$1V, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar,
        zeros = _ref.zeros,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm01 = createAlgorithm01({
      typed: typed
    });
    var algorithm02 = createAlgorithm02({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm08 = createAlgorithm08({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm10 = createAlgorithm10({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm11 = createAlgorithm11({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Bitwise right logical shift of value x by y number of bits, `x >>> y`.
     * For matrices, the function is evaluated element wise.
     * For units, the function is evaluated on the best prefix base.
     *
     * Syntax:
     *
     *    math.rightLogShift(x, y)
     *
     * Examples:
     *
     *    math.rightLogShift(4, 2)               // returns number 1
     *
     *    math.rightLogShift([16, -32, 64], 4)   // returns Array [1, 2, 3]
     *
     * See also:
     *
     *    bitAnd, bitNot, bitOr, bitXor, leftShift, rightLogShift
     *
     * @param  {number | Array | Matrix} x Value to be shifted
     * @param  {number} y Amount of shifts
     * @return {number | Array | Matrix} `x` zero-filled shifted right `y` times
     */

    return typed(name$1U, {
      'number, number': rightLogShiftNumber,
      // 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm08(x, y, this, false);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm01(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, number | BigNumber': function SparseMatrixNumberBigNumber(x, y) {
        // check scalar
        if (equalScalar(y, 0)) {
          return x.clone();
        }

        return algorithm11(x, y, this, false);
      },
      'DenseMatrix, number | BigNumber': function DenseMatrixNumberBigNumber(x, y) {
        // check scalar
        if (equalScalar(y, 0)) {
          return x.clone();
        }

        return algorithm14(x, y, this, false);
      },
      'number | BigNumber, SparseMatrix': function numberBigNumberSparseMatrix(x, y) {
        // check scalar
        if (equalScalar(x, 0)) {
          return zeros(y.size(), y.storage());
        }

        return algorithm10(y, x, this, true);
      },
      'number | BigNumber, DenseMatrix': function numberBigNumberDenseMatrix(x, y) {
        // check scalar
        if (equalScalar(x, 0)) {
          return zeros(y.size(), y.storage());
        }

        return algorithm14(y, x, this, true);
      },
      'Array, number | BigNumber': function ArrayNumberBigNumber(x, y) {
        // use matrix implementation
        return this(matrix(x), y).valueOf();
      },
      'number | BigNumber, Array': function numberBigNumberArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y)).valueOf();
      }
    });
  });

  var name$1V = 'and';
  var dependencies$1W = ['typed', 'matrix', 'equalScalar', 'zeros', 'not'];
  var createAnd = /* #__PURE__ */factory(name$1V, dependencies$1W, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar,
        zeros = _ref.zeros,
        not = _ref.not;
    var algorithm02 = createAlgorithm02({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm06 = createAlgorithm06({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm11 = createAlgorithm11({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Logical `and`. Test whether two values are both defined with a nonzero/nonempty value.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.and(x, y)
     *
     * Examples:
     *
     *    math.and(2, 4)   // returns true
     *
     *    a = [2, 0, 0]
     *    b = [3, 7, 0]
     *    c = 0
     *
     *    math.and(a, b)   // returns [true, false, false]
     *    math.and(a, c)   // returns [false, false, false]
     *
     * See also:
     *
     *    not, or, xor
     *
     * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
     * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y Second value to check
     * @return {boolean | Array | Matrix}
     *            Returns true when both inputs are defined with a nonzero/nonempty value.
     */

    return typed(name$1V, {
      'number, number': andNumber,
      'Complex, Complex': function ComplexComplex(x, y) {
        return (x.re !== 0 || x.im !== 0) && (y.re !== 0 || y.im !== 0);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return !x.isZero() && !y.isZero() && !x.isNaN() && !y.isNaN();
      },
      'Unit, Unit': function UnitUnit(x, y) {
        return this(x.value || 0, y.value || 0);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm06(x, y, this, false);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm02(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm02(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        // check scalar
        if (not(y)) {
          // return zero matrix
          return zeros(x.size(), x.storage());
        }

        return algorithm11(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        // check scalar
        if (not(y)) {
          // return zero matrix
          return zeros(x.size(), x.storage());
        }

        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        // check scalar
        if (not(x)) {
          // return zero matrix
          return zeros(x.size(), x.storage());
        }

        return algorithm11(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        // check scalar
        if (not(x)) {
          // return zero matrix
          return zeros(x.size(), x.storage());
        }

        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return this(matrix(x), y).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y)).valueOf();
      }
    });
  });

  var name$1W = 'compare';
  var dependencies$1X = ['typed', 'config', 'matrix', 'equalScalar', 'BigNumber', 'Fraction', 'DenseMatrix'];
  var createCompare = /* #__PURE__ */factory(name$1W, dependencies$1X, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        equalScalar = _ref.equalScalar,
        matrix = _ref.matrix,
        BigNumber = _ref.BigNumber,
        Fraction = _ref.Fraction,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm03 = createAlgorithm03({
      typed: typed
    });
    var algorithm05 = createAlgorithm05({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm12 = createAlgorithm12({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.
     *
     * x and y are considered equal when the relative difference between x and y
     * is smaller than the configured epsilon. The function cannot be used to
     * compare values smaller than approximately 2.22e-16.
     *
     * For matrices, the function is evaluated element wise.
     * Strings are compared by their numerical value.
     *
     * Syntax:
     *
     *    math.compare(x, y)
     *
     * Examples:
     *
     *    math.compare(6, 1)           // returns 1
     *    math.compare(2, 3)           // returns -1
     *    math.compare(7, 7)           // returns 0
     *    math.compare('10', '2')      // returns 1
     *    math.compare('1000', '1e3')  // returns 0
     *
     *    const a = math.unit('5 cm')
     *    const b = math.unit('40 mm')
     *    math.compare(a, b)           // returns 1
     *
     *    math.compare(2, [1, 2, 3])   // returns [1, 0, -1]
     *
     * See also:
     *
     *    equal, unequal, smaller, smallerEq, larger, largerEq, compareNatural, compareText
     *
     * @param  {number | BigNumber | Fraction | Unit | string | Array | Matrix} x First value to compare
     * @param  {number | BigNumber | Fraction | Unit | string | Array | Matrix} y Second value to compare
     * @return {number | BigNumber | Fraction | Array | Matrix} Returns the result of the comparison:
     *                                                          1 when x > y, -1 when x < y, and 0 when x == y.
     */

    return typed(name$1W, {
      'boolean, boolean': function booleanBoolean(x, y) {
        return x === y ? 0 : x > y ? 1 : -1;
      },
      'number, number': function numberNumber(x, y) {
        return nearlyEqual(x, y, config.epsilon) ? 0 : x > y ? 1 : -1;
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return nearlyEqual$1(x, y, config.epsilon) ? new BigNumber(0) : new BigNumber(x.cmp(y));
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return new Fraction(x.compare(y));
      },
      'Complex, Complex': function ComplexComplex() {
        throw new TypeError('No ordering relation is defined for complex numbers');
      },
      'Unit, Unit': function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error('Cannot compare units with different base');
        }

        return this(x.value, y.value);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm05(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });
  var createCompareNumber = /* #__PURE__ */factory(name$1W, ['typed', 'config'], function (_ref2) {
    var typed = _ref2.typed,
        config = _ref2.config;
    return typed(name$1W, {
      'number, number': function numberNumber(x, y) {
        return nearlyEqual(x, y, config.epsilon) ? 0 : x > y ? 1 : -1;
      }
    });
  });

  /*
   * Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license
   * Author: Jim Palmer (based on chunking idea from Dave Koelle)
   */
  /*jshint unused:false */
  var naturalSort = function naturalSort (a, b) {
  	var re = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,
  		sre = /(^[ ]*|[ ]*$)/g,
  		dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
  		hre = /^0x[0-9a-f]+$/i,
  		ore = /^0/,
  		i = function(s) { return naturalSort.insensitive && ('' + s).toLowerCase() || '' + s; },
  		// convert all to strings strip whitespace
  		x = i(a).replace(sre, '') || '',
  		y = i(b).replace(sre, '') || '',
  		// chunk/tokenize
  		xN = x.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
  		yN = y.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
  		// numeric, hex or date detection
  		xD = parseInt(x.match(hre), 16) || (xN.length !== 1 && x.match(dre) && Date.parse(x)),
  		yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null,
  		oFxNcL, oFyNcL;
  	// first try and sort Hex codes or Dates
  	if (yD) {
  		if ( xD < yD ) { return -1; }
  		else if ( xD > yD ) { return 1; }
  	}
  	// natural sorting through split numeric strings and default strings
  	for(var cLoc=0, numS=Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
  		// find floats not starting with '0', string or 0 if not defined (Clint Priest)
  		oFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
  		oFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
  		// handle numeric vs string comparison - number < string - (Kyle Adams)
  		if (isNaN(oFxNcL) !== isNaN(oFyNcL)) { return (isNaN(oFxNcL)) ? 1 : -1; }
  		// rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'
  		else if (typeof oFxNcL !== typeof oFyNcL) {
  			oFxNcL += '';
  			oFyNcL += '';
  		}
  		if (oFxNcL < oFyNcL) { return -1; }
  		if (oFxNcL > oFyNcL) { return 1; }
  	}
  	return 0;
  };

  var name$1X = 'compareNatural';
  var dependencies$1Y = ['typed', 'compare'];
  var createCompareNatural = /* #__PURE__ */factory(name$1X, dependencies$1Y, function (_ref) {
    var typed = _ref.typed,
        compare = _ref.compare;
    var compareBooleans = compare.signatures['boolean,boolean'];
    /**
     * Compare two values of any type in a deterministic, natural way.
     *
     * For numeric values, the function works the same as `math.compare`.
     * For types of values that can't be compared mathematically,
     * the function compares in a natural way.
     *
     * For numeric values, x and y are considered equal when the relative
     * difference between x and y is smaller than the configured epsilon.
     * The function cannot be used to compare values smaller than
     * approximately 2.22e-16.
     *
     * For Complex numbers, first the real parts are compared. If equal,
     * the imaginary parts are compared.
     *
     * Strings are compared with a natural sorting algorithm, which
     * orders strings in a "logic" way following some heuristics.
     * This differs from the function `compare`, which converts the string
     * into a numeric value and compares that. The function `compareText`
     * on the other hand compares text lexically.
     *
     * Arrays and Matrices are compared value by value until there is an
     * unequal pair of values encountered. Objects are compared by sorted
     * keys until the keys or their values are unequal.
     *
     * Syntax:
     *
     *    math.compareNatural(x, y)
     *
     * Examples:
     *
     *    math.compareNatural(6, 1)              // returns 1
     *    math.compareNatural(2, 3)              // returns -1
     *    math.compareNatural(7, 7)              // returns 0
     *
     *    math.compareNatural('10', '2')         // returns 1
     *    math.compareText('10', '2')            // returns -1
     *    math.compare('10', '2')                // returns 1
     *
     *    math.compareNatural('Answer: 10', 'Answer: 2') // returns 1
     *    math.compareText('Answer: 10', 'Answer: 2')    // returns -1
     *    math.compare('Answer: 10', 'Answer: 2')
     *        // Error: Cannot convert "Answer: 10" to a number
     *
     *    const a = math.unit('5 cm')
     *    const b = math.unit('40 mm')
     *    math.compareNatural(a, b)              // returns 1
     *
     *    const c = math.complex('2 + 3i')
     *    const d = math.complex('2 + 4i')
     *    math.compareNatural(c, d)              // returns -1
     *
     *    math.compareNatural([1, 2, 4], [1, 2, 3]) // returns 1
     *    math.compareNatural([1, 2, 3], [1, 2])    // returns 1
     *    math.compareNatural([1, 5], [1, 2, 3])    // returns 1
     *    math.compareNatural([1, 2], [1, 2])       // returns 0
     *
     *    math.compareNatural({a: 2}, {a: 4})       // returns -1
     *
     * See also:
     *
     *    compare, compareText
     *
     * @param  {*} x First value to compare
     * @param  {*} y Second value to compare
     * @return {number} Returns the result of the comparison:
     *                  1 when x > y, -1 when x < y, and 0 when x == y.
     */

    return typed(name$1X, {
      'any, any': function anyAny(x, y) {
        var typeX = typeOf(x);
        var typeY = typeOf(y);
        var c; // numeric types

        if ((typeX === 'number' || typeX === 'BigNumber' || typeX === 'Fraction') && (typeY === 'number' || typeY === 'BigNumber' || typeY === 'Fraction')) {
          c = compare(x, y);

          if (c.toString() !== '0') {
            // c can be number, BigNumber, or Fraction
            return c > 0 ? 1 : -1; // return a number
          } else {
            return naturalSort(typeX, typeY);
          }
        } // matrix types


        if (typeX === 'Array' || typeX === 'Matrix' || typeY === 'Array' || typeY === 'Matrix') {
          c = compareMatricesAndArrays(this, x, y);

          if (c !== 0) {
            return c;
          } else {
            return naturalSort(typeX, typeY);
          }
        } // in case of different types, order by name of type, i.e. 'BigNumber' < 'Complex'


        if (typeX !== typeY) {
          return naturalSort(typeX, typeY);
        }

        if (typeX === 'Complex') {
          return compareComplexNumbers(x, y);
        }

        if (typeX === 'Unit') {
          if (x.equalBase(y)) {
            return this(x.value, y.value);
          } // compare by units


          return compareArrays(this, x.formatUnits(), y.formatUnits());
        }

        if (typeX === 'boolean') {
          return compareBooleans(x, y);
        }

        if (typeX === 'string') {
          return naturalSort(x, y);
        }

        if (typeX === 'Object') {
          return compareObjects(this, x, y);
        }

        if (typeX === 'null') {
          return 0;
        }

        if (typeX === 'undefined') {
          return 0;
        } // this should not occur...


        throw new TypeError('Unsupported type of value "' + typeX + '"');
      }
    });
    /**
     * Compare mixed matrix/array types, by converting to same-shaped array.
     * This comparator is non-deterministic regarding input types.
     * @param {Array | SparseMatrix | DenseMatrix | *} x
     * @param {Array | SparseMatrix | DenseMatrix | *} y
     * @returns {number} Returns the comparison result: -1, 0, or 1
     */

    function compareMatricesAndArrays(compareNatural, x, y) {
      if (isSparseMatrix(x) && isSparseMatrix(y)) {
        return compareArrays(compareNatural, x.toJSON().values, y.toJSON().values);
      }

      if (isSparseMatrix(x)) {
        // note: convert to array is expensive
        return compareMatricesAndArrays(compareNatural, x.toArray(), y);
      }

      if (isSparseMatrix(y)) {
        // note: convert to array is expensive
        return compareMatricesAndArrays(compareNatural, x, y.toArray());
      } // convert DenseArray into Array


      if (isDenseMatrix(x)) {
        return compareMatricesAndArrays(compareNatural, x.toJSON().data, y);
      }

      if (isDenseMatrix(y)) {
        return compareMatricesAndArrays(compareNatural, x, y.toJSON().data);
      } // convert scalars to array


      if (!Array.isArray(x)) {
        return compareMatricesAndArrays(compareNatural, [x], y);
      }

      if (!Array.isArray(y)) {
        return compareMatricesAndArrays(compareNatural, x, [y]);
      }

      return compareArrays(compareNatural, x, y);
    }
    /**
     * Compare two Arrays
     *
     * - First, compares value by value
     * - Next, if all corresponding values are equal,
     *   look at the length: longest array will be considered largest
     *
     * @param {Array} x
     * @param {Array} y
     * @returns {number} Returns the comparison result: -1, 0, or 1
     */


    function compareArrays(compareNatural, x, y) {
      // compare each value
      for (var i = 0, ii = Math.min(x.length, y.length); i < ii; i++) {
        var v = compareNatural(x[i], y[i]);

        if (v !== 0) {
          return v;
        }
      } // compare the size of the arrays


      if (x.length > y.length) {
        return 1;
      }

      if (x.length < y.length) {
        return -1;
      } // both Arrays have equal size and content


      return 0;
    }
    /**
     * Compare two objects
     *
     * - First, compare sorted property names
     * - Next, compare the property values
     *
     * @param {Object} x
     * @param {Object} y
     * @returns {number} Returns the comparison result: -1, 0, or 1
     */


    function compareObjects(compareNatural, x, y) {
      var keysX = Object.keys(x);
      var keysY = Object.keys(y); // compare keys

      keysX.sort(naturalSort);
      keysY.sort(naturalSort);
      var c = compareArrays(compareNatural, keysX, keysY);

      if (c !== 0) {
        return c;
      } // compare values


      for (var i = 0; i < keysX.length; i++) {
        var v = compareNatural(x[keysX[i]], y[keysY[i]]);

        if (v !== 0) {
          return v;
        }
      }

      return 0;
    }
  });
  /**
   * Compare two complex numbers, `x` and `y`:
   *
   * - First, compare the real values of `x` and `y`
   * - If equal, compare the imaginary values of `x` and `y`
   *
   * @params {Complex} x
   * @params {Complex} y
   * @returns {number} Returns the comparison result: -1, 0, or 1
   */

  function compareComplexNumbers(x, y) {
    if (x.re > y.re) {
      return 1;
    }

    if (x.re < y.re) {
      return -1;
    }

    if (x.im > y.im) {
      return 1;
    }

    if (x.im < y.im) {
      return -1;
    }

    return 0;
  }

  var name$1Y = 'compareText';
  var dependencies$1Z = ['typed', 'matrix'];
  var createCompareText = /* #__PURE__ */factory(name$1Y, dependencies$1Z, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix;
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Compare two strings lexically. Comparison is case sensitive.
     * Returns 1 when x > y, -1 when x < y, and 0 when x == y.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.compareText(x, y)
     *
     * Examples:
     *
     *    math.compareText('B', 'A')     // returns 1
     *    math.compareText('2', '10')    // returns 1
     *    math.compare('2', '10')        // returns -1
     *    math.compareNatural('2', '10') // returns -1
     *
     *    math.compareText('B', ['A', 'B', 'C']) // returns [1, 0, -1]
     *
     * See also:
     *
     *    equal, equalText, compare, compareNatural
     *
     * @param  {string | Array | DenseMatrix} x First string to compare
     * @param  {string | Array | DenseMatrix} y Second string to compare
     * @return {number | Array | DenseMatrix} Returns the result of the comparison:
     *                                        1 when x > y, -1 when x < y, and 0 when x == y.
     */

    return typed(name$1Y, {
      'any, any': compareText,
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, compareText);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, compareText, false);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, compareText, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, compareText, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, compareText, true).valueOf();
      }
    });
  });
  var createCompareTextNumber = /* #__PURE__ */factory(name$1Y, ['typed'], function (_ref2) {
    var typed = _ref2.typed;
    return typed(name$1Y, {
      'any, any': compareText
    });
  });

  var name$1Z = 'equal';
  var dependencies$1_ = ['typed', 'matrix', 'equalScalar', 'DenseMatrix'];
  var createEqual = /* #__PURE__ */factory(name$1Z, dependencies$1_, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm03 = createAlgorithm03({
      typed: typed
    });
    var algorithm07 = createAlgorithm07({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Test whether two values are equal.
     *
     * The function tests whether the relative difference between x and y is
     * smaller than the configured epsilon. The function cannot be used to
     * compare values smaller than approximately 2.22e-16.
     *
     * For matrices, the function is evaluated element wise.
     * In case of complex numbers, x.re must equal y.re, and x.im must equal y.im.
     *
     * Values `null` and `undefined` are compared strictly, thus `null` is only
     * equal to `null` and nothing else, and `undefined` is only equal to
     * `undefined` and nothing else. Strings are compared by their numerical value.
     *
     * Syntax:
     *
     *    math.equal(x, y)
     *
     * Examples:
     *
     *    math.equal(2 + 2, 3)         // returns false
     *    math.equal(2 + 2, 4)         // returns true
     *
     *    const a = math.unit('50 cm')
     *    const b = math.unit('5 m')
     *    math.equal(a, b)             // returns true
     *
     *    const c = [2, 5, 1]
     *    const d = [2, 7, 1]
     *
     *    math.equal(c, d)             // returns [true, false, true]
     *    math.deepEqual(c, d)         // returns false
     *
     *    math.equal("1000", "1e3")    // returns true
     *    math.equal(0, null)          // returns false
     *
     * See also:
     *
     *    unequal, smaller, smallerEq, larger, largerEq, compare, deepEqual, equalText
     *
     * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} x First value to compare
     * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} y Second value to compare
     * @return {boolean | Array | Matrix} Returns true when the compared values are equal, else returns false
     */

    return typed(name$1Z, {
      'any, any': function anyAny(x, y) {
        // strict equality for null and undefined?
        if (x === null) {
          return y === null;
        }

        if (y === null) {
          return x === null;
        }

        if (x === undefined) {
          return y === undefined;
        }

        if (y === undefined) {
          return x === undefined;
        }

        return equalScalar(x, y);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, equalScalar);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, equalScalar, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, equalScalar, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, equalScalar);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm12(x, y, equalScalar, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, equalScalar, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, equalScalar, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, equalScalar, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, equalScalar, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, equalScalar, true).valueOf();
      }
    });
  });
  var createEqualNumber = factory(name$1Z, ['typed', 'equalScalar'], function (_ref2) {
    var typed = _ref2.typed,
        equalScalar = _ref2.equalScalar;
    return typed(name$1Z, {
      'any, any': function anyAny(x, y) {
        // strict equality for null and undefined?
        if (x === null) {
          return y === null;
        }

        if (y === null) {
          return x === null;
        }

        if (x === undefined) {
          return y === undefined;
        }

        if (y === undefined) {
          return x === undefined;
        }

        return equalScalar(x, y);
      }
    });
  });

  var name$1_ = 'equalText';
  var dependencies$20 = ['typed', 'compareText', 'isZero'];
  var createEqualText = /* #__PURE__ */factory(name$1_, dependencies$20, function (_ref) {
    var typed = _ref.typed,
        compareText = _ref.compareText,
        isZero = _ref.isZero;

    /**
     * Check equality of two strings. Comparison is case sensitive.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.equalText(x, y)
     *
     * Examples:
     *
     *    math.equalText('Hello', 'Hello')     // returns true
     *    math.equalText('a', 'A')             // returns false
     *    math.equal('2e3', '2000')            // returns true
     *    math.equalText('2e3', '2000')        // returns false
     *
     *    math.equalText('B', ['A', 'B', 'C']) // returns [false, true, false]
     *
     * See also:
     *
     *    equal, compareText, compare, compareNatural
     *
     * @param  {string | Array | DenseMatrix} x First string to compare
     * @param  {string | Array | DenseMatrix} y Second string to compare
     * @return {number | Array | DenseMatrix} Returns true if the values are equal, and false if not.
     */
    return typed(name$1_, {
      'any, any': function anyAny(x, y) {
        return isZero(compareText(x, y));
      }
    });
  });

  var name$20 = 'smaller';
  var dependencies$21 = ['typed', 'config', 'matrix', 'DenseMatrix'];
  var createSmaller = /* #__PURE__ */factory(name$20, dependencies$21, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        matrix = _ref.matrix,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm03 = createAlgorithm03({
      typed: typed
    });
    var algorithm07 = createAlgorithm07({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Test whether value x is smaller than y.
     *
     * The function returns true when x is smaller than y and the relative
     * difference between x and y is smaller than the configured epsilon. The
     * function cannot be used to compare values smaller than approximately 2.22e-16.
     *
     * For matrices, the function is evaluated element wise.
     * Strings are compared by their numerical value.
     *
     * Syntax:
     *
     *    math.smaller(x, y)
     *
     * Examples:
     *
     *    math.smaller(2, 3)            // returns true
     *    math.smaller(5, 2 * 2)        // returns false
     *
     *    const a = math.unit('5 cm')
     *    const b = math.unit('2 inch')
     *    math.smaller(a, b)            // returns true
     *
     * See also:
     *
     *    equal, unequal, smallerEq, smaller, smallerEq, compare
     *
     * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
     * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
     * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
     */

    return typed(name$20, {
      'boolean, boolean': function booleanBoolean(x, y) {
        return x < y;
      },
      'number, number': function numberNumber(x, y) {
        return x < y && !nearlyEqual(x, y, config.epsilon);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.lt(y) && !nearlyEqual$1(x, y, config.epsilon);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.compare(y) === -1;
      },
      'Complex, Complex': function ComplexComplex(x, y) {
        throw new TypeError('No ordering relation is defined for complex numbers');
      },
      'Unit, Unit': function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error('Cannot compare units with different base');
        }

        return this(x.value, y.value);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });
  var createSmallerNumber = /* #__PURE__ */factory(name$20, ['typed', 'config'], function (_ref2) {
    var typed = _ref2.typed,
        config = _ref2.config;
    return typed(name$20, {
      'number, number': function numberNumber(x, y) {
        return x < y && !nearlyEqual(x, y, config.epsilon);
      }
    });
  });

  var name$21 = 'smallerEq';
  var dependencies$22 = ['typed', 'config', 'matrix', 'DenseMatrix'];
  var createSmallerEq = /* #__PURE__ */factory(name$21, dependencies$22, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        matrix = _ref.matrix,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm03 = createAlgorithm03({
      typed: typed
    });
    var algorithm07 = createAlgorithm07({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Test whether value x is smaller or equal to y.
     *
     * The function returns true when x is smaller than y or the relative
     * difference between x and y is smaller than the configured epsilon. The
     * function cannot be used to compare values smaller than approximately 2.22e-16.
     *
     * For matrices, the function is evaluated element wise.
     * Strings are compared by their numerical value.
     *
     * Syntax:
     *
     *    math.smallerEq(x, y)
     *
     * Examples:
     *
     *    math.smaller(1 + 2, 3)        // returns false
     *    math.smallerEq(1 + 2, 3)      // returns true
     *
     * See also:
     *
     *    equal, unequal, smaller, larger, largerEq, compare
     *
     * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
     * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
     * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
     */

    return typed(name$21, {
      'boolean, boolean': function booleanBoolean(x, y) {
        return x <= y;
      },
      'number, number': function numberNumber(x, y) {
        return x <= y || nearlyEqual(x, y, config.epsilon);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.lte(y) || nearlyEqual$1(x, y, config.epsilon);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.compare(y) !== 1;
      },
      'Complex, Complex': function ComplexComplex() {
        throw new TypeError('No ordering relation is defined for complex numbers');
      },
      'Unit, Unit': function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error('Cannot compare units with different base');
        }

        return this(x.value, y.value);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });
  var createSmallerEqNumber = /* #__PURE__ */factory(name$21, ['typed', 'config'], function (_ref2) {
    var typed = _ref2.typed,
        config = _ref2.config;
    return typed(name$21, {
      'number, number': function numberNumber(x, y) {
        return x <= y || nearlyEqual(x, y, config.epsilon);
      }
    });
  });

  var name$22 = 'larger';
  var dependencies$23 = ['typed', 'config', 'matrix', 'DenseMatrix'];
  var createLarger = /* #__PURE__ */factory(name$22, dependencies$23, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        matrix = _ref.matrix,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm03 = createAlgorithm03({
      typed: typed
    });
    var algorithm07 = createAlgorithm07({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Test whether value x is larger than y.
     *
     * The function returns true when x is larger than y and the relative
     * difference between x and y is larger than the configured epsilon. The
     * function cannot be used to compare values smaller than approximately 2.22e-16.
     *
     * For matrices, the function is evaluated element wise.
     * Strings are compared by their numerical value.
     *
     * Syntax:
     *
     *    math.larger(x, y)
     *
     * Examples:
     *
     *    math.larger(2, 3)             // returns false
     *    math.larger(5, 2 + 2)         // returns true
     *
     *    const a = math.unit('5 cm')
     *    const b = math.unit('2 inch')
     *    math.larger(a, b)             // returns false
     *
     * See also:
     *
     *    equal, unequal, smaller, smallerEq, largerEq, compare
     *
     * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
     * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
     * @return {boolean | Array | Matrix} Returns true when the x is larger than y, else returns false
     */

    return typed(name$22, {
      'boolean, boolean': function booleanBoolean(x, y) {
        return x > y;
      },
      'number, number': function numberNumber(x, y) {
        return x > y && !nearlyEqual(x, y, config.epsilon);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.gt(y) && !nearlyEqual$1(x, y, config.epsilon);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.compare(y) === 1;
      },
      'Complex, Complex': function ComplexComplex() {
        throw new TypeError('No ordering relation is defined for complex numbers');
      },
      'Unit, Unit': function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error('Cannot compare units with different base');
        }

        return this(x.value, y.value);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });
  var createLargerNumber = /* #__PURE__ */factory(name$22, ['typed', 'config'], function (_ref2) {
    var typed = _ref2.typed,
        config = _ref2.config;
    return typed(name$22, {
      'number, number': function numberNumber(x, y) {
        return x > y && !nearlyEqual(x, y, config.epsilon);
      }
    });
  });

  var name$23 = 'largerEq';
  var dependencies$24 = ['typed', 'config', 'matrix', 'DenseMatrix'];
  var createLargerEq = /* #__PURE__ */factory(name$23, dependencies$24, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        matrix = _ref.matrix,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm03 = createAlgorithm03({
      typed: typed
    });
    var algorithm07 = createAlgorithm07({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Test whether value x is larger or equal to y.
     *
     * The function returns true when x is larger than y or the relative
     * difference between x and y is smaller than the configured epsilon. The
     * function cannot be used to compare values smaller than approximately 2.22e-16.
     *
     * For matrices, the function is evaluated element wise.
     * Strings are compared by their numerical value.
     *
     * Syntax:
     *
     *    math.largerEq(x, y)
     *
     * Examples:
     *
     *    math.larger(2, 1 + 1)         // returns false
     *    math.largerEq(2, 1 + 1)       // returns true
     *
     * See also:
     *
     *    equal, unequal, smaller, smallerEq, larger, compare
     *
     * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
     * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
     * @return {boolean | Array | Matrix} Returns true when the x is larger or equal to y, else returns false
     */

    return typed(name$23, {
      'boolean, boolean': function booleanBoolean(x, y) {
        return x >= y;
      },
      'number, number': function numberNumber(x, y) {
        return x >= y || nearlyEqual(x, y, config.epsilon);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.gte(y) || nearlyEqual$1(x, y, config.epsilon);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.compare(y) !== -1;
      },
      'Complex, Complex': function ComplexComplex() {
        throw new TypeError('No ordering relation is defined for complex numbers');
      },
      'Unit, Unit': function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error('Cannot compare units with different base');
        }

        return this(x.value, y.value);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });
  var createLargerEqNumber = /* #__PURE__ */factory(name$23, ['typed', 'config'], function (_ref2) {
    var typed = _ref2.typed,
        config = _ref2.config;
    return typed(name$23, {
      'number, number': function numberNumber(x, y) {
        return x >= y || nearlyEqual(x, y, config.epsilon);
      }
    });
  });

  var name$24 = 'deepEqual';
  var dependencies$25 = ['typed', 'equal'];
  var createDeepEqual = /* #__PURE__ */factory(name$24, dependencies$25, function (_ref) {
    var typed = _ref.typed,
        equal = _ref.equal;

    /**
     * Test element wise whether two matrices are equal.
     * The function accepts both matrices and scalar values.
     *
     * Strings are compared by their numerical value.
     *
     * Syntax:
     *
     *    math.deepEqual(x, y)
     *
     * Examples:
     *
     *    math.deepEqual(2, 4)   // returns false
     *
     *    a = [2, 5, 1]
     *    b = [2, 7, 1]
     *
     *    math.deepEqual(a, b)   // returns false
     *    math.equal(a, b)       // returns [true, false, true]
     *
     * See also:
     *
     *    equal, unequal
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First matrix to compare
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second matrix to compare
     * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
     *            Returns true when the input matrices have the same size and each of their elements is equal.
     */
    return typed(name$24, {
      'any, any': function anyAny(x, y) {
        return _deepEqual(x.valueOf(), y.valueOf());
      }
    });
    /**
     * Test whether two arrays have the same size and all elements are equal
     * @param {Array | *} x
     * @param {Array | *} y
     * @return {boolean} Returns true if both arrays are deep equal
     */

    function _deepEqual(x, y) {
      if (Array.isArray(x)) {
        if (Array.isArray(y)) {
          var len = x.length;

          if (len !== y.length) {
            return false;
          }

          for (var i = 0; i < len; i++) {
            if (!_deepEqual(x[i], y[i])) {
              return false;
            }
          }

          return true;
        } else {
          return false;
        }
      } else {
        if (Array.isArray(y)) {
          return false;
        } else {
          return equal(x, y);
        }
      }
    }
  });

  var name$25 = 'unequal';
  var dependencies$26 = ['typed', 'config', 'equalScalar', 'matrix', 'DenseMatrix'];
  var createUnequal = /* #__PURE__ */factory(name$25, dependencies$26, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        equalScalar = _ref.equalScalar,
        matrix = _ref.matrix,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm03 = createAlgorithm03({
      typed: typed
    });
    var algorithm07 = createAlgorithm07({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Test whether two values are unequal.
     *
     * The function tests whether the relative difference between x and y is
     * larger than the configured epsilon. The function cannot be used to compare
     * values smaller than approximately 2.22e-16.
     *
     * For matrices, the function is evaluated element wise.
     * In case of complex numbers, x.re must unequal y.re, or x.im must unequal y.im.
     * Strings are compared by their numerical value.
     *
     * Values `null` and `undefined` are compared strictly, thus `null` is unequal
     * with everything except `null`, and `undefined` is unequal with everything
     * except `undefined`.
     *
     * Syntax:
     *
     *    math.unequal(x, y)
     *
     * Examples:
     *
     *    math.unequal(2 + 2, 3)       // returns true
     *    math.unequal(2 + 2, 4)       // returns false
     *
     *    const a = math.unit('50 cm')
     *    const b = math.unit('5 m')
     *    math.unequal(a, b)           // returns false
     *
     *    const c = [2, 5, 1]
     *    const d = [2, 7, 1]
     *
     *    math.unequal(c, d)           // returns [false, true, false]
     *    math.deepEqual(c, d)         // returns false
     *
     *    math.unequal(0, null)        // returns true
     * See also:
     *
     *    equal, deepEqual, smaller, smallerEq, larger, largerEq, compare
     *
     * @param  {number | BigNumber | Fraction | boolean | Complex | Unit | string | Array | Matrix | undefined} x First value to compare
     * @param  {number | BigNumber | Fraction | boolean | Complex | Unit | string | Array | Matrix | undefined} y Second value to compare
     * @return {boolean | Array | Matrix} Returns true when the compared values are unequal, else returns false
     */

    return typed('unequal', {
      'any, any': function anyAny(x, y) {
        // strict equality for null and undefined?
        if (x === null) {
          return y !== null;
        }

        if (y === null) {
          return x !== null;
        }

        if (x === undefined) {
          return y !== undefined;
        }

        if (y === undefined) {
          return x !== undefined;
        }

        return _unequal(x, y);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, _unequal);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, _unequal, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, _unequal, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, _unequal);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm12(x, y, _unequal, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, _unequal, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, _unequal, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, _unequal, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, _unequal, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, _unequal, true).valueOf();
      }
    });

    function _unequal(x, y) {
      return !equalScalar(x, y);
    }
  });
  var createUnequalNumber = factory(name$25, ['typed', 'equalScalar'], function (_ref2) {
    var typed = _ref2.typed,
        equalScalar = _ref2.equalScalar;
    return typed(name$25, {
      'any, any': function anyAny(x, y) {
        // strict equality for null and undefined?
        if (x === null) {
          return y !== null;
        }

        if (y === null) {
          return x !== null;
        }

        if (x === undefined) {
          return y !== undefined;
        }

        if (y === undefined) {
          return x !== undefined;
        }

        return !equalScalar(x, y);
      }
    });
  });

  var name$26 = 'partitionSelect';
  var dependencies$27 = ['typed', 'isNumeric', 'isNaN', 'compare'];
  var createPartitionSelect = /* #__PURE__ */factory(name$26, dependencies$27, function (_ref) {
    var typed = _ref.typed,
        isNumeric = _ref.isNumeric,
        isNaN = _ref.isNaN,
        compare = _ref.compare;
    var asc = compare;

    var desc = function desc(a, b) {
      return -compare(a, b);
    };
    /**
     * Partition-based selection of an array or 1D matrix.
     * Will find the kth smallest value, and mutates the input array.
     * Uses Quickselect.
     *
     * Syntax:
     *
     *    math.partitionSelect(x, k)
     *    math.partitionSelect(x, k, compare)
     *
     * Examples:
     *
     *    math.partitionSelect([5, 10, 1], 2)           // returns 10
     *    math.partitionSelect(['C', 'B', 'A', 'D'], 1) // returns 'B'
     *
     *    function sortByLength (a, b) {
     *      return a.length - b.length
     *    }
     *    math.partitionSelect(['Langdon', 'Tom', 'Sara'], 2, sortByLength) // returns 'Langdon'
     *
     * See also:
     *
     *    sort
     *
     * @param {Matrix | Array} x    A one dimensional matrix or array to sort
     * @param {Number} k            The kth smallest value to be retrieved zero-based index
     * @param {Function | 'asc' | 'desc'} [compare='asc']
     *        An optional comparator function. The function is called as
     *        `compare(a, b)`, and must return 1 when a > b, -1 when a < b,
     *        and 0 when a == b.
     * @return {*} Returns the kth lowest value.
     */


    return typed(name$26, {
      'Array | Matrix, number': function ArrayMatrixNumber(x, k) {
        return _partitionSelect(x, k, asc);
      },
      'Array | Matrix, number, string': function ArrayMatrixNumberString(x, k, compare) {
        if (compare === 'asc') {
          return _partitionSelect(x, k, asc);
        } else if (compare === 'desc') {
          return _partitionSelect(x, k, desc);
        } else {
          throw new Error('Compare string must be "asc" or "desc"');
        }
      },
      'Array | Matrix, number, function': _partitionSelect
    });

    function _partitionSelect(x, k, compare) {
      if (!isInteger(k) || k < 0) {
        throw new Error('k must be a non-negative integer');
      }

      if (isMatrix(x)) {
        var size = x.size();

        if (size.length > 1) {
          throw new Error('Only one dimensional matrices supported');
        }

        return quickSelect(x.valueOf(), k, compare);
      }

      if (Array.isArray(x)) {
        return quickSelect(x, k, compare);
      }
    }
    /**
     * Quickselect algorithm.
     * Code adapted from:
     * https://blog.teamleadnet.com/2012/07/quick-select-algorithm-find-kth-element.html
     *
     * @param {Array} arr
     * @param {Number} k
     * @param {Function} compare
     * @private
     */


    function quickSelect(arr, k, compare) {
      if (k >= arr.length) {
        throw new Error('k out of bounds');
      } // check for NaN values since these can cause an infinite while loop


      for (var i = 0; i < arr.length; i++) {
        if (isNumeric(arr[i]) && isNaN(arr[i])) {
          return arr[i]; // return NaN
        }
      }

      var from = 0;
      var to = arr.length - 1; // if from == to we reached the kth element

      while (from < to) {
        var r = from;
        var w = to;
        var pivot = arr[Math.floor(Math.random() * (to - from + 1)) + from]; // stop if the reader and writer meets

        while (r < w) {
          // arr[r] >= pivot
          if (compare(arr[r], pivot) >= 0) {
            // put the large values at the end
            var tmp = arr[w];
            arr[w] = arr[r];
            arr[r] = tmp;
            --w;
          } else {
            // the value is smaller than the pivot, skip
            ++r;
          }
        } // if we stepped up (r++) we need to step one down (arr[r] > pivot)


        if (compare(arr[r], pivot) > 0) {
          --r;
        } // the r pointer is on the end of the first k elements


        if (k <= r) {
          to = r;
        } else {
          from = r + 1;
        }
      }

      return arr[k];
    }
  });

  var name$27 = 'sort';
  var dependencies$28 = ['typed', 'matrix', 'compare', 'compareNatural'];
  var createSort = /* #__PURE__ */factory(name$27, dependencies$28, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        compare = _ref.compare,
        compareNatural = _ref.compareNatural;
    var compareAsc = compare;

    var compareDesc = function compareDesc(a, b) {
      return -compare(a, b);
    };
    /**
     * Sort the items in a matrix.
     *
     * Syntax:
     *
     *    math.sort(x)
     *    math.sort(x, compare)
     *
     * Examples:
     *
     *    math.sort([5, 10, 1]) // returns [1, 5, 10]
     *    math.sort(['C', 'B', 'A', 'D'], math.compareNatural)
     *    // returns ['A', 'B', 'C', 'D']
     *
     *    function sortByLength (a, b) {
     *      return a.length - b.length
     *    }
     *    math.sort(['Langdon', 'Tom', 'Sara'], sortByLength)
     *    // returns ['Tom', 'Sara', 'Langdon']
     *
     * See also:
     *
     *    filter, forEach, map, compare, compareNatural
     *
     * @param {Matrix | Array} x    A one dimensional matrix or array to sort
     * @param {Function | 'asc' | 'desc' | 'natural'} [compare='asc']
     *        An optional _comparator function or name. The function is called as
     *        `compare(a, b)`, and must return 1 when a > b, -1 when a < b,
     *        and 0 when a == b.
     * @return {Matrix | Array} Returns the sorted matrix.
     */


    return typed(name$27, {
      Array: function Array(x) {
        _arrayIsVector(x);

        return x.sort(compareAsc);
      },
      Matrix: function Matrix(x) {
        _matrixIsVector(x);

        return matrix(x.toArray().sort(compareAsc), x.storage());
      },
      'Array, function': function ArrayFunction(x, _comparator) {
        _arrayIsVector(x);

        return x.sort(_comparator);
      },
      'Matrix, function': function MatrixFunction(x, _comparator) {
        _matrixIsVector(x);

        return matrix(x.toArray().sort(_comparator), x.storage());
      },
      'Array, string': function ArrayString(x, order) {
        _arrayIsVector(x);

        return x.sort(_comparator(order));
      },
      'Matrix, string': function MatrixString(x, order) {
        _matrixIsVector(x);

        return matrix(x.toArray().sort(_comparator(order)), x.storage());
      }
    });
    /**
     * Get the comparator for given order ('asc', 'desc', 'natural')
     * @param {'asc' | 'desc' | 'natural'} order
     * @return {Function} Returns a _comparator function
     */

    function _comparator(order) {
      if (order === 'asc') {
        return compareAsc;
      } else if (order === 'desc') {
        return compareDesc;
      } else if (order === 'natural') {
        return compareNatural;
      } else {
        throw new Error('String "asc", "desc", or "natural" expected');
      }
    }
    /**
     * Validate whether an array is one dimensional
     * Throws an error when this is not the case
     * @param {Array} array
     * @private
     */


    function _arrayIsVector(array) {
      if (arraySize(array).length !== 1) {
        throw new Error('One dimensional array expected');
      }
    }
    /**
     * Validate whether a matrix is one dimensional
     * Throws an error when this is not the case
     * @param {Matrix} matrix
     * @private
     */


    function _matrixIsVector(matrix) {
      if (matrix.size().length !== 1) {
        throw new Error('One dimensional matrix expected');
      }
    }
  });

  var name$28 = 'max';
  var dependencies$29 = ['typed', 'config', 'numeric', 'larger'];
  var createMax = /* #__PURE__ */factory(name$28, dependencies$29, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        numeric = _ref.numeric,
        larger = _ref.larger;

    /**
     * Compute the maximum value of a matrix or a  list with values.
     * In case of a multi dimensional array, the maximum of the flattened array
     * will be calculated. When `dim` is provided, the maximum over the selected
     * dimension will be calculated. Parameter `dim` is zero-based.
     *
     * Syntax:
     *
     *     math.max(a, b, c, ...)
     *     math.max(A)
     *     math.max(A, dim)
     *
     * Examples:
     *
     *     math.max(2, 1, 4, 3)                  // returns 4
     *     math.max([2, 1, 4, 3])                // returns 4
     *
     *     // maximum over a specified dimension (zero-based)
     *     math.max([[2, 5], [4, 3], [1, 7]], 0) // returns [4, 7]
     *     math.max([[2, 5], [4, 3]], [1, 7], 1) // returns [5, 4, 7]
     *
     *     math.max(2.7, 7.1, -4.5, 2.0, 4.1)    // returns 7.1
     *     math.min(2.7, 7.1, -4.5, 2.0, 4.1)    // returns -4.5
     *
     * See also:
     *
     *    mean, median, min, prod, std, sum, variance
     *
     * @param {... *} args  A single matrix or or multiple scalar values
     * @return {*} The maximum value
     */
    return typed(name$28, {
      // max([a, b, c, d, ...])
      'Array | Matrix': _max,
      // max([a, b, c, d, ...], dim)
      'Array | Matrix, number | BigNumber': function ArrayMatrixNumberBigNumber(array, dim) {
        return reduce(array, dim.valueOf(), _largest);
      },
      // max(a, b, c, d, ...)
      '...': function _(args) {
        if (containsCollections(args)) {
          throw new TypeError('Scalar values expected in function max');
        }

        return _max(args);
      }
    });
    /**
     * Return the largest of two values
     * @param {*} x
     * @param {*} y
     * @returns {*} Returns x when x is largest, or y when y is largest
     * @private
     */

    function _largest(x, y) {
      try {
        return larger(x, y) ? x : y;
      } catch (err) {
        throw improveErrorMessage(err, 'max', y);
      }
    }
    /**
     * Recursively calculate the maximum value in an n-dimensional array
     * @param {Array} array
     * @return {number} max
     * @private
     */


    function _max(array) {
      var res;
      deepForEach(array, function (value) {
        try {
          if (isNaN(value) && typeof value === 'number') {
            res = NaN;
          } else if (res === undefined || larger(value, res)) {
            res = value;
          }
        } catch (err) {
          throw improveErrorMessage(err, 'max', value);
        }
      });

      if (res === undefined) {
        throw new Error('Cannot calculate max of an empty array');
      } // make sure returning numeric value: parse a string into a numeric value


      if (typeof res === 'string') {
        res = numeric(res, config.number);
      }

      return res;
    }
  });

  var name$29 = 'min';
  var dependencies$2a = ['typed', 'config', 'numeric', 'smaller'];
  var createMin = /* #__PURE__ */factory(name$29, dependencies$2a, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        numeric = _ref.numeric,
        smaller = _ref.smaller;

    /**
     * Compute the minimum value of a matrix or a  list of values.
     * In case of a multi dimensional array, the minimum of the flattened array
     * will be calculated. When `dim` is provided, the minimum over the selected
     * dimension will be calculated. Parameter `dim` is zero-based.
     *
     * Syntax:
     *
     *     math.min(a, b, c, ...)
     *     math.min(A)
     *     math.min(A, dim)
     *
     * Examples:
     *
     *     math.min(2, 1, 4, 3)                  // returns 1
     *     math.min([2, 1, 4, 3])                // returns 1
     *
     *     // minimum over a specified dimension (zero-based)
     *     math.min([[2, 5], [4, 3], [1, 7]], 0) // returns [1, 3]
     *     math.min([[2, 5], [4, 3], [1, 7]], 1) // returns [2, 3, 1]
     *
     *     math.max(2.7, 7.1, -4.5, 2.0, 4.1)    // returns 7.1
     *     math.min(2.7, 7.1, -4.5, 2.0, 4.1)    // returns -4.5
     *
     * See also:
     *
     *    mean, median, max, prod, std, sum, variance
     *
     * @param {... *} args  A single matrix or or multiple scalar values
     * @return {*} The minimum value
     */
    return typed(name$29, {
      // min([a, b, c, d, ...])
      'Array | Matrix': _min,
      // min([a, b, c, d, ...], dim)
      'Array | Matrix, number | BigNumber': function ArrayMatrixNumberBigNumber(array, dim) {
        return reduce(array, dim.valueOf(), _smallest);
      },
      // min(a, b, c, d, ...)
      '...': function _(args) {
        if (containsCollections(args)) {
          throw new TypeError('Scalar values expected in function min');
        }

        return _min(args);
      }
    });
    /**
     * Return the smallest of two values
     * @param {*} x
     * @param {*} y
     * @returns {*} Returns x when x is smallest, or y when y is smallest
     * @private
     */

    function _smallest(x, y) {
      try {
        return smaller(x, y) ? x : y;
      } catch (err) {
        throw improveErrorMessage(err, 'min', y);
      }
    }
    /**
     * Recursively calculate the minimum value in an n-dimensional array
     * @param {Array} array
     * @return {number} min
     * @private
     */


    function _min(array) {
      var min;
      deepForEach(array, function (value) {
        try {
          if (isNaN(value) && typeof value === 'number') {
            min = NaN;
          } else if (min === undefined || smaller(value, min)) {
            min = value;
          }
        } catch (err) {
          throw improveErrorMessage(err, 'min', value);
        }
      });

      if (min === undefined) {
        throw new Error('Cannot calculate min of an empty array');
      } // make sure returning numeric value: parse a string into a numeric value


      if (typeof min === 'string') {
        min = numeric(min, config.number);
      }

      return min;
    }
  });

  var name$2a = 'ImmutableDenseMatrix';
  var dependencies$2b = ['smaller', 'DenseMatrix'];
  var createImmutableDenseMatrixClass = /* #__PURE__ */factory(name$2a, dependencies$2b, function (_ref) {
    var smaller = _ref.smaller,
        DenseMatrix = _ref.DenseMatrix;

    function ImmutableDenseMatrix(data, datatype) {
      if (!(this instanceof ImmutableDenseMatrix)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      if (datatype && !isString(datatype)) {
        throw new Error('Invalid datatype: ' + datatype);
      }

      if (isMatrix(data) || isArray(data)) {
        // use DenseMatrix implementation
        var matrix = new DenseMatrix(data, datatype); // internal structures

        this._data = matrix._data;
        this._size = matrix._size;
        this._datatype = matrix._datatype;
        this._min = null;
        this._max = null;
      } else if (data && isArray(data.data) && isArray(data.size)) {
        // initialize fields from JSON representation
        this._data = data.data;
        this._size = data.size;
        this._datatype = data.datatype;
        this._min = typeof data.min !== 'undefined' ? data.min : null;
        this._max = typeof data.max !== 'undefined' ? data.max : null;
      } else if (data) {
        // unsupported type
        throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');
      } else {
        // nothing provided
        this._data = [];
        this._size = [0];
        this._datatype = datatype;
        this._min = null;
        this._max = null;
      }
    }

    ImmutableDenseMatrix.prototype = new DenseMatrix();
    /**
     * Attach type information
     */

    ImmutableDenseMatrix.prototype.type = 'ImmutableDenseMatrix';
    ImmutableDenseMatrix.prototype.isImmutableDenseMatrix = true;
    /**
     * Get a subset of the matrix, or replace a subset of the matrix.
     *
     * Usage:
     *     const subset = matrix.subset(index)               // retrieve subset
     *     const value = matrix.subset(index, replacement)   // replace subset
     *
     * @param {Index} index
     * @param {Array | ImmutableDenseMatrix | *} [replacement]
     * @param {*} [defaultValue=0]      Default value, filled in on new entries when
     *                                  the matrix is resized. If not provided,
     *                                  new matrix elements will be filled with zeros.
     */

    ImmutableDenseMatrix.prototype.subset = function (index) {
      switch (arguments.length) {
        case 1:
          {
            // use base implementation
            var m = DenseMatrix.prototype.subset.call(this, index); // check result is a matrix

            if (isMatrix(m)) {
              // return immutable matrix
              return new ImmutableDenseMatrix({
                data: m._data,
                size: m._size,
                datatype: m._datatype
              });
            }

            return m;
          }
        // intentional fall through

        case 2:
        case 3:
          throw new Error('Cannot invoke set subset on an Immutable Matrix instance');

        default:
          throw new SyntaxError('Wrong number of arguments');
      }
    };
    /**
     * Replace a single element in the matrix.
     * @param {Number[]} index   Zero-based index
     * @param {*} value
     * @param {*} [defaultValue]        Default value, filled in on new entries when
     *                                  the matrix is resized. If not provided,
     *                                  new matrix elements will be left undefined.
     * @return {ImmutableDenseMatrix} self
     */


    ImmutableDenseMatrix.prototype.set = function () {
      throw new Error('Cannot invoke set on an Immutable Matrix instance');
    };
    /**
     * Resize the matrix to the given size. Returns a copy of the matrix when
     * `copy=true`, otherwise return the matrix itself (resize in place).
     *
     * @param {Number[]} size           The new size the matrix should have.
     * @param {*} [defaultValue=0]      Default value, filled in on new entries.
     *                                  If not provided, the matrix elements will
     *                                  be filled with zeros.
     * @param {boolean} [copy]          Return a resized copy of the matrix
     *
     * @return {Matrix}                 The resized matrix
     */


    ImmutableDenseMatrix.prototype.resize = function () {
      throw new Error('Cannot invoke resize on an Immutable Matrix instance');
    };
    /**
     * Disallows reshaping in favor of immutability.
     *
     * @throws {Error} Operation not allowed
     */


    ImmutableDenseMatrix.prototype.reshape = function () {
      throw new Error('Cannot invoke reshape on an Immutable Matrix instance');
    };
    /**
     * Create a clone of the matrix
     * @return {ImmutableDenseMatrix} clone
     */


    ImmutableDenseMatrix.prototype.clone = function () {
      return new ImmutableDenseMatrix({
        data: clone(this._data),
        size: clone(this._size),
        datatype: this._datatype
      });
    };
    /**
     * Get a JSON representation of the matrix
     * @returns {Object}
     */


    ImmutableDenseMatrix.prototype.toJSON = function () {
      return {
        mathjs: 'ImmutableDenseMatrix',
        data: this._data,
        size: this._size,
        datatype: this._datatype
      };
    };
    /**
     * Generate a matrix from a JSON object
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ImmutableDenseMatrix", data: [], size: []}`,
     *                       where mathjs is optional
     * @returns {ImmutableDenseMatrix}
     */


    ImmutableDenseMatrix.fromJSON = function (json) {
      return new ImmutableDenseMatrix(json);
    };
    /**
     * Swap rows i and j in Matrix.
     *
     * @param {Number} i       Matrix row index 1
     * @param {Number} j       Matrix row index 2
     *
     * @return {Matrix}        The matrix reference
     */


    ImmutableDenseMatrix.prototype.swapRows = function () {
      throw new Error('Cannot invoke swapRows on an Immutable Matrix instance');
    };
    /**
     * Calculate the minimum value in the set
     * @return {Number | undefined} min
     */


    ImmutableDenseMatrix.prototype.min = function () {
      // check min has been calculated before
      if (this._min === null) {
        // minimum
        var m = null; // compute min

        this.forEach(function (v) {
          if (m === null || smaller(v, m)) {
            m = v;
          }
        });
        this._min = m !== null ? m : undefined;
      }

      return this._min;
    };
    /**
     * Calculate the maximum value in the set
     * @return {Number | undefined} max
     */


    ImmutableDenseMatrix.prototype.max = function () {
      // check max has been calculated before
      if (this._max === null) {
        // maximum
        var m = null; // compute max

        this.forEach(function (v) {
          if (m === null || smaller(m, v)) {
            m = v;
          }
        });
        this._max = m !== null ? m : undefined;
      }

      return this._max;
    };

    return ImmutableDenseMatrix;
  }, {
    isClass: true
  });

  var name$2b = 'Index';
  var dependencies$2c = ['ImmutableDenseMatrix'];
  var createIndexClass = /* #__PURE__ */factory(name$2b, dependencies$2c, function (_ref) {
    var ImmutableDenseMatrix = _ref.ImmutableDenseMatrix;

    /**
     * Create an index. An Index can store ranges and sets for multiple dimensions.
     * Matrix.get, Matrix.set, and math.subset accept an Index as input.
     *
     * Usage:
     *     const index = new Index(range1, range2, matrix1, array1, ...)
     *
     * Where each parameter can be any of:
     *     A number
     *     A string (containing a name of an object property)
     *     An instance of Range
     *     An Array with the Set values
     *     A Matrix with the Set values
     *
     * The parameters start, end, and step must be integer numbers.
     *
     * @class Index
     * @Constructor Index
     * @param {...*} ranges
     */
    function Index(ranges) {
      if (!(this instanceof Index)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      this._dimensions = [];
      this._isScalar = true;

      for (var i = 0, ii = arguments.length; i < ii; i++) {
        var arg = arguments[i];

        if (isRange(arg)) {
          this._dimensions.push(arg);

          this._isScalar = false;
        } else if (Array.isArray(arg) || isMatrix(arg)) {
          // create matrix
          var m = _createImmutableMatrix(arg.valueOf());

          this._dimensions.push(m); // size


          var size = m.size(); // scalar

          if (size.length !== 1 || size[0] !== 1) {
            this._isScalar = false;
          }
        } else if (typeof arg === 'number') {
          this._dimensions.push(_createImmutableMatrix([arg]));
        } else if (typeof arg === 'string') {
          // object property (arguments.count should be 1)
          this._dimensions.push(arg);
        } else {
          throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
        } // TODO: implement support for wildcard '*'

      }
    }
    /**
     * Attach type information
     */


    Index.prototype.type = 'Index';
    Index.prototype.isIndex = true;

    function _createImmutableMatrix(arg) {
      // loop array elements
      for (var i = 0, l = arg.length; i < l; i++) {
        if (typeof arg[i] !== 'number' || !isInteger(arg[i])) {
          throw new TypeError('Index parameters must be positive integer numbers');
        }
      } // create matrix


      return new ImmutableDenseMatrix(arg);
    }
    /**
     * Create a clone of the index
     * @memberof Index
     * @return {Index} clone
     */


    Index.prototype.clone = function () {
      var index = new Index();
      index._dimensions = clone(this._dimensions);
      index._isScalar = this._isScalar;
      return index;
    };
    /**
     * Create an index from an array with ranges/numbers
     * @memberof Index
     * @param {Array.<Array | number>} ranges
     * @return {Index} index
     * @private
     */


    Index.create = function (ranges) {
      var index = new Index();
      Index.apply(index, ranges);
      return index;
    };
    /**
     * Retrieve the size of the index, the number of elements for each dimension.
     * @memberof Index
     * @returns {number[]} size
     */


    Index.prototype.size = function () {
      var size = [];

      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var d = this._dimensions[i];
        size[i] = typeof d === 'string' ? 1 : d.size()[0];
      }

      return size;
    };
    /**
     * Get the maximum value for each of the indexes ranges.
     * @memberof Index
     * @returns {number[]} max
     */


    Index.prototype.max = function () {
      var values$$1 = [];

      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var range = this._dimensions[i];
        values$$1[i] = typeof range === 'string' ? range : range.max();
      }

      return values$$1;
    };
    /**
     * Get the minimum value for each of the indexes ranges.
     * @memberof Index
     * @returns {number[]} min
     */


    Index.prototype.min = function () {
      var values$$1 = [];

      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var range = this._dimensions[i];
        values$$1[i] = typeof range === 'string' ? range : range.min();
      }

      return values$$1;
    };
    /**
     * Loop over each of the ranges of the index
     * @memberof Index
     * @param {Function} callback   Called for each range with a Range as first
     *                              argument, the dimension as second, and the
     *                              index object as third.
     */


    Index.prototype.forEach = function (callback) {
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        callback(this._dimensions[i], i, this);
      }
    };
    /**
     * Retrieve the dimension for the given index
     * @memberof Index
     * @param {Number} dim                  Number of the dimension
     * @returns {Range | null} range
     */


    Index.prototype.dimension = function (dim) {
      return this._dimensions[dim] || null;
    };
    /**
     * Test whether this index contains an object property
     * @returns {boolean} Returns true if the index is an object property
     */


    Index.prototype.isObjectProperty = function () {
      return this._dimensions.length === 1 && typeof this._dimensions[0] === 'string';
    };
    /**
     * Returns the object property name when the Index holds a single object property,
     * else returns null
     * @returns {string | null}
     */


    Index.prototype.getObjectProperty = function () {
      return this.isObjectProperty() ? this._dimensions[0] : null;
    };
    /**
     * Test whether this index contains only a single value.
     *
     * This is the case when the index is created with only scalar values as ranges,
     * not for ranges resolving into a single value.
     * @memberof Index
     * @return {boolean} isScalar
     */


    Index.prototype.isScalar = function () {
      return this._isScalar;
    };
    /**
     * Expand the Index into an array.
     * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]
     * @memberof Index
     * @returns {Array} array
     */


    Index.prototype.toArray = function () {
      var array = [];

      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var dimension = this._dimensions[i];
        array.push(typeof dimension === 'string' ? dimension : dimension.toArray());
      }

      return array;
    };
    /**
     * Get the primitive value of the Index, a two dimensional array.
     * Equivalent to Index.toArray().
     * @memberof Index
     * @returns {Array} array
     */


    Index.prototype.valueOf = Index.prototype.toArray;
    /**
     * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'
     * @memberof Index
     * @returns {String} str
     */

    Index.prototype.toString = function () {
      var strings = [];

      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var dimension = this._dimensions[i];

        if (typeof dimension === 'string') {
          strings.push(JSON.stringify(dimension));
        } else {
          strings.push(dimension.toString());
        }
      }

      return '[' + strings.join(', ') + ']';
    };
    /**
     * Get a JSON representation of the Index
     * @memberof Index
     * @returns {Object} Returns a JSON object structured as:
     *                   `{"mathjs": "Index", "ranges": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
     */


    Index.prototype.toJSON = function () {
      return {
        mathjs: 'Index',
        dimensions: this._dimensions
      };
    };
    /**
     * Instantiate an Index from a JSON object
     * @memberof Index
     * @param {Object} json A JSON object structured as:
     *                     `{"mathjs": "Index", "dimensions": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
     * @return {Index}
     */


    Index.fromJSON = function (json) {
      return Index.create(json.dimensions);
    };

    return Index;
  }, {
    isClass: true
  });

  var name$2c = 'FibonacciHeap';
  var dependencies$2d = ['smaller', 'larger'];
  var createFibonacciHeapClass = /* #__PURE__ */factory(name$2c, dependencies$2d, function (_ref) {
    var smaller = _ref.smaller,
        larger = _ref.larger;
    var oneOverLogPhi = 1.0 / Math.log((1.0 + Math.sqrt(5.0)) / 2.0);
    /**
     * Fibonacci Heap implementation, used interally for Matrix math.
     * @class FibonacciHeap
     * @constructor FibonacciHeap
     */

    function FibonacciHeap() {
      if (!(this instanceof FibonacciHeap)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      } // initialize fields


      this._minimum = null;
      this._size = 0;
    }
    /**
     * Attach type information
     */


    FibonacciHeap.prototype.type = 'FibonacciHeap';
    FibonacciHeap.prototype.isFibonacciHeap = true;
    /**
     * Inserts a new data element into the heap. No heap consolidation is
     * performed at this time, the new node is simply inserted into the root
     * list of this heap. Running time: O(1) actual.
     * @memberof FibonacciHeap
     */

    FibonacciHeap.prototype.insert = function (key, value) {
      // create node
      var node = {
        key: key,
        value: value,
        degree: 0
      }; // check we have a node in the minimum

      if (this._minimum) {
        // minimum node
        var minimum = this._minimum; // update left & right of node

        node.left = minimum;
        node.right = minimum.right;
        minimum.right = node;
        node.right.left = node; // update minimum node in heap if needed

        if (smaller(key, minimum.key)) {
          // node has a smaller key, use it as minimum
          this._minimum = node;
        }
      } else {
        // set left & right
        node.left = node;
        node.right = node; // this is the first node

        this._minimum = node;
      } // increment number of nodes in heap


      this._size++; // return node

      return node;
    };
    /**
     * Returns the number of nodes in heap. Running time: O(1) actual.
     * @memberof FibonacciHeap
     */


    FibonacciHeap.prototype.size = function () {
      return this._size;
    };
    /**
     * Removes all elements from this heap.
     * @memberof FibonacciHeap
     */


    FibonacciHeap.prototype.clear = function () {
      this._minimum = null;
      this._size = 0;
    };
    /**
     * Returns true if the heap is empty, otherwise false.
     * @memberof FibonacciHeap
     */


    FibonacciHeap.prototype.isEmpty = function () {
      return this._size === 0;
    };
    /**
     * Extracts the node with minimum key from heap. Amortized running
     * time: O(log n).
     * @memberof FibonacciHeap
     */


    FibonacciHeap.prototype.extractMinimum = function () {
      // node to remove
      var node = this._minimum; // check we have a minimum

      if (node === null) {
        return node;
      } // current minimum


      var minimum = this._minimum; // get number of children

      var numberOfChildren = node.degree; // pointer to the first child

      var x = node.child; // for each child of node do...

      while (numberOfChildren > 0) {
        // store node in right side
        var tempRight = x.right; // remove x from child list

        x.left.right = x.right;
        x.right.left = x.left; // add x to root list of heap

        x.left = minimum;
        x.right = minimum.right;
        minimum.right = x;
        x.right.left = x; // set Parent[x] to null

        x.parent = null;
        x = tempRight;
        numberOfChildren--;
      } // remove node from root list of heap


      node.left.right = node.right;
      node.right.left = node.left; // update minimum

      if (node === node.right) {
        // empty
        minimum = null;
      } else {
        // update minimum
        minimum = node.right; // we need to update the pointer to the root with minimum key

        minimum = _findMinimumNode(minimum, this._size);
      } // decrement size of heap


      this._size--; // update minimum

      this._minimum = minimum; // return node

      return node;
    };
    /**
     * Removes a node from the heap given the reference to the node. The trees
     * in the heap will be consolidated, if necessary. This operation may fail
     * to remove the correct element if there are nodes with key value -Infinity.
     * Running time: O(log n) amortized.
     * @memberof FibonacciHeap
     */


    FibonacciHeap.prototype.remove = function (node) {
      // decrease key value
      this._minimum = _decreaseKey(this._minimum, node, -1); // remove the smallest

      this.extractMinimum();
    };
    /**
     * Decreases the key value for a heap node, given the new value to take on.
     * The structure of the heap may be changed and will not be consolidated.
     * Running time: O(1) amortized.
     * @memberof FibonacciHeap
     */


    function _decreaseKey(minimum, node, key) {
      // set node key
      node.key = key; // get parent node

      var parent = node.parent;

      if (parent && smaller(node.key, parent.key)) {
        // remove node from parent
        _cut(minimum, node, parent); // remove all nodes from parent to the root parent


        _cascadingCut(minimum, parent);
      } // update minimum node if needed


      if (smaller(node.key, minimum.key)) {
        minimum = node;
      } // return minimum


      return minimum;
    }
    /**
     * The reverse of the link operation: removes node from the child list of parent.
     * This method assumes that min is non-null. Running time: O(1).
     * @memberof FibonacciHeap
     */


    function _cut(minimum, node, parent) {
      // remove node from parent children and decrement Degree[parent]
      node.left.right = node.right;
      node.right.left = node.left;
      parent.degree--; // reset y.child if necessary

      if (parent.child === node) {
        parent.child = node.right;
      } // remove child if degree is 0


      if (parent.degree === 0) {
        parent.child = null;
      } // add node to root list of heap


      node.left = minimum;
      node.right = minimum.right;
      minimum.right = node;
      node.right.left = node; // set parent[node] to null

      node.parent = null; // set mark[node] to false

      node.mark = false;
    }
    /**
     * Performs a cascading cut operation. This cuts node from its parent and then
     * does the same for its parent, and so on up the tree.
     * Running time: O(log n); O(1) excluding the recursion.
     * @memberof FibonacciHeap
     */


    function _cascadingCut(minimum, node) {
      // store parent node
      var parent = node.parent; // if there's a parent...

      if (!parent) {
        return;
      } // if node is unmarked, set it marked


      if (!node.mark) {
        node.mark = true;
      } else {
        // it's marked, cut it from parent
        _cut(minimum, node, parent); // cut its parent as well


        _cascadingCut(parent);
      }
    }
    /**
     * Make the first node a child of the second one. Running time: O(1) actual.
     * @memberof FibonacciHeap
     */


    var _linkNodes = function _linkNodes(node, parent) {
      // remove node from root list of heap
      node.left.right = node.right;
      node.right.left = node.left; // make node a Child of parent

      node.parent = parent;

      if (!parent.child) {
        parent.child = node;
        node.right = node;
        node.left = node;
      } else {
        node.left = parent.child;
        node.right = parent.child.right;
        parent.child.right = node;
        node.right.left = node;
      } // increase degree[parent]


      parent.degree++; // set mark[node] false

      node.mark = false;
    };

    function _findMinimumNode(minimum, size) {
      // to find trees of the same degree efficiently we use an array of length O(log n) in which we keep a pointer to one root of each degree
      var arraySize = Math.floor(Math.log(size) * oneOverLogPhi) + 1; // create list with initial capacity

      var array = new Array(arraySize); // find the number of root nodes.

      var numRoots = 0;
      var x = minimum;

      if (x) {
        numRoots++;
        x = x.right;

        while (x !== minimum) {
          numRoots++;
          x = x.right;
        }
      } // vars


      var y; // For each node in root list do...

      while (numRoots > 0) {
        // access this node's degree..
        var d = x.degree; // get next node

        var next = x.right; // check if there is a node already in array with the same degree

        while (true) {
          // get node with the same degree is any
          y = array[d];

          if (!y) {
            break;
          } // make one node with the same degree a child of the other, do this based on the key value.


          if (larger(x.key, y.key)) {
            var temp = y;
            y = x;
            x = temp;
          } // make y a child of x


          _linkNodes(y, x); // we have handled this degree, go to next one.


          array[d] = null;
          d++;
        } // save this node for later when we might encounter another of the same degree.


        array[d] = x; // move forward through list.

        x = next;
        numRoots--;
      } // Set min to null (effectively losing the root list) and reconstruct the root list from the array entries in array[].


      minimum = null; // loop nodes in array

      for (var i = 0; i < arraySize; i++) {
        // get current node
        y = array[i];

        if (!y) {
          continue;
        } // check if we have a linked list


        if (minimum) {
          // First remove node from root list.
          y.left.right = y.right;
          y.right.left = y.left; // now add to root list, again.

          y.left = minimum;
          y.right = minimum.right;
          minimum.right = y;
          y.right.left = y; // check if this is a new min.

          if (smaller(y.key, minimum.key)) {
            minimum = y;
          }
        } else {
          minimum = y;
        }
      }

      return minimum;
    }

    return FibonacciHeap;
  }, {
    isClass: true
  });

  var name$2d = 'Spa';
  var dependencies$2e = ['addScalar', 'equalScalar', 'FibonacciHeap'];
  var createSpaClass = /* #__PURE__ */factory(name$2d, dependencies$2e, function (_ref) {
    var addScalar = _ref.addScalar,
        equalScalar = _ref.equalScalar,
        FibonacciHeap = _ref.FibonacciHeap;

    /**
     * An ordered Sparse Accumulator is a representation for a sparse vector that includes a dense array
     * of the vector elements and an ordered list of non-zero elements.
     */
    function Spa() {
      if (!(this instanceof Spa)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      } // allocate vector, TODO use typed arrays


      this._values = [];
      this._heap = new FibonacciHeap();
    }
    /**
     * Attach type information
     */


    Spa.prototype.type = 'Spa';
    Spa.prototype.isSpa = true;
    /**
     * Set the value for index i.
     *
     * @param {number} i                       The index
     * @param {number | BigNumber | Complex}   The value at index i
     */

    Spa.prototype.set = function (i, v) {
      // check we have a value @ i
      if (!this._values[i]) {
        // insert in heap
        var node = this._heap.insert(i, v); // set the value @ i


        this._values[i] = node;
      } else {
        // update the value @ i
        this._values[i].value = v;
      }
    };

    Spa.prototype.get = function (i) {
      var node = this._values[i];

      if (node) {
        return node.value;
      }

      return 0;
    };

    Spa.prototype.accumulate = function (i, v) {
      // node @ i
      var node = this._values[i];

      if (!node) {
        // insert in heap
        node = this._heap.insert(i, v); // initialize value

        this._values[i] = node;
      } else {
        // accumulate value
        node.value = addScalar(node.value, v);
      }
    };

    Spa.prototype.forEach = function (from, to, callback) {
      // references
      var heap = this._heap;
      var values = this._values; // nodes

      var nodes = []; // node with minimum key, save it

      var node = heap.extractMinimum();

      if (node) {
        nodes.push(node);
      } // extract nodes from heap (ordered)


      while (node && node.key <= to) {
        // check it is in range
        if (node.key >= from) {
          // check value is not zero
          if (!equalScalar(node.value, 0)) {
            // invoke callback
            callback(node.key, node.value, this);
          }
        } // extract next node, save it


        node = heap.extractMinimum();

        if (node) {
          nodes.push(node);
        }
      } // reinsert all nodes in heap


      for (var i = 0; i < nodes.length; i++) {
        // current node
        var n = nodes[i]; // insert node in heap

        node = heap.insert(n.key, n.value); // update values

        values[node.key] = node;
      }
    };

    Spa.prototype.swap = function (i, j) {
      // node @ i and j
      var nodei = this._values[i];
      var nodej = this._values[j]; // check we need to insert indeces

      if (!nodei && nodej) {
        // insert in heap
        nodei = this._heap.insert(i, nodej.value); // remove from heap

        this._heap.remove(nodej); // set values


        this._values[i] = nodei;
        this._values[j] = undefined;
      } else if (nodei && !nodej) {
        // insert in heap
        nodej = this._heap.insert(j, nodei.value); // remove from heap

        this._heap.remove(nodei); // set values


        this._values[j] = nodej;
        this._values[i] = undefined;
      } else if (nodei && nodej) {
        // swap values
        var v = nodei.value;
        nodei.value = nodej.value;
        nodej.value = v;
      }
    };

    return Spa;
  }, {
    isClass: true
  });

  /**
   * Calculate BigNumber e
   * @param {function} BigNumber   BigNumber constructor
   * @returns {BigNumber} Returns e
   */

  var createBigNumberE = memoize(function (BigNumber) {
    return new BigNumber(1).exp();
  }, hasher);
  /**
   * Calculate BigNumber golden ratio, phi = (1+sqrt(5))/2
   * @param {function} BigNumber   BigNumber constructor
   * @returns {BigNumber} Returns phi
   */

  var createBigNumberPhi = memoize(function (BigNumber) {
    return new BigNumber(1).plus(new BigNumber(5).sqrt()).div(2);
  }, hasher);
  /**
   * Calculate BigNumber pi.
   * @param {function} BigNumber   BigNumber constructor
   * @returns {BigNumber} Returns pi
   */

  var createBigNumberPi = memoize(function (BigNumber) {
    return BigNumber.acos(-1);
  }, hasher);
  /**
   * Calculate BigNumber tau, tau = 2 * pi
   * @param {function} BigNumber   BigNumber constructor
   * @returns {BigNumber} Returns tau
   */

  var createBigNumberTau = memoize(function (BigNumber) {
    return createBigNumberPi(BigNumber).times(2);
  }, hasher);
  /**
   * Create a hash for a BigNumber constructor function. The created has is
   * the configured precision
   * @param {Array} args         Supposed to contain a single entry with
   *                             a BigNumber constructor
   * @return {number} precision
   * @private
   */

  function hasher(args) {
    return args[0].precision;
  }

  function _typeof$6(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$6 = function _typeof(obj) { return typeof obj; }; } else { _typeof$6 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$6(obj); }

  function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }

  function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  var name$2e = 'Unit';
  var dependencies$2f = ['?on', 'config', 'addScalar', 'subtract', 'multiplyScalar', 'divideScalar', 'pow', 'abs', 'fix', 'round', 'equal', 'isNumeric', 'format', 'number', 'Complex', 'BigNumber', 'Fraction'];
  var createUnitClass = /* #__PURE__ */factory(name$2e, dependencies$2f, function (_ref) {
    var on = _ref.on,
        config = _ref.config,
        addScalar = _ref.addScalar,
        subtract = _ref.subtract,
        multiplyScalar = _ref.multiplyScalar,
        divideScalar = _ref.divideScalar,
        pow = _ref.pow,
        abs = _ref.abs,
        fix = _ref.fix,
        round = _ref.round,
        equal = _ref.equal,
        isNumeric = _ref.isNumeric,
        format = _ref.format,
        number = _ref.number,
        Complex = _ref.Complex,
        _BigNumber = _ref.BigNumber,
        _Fraction = _ref.Fraction;
    var toNumber = number;
    /**
     * A unit can be constructed in the following ways:
     *
     *     const a = new Unit(value, name)
     *     const b = new Unit(null, name)
     *     const c = Unit.parse(str)
     *
     * Example usage:
     *
     *     const a = new Unit(5, 'cm')               // 50 mm
     *     const b = Unit.parse('23 kg')             // 23 kg
     *     const c = math.in(a, new Unit(null, 'm')  // 0.05 m
     *     const d = new Unit(9.81, "m/s^2")         // 9.81 m/s^2
     *
     * @class Unit
     * @constructor Unit
     * @param {number | BigNumber | Fraction | Complex | boolean} [value]  A value like 5.2
     * @param {string} [name]   A unit name like "cm" or "inch", or a derived unit of the form: "u1[^ex1] [u2[^ex2] ...] [/ u3[^ex3] [u4[^ex4]]]", such as "kg m^2/s^2", where each unit appearing after the forward slash is taken to be in the denominator. "kg m^2 s^-2" is a synonym and is also acceptable. Any of the units can include a prefix.
     */

    function Unit(value, name) {
      if (!(this instanceof Unit)) {
        throw new Error('Constructor must be called with the new operator');
      }

      if (!(value === null || value === undefined || isNumeric(value) || isComplex(value))) {
        throw new TypeError('First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined');
      }

      if (name !== undefined && (typeof name !== 'string' || name === '')) {
        throw new TypeError('Second parameter in Unit constructor must be a string');
      }

      if (name !== undefined) {
        var u = Unit.parse(name);
        this.units = u.units;
        this.dimensions = u.dimensions;
      } else {
        this.units = [{
          unit: UNIT_NONE,
          prefix: PREFIXES.NONE,
          // link to a list with supported prefixes
          power: 0
        }];
        this.dimensions = [];

        for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
          this.dimensions[i] = 0;
        }
      }

      this.value = value !== undefined && value !== null ? this._normalize(value) : null;
      this.fixPrefix = false; // if true, function format will not search for the
      // best prefix but leave it as initially provided.
      // fixPrefix is set true by the method Unit.to
      // The justification behind this is that if the constructor is explicitly called,
      // the caller wishes the units to be returned exactly as he supplied.

      this.skipAutomaticSimplification = true;
    }
    /**
     * Attach type information
     */


    Unit.prototype.type = 'Unit';
    Unit.prototype.isUnit = true; // private variables and functions for the Unit parser

    var text, index, c;

    function skipWhitespace() {
      while (c === ' ' || c === '\t') {
        next();
      }
    }

    function isDigitDot(c) {
      return c >= '0' && c <= '9' || c === '.';
    }

    function isDigit(c) {
      return c >= '0' && c <= '9';
    }

    function next() {
      index++;
      c = text.charAt(index);
    }

    function revert(oldIndex) {
      index = oldIndex;
      c = text.charAt(index);
    }

    function parseNumber() {
      var number = '';
      var oldIndex = index;

      if (c === '+') {
        next();
      } else if (c === '-') {
        number += c;
        next();
      }

      if (!isDigitDot(c)) {
        // a + or - must be followed by a digit
        revert(oldIndex);
        return null;
      } // get number, can have a single dot


      if (c === '.') {
        number += c;
        next();

        if (!isDigit(c)) {
          // this is no legal number, it is just a dot
          revert(oldIndex);
          return null;
        }
      } else {
        while (isDigit(c)) {
          number += c;
          next();
        }

        if (c === '.') {
          number += c;
          next();
        }
      }

      while (isDigit(c)) {
        number += c;
        next();
      } // check for exponential notation like "2.3e-4" or "1.23e50"


      if (c === 'E' || c === 'e') {
        // The grammar branches here. This could either be part of an exponent or the start of a unit that begins with the letter e, such as "4exabytes"
        var tentativeNumber = '';
        var tentativeIndex = index;
        tentativeNumber += c;
        next();

        if (c === '+' || c === '-') {
          tentativeNumber += c;
          next();
        } // Scientific notation MUST be followed by an exponent (otherwise we assume it is not scientific notation)


        if (!isDigit(c)) {
          // The e or E must belong to something else, so return the number without the e or E.
          revert(tentativeIndex);
          return number;
        } // We can now safely say that this is scientific notation.


        number = number + tentativeNumber;

        while (isDigit(c)) {
          number += c;
          next();
        }
      }

      return number;
    }

    function parseUnit() {
      var unitName = ''; // Alphanumeric characters only; matches [a-zA-Z0-9]

      var code = text.charCodeAt(index);

      while (code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122) {
        unitName += c;
        next();
        code = text.charCodeAt(index);
      } // Must begin with [a-zA-Z]


      code = unitName.charCodeAt(0);

      if (code >= 65 && code <= 90 || code >= 97 && code <= 122) {
        return unitName || null;
      } else {
        return null;
      }
    }

    function parseCharacter(toFind) {
      if (c === toFind) {
        next();
        return toFind;
      } else {
        return null;
      }
    }
    /**
     * Parse a string into a unit. The value of the unit is parsed as number,
     * BigNumber, or Fraction depending on the math.js config setting `number`.
     *
     * Throws an exception if the provided string does not contain a valid unit or
     * cannot be parsed.
     * @memberof Unit
     * @param {string} str        A string like "5.2 inch", "4e2 cm/s^2"
     * @return {Unit} unit
     */


    Unit.parse = function (str, options) {
      options = options || {};
      text = str;
      index = -1;
      c = '';

      if (typeof text !== 'string') {
        throw new TypeError('Invalid argument in Unit.parse, string expected');
      }

      var unit = new Unit();
      unit.units = [];
      var powerMultiplierCurrent = 1;
      var expectingUnit = false; // A unit should follow this pattern:
      // [number] ...[ [*/] unit[^number] ]
      // unit[^number] ... [ [*/] unit[^number] ]
      // Rules:
      // number is any floating point number.
      // unit is any alphanumeric string beginning with an alpha. Units with names like e3 should be avoided because they look like the exponent of a floating point number!
      // The string may optionally begin with a number.
      // Each unit may optionally be followed by ^number.
      // Whitespace or a forward slash is recommended between consecutive units, although the following technically is parseable:
      //   2m^2kg/s^2
      // it is not good form. If a unit starts with e, then it could be confused as a floating point number:
      //   4erg

      next();
      skipWhitespace(); // Optional number at the start of the string

      var valueStr = parseNumber();
      var value = null;

      if (valueStr) {
        if (config.number === 'BigNumber') {
          value = new _BigNumber(valueStr);
        } else if (config.number === 'Fraction') {
          try {
            // not all numbers can be turned in Fractions, for example very small numbers not
            value = new _Fraction(valueStr);
          } catch (err) {
            value = parseFloat(valueStr);
          }
        } else {
          // number
          value = parseFloat(valueStr);
        }

        skipWhitespace(); // Whitespace is not required here
        // handle multiplication or division right after the value, like '1/s'

        if (parseCharacter('*')) {
          powerMultiplierCurrent = 1;
          expectingUnit = true;
        } else if (parseCharacter('/')) {
          powerMultiplierCurrent = -1;
          expectingUnit = true;
        }
      } // Stack to keep track of powerMultipliers applied to each parentheses group


      var powerMultiplierStack = []; // Running product of all elements in powerMultiplierStack

      var powerMultiplierStackProduct = 1;

      while (true) {
        skipWhitespace(); // Check for and consume opening parentheses, pushing powerMultiplierCurrent to the stack
        // A '(' will always appear directly before a unit.

        while (c === '(') {
          powerMultiplierStack.push(powerMultiplierCurrent);
          powerMultiplierStackProduct *= powerMultiplierCurrent;
          powerMultiplierCurrent = 1;
          next();
          skipWhitespace();
        } // Is there something here?


        var uStr = void 0;

        if (c) {
          var oldC = c;
          uStr = parseUnit();

          if (uStr === null) {
            throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index.toString());
          }
        } else {
          // End of input.
          break;
        } // Verify the unit exists and get the prefix (if any)


        var res = _findUnit(uStr);

        if (res === null) {
          // Unit not found.
          throw new SyntaxError('Unit "' + uStr + '" not found.');
        }

        var power = powerMultiplierCurrent * powerMultiplierStackProduct; // Is there a "^ number"?

        skipWhitespace();

        if (parseCharacter('^')) {
          skipWhitespace();
          var p = parseNumber();

          if (p === null) {
            // No valid number found for the power!
            throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
          }

          power *= p;
        } // Add the unit to the list


        unit.units.push({
          unit: res.unit,
          prefix: res.prefix,
          power: power
        });

        for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
          unit.dimensions[i] += (res.unit.dimensions[i] || 0) * power;
        } // Check for and consume closing parentheses, popping from the stack.
        // A ')' will always follow a unit.


        skipWhitespace();

        while (c === ')') {
          if (powerMultiplierStack.length === 0) {
            throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index.toString());
          }

          powerMultiplierStackProduct /= powerMultiplierStack.pop();
          next();
          skipWhitespace();
        } // "*" and "/" should mean we are expecting something to come next.
        // Is there a forward slash? If so, negate powerMultiplierCurrent. The next unit or paren group is in the denominator.


        expectingUnit = false;

        if (parseCharacter('*')) {
          // explicit multiplication
          powerMultiplierCurrent = 1;
          expectingUnit = true;
        } else if (parseCharacter('/')) {
          // division
          powerMultiplierCurrent = -1;
          expectingUnit = true;
        } else {
          // implicit multiplication
          powerMultiplierCurrent = 1;
        } // Replace the unit into the auto unit system


        if (res.unit.base) {
          var baseDim = res.unit.base.key;
          UNIT_SYSTEMS.auto[baseDim] = {
            unit: res.unit,
            prefix: res.prefix
          };
        }
      } // Has the string been entirely consumed?


      skipWhitespace();

      if (c) {
        throw new SyntaxError('Could not parse: "' + str + '"');
      } // Is there a trailing slash?


      if (expectingUnit) {
        throw new SyntaxError('Trailing characters: "' + str + '"');
      } // Is the parentheses stack empty?


      if (powerMultiplierStack.length !== 0) {
        throw new SyntaxError('Unmatched "(" in "' + text + '"');
      } // Are there any units at all?


      if (unit.units.length === 0 && !options.allowNoUnits) {
        throw new SyntaxError('"' + str + '" contains no units');
      }

      unit.value = value !== undefined ? unit._normalize(value) : null;
      return unit;
    };
    /**
     * create a copy of this unit
     * @memberof Unit
     * @return {Unit} Returns a cloned version of the unit
     */


    Unit.prototype.clone = function () {
      var unit = new Unit();
      unit.fixPrefix = this.fixPrefix;
      unit.skipAutomaticSimplification = this.skipAutomaticSimplification;
      unit.value = clone(this.value);
      unit.dimensions = this.dimensions.slice(0);
      unit.units = [];

      for (var i = 0; i < this.units.length; i++) {
        unit.units[i] = {};

        for (var p in this.units[i]) {
          if (hasOwnProperty(this.units[i], p)) {
            unit.units[i][p] = this.units[i][p];
          }
        }
      }

      return unit;
    };
    /**
     * Return whether the unit is derived (such as m/s, or cm^2, but not N)
     * @memberof Unit
     * @return {boolean} True if the unit is derived
     */


    Unit.prototype._isDerived = function () {
      if (this.units.length === 0) {
        return false;
      }

      return this.units.length > 1 || Math.abs(this.units[0].power - 1.0) > 1e-15;
    };
    /**
     * Normalize a value, based on its currently set unit(s)
     * @memberof Unit
     * @param {number | BigNumber | Fraction | boolean} value
     * @return {number | BigNumber | Fraction | boolean} normalized value
     * @private
     */


    Unit.prototype._normalize = function (value) {
      var unitValue, unitOffset, unitPower, unitPrefixValue;
      var convert;

      if (value === null || value === undefined || this.units.length === 0) {
        return value;
      } else if (this._isDerived()) {
        // This is a derived unit, so do not apply offsets.
        // For example, with J kg^-1 degC^-1 you would NOT want to apply the offset.
        var res = value;
        convert = Unit._getNumberConverter(typeOf(value)); // convert to Fraction or BigNumber if needed

        for (var i = 0; i < this.units.length; i++) {
          unitValue = convert(this.units[i].unit.value);
          unitPrefixValue = convert(this.units[i].prefix.value);
          unitPower = convert(this.units[i].power);
          res = multiplyScalar(res, pow(multiplyScalar(unitValue, unitPrefixValue), unitPower));
        }

        return res;
      } else {
        // This is a single unit of power 1, like kg or degC
        convert = Unit._getNumberConverter(typeOf(value)); // convert to Fraction or BigNumber if needed

        unitValue = convert(this.units[0].unit.value);
        unitOffset = convert(this.units[0].unit.offset);
        unitPrefixValue = convert(this.units[0].prefix.value);
        return multiplyScalar(addScalar(value, unitOffset), multiplyScalar(unitValue, unitPrefixValue));
      }
    };
    /**
     * Denormalize a value, based on its currently set unit(s)
     * @memberof Unit
     * @param {number} value
     * @param {number} [prefixValue]    Optional prefix value to be used (ignored if this is a derived unit)
     * @return {number} denormalized value
     * @private
     */


    Unit.prototype._denormalize = function (value, prefixValue) {
      var unitValue, unitOffset, unitPower, unitPrefixValue;
      var convert;

      if (value === null || value === undefined || this.units.length === 0) {
        return value;
      } else if (this._isDerived()) {
        // This is a derived unit, so do not apply offsets.
        // For example, with J kg^-1 degC^-1 you would NOT want to apply the offset.
        // Also, prefixValue is ignored--but we will still use the prefix value stored in each unit, since kg is usually preferable to g unless the user decides otherwise.
        var res = value;
        convert = Unit._getNumberConverter(typeOf(value)); // convert to Fraction or BigNumber if needed

        for (var i = 0; i < this.units.length; i++) {
          unitValue = convert(this.units[i].unit.value);
          unitPrefixValue = convert(this.units[i].prefix.value);
          unitPower = convert(this.units[i].power);
          res = divideScalar(res, pow(multiplyScalar(unitValue, unitPrefixValue), unitPower));
        }

        return res;
      } else {
        // This is a single unit of power 1, like kg or degC
        convert = Unit._getNumberConverter(typeOf(value)); // convert to Fraction or BigNumber if needed

        unitValue = convert(this.units[0].unit.value);
        unitPrefixValue = convert(this.units[0].prefix.value);
        unitOffset = convert(this.units[0].unit.offset);

        if (prefixValue === undefined || prefixValue === null) {
          return subtract(divideScalar(divideScalar(value, unitValue), unitPrefixValue), unitOffset);
        } else {
          return subtract(divideScalar(divideScalar(value, unitValue), prefixValue), unitOffset);
        }
      }
    };
    /**
     * Find a unit from a string
     * @memberof Unit
     * @param {string} str              A string like 'cm' or 'inch'
     * @returns {Object | null} result  When found, an object with fields unit and
     *                                  prefix is returned. Else, null is returned.
     * @private
     */


    function _findUnit(str) {
      // First, match units names exactly. For example, a user could define 'mm' as 10^-4 m, which is silly, but then we would want 'mm' to match the user-defined unit.
      if (hasOwnProperty(UNITS, str)) {
        var unit = UNITS[str];
        var prefix = unit.prefixes[''];
        return {
          unit: unit,
          prefix: prefix
        };
      }

      for (var _name in UNITS) {
        if (hasOwnProperty(UNITS, _name)) {
          if (endsWith(str, _name)) {
            var _unit = UNITS[_name];
            var prefixLen = str.length - _name.length;
            var prefixName = str.substring(0, prefixLen);

            var _prefix = hasOwnProperty(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : undefined;

            if (_prefix !== undefined) {
              // store unit, prefix, and value
              return {
                unit: _unit,
                prefix: _prefix
              };
            }
          }
        }
      }

      return null;
    }
    /**
     * Test if the given expression is a unit.
     * The unit can have a prefix but cannot have a value.
     * @memberof Unit
     * @param {string} name   A string to be tested whether it is a value less unit.
     *                        The unit can have prefix, like "cm"
     * @return {boolean}      true if the given string is a unit
     */


    Unit.isValuelessUnit = function (name) {
      return _findUnit(name) !== null;
    };
    /**
     * check if this unit has given base unit
     * If this unit is a derived unit, this will ALWAYS return false, since by definition base units are not derived.
     * @memberof Unit
     * @param {BASE_UNITS | string | undefined} base
     */


    Unit.prototype.hasBase = function (base) {
      if (typeof base === 'string') {
        base = BASE_UNITS[base];
      }

      if (!base) {
        return false;
      } // All dimensions must be the same


      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        if (Math.abs((this.dimensions[i] || 0) - (base.dimensions[i] || 0)) > 1e-12) {
          return false;
        }
      }

      return true;
    };
    /**
     * Check if this unit has a base or bases equal to another base or bases
     * For derived units, the exponent on each base also must match
     * @memberof Unit
     * @param {Unit} other
     * @return {boolean} true if equal base
     */


    Unit.prototype.equalBase = function (other) {
      // All dimensions must be the same
      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        if (Math.abs((this.dimensions[i] || 0) - (other.dimensions[i] || 0)) > 1e-12) {
          return false;
        }
      }

      return true;
    };
    /**
     * Check if this unit equals another unit
     * @memberof Unit
     * @param {Unit} other
     * @return {boolean} true if both units are equal
     */


    Unit.prototype.equals = function (other) {
      return this.equalBase(other) && equal(this.value, other.value);
    };
    /**
     * Multiply this unit with another one
     * @memberof Unit
     * @param {Unit} other
     * @return {Unit} product of this unit and the other unit
     */


    Unit.prototype.multiply = function (other) {
      var res = this.clone();

      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        // Dimensions arrays may be of different lengths. Default to 0.
        res.dimensions[i] = (this.dimensions[i] || 0) + (other.dimensions[i] || 0);
      } // Append other's units list onto res


      for (var _i = 0; _i < other.units.length; _i++) {
        // Make a shallow copy of every unit
        var inverted = _objectSpread$1({}, other.units[_i]);

        res.units.push(inverted);
      } // If at least one operand has a value, then the result should also have a value


      if (this.value !== null || other.value !== null) {
        var valThis = this.value === null ? this._normalize(1) : this.value;
        var valOther = other.value === null ? other._normalize(1) : other.value;
        res.value = multiplyScalar(valThis, valOther);
      } else {
        res.value = null;
      }

      res.skipAutomaticSimplification = false;
      return getNumericIfUnitless(res);
    };
    /**
     * Divide this unit by another one
     * @memberof Unit
     * @param {Unit} other
     * @return {Unit} result of dividing this unit by the other unit
     */


    Unit.prototype.divide = function (other) {
      var res = this.clone();

      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        // Dimensions arrays may be of different lengths. Default to 0.
        res.dimensions[i] = (this.dimensions[i] || 0) - (other.dimensions[i] || 0);
      } // Invert and append other's units list onto res


      for (var _i2 = 0; _i2 < other.units.length; _i2++) {
        // Make a shallow copy of every unit
        var inverted = _objectSpread$1(_objectSpread$1({}, other.units[_i2]), {}, {
          power: -other.units[_i2].power
        });

        res.units.push(inverted);
      } // If at least one operand has a value, the result should have a value


      if (this.value !== null || other.value !== null) {
        var valThis = this.value === null ? this._normalize(1) : this.value;
        var valOther = other.value === null ? other._normalize(1) : other.value;
        res.value = divideScalar(valThis, valOther);
      } else {
        res.value = null;
      }

      res.skipAutomaticSimplification = false;
      return getNumericIfUnitless(res);
    };
    /**
     * Calculate the power of a unit
     * @memberof Unit
     * @param {number | Fraction | BigNumber} p
     * @returns {Unit}      The result: this^p
     */


    Unit.prototype.pow = function (p) {
      var res = this.clone();

      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        // Dimensions arrays may be of different lengths. Default to 0.
        res.dimensions[i] = (this.dimensions[i] || 0) * p;
      } // Adjust the power of each unit in the list


      for (var _i3 = 0; _i3 < res.units.length; _i3++) {
        res.units[_i3].power *= p;
      }

      if (res.value !== null) {
        res.value = pow(res.value, p); // only allow numeric output, we don't want to return a Complex number
        // if (!isNumeric(res.value)) {
        //  res.value = NaN
        // }
        // Update: Complex supported now
      } else {
        res.value = null;
      }

      res.skipAutomaticSimplification = false;
      return getNumericIfUnitless(res);
    };
    /**
     * Return the numeric value of this unit if it is dimensionless, has a value, and config.predictable == false; or the original unit otherwise
     * @param {Unit} unit
     * @returns {number | Fraction | BigNumber | Unit}  The numeric value of the unit if conditions are met, or the original unit otherwise
     */


    function getNumericIfUnitless(unit) {
      if (unit.equalBase(BASE_UNITS.NONE) && unit.value !== null && !config.predictable) {
        return unit.value;
      } else {
        return unit;
      }
    }
    /**
     * Calculate the absolute value of a unit
     * @memberof Unit
     * @param {number | Fraction | BigNumber} x
     * @returns {Unit}      The result: |x|, absolute value of x
     */


    Unit.prototype.abs = function () {
      // This gives correct, but unexpected, results for units with an offset.
      // For example, abs(-283.15 degC) = -263.15 degC !!!
      var ret = this.clone();
      ret.value = ret.value !== null ? abs(ret.value) : null;

      for (var i in ret.units) {
        if (ret.units[i].unit.name === 'VA' || ret.units[i].unit.name === 'VAR') {
          ret.units[i].unit = UNITS.W;
        }
      }

      return ret;
    };
    /**
     * Convert the unit to a specific unit name.
     * @memberof Unit
     * @param {string | Unit} valuelessUnit   A unit without value. Can have prefix, like "cm"
     * @returns {Unit} Returns a clone of the unit with a fixed prefix and unit.
     */


    Unit.prototype.to = function (valuelessUnit) {
      var other;
      var value = this.value === null ? this._normalize(1) : this.value;

      if (typeof valuelessUnit === 'string') {
        // other = new Unit(null, valuelessUnit)
        other = Unit.parse(valuelessUnit);

        if (!this.equalBase(other)) {
          throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
        }

        if (other.value !== null) {
          throw new Error('Cannot convert to a unit with a value');
        }

        other.value = clone(value);
        other.fixPrefix = true;
        other.skipAutomaticSimplification = true;
        return other;
      } else if (isUnit(valuelessUnit)) {
        if (!this.equalBase(valuelessUnit)) {
          throw new Error("Units do not match ('".concat(valuelessUnit.toString(), "' != '").concat(this.toString(), "')"));
        }

        if (valuelessUnit.value !== null) {
          throw new Error('Cannot convert to a unit with a value');
        }

        other = valuelessUnit.clone();
        other.value = clone(value);
        other.fixPrefix = true;
        other.skipAutomaticSimplification = true;
        return other;
      } else {
        throw new Error('String or Unit expected as parameter');
      }
    };
    /**
     * Return the value of the unit when represented with given valueless unit
     * @memberof Unit
     * @param {string | Unit} valuelessUnit    For example 'cm' or 'inch'
     * @return {number} Returns the unit value as number.
     */
    // TODO: deprecate Unit.toNumber? It's always better to use toNumeric


    Unit.prototype.toNumber = function (valuelessUnit) {
      return toNumber(this.toNumeric(valuelessUnit));
    };
    /**
     * Return the value of the unit in the original numeric type
     * @memberof Unit
     * @param {string | Unit} valuelessUnit    For example 'cm' or 'inch'
     * @return {number | BigNumber | Fraction} Returns the unit value
     */


    Unit.prototype.toNumeric = function (valuelessUnit) {
      var other;

      if (valuelessUnit) {
        // Allow getting the numeric value without converting to a different unit
        other = this.to(valuelessUnit);
      } else {
        other = this.clone();
      }

      if (other._isDerived() || other.units.length === 0) {
        return other._denormalize(other.value);
      } else {
        return other._denormalize(other.value, other.units[0].prefix.value);
      }
    };
    /**
     * Get a string representation of the unit.
     * @memberof Unit
     * @return {string}
     */


    Unit.prototype.toString = function () {
      return this.format();
    };
    /**
     * Get a JSON representation of the unit
     * @memberof Unit
     * @returns {Object} Returns a JSON object structured as:
     *                   `{"mathjs": "Unit", "value": 2, "unit": "cm", "fixPrefix": false}`
     */


    Unit.prototype.toJSON = function () {
      return {
        mathjs: 'Unit',
        value: this._denormalize(this.value),
        unit: this.formatUnits(),
        fixPrefix: this.fixPrefix
      };
    };
    /**
     * Instantiate a Unit from a JSON object
     * @memberof Unit
     * @param {Object} json  A JSON object structured as:
     *                       `{"mathjs": "Unit", "value": 2, "unit": "cm", "fixPrefix": false}`
     * @return {Unit}
     */


    Unit.fromJSON = function (json) {
      var unit = new Unit(json.value, json.unit);
      unit.fixPrefix = json.fixPrefix || false;
      return unit;
    };
    /**
     * Returns the string representation of the unit.
     * @memberof Unit
     * @return {string}
     */


    Unit.prototype.valueOf = Unit.prototype.toString;
    /**
     * Simplify this Unit's unit list and return a new Unit with the simplified list.
     * The returned Unit will contain a list of the "best" units for formatting.
     */

    Unit.prototype.simplify = function () {
      var ret = this.clone();
      var proposedUnitList = []; // Search for a matching base

      var matchingBase;

      for (var key in currentUnitSystem) {
        if (hasOwnProperty(currentUnitSystem, key)) {
          if (ret.hasBase(BASE_UNITS[key])) {
            matchingBase = key;
            break;
          }
        }
      }

      if (matchingBase === 'NONE') {
        ret.units = [];
      } else {
        var matchingUnit;

        if (matchingBase) {
          // Does the unit system have a matching unit?
          if (hasOwnProperty(currentUnitSystem, matchingBase)) {
            matchingUnit = currentUnitSystem[matchingBase];
          }
        }

        if (matchingUnit) {
          ret.units = [{
            unit: matchingUnit.unit,
            prefix: matchingUnit.prefix,
            power: 1.0
          }];
        } else {
          // Multiple units or units with powers are formatted like this:
          // 5 (kg m^2) / (s^3 mol)
          // Build an representation from the base units of the current unit system
          var missingBaseDim = false;

          for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
            var baseDim = BASE_DIMENSIONS[i];

            if (Math.abs(ret.dimensions[i] || 0) > 1e-12) {
              if (hasOwnProperty(currentUnitSystem, baseDim)) {
                proposedUnitList.push({
                  unit: currentUnitSystem[baseDim].unit,
                  prefix: currentUnitSystem[baseDim].prefix,
                  power: ret.dimensions[i] || 0
                });
              } else {
                missingBaseDim = true;
              }
            }
          } // Is the proposed unit list "simpler" than the existing one?


          if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
            // Replace this unit list with the proposed list
            ret.units = proposedUnitList;
          }
        }
      }

      return ret;
    };
    /**
     * Returns a new Unit in the SI system with the same value as this one
     */


    Unit.prototype.toSI = function () {
      var ret = this.clone();
      var proposedUnitList = []; // Multiple units or units with powers are formatted like this:
      // 5 (kg m^2) / (s^3 mol)
      // Build an representation from the base units of the SI unit system

      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        var baseDim = BASE_DIMENSIONS[i];

        if (Math.abs(ret.dimensions[i] || 0) > 1e-12) {
          if (hasOwnProperty(UNIT_SYSTEMS.si, baseDim)) {
            proposedUnitList.push({
              unit: UNIT_SYSTEMS.si[baseDim].unit,
              prefix: UNIT_SYSTEMS.si[baseDim].prefix,
              power: ret.dimensions[i] || 0
            });
          } else {
            throw new Error('Cannot express custom unit ' + baseDim + ' in SI units');
          }
        }
      } // Replace this unit list with the proposed list


      ret.units = proposedUnitList;
      ret.fixPrefix = true;
      ret.skipAutomaticSimplification = true;
      return ret;
    };
    /**
     * Get a string representation of the units of this Unit, without the value. The unit list is formatted as-is without first being simplified.
     * @memberof Unit
     * @return {string}
     */


    Unit.prototype.formatUnits = function () {
      var strNum = '';
      var strDen = '';
      var nNum = 0;
      var nDen = 0;

      for (var i = 0; i < this.units.length; i++) {
        if (this.units[i].power > 0) {
          nNum++;
          strNum += ' ' + this.units[i].prefix.name + this.units[i].unit.name;

          if (Math.abs(this.units[i].power - 1.0) > 1e-15) {
            strNum += '^' + this.units[i].power;
          }
        } else if (this.units[i].power < 0) {
          nDen++;
        }
      }

      if (nDen > 0) {
        for (var _i4 = 0; _i4 < this.units.length; _i4++) {
          if (this.units[_i4].power < 0) {
            if (nNum > 0) {
              strDen += ' ' + this.units[_i4].prefix.name + this.units[_i4].unit.name;

              if (Math.abs(this.units[_i4].power + 1.0) > 1e-15) {
                strDen += '^' + -this.units[_i4].power;
              }
            } else {
              strDen += ' ' + this.units[_i4].prefix.name + this.units[_i4].unit.name;
              strDen += '^' + this.units[_i4].power;
            }
          }
        }
      } // Remove leading " "


      strNum = strNum.substr(1);
      strDen = strDen.substr(1); // Add parans for better copy/paste back into evaluate, for example, or for better pretty print formatting

      if (nNum > 1 && nDen > 0) {
        strNum = '(' + strNum + ')';
      }

      if (nDen > 1 && nNum > 0) {
        strDen = '(' + strDen + ')';
      }

      var str = strNum;

      if (nNum > 0 && nDen > 0) {
        str += ' / ';
      }

      str += strDen;
      return str;
    };
    /**
     * Get a string representation of the Unit, with optional formatting options.
     * @memberof Unit
     * @param {Object | number | Function} [options]  Formatting options. See
     *                                                lib/utils/number:format for a
     *                                                description of the available
     *                                                options.
     * @return {string}
     */


    Unit.prototype.format = function (options) {
      // Simplfy the unit list, unless it is valueless or was created directly in the
      // constructor or as the result of to or toSI
      var simp = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify(); // Apply some custom logic for handling VA and VAR. The goal is to express the value of the unit as a real value, if possible. Otherwise, use a real-valued unit instead of a complex-valued one.

      var isImaginary = false;

      if (typeof simp.value !== 'undefined' && simp.value !== null && isComplex(simp.value)) {
        // TODO: Make this better, for example, use relative magnitude of re and im rather than absolute
        isImaginary = Math.abs(simp.value.re) < 1e-14;
      }

      for (var i in simp.units) {
        if (hasOwnProperty(simp.units, i)) {
          if (simp.units[i].unit) {
            if (simp.units[i].unit.name === 'VA' && isImaginary) {
              simp.units[i].unit = UNITS.VAR;
            } else if (simp.units[i].unit.name === 'VAR' && !isImaginary) {
              simp.units[i].unit = UNITS.VA;
            }
          }
        }
      } // Now apply the best prefix
      // Units must have only one unit and not have the fixPrefix flag set


      if (simp.units.length === 1 && !simp.fixPrefix) {
        // Units must have integer powers, otherwise the prefix will change the
        // outputted value by not-an-integer-power-of-ten
        if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 1e-14) {
          // Apply the best prefix
          simp.units[0].prefix = simp._bestPrefix();
        }
      }

      var value = simp._denormalize(simp.value);

      var str = simp.value !== null ? format(value, options || {}) : '';
      var unitStr = simp.formatUnits();

      if (simp.value && isComplex(simp.value)) {
        str = '(' + str + ')'; // Surround complex values with ( ) to enable better parsing
      }

      if (unitStr.length > 0 && str.length > 0) {
        str += ' ';
      }

      str += unitStr;
      return str;
    };
    /**
     * Calculate the best prefix using current value.
     * @memberof Unit
     * @returns {Object} prefix
     * @private
     */


    Unit.prototype._bestPrefix = function () {
      if (this.units.length !== 1) {
        throw new Error('Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!');
      }

      if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
        throw new Error('Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!');
      } // find the best prefix value (resulting in the value of which
      // the absolute value of the log10 is closest to zero,
      // though with a little offset of 1.2 for nicer values: you get a
      // sequence 1mm 100mm 500mm 0.6m 1m 10m 100m 500m 0.6km 1km ...
      // Note: the units value can be any numeric type, but to find the best
      // prefix it's enough to work with limited precision of a regular number
      // Update: using mathjs abs since we also allow complex numbers


      var absValue = this.value !== null ? abs(this.value) : 0;
      var absUnitValue = abs(this.units[0].unit.value);
      var bestPrefix = this.units[0].prefix;

      if (absValue === 0) {
        return bestPrefix;
      }

      var power = this.units[0].power;
      var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
      if (bestDiff > -2.200001 && bestDiff < 1.800001) return bestPrefix; // Allow the original prefix

      bestDiff = Math.abs(bestDiff);
      var prefixes = this.units[0].unit.prefixes;

      for (var p in prefixes) {
        if (hasOwnProperty(prefixes, p)) {
          var prefix = prefixes[p];

          if (prefix.scientific) {
            var diff = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);

            if (diff < bestDiff || diff === bestDiff && prefix.name.length < bestPrefix.name.length) {
              // choose the prefix with the smallest diff, or if equal, choose the one
              // with the shortest name (can happen with SHORTLONG for example)
              bestPrefix = prefix;
              bestDiff = diff;
            }
          }
        }
      }

      return bestPrefix;
    };
    /**
     * Returns an array of units whose sum is equal to this unit
     * @memberof Unit
     * @param {Array} [parts] An array of strings or valueless units.
     *
     *   Example:
     *
     *   const u = new Unit(1, 'm')
     *   u.splitUnit(['feet', 'inch'])
     *     [ 3 feet, 3.3700787401575 inch ]
     *
     * @return {Array} An array of units.
     */


    Unit.prototype.splitUnit = function (parts) {
      var x = this.clone();
      var ret = [];

      for (var i = 0; i < parts.length; i++) {
        // Convert x to the requested unit
        x = x.to(parts[i]);
        if (i === parts.length - 1) break; // Get the numeric value of this unit

        var xNumeric = x.toNumeric(); // Check to see if xNumeric is nearly equal to an integer,
        // since fix can incorrectly round down if there is round-off error

        var xRounded = round(xNumeric);
        var xFixed = void 0;
        var isNearlyEqual = equal(xRounded, xNumeric);

        if (isNearlyEqual) {
          xFixed = xRounded;
        } else {
          xFixed = fix(x.toNumeric());
        }

        var y = new Unit(xFixed, parts[i].toString());
        ret.push(y);
        x = subtract(x, y);
      } // This little bit fixes a bug where the remainder should be 0 but is a little bit off.
      // But instead of comparing x, the remainder, with zero--we will compare the sum of
      // all the parts so far with the original value. If they are nearly equal,
      // we set the remainder to 0.


      var testSum = 0;

      for (var _i5 = 0; _i5 < ret.length; _i5++) {
        testSum = addScalar(testSum, ret[_i5].value);
      }

      if (equal(testSum, this.value)) {
        x.value = 0;
      }

      ret.push(x);
      return ret;
    };

    var PREFIXES = {
      NONE: {
        '': {
          name: '',
          value: 1,
          scientific: true
        }
      },
      SHORT: {
        '': {
          name: '',
          value: 1,
          scientific: true
        },
        da: {
          name: 'da',
          value: 1e1,
          scientific: false
        },
        h: {
          name: 'h',
          value: 1e2,
          scientific: false
        },
        k: {
          name: 'k',
          value: 1e3,
          scientific: true
        },
        M: {
          name: 'M',
          value: 1e6,
          scientific: true
        },
        G: {
          name: 'G',
          value: 1e9,
          scientific: true
        },
        T: {
          name: 'T',
          value: 1e12,
          scientific: true
        },
        P: {
          name: 'P',
          value: 1e15,
          scientific: true
        },
        E: {
          name: 'E',
          value: 1e18,
          scientific: true
        },
        Z: {
          name: 'Z',
          value: 1e21,
          scientific: true
        },
        Y: {
          name: 'Y',
          value: 1e24,
          scientific: true
        },
        d: {
          name: 'd',
          value: 1e-1,
          scientific: false
        },
        c: {
          name: 'c',
          value: 1e-2,
          scientific: false
        },
        m: {
          name: 'm',
          value: 1e-3,
          scientific: true
        },
        u: {
          name: 'u',
          value: 1e-6,
          scientific: true
        },
        n: {
          name: 'n',
          value: 1e-9,
          scientific: true
        },
        p: {
          name: 'p',
          value: 1e-12,
          scientific: true
        },
        f: {
          name: 'f',
          value: 1e-15,
          scientific: true
        },
        a: {
          name: 'a',
          value: 1e-18,
          scientific: true
        },
        z: {
          name: 'z',
          value: 1e-21,
          scientific: true
        },
        y: {
          name: 'y',
          value: 1e-24,
          scientific: true
        }
      },
      LONG: {
        '': {
          name: '',
          value: 1,
          scientific: true
        },
        deca: {
          name: 'deca',
          value: 1e1,
          scientific: false
        },
        hecto: {
          name: 'hecto',
          value: 1e2,
          scientific: false
        },
        kilo: {
          name: 'kilo',
          value: 1e3,
          scientific: true
        },
        mega: {
          name: 'mega',
          value: 1e6,
          scientific: true
        },
        giga: {
          name: 'giga',
          value: 1e9,
          scientific: true
        },
        tera: {
          name: 'tera',
          value: 1e12,
          scientific: true
        },
        peta: {
          name: 'peta',
          value: 1e15,
          scientific: true
        },
        exa: {
          name: 'exa',
          value: 1e18,
          scientific: true
        },
        zetta: {
          name: 'zetta',
          value: 1e21,
          scientific: true
        },
        yotta: {
          name: 'yotta',
          value: 1e24,
          scientific: true
        },
        deci: {
          name: 'deci',
          value: 1e-1,
          scientific: false
        },
        centi: {
          name: 'centi',
          value: 1e-2,
          scientific: false
        },
        milli: {
          name: 'milli',
          value: 1e-3,
          scientific: true
        },
        micro: {
          name: 'micro',
          value: 1e-6,
          scientific: true
        },
        nano: {
          name: 'nano',
          value: 1e-9,
          scientific: true
        },
        pico: {
          name: 'pico',
          value: 1e-12,
          scientific: true
        },
        femto: {
          name: 'femto',
          value: 1e-15,
          scientific: true
        },
        atto: {
          name: 'atto',
          value: 1e-18,
          scientific: true
        },
        zepto: {
          name: 'zepto',
          value: 1e-21,
          scientific: true
        },
        yocto: {
          name: 'yocto',
          value: 1e-24,
          scientific: true
        }
      },
      SQUARED: {
        '': {
          name: '',
          value: 1,
          scientific: true
        },
        da: {
          name: 'da',
          value: 1e2,
          scientific: false
        },
        h: {
          name: 'h',
          value: 1e4,
          scientific: false
        },
        k: {
          name: 'k',
          value: 1e6,
          scientific: true
        },
        M: {
          name: 'M',
          value: 1e12,
          scientific: true
        },
        G: {
          name: 'G',
          value: 1e18,
          scientific: true
        },
        T: {
          name: 'T',
          value: 1e24,
          scientific: true
        },
        P: {
          name: 'P',
          value: 1e30,
          scientific: true
        },
        E: {
          name: 'E',
          value: 1e36,
          scientific: true
        },
        Z: {
          name: 'Z',
          value: 1e42,
          scientific: true
        },
        Y: {
          name: 'Y',
          value: 1e48,
          scientific: true
        },
        d: {
          name: 'd',
          value: 1e-2,
          scientific: false
        },
        c: {
          name: 'c',
          value: 1e-4,
          scientific: false
        },
        m: {
          name: 'm',
          value: 1e-6,
          scientific: true
        },
        u: {
          name: 'u',
          value: 1e-12,
          scientific: true
        },
        n: {
          name: 'n',
          value: 1e-18,
          scientific: true
        },
        p: {
          name: 'p',
          value: 1e-24,
          scientific: true
        },
        f: {
          name: 'f',
          value: 1e-30,
          scientific: true
        },
        a: {
          name: 'a',
          value: 1e-36,
          scientific: true
        },
        z: {
          name: 'z',
          value: 1e-42,
          scientific: true
        },
        y: {
          name: 'y',
          value: 1e-48,
          scientific: true
        }
      },
      CUBIC: {
        '': {
          name: '',
          value: 1,
          scientific: true
        },
        da: {
          name: 'da',
          value: 1e3,
          scientific: false
        },
        h: {
          name: 'h',
          value: 1e6,
          scientific: false
        },
        k: {
          name: 'k',
          value: 1e9,
          scientific: true
        },
        M: {
          name: 'M',
          value: 1e18,
          scientific: true
        },
        G: {
          name: 'G',
          value: 1e27,
          scientific: true
        },
        T: {
          name: 'T',
          value: 1e36,
          scientific: true
        },
        P: {
          name: 'P',
          value: 1e45,
          scientific: true
        },
        E: {
          name: 'E',
          value: 1e54,
          scientific: true
        },
        Z: {
          name: 'Z',
          value: 1e63,
          scientific: true
        },
        Y: {
          name: 'Y',
          value: 1e72,
          scientific: true
        },
        d: {
          name: 'd',
          value: 1e-3,
          scientific: false
        },
        c: {
          name: 'c',
          value: 1e-6,
          scientific: false
        },
        m: {
          name: 'm',
          value: 1e-9,
          scientific: true
        },
        u: {
          name: 'u',
          value: 1e-18,
          scientific: true
        },
        n: {
          name: 'n',
          value: 1e-27,
          scientific: true
        },
        p: {
          name: 'p',
          value: 1e-36,
          scientific: true
        },
        f: {
          name: 'f',
          value: 1e-45,
          scientific: true
        },
        a: {
          name: 'a',
          value: 1e-54,
          scientific: true
        },
        z: {
          name: 'z',
          value: 1e-63,
          scientific: true
        },
        y: {
          name: 'y',
          value: 1e-72,
          scientific: true
        }
      },
      BINARY_SHORT_SI: {
        '': {
          name: '',
          value: 1,
          scientific: true
        },
        k: {
          name: 'k',
          value: 1e3,
          scientific: true
        },
        M: {
          name: 'M',
          value: 1e6,
          scientific: true
        },
        G: {
          name: 'G',
          value: 1e9,
          scientific: true
        },
        T: {
          name: 'T',
          value: 1e12,
          scientific: true
        },
        P: {
          name: 'P',
          value: 1e15,
          scientific: true
        },
        E: {
          name: 'E',
          value: 1e18,
          scientific: true
        },
        Z: {
          name: 'Z',
          value: 1e21,
          scientific: true
        },
        Y: {
          name: 'Y',
          value: 1e24,
          scientific: true
        }
      },
      BINARY_SHORT_IEC: {
        '': {
          name: '',
          value: 1,
          scientific: true
        },
        Ki: {
          name: 'Ki',
          value: 1024,
          scientific: true
        },
        Mi: {
          name: 'Mi',
          value: Math.pow(1024, 2),
          scientific: true
        },
        Gi: {
          name: 'Gi',
          value: Math.pow(1024, 3),
          scientific: true
        },
        Ti: {
          name: 'Ti',
          value: Math.pow(1024, 4),
          scientific: true
        },
        Pi: {
          name: 'Pi',
          value: Math.pow(1024, 5),
          scientific: true
        },
        Ei: {
          name: 'Ei',
          value: Math.pow(1024, 6),
          scientific: true
        },
        Zi: {
          name: 'Zi',
          value: Math.pow(1024, 7),
          scientific: true
        },
        Yi: {
          name: 'Yi',
          value: Math.pow(1024, 8),
          scientific: true
        }
      },
      BINARY_LONG_SI: {
        '': {
          name: '',
          value: 1,
          scientific: true
        },
        kilo: {
          name: 'kilo',
          value: 1e3,
          scientific: true
        },
        mega: {
          name: 'mega',
          value: 1e6,
          scientific: true
        },
        giga: {
          name: 'giga',
          value: 1e9,
          scientific: true
        },
        tera: {
          name: 'tera',
          value: 1e12,
          scientific: true
        },
        peta: {
          name: 'peta',
          value: 1e15,
          scientific: true
        },
        exa: {
          name: 'exa',
          value: 1e18,
          scientific: true
        },
        zetta: {
          name: 'zetta',
          value: 1e21,
          scientific: true
        },
        yotta: {
          name: 'yotta',
          value: 1e24,
          scientific: true
        }
      },
      BINARY_LONG_IEC: {
        '': {
          name: '',
          value: 1,
          scientific: true
        },
        kibi: {
          name: 'kibi',
          value: 1024,
          scientific: true
        },
        mebi: {
          name: 'mebi',
          value: Math.pow(1024, 2),
          scientific: true
        },
        gibi: {
          name: 'gibi',
          value: Math.pow(1024, 3),
          scientific: true
        },
        tebi: {
          name: 'tebi',
          value: Math.pow(1024, 4),
          scientific: true
        },
        pebi: {
          name: 'pebi',
          value: Math.pow(1024, 5),
          scientific: true
        },
        exi: {
          name: 'exi',
          value: Math.pow(1024, 6),
          scientific: true
        },
        zebi: {
          name: 'zebi',
          value: Math.pow(1024, 7),
          scientific: true
        },
        yobi: {
          name: 'yobi',
          value: Math.pow(1024, 8),
          scientific: true
        }
      },
      BTU: {
        '': {
          name: '',
          value: 1,
          scientific: true
        },
        MM: {
          name: 'MM',
          value: 1e6,
          scientific: true
        }
      }
    };
    PREFIXES.SHORTLONG = _extends$1({}, PREFIXES.SHORT, PREFIXES.LONG);
    PREFIXES.BINARY_SHORT = _extends$1({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
    PREFIXES.BINARY_LONG = _extends$1({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);
    /* Internally, each unit is represented by a value and a dimension array. The elements of the dimensions array have the following meaning:
     * Index  Dimension
     * -----  ---------
     *   0    Length
     *   1    Mass
     *   2    Time
     *   3    Current
     *   4    Temperature
     *   5    Luminous intensity
     *   6    Amount of substance
     *   7    Angle
     *   8    Bit (digital)
     * For example, the unit "298.15 K" is a pure temperature and would have a value of 298.15 and a dimension array of [0, 0, 0, 0, 1, 0, 0, 0, 0]. The unit "1 cal / (gm C)" can be written in terms of the 9 fundamental dimensions as [length^2] / ([time^2] * [temperature]), and would a value of (after conversion to SI) 4184.0 and a dimensions array of [2, 0, -2, 0, -1, 0, 0, 0, 0].
     *
     */

    var BASE_DIMENSIONS = ['MASS', 'LENGTH', 'TIME', 'CURRENT', 'TEMPERATURE', 'LUMINOUS_INTENSITY', 'AMOUNT_OF_SUBSTANCE', 'ANGLE', 'BIT'];
    var BASE_UNITS = {
      NONE: {
        dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      MASS: {
        dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      LENGTH: {
        dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
      },
      TIME: {
        dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
      },
      CURRENT: {
        dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
      },
      TEMPERATURE: {
        dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
      },
      LUMINOUS_INTENSITY: {
        dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
      },
      AMOUNT_OF_SUBSTANCE: {
        dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
      },
      FORCE: {
        dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
      },
      SURFACE: {
        dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
      },
      VOLUME: {
        dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
      },
      ENERGY: {
        dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
      },
      POWER: {
        dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
      },
      PRESSURE: {
        dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
      },
      ELECTRIC_CHARGE: {
        dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
      },
      ELECTRIC_CAPACITANCE: {
        dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
      },
      ELECTRIC_POTENTIAL: {
        dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
      },
      ELECTRIC_RESISTANCE: {
        dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
      },
      ELECTRIC_INDUCTANCE: {
        dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
      },
      ELECTRIC_CONDUCTANCE: {
        dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
      },
      MAGNETIC_FLUX: {
        dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
      },
      MAGNETIC_FLUX_DENSITY: {
        dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
      },
      FREQUENCY: {
        dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
      },
      ANGLE: {
        dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
      },
      BIT: {
        dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
      }
    };

    for (var key in BASE_UNITS) {
      if (hasOwnProperty(BASE_UNITS, key)) {
        BASE_UNITS[key].key = key;
      }
    }

    var BASE_UNIT_NONE = {};
    var UNIT_NONE = {
      name: '',
      base: BASE_UNIT_NONE,
      value: 1,
      offset: 0,
      dimensions: BASE_DIMENSIONS.map(function (x) {
        return 0;
      })
    };
    var UNITS = {
      // length
      meter: {
        name: 'meter',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      inch: {
        name: 'inch',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.0254,
        offset: 0
      },
      foot: {
        name: 'foot',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.3048,
        offset: 0
      },
      yard: {
        name: 'yard',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.9144,
        offset: 0
      },
      mile: {
        name: 'mile',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 1609.344,
        offset: 0
      },
      link: {
        name: 'link',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.201168,
        offset: 0
      },
      rod: {
        name: 'rod',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 5.0292,
        offset: 0
      },
      chain: {
        name: 'chain',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 20.1168,
        offset: 0
      },
      angstrom: {
        name: 'angstrom',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 1e-10,
        offset: 0
      },
      m: {
        name: 'm',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      "in": {
        name: 'in',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.0254,
        offset: 0
      },
      ft: {
        name: 'ft',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.3048,
        offset: 0
      },
      yd: {
        name: 'yd',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.9144,
        offset: 0
      },
      mi: {
        name: 'mi',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 1609.344,
        offset: 0
      },
      li: {
        name: 'li',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.201168,
        offset: 0
      },
      rd: {
        name: 'rd',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 5.029210,
        offset: 0
      },
      ch: {
        name: 'ch',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 20.1168,
        offset: 0
      },
      mil: {
        name: 'mil',
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.0000254,
        offset: 0
      },
      // 1/1000 inch
      // Surface
      m2: {
        name: 'm2',
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.SQUARED,
        value: 1,
        offset: 0
      },
      sqin: {
        name: 'sqin',
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 0.00064516,
        offset: 0
      },
      // 645.16 mm2
      sqft: {
        name: 'sqft',
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 0.09290304,
        offset: 0
      },
      // 0.09290304 m2
      sqyd: {
        name: 'sqyd',
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 0.83612736,
        offset: 0
      },
      // 0.83612736 m2
      sqmi: {
        name: 'sqmi',
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 2589988.110336,
        offset: 0
      },
      // 2.589988110336 km2
      sqrd: {
        name: 'sqrd',
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 25.29295,
        offset: 0
      },
      // 25.29295 m2
      sqch: {
        name: 'sqch',
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 404.6873,
        offset: 0
      },
      // 404.6873 m2
      sqmil: {
        name: 'sqmil',
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 6.4516e-10,
        offset: 0
      },
      // 6.4516 * 10^-10 m2
      acre: {
        name: 'acre',
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 4046.86,
        offset: 0
      },
      // 4046.86 m2
      hectare: {
        name: 'hectare',
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 10000,
        offset: 0
      },
      // 10000 m2
      // Volume
      m3: {
        name: 'm3',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.CUBIC,
        value: 1,
        offset: 0
      },
      L: {
        name: 'L',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.SHORT,
        value: 0.001,
        offset: 0
      },
      // litre
      l: {
        name: 'l',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.SHORT,
        value: 0.001,
        offset: 0
      },
      // litre
      litre: {
        name: 'litre',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.LONG,
        value: 0.001,
        offset: 0
      },
      cuin: {
        name: 'cuin',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 1.6387064e-5,
        offset: 0
      },
      // 1.6387064e-5 m3
      cuft: {
        name: 'cuft',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.028316846592,
        offset: 0
      },
      // 28.316 846 592 L
      cuyd: {
        name: 'cuyd',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.764554857984,
        offset: 0
      },
      // 764.554 857 984 L
      teaspoon: {
        name: 'teaspoon',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.000005,
        offset: 0
      },
      // 5 mL
      tablespoon: {
        name: 'tablespoon',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.000015,
        offset: 0
      },
      // 15 mL
      // {name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
      drop: {
        name: 'drop',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 5e-8,
        offset: 0
      },
      // 0.05 mL = 5e-8 m3
      gtt: {
        name: 'gtt',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 5e-8,
        offset: 0
      },
      // 0.05 mL = 5e-8 m3
      // Liquid volume
      minim: {
        name: 'minim',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.00000006161152,
        offset: 0
      },
      // 0.06161152 mL
      fluiddram: {
        name: 'fluiddram',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.0000036966911,
        offset: 0
      },
      // 3.696691 mL
      fluidounce: {
        name: 'fluidounce',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.00002957353,
        offset: 0
      },
      // 29.57353 mL
      gill: {
        name: 'gill',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.0001182941,
        offset: 0
      },
      // 118.2941 mL
      cc: {
        name: 'cc',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 1e-6,
        offset: 0
      },
      // 1e-6 L
      cup: {
        name: 'cup',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.0002365882,
        offset: 0
      },
      // 236.5882 mL
      pint: {
        name: 'pint',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.0004731765,
        offset: 0
      },
      // 473.1765 mL
      quart: {
        name: 'quart',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.0009463529,
        offset: 0
      },
      // 946.3529 mL
      gallon: {
        name: 'gallon',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.003785412,
        offset: 0
      },
      // 3.785412 L
      beerbarrel: {
        name: 'beerbarrel',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.1173478,
        offset: 0
      },
      // 117.3478 L
      oilbarrel: {
        name: 'oilbarrel',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.1589873,
        offset: 0
      },
      // 158.9873 L
      hogshead: {
        name: 'hogshead',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.2384810,
        offset: 0
      },
      // 238.4810 L
      // {name: 'min', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00000006161152, offset: 0}, // 0.06161152 mL // min is already in use as minute
      fldr: {
        name: 'fldr',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.0000036966911,
        offset: 0
      },
      // 3.696691 mL
      floz: {
        name: 'floz',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.00002957353,
        offset: 0
      },
      // 29.57353 mL
      gi: {
        name: 'gi',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.0001182941,
        offset: 0
      },
      // 118.2941 mL
      cp: {
        name: 'cp',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.0002365882,
        offset: 0
      },
      // 236.5882 mL
      pt: {
        name: 'pt',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.0004731765,
        offset: 0
      },
      // 473.1765 mL
      qt: {
        name: 'qt',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.0009463529,
        offset: 0
      },
      // 946.3529 mL
      gal: {
        name: 'gal',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.003785412,
        offset: 0
      },
      // 3.785412 L
      bbl: {
        name: 'bbl',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.1173478,
        offset: 0
      },
      // 117.3478 L
      obl: {
        name: 'obl',
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.1589873,
        offset: 0
      },
      // 158.9873 L
      // {name: 'hogshead', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.2384810, offset: 0}, // 238.4810 L // TODO: hh?
      // Mass
      g: {
        name: 'g',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.SHORT,
        value: 0.001,
        offset: 0
      },
      gram: {
        name: 'gram',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.LONG,
        value: 0.001,
        offset: 0
      },
      ton: {
        name: 'ton',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.SHORT,
        value: 907.18474,
        offset: 0
      },
      t: {
        name: 't',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.SHORT,
        value: 1000,
        offset: 0
      },
      tonne: {
        name: 'tonne',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.LONG,
        value: 1000,
        offset: 0
      },
      grain: {
        name: 'grain',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 64.79891e-6,
        offset: 0
      },
      dram: {
        name: 'dram',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 1.7718451953125e-3,
        offset: 0
      },
      ounce: {
        name: 'ounce',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 28.349523125e-3,
        offset: 0
      },
      poundmass: {
        name: 'poundmass',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 453.59237e-3,
        offset: 0
      },
      hundredweight: {
        name: 'hundredweight',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 45.359237,
        offset: 0
      },
      stick: {
        name: 'stick',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 115e-3,
        offset: 0
      },
      stone: {
        name: 'stone',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 6.35029318,
        offset: 0
      },
      gr: {
        name: 'gr',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 64.79891e-6,
        offset: 0
      },
      dr: {
        name: 'dr',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 1.7718451953125e-3,
        offset: 0
      },
      oz: {
        name: 'oz',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 28.349523125e-3,
        offset: 0
      },
      lbm: {
        name: 'lbm',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 453.59237e-3,
        offset: 0
      },
      cwt: {
        name: 'cwt',
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 45.359237,
        offset: 0
      },
      // Time
      s: {
        name: 's',
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      min: {
        name: 'min',
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 60,
        offset: 0
      },
      h: {
        name: 'h',
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 3600,
        offset: 0
      },
      second: {
        name: 'second',
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      sec: {
        name: 'sec',
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      minute: {
        name: 'minute',
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 60,
        offset: 0
      },
      hour: {
        name: 'hour',
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 3600,
        offset: 0
      },
      day: {
        name: 'day',
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 86400,
        offset: 0
      },
      week: {
        name: 'week',
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 7 * 86400,
        offset: 0
      },
      month: {
        name: 'month',
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 2629800,
        // 1/12th of Julian year
        offset: 0
      },
      year: {
        name: 'year',
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 31557600,
        // Julian year
        offset: 0
      },
      decade: {
        name: 'decade',
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 315576000,
        // Julian decade
        offset: 0
      },
      century: {
        name: 'century',
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 3155760000,
        // Julian century
        offset: 0
      },
      millennium: {
        name: 'millennium',
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 31557600000,
        // Julian millennium
        offset: 0
      },
      // Frequency
      hertz: {
        name: 'Hertz',
        base: BASE_UNITS.FREQUENCY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0,
        reciprocal: true
      },
      Hz: {
        name: 'Hz',
        base: BASE_UNITS.FREQUENCY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0,
        reciprocal: true
      },
      // Angle
      rad: {
        name: 'rad',
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      radian: {
        name: 'radian',
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
      deg: {
        name: 'deg',
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.SHORT,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      degree: {
        name: 'degree',
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.LONG,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
      grad: {
        name: 'grad',
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.SHORT,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      gradian: {
        name: 'gradian',
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.LONG,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
      cycle: {
        name: 'cycle',
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.NONE,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      // arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
      arcsec: {
        name: 'arcsec',
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.NONE,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      // arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
      arcmin: {
        name: 'arcmin',
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.NONE,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      // Electric current
      A: {
        name: 'A',
        base: BASE_UNITS.CURRENT,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      ampere: {
        name: 'ampere',
        base: BASE_UNITS.CURRENT,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      // Temperature
      // K(C) = C + 273.15
      // K(F) = (F + 459.67) / 1.8
      // K(R) = R / 1.8
      K: {
        name: 'K',
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.NONE,
        value: 1,
        offset: 0
      },
      degC: {
        name: 'degC',
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.NONE,
        value: 1,
        offset: 273.15
      },
      degF: {
        name: 'degF',
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.NONE,
        value: 1 / 1.8,
        offset: 459.67
      },
      degR: {
        name: 'degR',
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.NONE,
        value: 1 / 1.8,
        offset: 0
      },
      kelvin: {
        name: 'kelvin',
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.NONE,
        value: 1,
        offset: 0
      },
      celsius: {
        name: 'celsius',
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.NONE,
        value: 1,
        offset: 273.15
      },
      fahrenheit: {
        name: 'fahrenheit',
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.NONE,
        value: 1 / 1.8,
        offset: 459.67
      },
      rankine: {
        name: 'rankine',
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.NONE,
        value: 1 / 1.8,
        offset: 0
      },
      // amount of substance
      mol: {
        name: 'mol',
        base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      mole: {
        name: 'mole',
        base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      // luminous intensity
      cd: {
        name: 'cd',
        base: BASE_UNITS.LUMINOUS_INTENSITY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      candela: {
        name: 'candela',
        base: BASE_UNITS.LUMINOUS_INTENSITY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      // TODO: units STERADIAN
      // {name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
      // {name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
      // Force
      N: {
        name: 'N',
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      newton: {
        name: 'newton',
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      dyn: {
        name: 'dyn',
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.SHORT,
        value: 0.00001,
        offset: 0
      },
      dyne: {
        name: 'dyne',
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.LONG,
        value: 0.00001,
        offset: 0
      },
      lbf: {
        name: 'lbf',
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.NONE,
        value: 4.4482216152605,
        offset: 0
      },
      poundforce: {
        name: 'poundforce',
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.NONE,
        value: 4.4482216152605,
        offset: 0
      },
      kip: {
        name: 'kip',
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.LONG,
        value: 4448.2216,
        offset: 0
      },
      // Energy
      J: {
        name: 'J',
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      joule: {
        name: 'joule',
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      erg: {
        name: 'erg',
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.NONE,
        value: 1e-7,
        offset: 0
      },
      Wh: {
        name: 'Wh',
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 3600,
        offset: 0
      },
      BTU: {
        name: 'BTU',
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.BTU,
        value: 1055.05585262,
        offset: 0
      },
      eV: {
        name: 'eV',
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 1.602176565e-19,
        offset: 0
      },
      electronvolt: {
        name: 'electronvolt',
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.LONG,
        value: 1.602176565e-19,
        offset: 0
      },
      // Power
      W: {
        name: 'W',
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      watt: {
        name: 'watt',
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      hp: {
        name: 'hp',
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.NONE,
        value: 745.6998715386,
        offset: 0
      },
      // Electrical power units
      VAR: {
        name: 'VAR',
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.SHORT,
        value: Complex.I,
        offset: 0
      },
      VA: {
        name: 'VA',
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Pressure
      Pa: {
        name: 'Pa',
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      psi: {
        name: 'psi',
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 6894.75729276459,
        offset: 0
      },
      atm: {
        name: 'atm',
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 101325,
        offset: 0
      },
      bar: {
        name: 'bar',
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.SHORTLONG,
        value: 100000,
        offset: 0
      },
      torr: {
        name: 'torr',
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 133.322,
        offset: 0
      },
      mmHg: {
        name: 'mmHg',
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 133.322,
        offset: 0
      },
      mmH2O: {
        name: 'mmH2O',
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 9.80665,
        offset: 0
      },
      cmH2O: {
        name: 'cmH2O',
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 98.0665,
        offset: 0
      },
      // Electric charge
      coulomb: {
        name: 'coulomb',
        base: BASE_UNITS.ELECTRIC_CHARGE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      C: {
        name: 'C',
        base: BASE_UNITS.ELECTRIC_CHARGE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Electric capacitance
      farad: {
        name: 'farad',
        base: BASE_UNITS.ELECTRIC_CAPACITANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      F: {
        name: 'F',
        base: BASE_UNITS.ELECTRIC_CAPACITANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Electric potential
      volt: {
        name: 'volt',
        base: BASE_UNITS.ELECTRIC_POTENTIAL,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      V: {
        name: 'V',
        base: BASE_UNITS.ELECTRIC_POTENTIAL,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Electric resistance
      ohm: {
        name: 'ohm',
        base: BASE_UNITS.ELECTRIC_RESISTANCE,
        prefixes: PREFIXES.SHORTLONG,
        // Both Mohm and megaohm are acceptable
        value: 1,
        offset: 0
      },

      /*
       * Unicode breaks in browsers if charset is not specified
      : {
        name: '',
        base: BASE_UNITS.ELECTRIC_RESISTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      */
      // Electric inductance
      henry: {
        name: 'henry',
        base: BASE_UNITS.ELECTRIC_INDUCTANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      H: {
        name: 'H',
        base: BASE_UNITS.ELECTRIC_INDUCTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Electric conductance
      siemens: {
        name: 'siemens',
        base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      S: {
        name: 'S',
        base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Magnetic flux
      weber: {
        name: 'weber',
        base: BASE_UNITS.MAGNETIC_FLUX,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      Wb: {
        name: 'Wb',
        base: BASE_UNITS.MAGNETIC_FLUX,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Magnetic flux density
      tesla: {
        name: 'tesla',
        base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      T: {
        name: 'T',
        base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Binary
      b: {
        name: 'b',
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_SHORT,
        value: 1,
        offset: 0
      },
      bits: {
        name: 'bits',
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_LONG,
        value: 1,
        offset: 0
      },
      B: {
        name: 'B',
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_SHORT,
        value: 8,
        offset: 0
      },
      bytes: {
        name: 'bytes',
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_LONG,
        value: 8,
        offset: 0
      }
    }; // aliases (formerly plurals)

    var ALIASES = {
      meters: 'meter',
      inches: 'inch',
      feet: 'foot',
      yards: 'yard',
      miles: 'mile',
      links: 'link',
      rods: 'rod',
      chains: 'chain',
      angstroms: 'angstrom',
      lt: 'l',
      litres: 'litre',
      liter: 'litre',
      liters: 'litre',
      teaspoons: 'teaspoon',
      tablespoons: 'tablespoon',
      minims: 'minim',
      fluiddrams: 'fluiddram',
      fluidounces: 'fluidounce',
      gills: 'gill',
      cups: 'cup',
      pints: 'pint',
      quarts: 'quart',
      gallons: 'gallon',
      beerbarrels: 'beerbarrel',
      oilbarrels: 'oilbarrel',
      hogsheads: 'hogshead',
      gtts: 'gtt',
      grams: 'gram',
      tons: 'ton',
      tonnes: 'tonne',
      grains: 'grain',
      drams: 'dram',
      ounces: 'ounce',
      poundmasses: 'poundmass',
      hundredweights: 'hundredweight',
      sticks: 'stick',
      lb: 'lbm',
      lbs: 'lbm',
      kips: 'kip',
      acres: 'acre',
      hectares: 'hectare',
      sqfeet: 'sqft',
      sqyard: 'sqyd',
      sqmile: 'sqmi',
      sqmiles: 'sqmi',
      mmhg: 'mmHg',
      mmh2o: 'mmH2O',
      cmh2o: 'cmH2O',
      seconds: 'second',
      secs: 'second',
      minutes: 'minute',
      mins: 'minute',
      hours: 'hour',
      hr: 'hour',
      hrs: 'hour',
      days: 'day',
      weeks: 'week',
      months: 'month',
      years: 'year',
      decades: 'decade',
      centuries: 'century',
      millennia: 'millennium',
      hertz: 'hertz',
      radians: 'radian',
      degrees: 'degree',
      gradians: 'gradian',
      cycles: 'cycle',
      arcsecond: 'arcsec',
      arcseconds: 'arcsec',
      arcminute: 'arcmin',
      arcminutes: 'arcmin',
      BTUs: 'BTU',
      watts: 'watt',
      joules: 'joule',
      amperes: 'ampere',
      coulombs: 'coulomb',
      volts: 'volt',
      ohms: 'ohm',
      farads: 'farad',
      webers: 'weber',
      teslas: 'tesla',
      electronvolts: 'electronvolt',
      moles: 'mole',
      bit: 'bits',
      "byte": 'bytes'
    };
    /**
     * Calculate the values for the angle units.
     * Value is calculated as number or BigNumber depending on the configuration
     * @param {{number: 'number' | 'BigNumber'}} config
     */

    function calculateAngleValues(config) {
      if (config.number === 'BigNumber') {
        var pi = createBigNumberPi(_BigNumber);
        UNITS.rad.value = new _BigNumber(1);
        UNITS.deg.value = pi.div(180); // 2 * pi / 360

        UNITS.grad.value = pi.div(200); // 2 * pi / 400

        UNITS.cycle.value = pi.times(2); // 2 * pi

        UNITS.arcsec.value = pi.div(648000); // 2 * pi / 360 / 3600

        UNITS.arcmin.value = pi.div(10800); // 2 * pi / 360 / 60
      } else {
        // number
        UNITS.rad.value = 1;
        UNITS.deg.value = Math.PI / 180; // 2 * pi / 360

        UNITS.grad.value = Math.PI / 200; // 2 * pi / 400

        UNITS.cycle.value = Math.PI * 2; // 2 * pi

        UNITS.arcsec.value = Math.PI / 648000; // 2 * pi / 360 / 3600

        UNITS.arcmin.value = Math.PI / 10800; // 2 * pi / 360 / 60
      } // copy to the full names of the angles


      UNITS.radian.value = UNITS.rad.value;
      UNITS.degree.value = UNITS.deg.value;
      UNITS.gradian.value = UNITS.grad.value;
    } // apply the angle values now


    calculateAngleValues(config);

    if (on) {
      // recalculate the values on change of configuration
      on('config', function (curr, prev) {
        if (curr.number !== prev.number) {
          calculateAngleValues(curr);
        }
      });
    }
    /**
     * A unit system is a set of dimensionally independent base units plus a set of derived units, formed by multiplication and division of the base units, that are by convention used with the unit system.
     * A user perhaps could issue a command to select a preferred unit system, or use the default (see below).
     * Auto unit system: The default unit system is updated on the fly anytime a unit is parsed. The corresponding unit in the default unit system is updated, so that answers are given in the same units the user supplies.
     */


    var UNIT_SYSTEMS = {
      si: {
        // Base units
        NONE: {
          unit: UNIT_NONE,
          prefix: PREFIXES.NONE['']
        },
        LENGTH: {
          unit: UNITS.m,
          prefix: PREFIXES.SHORT['']
        },
        MASS: {
          unit: UNITS.g,
          prefix: PREFIXES.SHORT.k
        },
        TIME: {
          unit: UNITS.s,
          prefix: PREFIXES.SHORT['']
        },
        CURRENT: {
          unit: UNITS.A,
          prefix: PREFIXES.SHORT['']
        },
        TEMPERATURE: {
          unit: UNITS.K,
          prefix: PREFIXES.SHORT['']
        },
        LUMINOUS_INTENSITY: {
          unit: UNITS.cd,
          prefix: PREFIXES.SHORT['']
        },
        AMOUNT_OF_SUBSTANCE: {
          unit: UNITS.mol,
          prefix: PREFIXES.SHORT['']
        },
        ANGLE: {
          unit: UNITS.rad,
          prefix: PREFIXES.SHORT['']
        },
        BIT: {
          unit: UNITS.bits,
          prefix: PREFIXES.SHORT['']
        },
        // Derived units
        FORCE: {
          unit: UNITS.N,
          prefix: PREFIXES.SHORT['']
        },
        ENERGY: {
          unit: UNITS.J,
          prefix: PREFIXES.SHORT['']
        },
        POWER: {
          unit: UNITS.W,
          prefix: PREFIXES.SHORT['']
        },
        PRESSURE: {
          unit: UNITS.Pa,
          prefix: PREFIXES.SHORT['']
        },
        ELECTRIC_CHARGE: {
          unit: UNITS.C,
          prefix: PREFIXES.SHORT['']
        },
        ELECTRIC_CAPACITANCE: {
          unit: UNITS.F,
          prefix: PREFIXES.SHORT['']
        },
        ELECTRIC_POTENTIAL: {
          unit: UNITS.V,
          prefix: PREFIXES.SHORT['']
        },
        ELECTRIC_RESISTANCE: {
          unit: UNITS.ohm,
          prefix: PREFIXES.SHORT['']
        },
        ELECTRIC_INDUCTANCE: {
          unit: UNITS.H,
          prefix: PREFIXES.SHORT['']
        },
        ELECTRIC_CONDUCTANCE: {
          unit: UNITS.S,
          prefix: PREFIXES.SHORT['']
        },
        MAGNETIC_FLUX: {
          unit: UNITS.Wb,
          prefix: PREFIXES.SHORT['']
        },
        MAGNETIC_FLUX_DENSITY: {
          unit: UNITS.T,
          prefix: PREFIXES.SHORT['']
        },
        FREQUENCY: {
          unit: UNITS.Hz,
          prefix: PREFIXES.SHORT['']
        }
      }
    }; // Clone to create the other unit systems

    UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    UNIT_SYSTEMS.cgs.LENGTH = {
      unit: UNITS.m,
      prefix: PREFIXES.SHORT.c
    };
    UNIT_SYSTEMS.cgs.MASS = {
      unit: UNITS.g,
      prefix: PREFIXES.SHORT['']
    };
    UNIT_SYSTEMS.cgs.FORCE = {
      unit: UNITS.dyn,
      prefix: PREFIXES.SHORT['']
    };
    UNIT_SYSTEMS.cgs.ENERGY = {
      unit: UNITS.erg,
      prefix: PREFIXES.NONE['']
    }; // there are wholly 4 unique cgs systems for electricity and magnetism,
    // so let's not worry about it unless somebody complains

    UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    UNIT_SYSTEMS.us.LENGTH = {
      unit: UNITS.ft,
      prefix: PREFIXES.NONE['']
    };
    UNIT_SYSTEMS.us.MASS = {
      unit: UNITS.lbm,
      prefix: PREFIXES.NONE['']
    };
    UNIT_SYSTEMS.us.TEMPERATURE = {
      unit: UNITS.degF,
      prefix: PREFIXES.NONE['']
    };
    UNIT_SYSTEMS.us.FORCE = {
      unit: UNITS.lbf,
      prefix: PREFIXES.NONE['']
    };
    UNIT_SYSTEMS.us.ENERGY = {
      unit: UNITS.BTU,
      prefix: PREFIXES.BTU['']
    };
    UNIT_SYSTEMS.us.POWER = {
      unit: UNITS.hp,
      prefix: PREFIXES.NONE['']
    };
    UNIT_SYSTEMS.us.PRESSURE = {
      unit: UNITS.psi,
      prefix: PREFIXES.NONE['']
    }; // Add additional unit systems here.
    // Choose a unit system to seed the auto unit system.

    UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si)); // Set the current unit system

    var currentUnitSystem = UNIT_SYSTEMS.auto;
    /**
     * Set a unit system for formatting derived units.
     * @param {string} [name] The name of the unit system.
     */

    Unit.setUnitSystem = function (name) {
      if (hasOwnProperty(UNIT_SYSTEMS, name)) {
        currentUnitSystem = UNIT_SYSTEMS[name];
      } else {
        throw new Error('Unit system ' + name + ' does not exist. Choices are: ' + Object.keys(UNIT_SYSTEMS).join(', '));
      }
    };
    /**
     * Return the current unit system.
     * @return {string} The current unit system.
     */


    Unit.getUnitSystem = function () {
      for (var _key in UNIT_SYSTEMS) {
        if (hasOwnProperty(UNIT_SYSTEMS, _key)) {
          if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
            return _key;
          }
        }
      }
    };
    /**
     * Converters to convert from number to an other numeric type like BigNumber
     * or Fraction
     */


    Unit.typeConverters = {
      BigNumber: function BigNumber(x) {
        return new _BigNumber(x + ''); // stringify to prevent constructor error
      },
      Fraction: function Fraction(x) {
        return new _Fraction(x);
      },
      Complex: function Complex(x) {
        return x;
      },
      number: function number(x) {
        return x;
      }
    };
    /**
     * Retrieve the right convertor function corresponding with the type
     * of provided exampleValue.
     *
     * @param {string} type   A string 'number', 'BigNumber', or 'Fraction'
     *                        In case of an unknown type,
     * @return {Function}
     */

    Unit._getNumberConverter = function (type) {
      if (!Unit.typeConverters[type]) {
        throw new TypeError('Unsupported type "' + type + '"');
      }

      return Unit.typeConverters[type];
    }; // Add dimensions to each built-in unit


    for (var _key2 in UNITS) {
      if (hasOwnProperty(UNITS, _key2)) {
        var unit = UNITS[_key2];
        unit.dimensions = unit.base.dimensions;
      }
    } // Create aliases


    for (var _name2 in ALIASES) {
      if (hasOwnProperty(ALIASES, _name2)) {
        var _unit2 = UNITS[ALIASES[_name2]];
        var alias = {};

        for (var _key3 in _unit2) {
          if (hasOwnProperty(_unit2, _key3)) {
            alias[_key3] = _unit2[_key3];
          }
        }

        alias.name = _name2;
        UNITS[_name2] = alias;
      }
    }

    function assertUnitNameIsValid(name) {
      for (var i = 0; i < name.length; i++) {
        var _c = name.charAt(i);

        var isValidAlpha = function isValidAlpha(p) {
          return /^[a-zA-Z]$/.test(p);
        };

        var _isDigit = function _isDigit(c) {
          return c >= '0' && c <= '9';
        };

        if (i === 0 && !isValidAlpha(_c)) {
          throw new Error('Invalid unit name (must begin with alpha character): "' + name + '"');
        }

        if (i > 0 && !(isValidAlpha(_c) || _isDigit(_c))) {
          throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name + '"');
        }
      }
    }
    /**
     * Wrapper around createUnitSingle.
     * Example:
     *  createUnit({
     *    foo: { },
     *    bar: {
     *      definition: 'kg/foo',
     *      aliases: ['ba', 'barr', 'bars'],
     *      offset: 200
     *    },
     *    baz: '4 bar'
     *  },
     *  {
     *    override: true
     *  })
     * @param {object} obj      Object map. Each key becomes a unit which is defined by its value.
     * @param {object} options
     */


    Unit.createUnit = function (obj, options) {
      if (_typeof$6(obj) !== 'object') {
        throw new TypeError("createUnit expects first parameter to be of type 'Object'");
      } // Remove all units and aliases we are overriding


      if (options && options.override) {
        for (var _key4 in obj) {
          if (hasOwnProperty(obj, _key4)) {
            Unit.deleteUnit(_key4);
          }

          if (obj[_key4].aliases) {
            for (var i = 0; i < obj[_key4].aliases.length; i++) {
              Unit.deleteUnit(obj[_key4].aliases[i]);
            }
          }
        }
      } // TODO: traverse multiple times until all units have been added


      var lastUnit;

      for (var _key5 in obj) {
        if (hasOwnProperty(obj, _key5)) {
          lastUnit = Unit.createUnitSingle(_key5, obj[_key5]);
        }
      }

      return lastUnit;
    };
    /**
     * Create a user-defined unit and register it with the Unit type.
     * Example:
     *  createUnitSingle('knot', '0.514444444 m/s')
     *  createUnitSingle('acre', new Unit(43560, 'ft^2'))
     *
     * @param {string} name      The name of the new unit. Must be unique. Example: 'knot'
     * @param {string, Unit, Object} definition      Definition of the unit in terms
     * of existing units. For example, '0.514444444 m / s'. Can be a Unit, a string,
     * or an Object. If an Object, may have the following properties:
     *   - definition {string|Unit} The definition of this unit.
     *   - prefixes {string} "none", "short", "long", "binary_short", or "binary_long".
     *     The default is "none".
     *   - aliases {Array} Array of strings. Example: ['knots', 'kt', 'kts']
     *   - offset {Numeric} An offset to apply when converting from the unit. For
     *     example, the offset for celsius is 273.15 and the offset for farhenheit
     *     is 459.67. Default is 0.
     *   - baseName {string} If the unit's dimension does not match that of any other
     *     base unit, the name of the newly create base unit. Otherwise, this property
     *     has no effect.
     *
     * @param {Object} options   (optional) An object containing any of the following
     * properties:
     *   - override {boolean} Whether this unit should be allowed to override existing
     *     units.
     *
     * @return {Unit}
     */


    Unit.createUnitSingle = function (name, obj, options) {
      if (typeof obj === 'undefined' || obj === null) {
        obj = {};
      }

      if (typeof name !== 'string') {
        throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
      } // Check collisions with existing units


      if (hasOwnProperty(UNITS, name)) {
        throw new Error('Cannot create unit "' + name + '": a unit with that name already exists');
      } // TODO: Validate name for collisions with other built-in functions (like abs or cos, for example), and for acceptable variable names. For example, '42' is probably not a valid unit. Nor is '%', since it is also an operator.


      assertUnitNameIsValid(name);
      var defUnit = null; // The Unit from which the new unit will be created.

      var aliases = [];
      var offset = 0;
      var definition;
      var prefixes;
      var baseName;

      if (obj && obj.type === 'Unit') {
        defUnit = obj.clone();
      } else if (typeof obj === 'string') {
        if (obj !== '') {
          definition = obj;
        }
      } else if (_typeof$6(obj) === 'object') {
        definition = obj.definition;
        prefixes = obj.prefixes;
        offset = obj.offset;
        baseName = obj.baseName;

        if (obj.aliases) {
          aliases = obj.aliases.valueOf(); // aliases could be a Matrix, so convert to Array
        }
      } else {
        throw new TypeError('Cannot create unit "' + name + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
      }

      if (aliases) {
        for (var i = 0; i < aliases.length; i++) {
          if (hasOwnProperty(UNITS, aliases[i])) {
            throw new Error('Cannot create alias "' + aliases[i] + '": a unit with that name already exists');
          }
        }
      }

      if (definition && typeof definition === 'string' && !defUnit) {
        try {
          defUnit = Unit.parse(definition, {
            allowNoUnits: true
          });
        } catch (ex) {
          ex.message = 'Could not create unit "' + name + '" from "' + definition + '": ' + ex.message;
          throw ex;
        }
      } else if (definition && definition.type === 'Unit') {
        defUnit = definition.clone();
      }

      aliases = aliases || [];
      offset = offset || 0;

      if (prefixes && prefixes.toUpperCase) {
        prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
      } else {
        prefixes = PREFIXES.NONE;
      } // If defUnit is null, it is because the user did not
      // specify a defintion. So create a new base dimension.


      var newUnit = {};

      if (!defUnit) {
        // Add a new base dimension
        baseName = baseName || name + '_STUFF'; // foo --> foo_STUFF, or the essence of foo

        if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
          throw new Error('Cannot create new base unit "' + name + '": a base unit with that name already exists (and cannot be overridden)');
        }

        BASE_DIMENSIONS.push(baseName); // Push 0 onto existing base units

        for (var b in BASE_UNITS) {
          if (hasOwnProperty(BASE_UNITS, b)) {
            BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
          }
        } // Add the new base unit


        var newBaseUnit = {
          dimensions: []
        };

        for (var _i6 = 0; _i6 < BASE_DIMENSIONS.length; _i6++) {
          newBaseUnit.dimensions[_i6] = 0;
        }

        newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
        newBaseUnit.key = baseName;
        BASE_UNITS[baseName] = newBaseUnit;
        newUnit = {
          name: name,
          value: 1,
          dimensions: BASE_UNITS[baseName].dimensions.slice(0),
          prefixes: prefixes,
          offset: offset,
          base: BASE_UNITS[baseName]
        };
        currentUnitSystem[baseName] = {
          unit: newUnit,
          prefix: PREFIXES.NONE['']
        };
      } else {
        newUnit = {
          name: name,
          value: defUnit.value,
          dimensions: defUnit.dimensions.slice(0),
          prefixes: prefixes,
          offset: offset
        }; // Create a new base if no matching base exists

        var anyMatch = false;

        for (var _i7 in BASE_UNITS) {
          if (hasOwnProperty(BASE_UNITS, _i7)) {
            var match = true;

            for (var j = 0; j < BASE_DIMENSIONS.length; j++) {
              if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[_i7].dimensions[j] || 0)) > 1e-12) {
                match = false;
                break;
              }
            }

            if (match) {
              anyMatch = true;
              newUnit.base = BASE_UNITS[_i7];
              break;
            }
          }
        }

        if (!anyMatch) {
          baseName = baseName || name + '_STUFF'; // foo --> foo_STUFF, or the essence of foo
          // Add the new base unit

          var _newBaseUnit = {
            dimensions: defUnit.dimensions.slice(0)
          };
          _newBaseUnit.key = baseName;
          BASE_UNITS[baseName] = _newBaseUnit;
          currentUnitSystem[baseName] = {
            unit: newUnit,
            prefix: PREFIXES.NONE['']
          };
          newUnit.base = BASE_UNITS[baseName];
        }
      }

      Unit.UNITS[name] = newUnit;

      for (var _i8 = 0; _i8 < aliases.length; _i8++) {
        var aliasName = aliases[_i8];
        var _alias = {};

        for (var _key6 in newUnit) {
          if (hasOwnProperty(newUnit, _key6)) {
            _alias[_key6] = newUnit[_key6];
          }
        }

        _alias.name = aliasName;
        Unit.UNITS[aliasName] = _alias;
      }

      return new Unit(null, name);
    };

    Unit.deleteUnit = function (name) {
      delete Unit.UNITS[name];
    }; // expose arrays with prefixes, dimensions, units, systems


    Unit.PREFIXES = PREFIXES;
    Unit.BASE_DIMENSIONS = BASE_DIMENSIONS;
    Unit.BASE_UNITS = BASE_UNITS;
    Unit.UNIT_SYSTEMS = UNIT_SYSTEMS;
    Unit.UNITS = UNITS;
    return Unit;
  }, {
    isClass: true
  });

  var name$2f = 'unit';
  var dependencies$2g = ['typed', 'Unit']; // This function is named createUnitFunction to prevent a naming conflict with createUnit

  var createUnitFunction = /* #__PURE__ */factory(name$2f, dependencies$2g, function (_ref) {
    var typed = _ref.typed,
        Unit = _ref.Unit;

    /**
     * Create a unit. Depending on the passed arguments, the function
     * will create and return a new math.Unit object.
     * When a matrix is provided, all elements will be converted to units.
     *
     * Syntax:
     *
     *     math.unit(unit : string)
     *     math.unit(value : number, unit : string)
     *
     * Examples:
     *
     *    const a = math.unit(5, 'cm')    // returns Unit 50 mm
     *    const b = math.unit('23 kg')    // returns Unit 23 kg
     *    a.to('m')                       // returns Unit 0.05 m
     *
     * See also:
     *
     *    bignumber, boolean, complex, index, matrix, number, string, createUnit
     *
     * @param {* | Array | Matrix} args   A number and unit.
     * @return {Unit | Array | Matrix}    The created unit
     */
    return typed(name$2f, {
      Unit: function Unit(x) {
        return x.clone();
      },
      string: function string(x) {
        if (Unit.isValuelessUnit(x)) {
          return new Unit(null, x); // a pure unit
        }

        return Unit.parse(x, {
          allowNoUnits: true
        }); // a unit with value, like '5cm'
      },
      'number | BigNumber | Fraction | Complex, string': function numberBigNumberFractionComplexString(value, unit) {
        return new Unit(value, unit);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2g = 'sparse';
  var dependencies$2h = ['typed', 'SparseMatrix'];
  var createSparse = /* #__PURE__ */factory(name$2g, dependencies$2h, function (_ref) {
    var typed = _ref.typed,
        SparseMatrix = _ref.SparseMatrix;

    /**
     * Create a Sparse Matrix. The function creates a new `math.Matrix` object from
     * an `Array`. A Matrix has utility functions to manipulate the data in the
     * matrix, like getting the size and getting or setting values in the matrix.
     *
     * Syntax:
     *
     *    math.sparse()               // creates an empty sparse matrix.
     *    math.sparse(data)           // creates a sparse matrix with initial data.
     *    math.sparse(data, 'number') // creates a sparse matrix with initial data, number datatype.
     *
     * Examples:
     *
     *    let m = math.sparse([[1, 2], [3, 4]])
     *    m.size()                        // Array [2, 2]
     *    m.resize([3, 2], 5)
     *    m.valueOf()                     // Array [[1, 2], [3, 4], [5, 5]]
     *    m.get([1, 0])                    // number 3
     *
     * See also:
     *
     *    bignumber, boolean, complex, index, number, string, unit, matrix
     *
     * @param {Array | Matrix} [data]    A two dimensional array
     *
     * @return {Matrix} The created matrix
     */
    return typed(name$2g, {
      '': function _() {
        return new SparseMatrix([]);
      },
      string: function string(datatype) {
        return new SparseMatrix([], datatype);
      },
      'Array | Matrix': function ArrayMatrix(data) {
        return new SparseMatrix(data);
      },
      'Array | Matrix, string': function ArrayMatrixString(data, datatype) {
        return new SparseMatrix(data, datatype);
      }
    });
  });

  var name$2h = 'createUnit';
  var dependencies$2i = ['typed', 'Unit'];
  var createCreateUnit = /* #__PURE__ */factory(name$2h, dependencies$2i, function (_ref) {
    var typed = _ref.typed,
        Unit = _ref.Unit;

    /**
     * Create a user-defined unit and register it with the Unit type.
     *
     * Syntax:
     *
     *     math.createUnit({
     *       baseUnit1: {
     *         aliases: [string, ...]
     *         prefixes: object
     *       },
     *       unit2: {
     *         definition: string,
     *         aliases: [string, ...]
     *         prefixes: object,
     *         offset: number
     *       },
     *       unit3: string    // Shortcut
     *     })
     *
     *     // Another shortcut:
     *     math.createUnit(string, unit : string, [object])
     *
     * Examples:
     *
     *     math.createUnit('foo')
     *     math.createUnit('knot', {definition: '0.514444444 m/s', aliases: ['knots', 'kt', 'kts']})
     *     math.createUnit('mph', '1 mile/hour')
     *
     * @param {string} name      The name of the new unit. Must be unique. Example: 'knot'
     * @param {string, Unit} definition      Definition of the unit in terms of existing units. For example, '0.514444444 m / s'.
     * @param {Object} options   (optional) An object containing any of the following properties:
     *     - `prefixes {string}` "none", "short", "long", "binary_short", or "binary_long". The default is "none".
     *     - `aliases {Array}` Array of strings. Example: ['knots', 'kt', 'kts']
     *     - `offset {Numeric}` An offset to apply when converting from the unit. For example, the offset for celsius is 273.15. Default is 0.
     *
     * See also:
     *
     *     unit
     *
     * @return {Unit} The new unit
     */
    return typed(name$2h, {
      // General function signature. First parameter is an object where each property is the definition of a new unit. The object keys are the unit names and the values are the definitions. The values can be objects, strings, or Units. If a property is an empty object or an empty string, a new base unit is created. The second parameter is the options.
      'Object, Object': function ObjectObject(obj, options) {
        return Unit.createUnit(obj, options);
      },
      // Same as above but without the options.
      Object: function Object(obj) {
        return Unit.createUnit(obj, {});
      },
      // Shortcut method for creating one unit.
      'string, Unit | string | Object, Object': function stringUnitStringObjectObject(name, def, options) {
        var obj = {};
        obj[name] = def;
        return Unit.createUnit(obj, options);
      },
      // Same as above but without the options.
      'string, Unit | string | Object': function stringUnitStringObject(name, def) {
        var obj = {};
        obj[name] = def;
        return Unit.createUnit(obj, {});
      },
      // Without a definition, creates a base unit.
      string: function string(name) {
        var obj = {};
        obj[name] = {};
        return Unit.createUnit(obj, {});
      }
    });
  });

  var name$2i = 'acos';
  var dependencies$2j = ['typed', 'config', 'Complex'];
  var createAcos = /* #__PURE__ */factory(name$2i, dependencies$2j, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        Complex = _ref.Complex;

    /**
     * Calculate the inverse cosine of a value.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.acos(x)
     *
     * Examples:
     *
     *    math.acos(0.5)           // returns number 1.0471975511965979
     *    math.acos(math.cos(1.5)) // returns number 1.5
     *
     *    math.acos(2)             // returns Complex 0 + 1.3169578969248166 i
     *
     * See also:
     *
     *    cos, atan, asin
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x  Function input
     * @return {number | BigNumber | Complex | Array | Matrix} The arc cosine of x
     */
    return typed(name$2i, {
      number: function number(x) {
        if (x >= -1 && x <= 1 || config.predictable) {
          return Math.acos(x);
        } else {
          return new Complex(x, 0).acos();
        }
      },
      Complex: function Complex(x) {
        return x.acos();
      },
      BigNumber: function BigNumber(x) {
        return x.acos();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2j = 'acosh';
  var dependencies$2k = ['typed', 'config', 'Complex'];
  var createAcosh = /* #__PURE__ */factory(name$2j, dependencies$2k, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        Complex = _ref.Complex;

    /**
     * Calculate the hyperbolic arccos of a value,
     * defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.acosh(x)
     *
     * Examples:
     *
     *    math.acosh(1.5)       // returns 0.9624236501192069
     *
     * See also:
     *
     *    cosh, asinh, atanh
     *
     * @param {number | Complex | Unit | Array | Matrix} x  Function input
     * @return {number | Complex | Array | Matrix} Hyperbolic arccosine of x
     */
    return typed(name$2j, {
      number: function number(x) {
        if (x >= 1 || config.predictable) {
          return acoshNumber(x);
        }

        if (x <= -1) {
          return new Complex(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);
        }

        return new Complex(x, 0).acosh();
      },
      Complex: function Complex(x) {
        return x.acosh();
      },
      BigNumber: function BigNumber(x) {
        return x.acosh();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2k = 'acot';
  var dependencies$2l = ['typed', 'BigNumber'];
  var createAcot = /* #__PURE__ */factory(name$2k, dependencies$2l, function (_ref) {
    var typed = _ref.typed,
        _BigNumber = _ref.BigNumber;

    /**
     * Calculate the inverse cotangent of a value, defined as `acot(x) = atan(1/x)`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.acot(x)
     *
     * Examples:
     *
     *    math.acot(0.5)           // returns number 0.4636476090008061
     *    math.acot(math.cot(1.5)) // returns number 1.5
     *
     *    math.acot(2)             // returns Complex 1.5707963267948966 -1.3169578969248166 i
     *
     * See also:
     *
     *    cot, atan
     *
     * @param {number | Complex | Array | Matrix} x   Function input
     * @return {number | Complex | Array | Matrix} The arc cotangent of x
     */
    return typed(name$2k, {
      number: acotNumber,
      Complex: function Complex(x) {
        return x.acot();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).atan();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2l = 'acoth';
  var dependencies$2m = ['typed', 'config', 'Complex', 'BigNumber'];
  var createAcoth = /* #__PURE__ */factory(name$2l, dependencies$2m, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        Complex = _ref.Complex,
        _BigNumber = _ref.BigNumber;

    /**
     * Calculate the hyperbolic arccotangent of a value,
     * defined as `acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.acoth(x)
     *
     * Examples:
     *
     *    math.acoth(0.5)       // returns 0.8047189562170503
     *
     * See also:
     *
     *    acsch, asech
     *
     * @param {number | Complex | Array | Matrix} x  Function input
     * @return {number | Complex | Array | Matrix} Hyperbolic arccotangent of x
     */
    return typed(name$2l, {
      number: function number(x) {
        if (x >= 1 || x <= -1 || config.predictable) {
          return acothNumber(x);
        }

        return new Complex(x, 0).acoth();
      },
      Complex: function Complex(x) {
        return x.acoth();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).atanh();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2m = 'acsc';
  var dependencies$2n = ['typed', 'config', 'Complex', 'BigNumber'];
  var createAcsc = /* #__PURE__ */factory(name$2m, dependencies$2n, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        Complex = _ref.Complex,
        _BigNumber = _ref.BigNumber;

    /**
     * Calculate the inverse cosecant of a value, defined as `acsc(x) = asin(1/x)`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.acsc(x)
     *
     * Examples:
     *
     *    math.acsc(0.5)           // returns number 0.5235987755982989
     *    math.acsc(math.csc(1.5)) // returns number ~1.5
     *
     *    math.acsc(2)             // returns Complex 1.5707963267948966 -1.3169578969248166 i
     *
     * See also:
     *
     *    csc, asin, asec
     *
     * @param {number | Complex | Array | Matrix} x   Function input
     * @return {number | Complex | Array | Matrix} The arc cosecant of x
     */
    return typed(name$2m, {
      number: function number(x) {
        if (x <= -1 || x >= 1 || config.predictable) {
          return acscNumber(x);
        }

        return new Complex(x, 0).acsc();
      },
      Complex: function Complex(x) {
        return x.acsc();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).asin();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2n = 'acsch';
  var dependencies$2o = ['typed', 'BigNumber'];
  var createAcsch = /* #__PURE__ */factory(name$2n, dependencies$2o, function (_ref) {
    var typed = _ref.typed,
        _BigNumber = _ref.BigNumber;

    /**
     * Calculate the hyperbolic arccosecant of a value,
     * defined as `acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1))`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.acsch(x)
     *
     * Examples:
     *
     *    math.acsch(0.5)       // returns 1.4436354751788103
     *
     * See also:
     *
     *    asech, acoth
     *
     * @param {number | Complex | Array | Matrix} x  Function input
     * @return {number | Complex | Array | Matrix} Hyperbolic arccosecant of x
     */
    return typed(name$2n, {
      number: acschNumber,
      Complex: function Complex(x) {
        return x.acsch();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).asinh();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2o = 'asec';
  var dependencies$2p = ['typed', 'config', 'Complex', 'BigNumber'];
  var createAsec = /* #__PURE__ */factory(name$2o, dependencies$2p, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        Complex = _ref.Complex,
        _BigNumber = _ref.BigNumber;

    /**
     * Calculate the inverse secant of a value. Defined as `asec(x) = acos(1/x)`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.asec(x)
     *
     * Examples:
     *
     *    math.asec(0.5)           // returns 1.0471975511965979
     *    math.asec(math.sec(1.5)) // returns 1.5
     *
     *    math.asec(2)             // returns 0 + 1.3169578969248166 i
     *
     * See also:
     *
     *    acos, acot, acsc
     *
     * @param {number | Complex | Array | Matrix} x  Function input
     * @return {number | Complex | Array | Matrix} The arc secant of x
     */
    return typed(name$2o, {
      number: function number(x) {
        if (x <= -1 || x >= 1 || config.predictable) {
          return asecNumber(x);
        }

        return new Complex(x, 0).asec();
      },
      Complex: function Complex(x) {
        return x.asec();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).acos();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2p = 'asech';
  var dependencies$2q = ['typed', 'config', 'Complex', 'BigNumber'];
  var createAsech = /* #__PURE__ */factory(name$2p, dependencies$2q, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        Complex = _ref.Complex,
        _BigNumber = _ref.BigNumber;

    /**
     * Calculate the hyperbolic arcsecant of a value,
     * defined as `asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x)`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.asech(x)
     *
     * Examples:
     *
     *    math.asech(0.5)       // returns 1.3169578969248166
     *
     * See also:
     *
     *    acsch, acoth
     *
     * @param {number | Complex | Array | Matrix} x  Function input
     * @return {number | Complex | Array | Matrix} Hyperbolic arcsecant of x
     */
    return typed(name$2p, {
      number: function number(x) {
        if (x <= 1 && x >= -1 || config.predictable) {
          var xInv = 1 / x;

          if (xInv > 0 || config.predictable) {
            return asechNumber(x);
          }

          var ret = Math.sqrt(xInv * xInv - 1);
          return new Complex(Math.log(ret - xInv), Math.PI);
        }

        return new Complex(x, 0).asech();
      },
      Complex: function Complex(x) {
        return x.asech();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).acosh();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2q = 'asin';
  var dependencies$2r = ['typed', 'config', 'Complex'];
  var createAsin = /* #__PURE__ */factory(name$2q, dependencies$2r, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        Complex = _ref.Complex;

    /**
     * Calculate the inverse sine of a value.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.asin(x)
     *
     * Examples:
     *
     *    math.asin(0.5)           // returns number 0.5235987755982989
     *    math.asin(math.sin(1.5)) // returns number ~1.5
     *
     *    math.asin(2)             // returns Complex 1.5707963267948966 -1.3169578969248166 i
     *
     * See also:
     *
     *    sin, atan, acos
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x   Function input
     * @return {number | BigNumber | Complex | Array | Matrix} The arc sine of x
     */
    return typed(name$2q, {
      number: function number(x) {
        if (x >= -1 && x <= 1 || config.predictable) {
          return Math.asin(x);
        } else {
          return new Complex(x, 0).asin();
        }
      },
      Complex: function Complex(x) {
        return x.asin();
      },
      BigNumber: function BigNumber(x) {
        return x.asin();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since asin(0) = 0
        return deepMap(x, this, true);
      }
    });
  });

  var name$2r = 'asinh';
  var dependencies$2s = ['typed'];
  var createAsinh = /* #__PURE__ */factory(name$2r, dependencies$2s, function (_ref) {
    var typed = _ref.typed;

    /**
     * Calculate the hyperbolic arcsine of a value,
     * defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.asinh(x)
     *
     * Examples:
     *
     *    math.asinh(0.5)       // returns 0.48121182505960347
     *
     * See also:
     *
     *    acosh, atanh
     *
     * @param {number | Complex | Array | Matrix} x  Function input
     * @return {number | Complex | Array | Matrix} Hyperbolic arcsine of x
     */
    return typed('asinh', {
      number: asinhNumber,
      Complex: function Complex(x) {
        return x.asinh();
      },
      BigNumber: function BigNumber(x) {
        return x.asinh();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since asinh(0) = 0
        return deepMap(x, this, true);
      }
    });
  });

  var name$2s = 'atan';
  var dependencies$2t = ['typed'];
  var createAtan = /* #__PURE__ */factory(name$2s, dependencies$2t, function (_ref) {
    var typed = _ref.typed;

    /**
     * Calculate the inverse tangent of a value.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.atan(x)
     *
     * Examples:
     *
     *    math.atan(0.5)           // returns number 0.4636476090008061
     *    math.atan(math.tan(1.5)) // returns number 1.5
     *
     *    math.atan(2)             // returns Complex 1.5707963267948966 -1.3169578969248166 i
     *
     * See also:
     *
     *    tan, asin, acos
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x   Function input
     * @return {number | BigNumber | Complex | Array | Matrix} The arc tangent of x
     */
    return typed('atan', {
      number: function number(x) {
        return Math.atan(x);
      },
      Complex: function Complex(x) {
        return x.atan();
      },
      BigNumber: function BigNumber(x) {
        return x.atan();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since atan(0) = 0
        return deepMap(x, this, true);
      }
    });
  });

  var name$2t = 'atan2';
  var dependencies$2u = ['typed', 'matrix', 'equalScalar', 'BigNumber', 'DenseMatrix'];
  var createAtan2 = /* #__PURE__ */factory(name$2t, dependencies$2u, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        equalScalar = _ref.equalScalar,
        BigNumber = _ref.BigNumber,
        DenseMatrix = _ref.DenseMatrix;
    var algorithm02 = createAlgorithm02({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm03 = createAlgorithm03({
      typed: typed
    });
    var algorithm09 = createAlgorithm09({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm11 = createAlgorithm11({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm12 = createAlgorithm12({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Calculate the inverse tangent function with two arguments, y/x.
     * By providing two arguments, the right quadrant of the computed angle can be
     * determined.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.atan2(y, x)
     *
     * Examples:
     *
     *    math.atan2(2, 2) / math.pi       // returns number 0.25
     *
     *    const angle = math.unit(60, 'deg') // returns Unit 60 deg
     *    const x = math.cos(angle)
     *    const y = math.sin(angle)
     *
     *    math.atan(2)             // returns Complex 1.5707963267948966 -1.3169578969248166 i
     *
     * See also:
     *
     *    tan, atan, sin, cos
     *
     * @param {number | Array | Matrix} y  Second dimension
     * @param {number | Array | Matrix} x  First dimension
     * @return {number | Array | Matrix} Four-quadrant inverse tangent
     */

    return typed(name$2t, {
      'number, number': Math.atan2,
      // Complex numbers doesn't seem to have a reasonable implementation of
      // atan2(). Even Matlab removed the support, after they only calculated
      // the atan only on base of the real part of the numbers and ignored the imaginary.
      'BigNumber, BigNumber': function BigNumberBigNumber(y, x) {
        return BigNumber.atan2(y, x);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm09(x, y, this, false);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        // mind the order of y and x!
        return algorithm02(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        return this(x, matrix(y));
      },
      'SparseMatrix, number | BigNumber': function SparseMatrixNumberBigNumber(x, y) {
        return algorithm11(x, y, this, false);
      },
      'DenseMatrix, number | BigNumber': function DenseMatrixNumberBigNumber(x, y) {
        return algorithm14(x, y, this, false);
      },
      'number | BigNumber, SparseMatrix': function numberBigNumberSparseMatrix(x, y) {
        // mind the order of y and x
        return algorithm12(y, x, this, true);
      },
      'number | BigNumber, DenseMatrix': function numberBigNumberDenseMatrix(x, y) {
        // mind the order of y and x
        return algorithm14(y, x, this, true);
      },
      'Array, number | BigNumber': function ArrayNumberBigNumber(x, y) {
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'number | BigNumber, Array': function numberBigNumberArray(x, y) {
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  var name$2u = 'atanh';
  var dependencies$2v = ['typed', 'config', 'Complex'];
  var createAtanh = /* #__PURE__ */factory(name$2u, dependencies$2v, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        Complex = _ref.Complex;

    /**
     * Calculate the hyperbolic arctangent of a value,
     * defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.atanh(x)
     *
     * Examples:
     *
     *    math.atanh(0.5)       // returns 0.5493061443340549
     *
     * See also:
     *
     *    acosh, asinh
     *
     * @param {number | Complex | Array | Matrix} x  Function input
     * @return {number | Complex | Array | Matrix} Hyperbolic arctangent of x
     */
    return typed(name$2u, {
      number: function number(x) {
        if (x <= 1 && x >= -1 || config.predictable) {
          return atanhNumber(x);
        }

        return new Complex(x, 0).atanh();
      },
      Complex: function Complex(x) {
        return x.atanh();
      },
      BigNumber: function BigNumber(x) {
        return x.atanh();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since atanh(0) = 0
        return deepMap(x, this, true);
      }
    });
  });

  var name$2v = 'cos';
  var dependencies$2w = ['typed'];
  var createCos = /* #__PURE__ */factory(name$2v, dependencies$2w, function (_ref) {
    var typed = _ref.typed;

    /**
     * Calculate the cosine of a value.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.cos(x)
     *
     * Examples:
     *
     *    math.cos(2)                      // returns number -0.4161468365471422
     *    math.cos(math.pi / 4)            // returns number  0.7071067811865475
     *    math.cos(math.unit(180, 'deg'))  // returns number -1
     *    math.cos(math.unit(60, 'deg'))   // returns number  0.5
     *
     *    const angle = 0.2
     *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2) // returns number ~1
     *
     * See also:
     *
     *    cos, tan
     *
     * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
     * @return {number | BigNumber | Complex | Array | Matrix} Cosine of x
     */
    return typed(name$2v, {
      number: Math.cos,
      Complex: function Complex(x) {
        return x.cos();
      },
      BigNumber: function BigNumber(x) {
        return x.cos();
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError('Unit in function cos is no angle');
        }

        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2w = 'cosh';
  var dependencies$2x = ['typed'];
  var createCosh = /* #__PURE__ */factory(name$2w, dependencies$2x, function (_ref) {
    var typed = _ref.typed;

    /**
     * Calculate the hyperbolic cosine of a value,
     * defined as `cosh(x) = 1/2 * (exp(x) + exp(-x))`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.cosh(x)
     *
     * Examples:
     *
     *    math.cosh(0.5)       // returns number 1.1276259652063807
     *
     * See also:
     *
     *    sinh, tanh
     *
     * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
     * @return {number | BigNumber | Complex | Array | Matrix} Hyperbolic cosine of x
     */
    return typed(name$2w, {
      number: cosh,
      Complex: function Complex(x) {
        return x.cosh();
      },
      BigNumber: function BigNumber(x) {
        return x.cosh();
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError('Unit in function cosh is no angle');
        }

        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2x = 'cot';
  var dependencies$2y = ['typed', 'BigNumber'];
  var createCot = /* #__PURE__ */factory(name$2x, dependencies$2y, function (_ref) {
    var typed = _ref.typed,
        _BigNumber = _ref.BigNumber;

    /**
     * Calculate the cotangent of a value. Defined as `cot(x) = 1 / tan(x)`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.cot(x)
     *
     * Examples:
     *
     *    math.cot(2)      // returns number -0.45765755436028577
     *    1 / math.tan(2)  // returns number -0.45765755436028577
     *
     * See also:
     *
     *    tan, sec, csc
     *
     * @param {number | Complex | Unit | Array | Matrix} x  Function input
     * @return {number | Complex | Array | Matrix} Cotangent of x
     */
    return typed(name$2x, {
      number: cotNumber,
      Complex: function Complex(x) {
        return x.cot();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x.tan());
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError('Unit in function cot is no angle');
        }

        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2y = 'coth';
  var dependencies$2z = ['typed', 'BigNumber'];
  var createCoth = /* #__PURE__ */factory(name$2y, dependencies$2z, function (_ref) {
    var typed = _ref.typed,
        _BigNumber = _ref.BigNumber;

    /**
     * Calculate the hyperbolic cotangent of a value,
     * defined as `coth(x) = 1 / tanh(x)`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.coth(x)
     *
     * Examples:
     *
     *    // coth(x) = 1 / tanh(x)
     *    math.coth(2)         // returns 1.0373147207275482
     *    1 / math.tanh(2)     // returns 1.0373147207275482
     *
     * See also:
     *
     *    sinh, tanh, cosh
     *
     * @param {number | Complex | Unit | Array | Matrix} x  Function input
     * @return {number | Complex | Array | Matrix} Hyperbolic cotangent of x
     */
    return typed(name$2y, {
      number: cothNumber,
      Complex: function Complex(x) {
        return x.coth();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x.tanh());
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError('Unit in function coth is no angle');
        }

        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2z = 'csc';
  var dependencies$2A = ['typed', 'BigNumber'];
  var createCsc = /* #__PURE__ */factory(name$2z, dependencies$2A, function (_ref) {
    var typed = _ref.typed,
        _BigNumber = _ref.BigNumber;

    /**
     * Calculate the cosecant of a value, defined as `csc(x) = 1/sin(x)`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.csc(x)
     *
     * Examples:
     *
     *    math.csc(2)      // returns number 1.099750170294617
     *    1 / math.sin(2)  // returns number 1.099750170294617
     *
     * See also:
     *
     *    sin, sec, cot
     *
     * @param {number | Complex | Unit | Array | Matrix} x  Function input
     * @return {number | Complex | Array | Matrix} Cosecant of x
     */
    return typed(name$2z, {
      number: cscNumber,
      Complex: function Complex(x) {
        return x.csc();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x.sin());
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError('Unit in function csc is no angle');
        }

        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2A = 'csch';
  var dependencies$2B = ['typed', 'BigNumber'];
  var createCsch = /* #__PURE__ */factory(name$2A, dependencies$2B, function (_ref) {
    var typed = _ref.typed,
        _BigNumber = _ref.BigNumber;

    /**
     * Calculate the hyperbolic cosecant of a value,
     * defined as `csch(x) = 1 / sinh(x)`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.csch(x)
     *
     * Examples:
     *
     *    // csch(x) = 1/ sinh(x)
     *    math.csch(0.5)       // returns 1.9190347513349437
     *    1 / math.sinh(0.5)   // returns 1.9190347513349437
     *
     * See also:
     *
     *    sinh, sech, coth
     *
     * @param {number | Complex | Unit | Array | Matrix} x  Function input
     * @return {number | Complex | Array | Matrix} Hyperbolic cosecant of x
     */
    return typed(name$2A, {
      number: cschNumber,
      Complex: function Complex(x) {
        return x.csch();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x.sinh());
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError('Unit in function csch is no angle');
        }

        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2B = 'sec';
  var dependencies$2C = ['typed', 'BigNumber'];
  var createSec = /* #__PURE__ */factory(name$2B, dependencies$2C, function (_ref) {
    var typed = _ref.typed,
        _BigNumber = _ref.BigNumber;

    /**
     * Calculate the secant of a value, defined as `sec(x) = 1/cos(x)`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.sec(x)
     *
     * Examples:
     *
     *    math.sec(2)      // returns number -2.4029979617223822
     *    1 / math.cos(2)  // returns number -2.4029979617223822
     *
     * See also:
     *
     *    cos, csc, cot
     *
     * @param {number | Complex | Unit | Array | Matrix} x  Function input
     * @return {number | Complex | Array | Matrix} Secant of x
     */
    return typed(name$2B, {
      number: secNumber,
      Complex: function Complex(x) {
        return x.sec();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x.cos());
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError('Unit in function sec is no angle');
        }

        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2C = 'sech';
  var dependencies$2D = ['typed', 'BigNumber'];
  var createSech = /* #__PURE__ */factory(name$2C, dependencies$2D, function (_ref) {
    var typed = _ref.typed,
        _BigNumber = _ref.BigNumber;

    /**
     * Calculate the hyperbolic secant of a value,
     * defined as `sech(x) = 1 / cosh(x)`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.sech(x)
     *
     * Examples:
     *
     *    // sech(x) = 1/ cosh(x)
     *    math.sech(0.5)       // returns 0.886818883970074
     *    1 / math.cosh(0.5)   // returns 0.886818883970074
     *
     * See also:
     *
     *    cosh, csch, coth
     *
     * @param {number | Complex | Unit | Array | Matrix} x  Function input
     * @return {number | Complex | Array | Matrix} Hyperbolic secant of x
     */
    return typed(name$2C, {
      number: sechNumber,
      Complex: function Complex(x) {
        return x.sech();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x.cosh());
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError('Unit in function sech is no angle');
        }

        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$2D = 'sin';
  var dependencies$2E = ['typed'];
  var createSin = /* #__PURE__ */factory(name$2D, dependencies$2E, function (_ref) {
    var typed = _ref.typed;

    /**
     * Calculate the sine of a value.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.sin(x)
     *
     * Examples:
     *
     *    math.sin(2)                      // returns number 0.9092974268256813
     *    math.sin(math.pi / 4)            // returns number 0.7071067811865475
     *    math.sin(math.unit(90, 'deg'))   // returns number 1
     *    math.sin(math.unit(30, 'deg'))   // returns number 0.5
     *
     *    const angle = 0.2
     *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2) // returns number ~1
     *
     * See also:
     *
     *    cos, tan
     *
     * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
     * @return {number | BigNumber | Complex | Array | Matrix} Sine of x
     */
    return typed(name$2D, {
      number: Math.sin,
      Complex: function Complex(x) {
        return x.sin();
      },
      BigNumber: function BigNumber(x) {
        return x.sin();
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError('Unit in function sin is no angle');
        }

        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since sin(0) = 0
        return deepMap(x, this, true);
      }
    });
  });

  var name$2E = 'sinh';
  var dependencies$2F = ['typed'];
  var createSinh = /* #__PURE__ */factory(name$2E, dependencies$2F, function (_ref) {
    var typed = _ref.typed;

    /**
     * Calculate the hyperbolic sine of a value,
     * defined as `sinh(x) = 1/2 * (exp(x) - exp(-x))`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.sinh(x)
     *
     * Examples:
     *
     *    math.sinh(0.5)       // returns number 0.5210953054937474
     *
     * See also:
     *
     *    cosh, tanh
     *
     * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
     * @return {number | BigNumber | Complex | Array | Matrix} Hyperbolic sine of x
     */
    return typed(name$2E, {
      number: sinhNumber,
      Complex: function Complex(x) {
        return x.sinh();
      },
      BigNumber: function BigNumber(x) {
        return x.sinh();
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError('Unit in function sinh is no angle');
        }

        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since sinh(0) = 0
        return deepMap(x, this, true);
      }
    });
  });

  var name$2F = 'tan';
  var dependencies$2G = ['typed'];
  var createTan = /* #__PURE__ */factory(name$2F, dependencies$2G, function (_ref) {
    var typed = _ref.typed;

    /**
     * Calculate the tangent of a value. `tan(x)` is equal to `sin(x) / cos(x)`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.tan(x)
     *
     * Examples:
     *
     *    math.tan(0.5)                    // returns number 0.5463024898437905
     *    math.sin(0.5) / math.cos(0.5)    // returns number 0.5463024898437905
     *    math.tan(math.pi / 4)            // returns number 1
     *    math.tan(math.unit(45, 'deg'))   // returns number 1
     *
     * See also:
     *
     *    atan, sin, cos
     *
     * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
     * @return {number | BigNumber | Complex | Array | Matrix} Tangent of x
     */
    return typed(name$2F, {
      number: Math.tan,
      Complex: function Complex(x) {
        return x.tan();
      },
      BigNumber: function BigNumber(x) {
        return x.tan();
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError('Unit in function tan is no angle');
        }

        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since tan(0) = 0
        return deepMap(x, this, true);
      }
    });
  });

  var name$2G = 'tanh';
  var dependencies$2H = ['typed'];
  var createTanh = /* #__PURE__ */factory(name$2G, dependencies$2H, function (_ref) {
    var typed = _ref.typed;

    /**
     * Calculate the hyperbolic tangent of a value,
     * defined as `tanh(x) = (exp(2 * x) - 1) / (exp(2 * x) + 1)`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.tanh(x)
     *
     * Examples:
     *
     *    // tanh(x) = sinh(x) / cosh(x) = 1 / coth(x)
     *    math.tanh(0.5)                   // returns 0.46211715726000974
     *    math.sinh(0.5) / math.cosh(0.5)  // returns 0.46211715726000974
     *    1 / math.coth(0.5)               // returns 0.46211715726000974
     *
     * See also:
     *
     *    sinh, cosh, coth
     *
     * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
     * @return {number | BigNumber | Complex | Array | Matrix} Hyperbolic tangent of x
     */
    return typed('tanh', {
      number: tanh,
      Complex: function Complex(x) {
        return x.tanh();
      },
      BigNumber: function BigNumber(x) {
        return x.tanh();
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError('Unit in function tanh is no angle');
        }

        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since tanh(0) = 0
        return deepMap(x, this, true);
      }
    });
  });

  var name$2H = 'setCartesian';
  var dependencies$2I = ['typed', 'size', 'subset', 'compareNatural', 'Index', 'DenseMatrix'];
  var createSetCartesian = /* #__PURE__ */factory(name$2H, dependencies$2I, function (_ref) {
    var typed = _ref.typed,
        size = _ref.size,
        subset = _ref.subset,
        compareNatural = _ref.compareNatural,
        Index = _ref.Index,
        DenseMatrix = _ref.DenseMatrix;

    /**
     * Create the cartesian product of two (multi)sets.
     * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
     *
     * Syntax:
     *
     *    math.setCartesian(set1, set2)
     *
     * Examples:
     *
     *    math.setCartesian([1, 2], [3, 4])        // returns [[1, 3], [1, 4], [2, 3], [2, 4]]
     *
     * See also:
     *
     *    setUnion, setIntersect, setDifference, setPowerset
     *
     * @param {Array | Matrix}    a1  A (multi)set
     * @param {Array | Matrix}    a2  A (multi)set
     * @return {Array | Matrix}    The cartesian product of two (multi)sets
     */
    return typed(name$2H, {
      'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {
        var result = [];

        if (subset(size(a1), new Index(0)) !== 0 && subset(size(a2), new Index(0)) !== 0) {
          // if any of them is empty, return empty
          var b1 = flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural);
          var b2 = flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural);
          result = [];

          for (var i = 0; i < b1.length; i++) {
            for (var j = 0; j < b2.length; j++) {
              result.push([b1[i], b2[j]]);
            }
          }
        } // return an array, if both inputs were arrays


        if (Array.isArray(a1) && Array.isArray(a2)) {
          return result;
        } // return a matrix otherwise


        return new DenseMatrix(result);
      }
    });
  });

  var name$2I = 'setDifference';
  var dependencies$2J = ['typed', 'size', 'subset', 'compareNatural', 'Index', 'DenseMatrix'];
  var createSetDifference = /* #__PURE__ */factory(name$2I, dependencies$2J, function (_ref) {
    var typed = _ref.typed,
        size = _ref.size,
        subset = _ref.subset,
        compareNatural = _ref.compareNatural,
        Index = _ref.Index,
        DenseMatrix = _ref.DenseMatrix;

    /**
     * Create the difference of two (multi)sets: every element of set1, that is not the element of set2.
     * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
     *
     * Syntax:
     *
     *    math.setDifference(set1, set2)
     *
     * Examples:
     *
     *    math.setDifference([1, 2, 3, 4], [3, 4, 5, 6])            // returns [1, 2]
     *    math.setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [1, 2]
     *
     * See also:
     *
     *    setUnion, setIntersect, setSymDifference
     *
     * @param {Array | Matrix}    a1  A (multi)set
     * @param {Array | Matrix}    a2  A (multi)set
     * @return {Array | Matrix}    The difference of two (multi)sets
     */
    return typed(name$2I, {
      'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {
        var result;

        if (subset(size(a1), new Index(0)) === 0) {
          // empty-anything=empty
          result = [];
        } else if (subset(size(a2), new Index(0)) === 0) {
          // anything-empty=anything
          return flatten(a1.toArray());
        } else {
          var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
          var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
          result = [];
          var inb2;

          for (var i = 0; i < b1.length; i++) {
            inb2 = false;

            for (var j = 0; j < b2.length; j++) {
              if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
                // the identifier is always a decimal int
                inb2 = true;
                break;
              }
            }

            if (!inb2) {
              result.push(b1[i]);
            }
          }
        } // return an array, if both inputs were arrays


        if (Array.isArray(a1) && Array.isArray(a2)) {
          return generalize(result);
        } // return a matrix otherwise


        return new DenseMatrix(generalize(result));
      }
    });
  });

  var name$2J = 'setDistinct';
  var dependencies$2K = ['typed', 'size', 'subset', 'compareNatural', 'Index', 'DenseMatrix'];
  var createSetDistinct = /* #__PURE__ */factory(name$2J, dependencies$2K, function (_ref) {
    var typed = _ref.typed,
        size = _ref.size,
        subset = _ref.subset,
        compareNatural = _ref.compareNatural,
        Index = _ref.Index,
        DenseMatrix = _ref.DenseMatrix;

    /**
     * Collect the distinct elements of a multiset.
     * A multi-dimension array will be converted to a single-dimension array before the operation.
     *
     * Syntax:
     *
     *    math.setDistinct(set)
     *
     * Examples:
     *
     *    math.setDistinct([1, 1, 1, 2, 2, 3])        // returns [1, 2, 3]
     *
     * See also:
     *
     *    setMultiplicity
     *
     * @param {Array | Matrix}    a  A multiset
     * @return {Array | Matrix}    A set containing the distinc elements of the multiset
     */
    return typed(name$2J, {
      'Array | Matrix': function ArrayMatrix(a) {
        var result;

        if (subset(size(a), new Index(0)) === 0) {
          // if empty, return empty
          result = [];
        } else {
          var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
          result = [];
          result.push(b[0]);

          for (var i = 1; i < b.length; i++) {
            if (compareNatural(b[i], b[i - 1]) !== 0) {
              result.push(b[i]);
            }
          }
        } // return an array, if the input was an array


        if (Array.isArray(a)) {
          return result;
        } // return a matrix otherwise


        return new DenseMatrix(result);
      }
    });
  });

  var name$2K = 'setIntersect';
  var dependencies$2L = ['typed', 'size', 'subset', 'compareNatural', 'Index', 'DenseMatrix'];
  var createSetIntersect = /* #__PURE__ */factory(name$2K, dependencies$2L, function (_ref) {
    var typed = _ref.typed,
        size = _ref.size,
        subset = _ref.subset,
        compareNatural = _ref.compareNatural,
        Index = _ref.Index,
        DenseMatrix = _ref.DenseMatrix;

    /**
     * Create the intersection of two (multi)sets.
     * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
     *
     * Syntax:
     *
     *    math.setIntersect(set1, set2)
     *
     * Examples:
     *
     *    math.setIntersect([1, 2, 3, 4], [3, 4, 5, 6])            // returns [3, 4]
     *    math.setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [3, 4]
     *
     * See also:
     *
     *    setUnion, setDifference
     *
     * @param {Array | Matrix}    a1  A (multi)set
     * @param {Array | Matrix}    a2  A (multi)set
     * @return {Array | Matrix}    The intersection of two (multi)sets
     */
    return typed(name$2K, {
      'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {
        var result;

        if (subset(size(a1), new Index(0)) === 0 || subset(size(a2), new Index(0)) === 0) {
          // of any of them is empty, return empty
          result = [];
        } else {
          var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
          var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
          result = [];

          for (var i = 0; i < b1.length; i++) {
            for (var j = 0; j < b2.length; j++) {
              if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
                // the identifier is always a decimal int
                result.push(b1[i]);
                break;
              }
            }
          }
        } // return an array, if both inputs were arrays


        if (Array.isArray(a1) && Array.isArray(a2)) {
          return generalize(result);
        } // return a matrix otherwise


        return new DenseMatrix(generalize(result));
      }
    });
  });

  var name$2L = 'setIsSubset';
  var dependencies$2M = ['typed', 'size', 'subset', 'compareNatural', 'Index'];
  var createSetIsSubset = /* #__PURE__ */factory(name$2L, dependencies$2M, function (_ref) {
    var typed = _ref.typed,
        size = _ref.size,
        subset = _ref.subset,
        compareNatural = _ref.compareNatural,
        Index = _ref.Index;

    /**
     * Check whether a (multi)set is a subset of another (multi)set. (Every element of set1 is the element of set2.)
     * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
     *
     * Syntax:
     *
     *    math.setIsSubset(set1, set2)
     *
     * Examples:
     *
     *    math.setIsSubset([1, 2], [3, 4, 5, 6])        // returns false
     *    math.setIsSubset([3, 4], [3, 4, 5, 6])        // returns true
     *
     * See also:
     *
     *    setUnion, setIntersect, setDifference
     *
     * @param {Array | Matrix}    a1  A (multi)set
     * @param {Array | Matrix}    a2  A (multi)set
     * @return {boolean}            true | false
     */
    return typed(name$2L, {
      'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {
        if (subset(size(a1), new Index(0)) === 0) {
          // empty is a subset of anything
          return true;
        } else if (subset(size(a2), new Index(0)) === 0) {
          // anything is not a subset of empty
          return false;
        }

        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
        var inb2;

        for (var i = 0; i < b1.length; i++) {
          inb2 = false;

          for (var j = 0; j < b2.length; j++) {
            if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
              // the identifier is always a decimal int
              inb2 = true;
              break;
            }
          }

          if (inb2 === false) {
            return false;
          }
        }

        return true;
      }
    });
  });

  var name$2M = 'setMultiplicity';
  var dependencies$2N = ['typed', 'size', 'subset', 'compareNatural', 'Index'];
  var createSetMultiplicity = /* #__PURE__ */factory(name$2M, dependencies$2N, function (_ref) {
    var typed = _ref.typed,
        size = _ref.size,
        subset = _ref.subset,
        compareNatural = _ref.compareNatural,
        Index = _ref.Index;

    /**
     * Count the multiplicity of an element in a multiset.
     * A multi-dimension array will be converted to a single-dimension array before the operation.
     *
     * Syntax:
     *
     *    math.setMultiplicity(element, set)
     *
     * Examples:
     *
     *    math.setMultiplicity(1, [1, 2, 2, 4])    // returns 1
     *    math.setMultiplicity(2, [1, 2, 2, 4])    // returns 2
     *
     * See also:
     *
     *    setDistinct, setSize
     *
     * @param {number | BigNumber | Fraction | Complex} e  An element in the multiset
     * @param {Array | Matrix}     a  A multiset
     * @return {number}            The number of how many times the multiset contains the element
     */
    return typed(name$2M, {
      'number | BigNumber | Fraction | Complex, Array | Matrix': function numberBigNumberFractionComplexArrayMatrix(e, a) {
        if (subset(size(a), new Index(0)) === 0) {
          // if empty, return 0
          return 0;
        }

        var b = flatten(Array.isArray(a) ? a : a.toArray());
        var count = 0;

        for (var i = 0; i < b.length; i++) {
          if (compareNatural(b[i], e) === 0) {
            count++;
          }
        }

        return count;
      }
    });
  });

  var name$2N = 'setPowerset';
  var dependencies$2O = ['typed', 'size', 'subset', 'compareNatural', 'Index'];
  var createSetPowerset = /* #__PURE__ */factory(name$2N, dependencies$2O, function (_ref) {
    var typed = _ref.typed,
        size = _ref.size,
        subset = _ref.subset,
        compareNatural = _ref.compareNatural,
        Index = _ref.Index;

    /**
     * Create the powerset of a (multi)set. (The powerset contains very possible subsets of a (multi)set.)
     * A multi-dimension array will be converted to a single-dimension array before the operation.
     *
     * Syntax:
     *
     *    math.setPowerset(set)
     *
     * Examples:
     *
     *    math.setPowerset([1, 2, 3])        // returns [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]
     *
     * See also:
     *
     *    setCartesian
     *
     * @param {Array | Matrix}    a  A (multi)set
     * @return {Array}    The powerset of the (multi)set
     */
    return typed(name$2N, {
      'Array | Matrix': function ArrayMatrix(a) {
        if (subset(size(a), new Index(0)) === 0) {
          // if empty, return empty
          return [];
        }

        var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
        var result = [];
        var number = 0;

        while (number.toString(2).length <= b.length) {
          result.push(_subset(b, number.toString(2).split('').reverse()));
          number++;
        } // can not return a matrix, because of the different size of the subarrays


        return _sort(result);
      }
    }); // create subset

    function _subset(array, bitarray) {
      var result = [];

      for (var i = 0; i < bitarray.length; i++) {
        if (bitarray[i] === '1') {
          result.push(array[i]);
        }
      }

      return result;
    } // sort subsests by length


    function _sort(array) {
      var temp = [];

      for (var i = array.length - 1; i > 0; i--) {
        for (var j = 0; j < i; j++) {
          if (array[j].length > array[j + 1].length) {
            temp = array[j];
            array[j] = array[j + 1];
            array[j + 1] = temp;
          }
        }
      }

      return array;
    }
  });

  var name$2O = 'setSize';
  var dependencies$2P = ['typed', 'compareNatural'];
  var createSetSize = /* #__PURE__ */factory(name$2O, dependencies$2P, function (_ref) {
    var typed = _ref.typed,
        compareNatural = _ref.compareNatural;

    /**
     * Count the number of elements of a (multi)set. When a second parameter is 'true', count only the unique values.
     * A multi-dimension array will be converted to a single-dimension array before the operation.
     *
     * Syntax:
     *
     *    math.setSize(set)
     *    math.setSize(set, unique)
     *
     * Examples:
     *
     *    math.setSize([1, 2, 2, 4])          // returns 4
     *    math.setSize([1, 2, 2, 4], true)    // returns 3
     *
     * See also:
     *
     *    setUnion, setIntersect, setDifference
     *
     * @param {Array | Matrix}    a  A multiset
     * @return {number}            The number of elements of the (multi)set
     */
    return typed(name$2O, {
      'Array | Matrix': function ArrayMatrix(a) {
        return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
      },
      'Array | Matrix, boolean': function ArrayMatrixBoolean(a, unique) {
        if (unique === false || a.length === 0) {
          return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
        } else {
          var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
          var count = 1;

          for (var i = 1; i < b.length; i++) {
            if (compareNatural(b[i], b[i - 1]) !== 0) {
              count++;
            }
          }

          return count;
        }
      }
    });
  });

  var name$2P = 'setSymDifference';
  var dependencies$2Q = ['typed', 'size', 'concat', 'subset', 'setDifference', 'Index'];
  var createSetSymDifference = /* #__PURE__ */factory(name$2P, dependencies$2Q, function (_ref) {
    var typed = _ref.typed,
        size = _ref.size,
        concat = _ref.concat,
        subset = _ref.subset,
        setDifference = _ref.setDifference,
        Index = _ref.Index;

    /**
     * Create the symmetric difference of two (multi)sets.
     * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
     *
     * Syntax:
     *
     *    math.setSymDifference(set1, set2)
     *
     * Examples:
     *
     *    math.setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])            // returns [1, 2, 5, 6]
     *    math.setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [1, 2, 5, 6]
     *
     * See also:
     *
     *    setUnion, setIntersect, setDifference
     *
     * @param {Array | Matrix}    a1  A (multi)set
     * @param {Array | Matrix}    a2  A (multi)set
     * @return {Array | Matrix}    The symmetric difference of two (multi)sets
     */
    return typed(name$2P, {
      'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {
        if (subset(size(a1), new Index(0)) === 0) {
          // if any of them is empty, return the other one
          return flatten(a2);
        } else if (subset(size(a2), new Index(0)) === 0) {
          return flatten(a1);
        }

        var b1 = flatten(a1);
        var b2 = flatten(a2);
        return concat(setDifference(b1, b2), setDifference(b2, b1));
      }
    });
  });

  var name$2Q = 'setUnion';
  var dependencies$2R = ['typed', 'size', 'concat', 'subset', 'setIntersect', 'setSymDifference', 'Index'];
  var createSetUnion = /* #__PURE__ */factory(name$2Q, dependencies$2R, function (_ref) {
    var typed = _ref.typed,
        size = _ref.size,
        concat = _ref.concat,
        subset = _ref.subset,
        setIntersect = _ref.setIntersect,
        setSymDifference = _ref.setSymDifference,
        Index = _ref.Index;

    /**
     * Create the union of two (multi)sets.
     * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
     *
     * Syntax:
     *
     *    math.setUnion(set1, set2)
     *
     * Examples:
     *
     *    math.setUnion([1, 2, 3, 4], [3, 4, 5, 6])            // returns [1, 2, 3, 4, 5, 6]
     *    math.setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [1, 2, 3, 4, 5, 6]
     *
     * See also:
     *
     *    setIntersect, setDifference
     *
     * @param {Array | Matrix}    a1  A (multi)set
     * @param {Array | Matrix}    a2  A (multi)set
     * @return {Array | Matrix}    The union of two (multi)sets
     */
    return typed(name$2Q, {
      'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(a1, a2) {
        if (subset(size(a1), new Index(0)) === 0) {
          // if any of them is empty, return the other one
          return flatten(a2);
        } else if (subset(size(a2), new Index(0)) === 0) {
          return flatten(a1);
        }

        var b1 = flatten(a1);
        var b2 = flatten(a2);
        return concat(setSymDifference(b1, b2), setIntersect(b1, b2));
      }
    });
  });

  var name$2R = 'add';
  var dependencies$2S = ['typed', 'matrix', 'addScalar', 'equalScalar', 'DenseMatrix', 'SparseMatrix'];
  var createAdd = /* #__PURE__ */factory(name$2R, dependencies$2S, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        addScalar = _ref.addScalar,
        equalScalar = _ref.equalScalar,
        DenseMatrix = _ref.DenseMatrix,
        SparseMatrix = _ref.SparseMatrix;
    var algorithm01 = createAlgorithm01({
      typed: typed
    });
    var algorithm04 = createAlgorithm04({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm10 = createAlgorithm10({
      typed: typed,
      DenseMatrix: DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed: typed
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Add two or more values, `x + y`.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.add(x, y)
     *    math.add(x, y, z, ...)
     *
     * Examples:
     *
     *    math.add(2, 3)               // returns number 5
     *    math.add(2, 3, 4)            // returns number 9
     *
     *    const a = math.complex(2, 3)
     *    const b = math.complex(-4, 1)
     *    math.add(a, b)               // returns Complex -2 + 4i
     *
     *    math.add([1, 2, 3], 4)       // returns Array [5, 6, 7]
     *
     *    const c = math.unit('5 cm')
     *    const d = math.unit('2.1 mm')
     *    math.add(c, d)               // returns Unit 52.1 mm
     *
     *    math.add("2.3", "4")         // returns number 6.3
     *
     * See also:
     *
     *    subtract, sum
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to add
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to add
     * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Sum of `x` and `y`
     */

    return typed(name$2R, extend({
      // we extend the signatures of addScalar with signatures dealing with matrices
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, addScalar);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm01(x, y, addScalar, false);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm01(y, x, addScalar, true);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm04(x, y, addScalar);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, addScalar, false);
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm10(x, y, addScalar, false);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, addScalar, true);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm10(y, x, addScalar, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, addScalar, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, addScalar, true).valueOf();
      },
      'any, any': addScalar,
      'any, any, ...any': function anyAnyAny(x, y, rest) {
        var result = this(x, y);

        for (var i = 0; i < rest.length; i++) {
          result = this(result, rest[i]);
        }

        return result;
      }
    }, addScalar.signatures));
  });

  var name$2S = 'hypot';
  var dependencies$2T = ['typed', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'sqrt', 'smaller', 'isPositive'];
  var createHypot = /* #__PURE__ */factory(name$2S, dependencies$2T, function (_ref) {
    var typed = _ref.typed,
        abs = _ref.abs,
        addScalar = _ref.addScalar,
        divideScalar = _ref.divideScalar,
        multiplyScalar = _ref.multiplyScalar,
        sqrt = _ref.sqrt,
        smaller = _ref.smaller,
        isPositive = _ref.isPositive;

    /**
     * Calculate the hypotenusa of a list with values. The hypotenusa is defined as:
     *
     *     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)
     *
     * For matrix input, the hypotenusa is calculated for all values in the matrix.
     *
     * Syntax:
     *
     *     math.hypot(a, b, ...)
     *     math.hypot([a, b, c, ...])
     *
     * Examples:
     *
     *     math.hypot(3, 4)      // 5
     *     math.hypot(3, 4, 5)   // 7.0710678118654755
     *     math.hypot([3, 4, 5]) // 7.0710678118654755
     *     math.hypot(-2)        // 2
     *
     * See also:
     *
     *     abs, norm
     *
     * @param {... number | BigNumber | Array | Matrix} args    A list with numeric values or an Array or Matrix.
     *                                                          Matrix and Array input is flattened and returns a
     *                                                          single number for the whole matrix.
     * @return {number | BigNumber} Returns the hypothenusa of the input values.
     */
    return typed(name$2S, {
      '... number | BigNumber': _hypot,
      Array: function Array(x) {
        return this.apply(this, flatten(x));
      },
      Matrix: function Matrix(x) {
        return this.apply(this, flatten(x.toArray()));
      }
    });
    /**
     * Calculate the hypotenusa for an Array with values
     * @param {Array.<number | BigNumber>} args
     * @return {number | BigNumber} Returns the result
     * @private
     */

    function _hypot(args) {
      // code based on `hypot` from es6-shim:
      // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1619-L1633
      var result = 0;
      var largest = 0;

      for (var i = 0; i < args.length; i++) {
        var value = abs(args[i]);

        if (smaller(largest, value)) {
          result = multiplyScalar(result, multiplyScalar(divideScalar(largest, value), divideScalar(largest, value)));
          result = addScalar(result, 1);
          largest = value;
        } else {
          result = addScalar(result, isPositive(value) ? multiplyScalar(divideScalar(value, largest), divideScalar(value, largest)) : value);
        }
      }

      return multiplyScalar(largest, sqrt(result));
    }
  });

  var name$2T = 'norm';
  var dependencies$2U = ['typed', 'abs', 'add', 'pow', 'conj', 'sqrt', 'multiply', 'equalScalar', 'larger', 'smaller', 'matrix'];
  var createNorm = /* #__PURE__ */factory(name$2T, dependencies$2U, function (_ref) {
    var typed = _ref.typed,
        abs = _ref.abs,
        add = _ref.add,
        pow = _ref.pow,
        conj = _ref.conj,
        sqrt = _ref.sqrt,
        multiply = _ref.multiply,
        equalScalar = _ref.equalScalar,
        larger = _ref.larger,
        smaller = _ref.smaller,
        matrix = _ref.matrix;

    /**
     * Calculate the norm of a number, vector or matrix.
     *
     * The second parameter p is optional. If not provided, it defaults to 2.
     *
     * Syntax:
     *
     *    math.norm(x)
     *    math.norm(x, p)
     *
     * Examples:
     *
     *    math.abs(-3.5)                         // returns 3.5
     *    math.norm(-3.5)                        // returns 3.5
     *
     *    math.norm(math.complex(3, -4))         // returns 5
     *
     *    math.norm([1, 2, -3], Infinity)        // returns 3
     *    math.norm([1, 2, -3], -Infinity)       // returns 1
     *
     *    math.norm([3, 4], 2)                   // returns 5
     *
     *    math.norm([[1, 2], [3, 4]], 1)          // returns 6
     *    math.norm([[1, 2], [3, 4]], 'inf')     // returns 7
     *    math.norm([[1, 2], [3, 4]], 'fro')     // returns 5.477225575051661
     *
     * See also:
     *
     *    abs, hypot
     *
     * @param  {number | BigNumber | Complex | Array | Matrix} x
     *            Value for which to calculate the norm
     * @param  {number | BigNumber | string} [p=2]
     *            Vector space.
     *            Supported numbers include Infinity and -Infinity.
     *            Supported strings are: 'inf', '-inf', and 'fro' (The Frobenius norm)
     * @return {number | BigNumber} the p-norm
     */
    return typed(name$2T, {
      number: Math.abs,
      Complex: function Complex(x) {
        return x.abs();
      },
      BigNumber: function BigNumber(x) {
        // norm(x) = abs(x)
        return x.abs();
      },
      "boolean": function boolean(x) {
        // norm(x) = abs(x)
        return Math.abs(x);
      },
      Array: function Array(x) {
        return _norm(matrix(x), 2);
      },
      Matrix: function Matrix(x) {
        return _norm(x, 2);
      },
      'number | Complex | BigNumber | boolean, number | BigNumber | string': function numberComplexBigNumberBooleanNumberBigNumberString(x) {
        // ignore second parameter, TODO: remove the option of second parameter for these types
        return this(x);
      },
      'Array, number | BigNumber | string': function ArrayNumberBigNumberString(x, p) {
        return _norm(matrix(x), p);
      },
      'Matrix, number | BigNumber | string': function MatrixNumberBigNumberString(x, p) {
        return _norm(x, p);
      }
    });
    /**
     * Calculate the norm for an array
     * @param {Matrix} x
     * @param {number | string} p
     * @returns {number} Returns the norm
     * @private
     */

    function _norm(x, p) {
      // size
      var sizeX = x.size(); // check if it is a vector

      if (sizeX.length === 1) {
        // check p
        if (p === Number.POSITIVE_INFINITY || p === 'inf') {
          // norm(x, Infinity) = max(abs(x))
          var pinf = 0; // skip zeros since abs(0) === 0

          x.forEach(function (value) {
            var v = abs(value);

            if (larger(v, pinf)) {
              pinf = v;
            }
          }, true);
          return pinf;
        }

        if (p === Number.NEGATIVE_INFINITY || p === '-inf') {
          // norm(x, -Infinity) = min(abs(x))
          var ninf; // skip zeros since abs(0) === 0

          x.forEach(function (value) {
            var v = abs(value);

            if (!ninf || smaller(v, ninf)) {
              ninf = v;
            }
          }, true);
          return ninf || 0;
        }

        if (p === 'fro') {
          return _norm(x, 2);
        }

        if (typeof p === 'number' && !isNaN(p)) {
          // check p != 0
          if (!equalScalar(p, 0)) {
            // norm(x, p) = sum(abs(xi) ^ p) ^ 1/p
            var n = 0; // skip zeros since abs(0) === 0

            x.forEach(function (value) {
              n = add(pow(abs(value), p), n);
            }, true);
            return pow(n, 1 / p);
          }

          return Number.POSITIVE_INFINITY;
        } // invalid parameter value


        throw new Error('Unsupported parameter value');
      } // MxN matrix


      if (sizeX.length === 2) {
        // check p
        if (p === 1) {
          // norm(x) = the largest column sum
          var c = []; // result

          var maxc = 0; // skip zeros since abs(0) == 0

          x.forEach(function (value, index) {
            var j = index[1];
            var cj = add(c[j] || 0, abs(value));

            if (larger(cj, maxc)) {
              maxc = cj;
            }

            c[j] = cj;
          }, true);
          return maxc;
        }

        if (p === Number.POSITIVE_INFINITY || p === 'inf') {
          // norm(x) = the largest row sum
          var r = []; // result

          var maxr = 0; // skip zeros since abs(0) == 0

          x.forEach(function (value, index) {
            var i = index[0];
            var ri = add(r[i] || 0, abs(value));

            if (larger(ri, maxr)) {
              maxr = ri;
            }

            r[i] = ri;
          }, true);
          return maxr;
        }

        if (p === 'fro') {
          // norm(x) = sqrt(sum(diag(x'x)))
          var fro = 0;
          x.forEach(function (value, index) {
            fro = add(fro, multiply(value, conj(value)));
          });
          return abs(sqrt(fro));
        }

        if (p === 2) {
          // not implemented
          throw new Error('Unsupported parameter value, missing implementation of matrix singular value decomposition');
        } // invalid parameter value


        throw new Error('Unsupported parameter value');
      }
    }
  });

  var name$2U = 'dot';
  var dependencies$2V = ['typed', 'addScalar', 'multiplyScalar', 'conj', 'size'];
  var createDot = /* #__PURE__ */factory(name$2U, dependencies$2V, function (_ref) {
    var typed = _ref.typed,
        addScalar = _ref.addScalar,
        multiplyScalar = _ref.multiplyScalar,
        conj = _ref.conj,
        size = _ref.size;

    /**
     * Calculate the dot product of two vectors. The dot product of
     * `A = [a1, a2, ..., an]` and `B = [b1, b2, ..., bn]` is defined as:
     *
     *    dot(A, B) = conj(a1) * b1 + conj(a2) * b2 + ... + conj(an) * bn
     *
     * Syntax:
     *
     *    math.dot(x, y)
     *
     * Examples:
     *
     *    math.dot([2, 4, 1], [2, 2, 3])       // returns number 15
     *    math.multiply([2, 4, 1], [2, 2, 3])  // returns number 15
     *
     * See also:
     *
     *    multiply, cross
     *
     * @param  {Array | Matrix} x     First vector
     * @param  {Array | Matrix} y     Second vector
     * @return {number}               Returns the dot product of `x` and `y`
     */
    return typed(name$2U, {
      'Array | DenseMatrix, Array | DenseMatrix': _denseDot,
      'SparseMatrix, SparseMatrix': _sparseDot
    });

    function _validateDim(x, y) {
      var xSize = _size(x);

      var ySize = _size(y);

      var xLen, yLen;

      if (xSize.length === 1) {
        xLen = xSize[0];
      } else if (xSize.length === 2 && xSize[1] === 1) {
        xLen = xSize[0];
      } else {
        throw new RangeError('Expected a column vector, instead got a matrix of size (' + xSize.join(', ') + ')');
      }

      if (ySize.length === 1) {
        yLen = ySize[0];
      } else if (ySize.length === 2 && ySize[1] === 1) {
        yLen = ySize[0];
      } else {
        throw new RangeError('Expected a column vector, instead got a matrix of size (' + ySize.join(', ') + ')');
      }

      if (xLen !== yLen) throw new RangeError('Vectors must have equal length (' + xLen + ' != ' + yLen + ')');
      if (xLen === 0) throw new RangeError('Cannot calculate the dot product of empty vectors');
      return xLen;
    }

    function _denseDot(a, b) {
      var N = _validateDim(a, b);

      var adata = isMatrix(a) ? a._data : a;
      var adt = isMatrix(a) ? a._datatype : undefined;
      var bdata = isMatrix(b) ? b._data : b;
      var bdt = isMatrix(b) ? b._datatype : undefined; // are these 2-dimensional column vectors? (as opposed to 1-dimensional vectors)

      var aIsColumn = _size(a).length === 2;
      var bIsColumn = _size(b).length === 2;
      var add = addScalar;
      var mul = multiplyScalar; // process data types

      if (adt && bdt && adt === bdt && typeof adt === 'string') {
        var dt = adt; // find signatures that matches (dt, dt)

        add = typed.find(addScalar, [dt, dt]);
        mul = typed.find(multiplyScalar, [dt, dt]);
      } // both vectors 1-dimensional


      if (!aIsColumn && !bIsColumn) {
        var c = mul(conj(adata[0]), bdata[0]);

        for (var i = 1; i < N; i++) {
          c = add(c, mul(conj(adata[i]), bdata[i]));
        }

        return c;
      } // a is 1-dim, b is column


      if (!aIsColumn && bIsColumn) {
        var _c = mul(conj(adata[0]), bdata[0][0]);

        for (var _i = 1; _i < N; _i++) {
          _c = add(_c, mul(conj(adata[_i]), bdata[_i][0]));
        }

        return _c;
      } // a is column, b is 1-dim


      if (aIsColumn && !bIsColumn) {
        var _c2 = mul(conj(adata[0][0]), bdata[0]);

        for (var _i2 = 1; _i2 < N; _i2++) {
          _c2 = add(_c2, mul(conj(adata[_i2][0]), bdata[_i2]));
        }

        return _c2;
      } // both vectors are column


      if (aIsColumn && bIsColumn) {
        var _c3 = mul(conj(adata[0][0]), bdata[0][0]);

        for (var _i3 = 1; _i3 < N; _i3++) {
          _c3 = add(_c3, mul(conj(adata[_i3][0]), bdata[_i3][0]));
        }

        return _c3;
      }
    }

    function _sparseDot(x, y) {
      _validateDim(x, y);

      var xindex = x._index;
      var xvalues = x._values;
      var yindex = y._index;
      var yvalues = y._values; // TODO optimize add & mul using datatype

      var c = 0;
      var add = addScalar;
      var mul = multiplyScalar;
      var i = 0;
      var j = 0;

      while (i < xindex.length && j < yindex.length) {
        var I = xindex[i];
        var J = yindex[j];

        if (I < J) {
          i++;
          continue;
        }

        if (I > J) {
          j++;
          continue;
        }

        if (I === J) {
          c = add(c, mul(xvalues[i], yvalues[j]));
          i++;
          j++;
        }
      }

      return c;
    } // TODO remove this once #1771 is fixed


    function _size(x) {
      return isMatrix(x) ? x.size() : size(x);
    }
  });

  var name$2V = 'trace';
  var dependencies$2W = ['typed', 'matrix', 'add'];
  var createTrace = /* #__PURE__ */factory(name$2V, dependencies$2W, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        add = _ref.add;

    /**
     * Calculate the trace of a matrix: the sum of the elements on the main
     * diagonal of a square matrix.
     *
     * Syntax:
     *
     *    math.trace(x)
     *
     * Examples:
     *
     *    math.trace([[1, 2], [3, 4]]) // returns 5
     *
     *    const A = [
     *      [1, 2, 3],
     *      [-1, 2, 3],
     *      [2, 0, 3]
     *    ]
     *    math.trace(A) // returns 6
     *
     * See also:
     *
     *    diag
     *
     * @param {Array | Matrix} x  A matrix
     *
     * @return {number} The trace of `x`
     */
    return typed('trace', {
      Array: function _arrayTrace(x) {
        // use dense matrix implementation
        return _denseTrace(matrix(x));
      },
      SparseMatrix: _sparseTrace,
      DenseMatrix: _denseTrace,
      any: clone
    });

    function _denseTrace(m) {
      // matrix size & data
      var size = m._size;
      var data = m._data; // process dimensions

      switch (size.length) {
        case 1:
          // vector
          if (size[0] === 1) {
            // return data[0]
            return clone(data[0]);
          }

          throw new RangeError('Matrix must be square (size: ' + format$2(size) + ')');

        case 2:
          {
            // two dimensional
            var rows = size[0];
            var cols = size[1];

            if (rows === cols) {
              // calulate sum
              var sum = 0; // loop diagonal

              for (var i = 0; i < rows; i++) {
                sum = add(sum, data[i][i]);
              } // return trace


              return sum;
            } else {
              throw new RangeError('Matrix must be square (size: ' + format$2(size) + ')');
            }
          }

        default:
          // multi dimensional
          throw new RangeError('Matrix must be two dimensional (size: ' + format$2(size) + ')');
      }
    }

    function _sparseTrace(m) {
      // matrix arrays
      var values$$1 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      var size = m._size; // check dimensions

      var rows = size[0];
      var columns = size[1]; // matrix must be square

      if (rows === columns) {
        // calulate sum
        var sum = 0; // check we have data (avoid looping columns)

        if (values$$1.length > 0) {
          // loop columns
          for (var j = 0; j < columns; j++) {
            // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
            var k0 = ptr[j];
            var k1 = ptr[j + 1]; // loop k within [k0, k1[

            for (var k = k0; k < k1; k++) {
              // row index
              var i = index[k]; // check row

              if (i === j) {
                // accumulate value
                sum = add(sum, values$$1[k]); // exit loop

                break;
              }

              if (i > j) {
                // exit loop, no value on the diagonal for column j
                break;
              }
            }
          }
        } // return trace


        return sum;
      }

      throw new RangeError('Matrix must be square (size: ' + format$2(size) + ')');
    }
  });

  var name$2W = 'index';
  var dependencies$2X = ['typed', 'Index'];
  var createIndex = /* #__PURE__ */factory(name$2W, dependencies$2X, function (_ref) {
    var typed = _ref.typed,
        Index = _ref.Index;

    /**
     * Create an index. An Index can store ranges having start, step, and end
     * for multiple dimensions.
     * Matrix.get, Matrix.set, and math.subset accept an Index as input.
     *
     * Syntax:
     *
     *     math.index(range1, range2, ...)
     *
     * Where each range can be any of:
     *
     * - A number
     * - A string for getting/setting an object property
     * - An instance of `Range`
     * - A one-dimensional Array or a Matrix with numbers
     *
     * Indexes must be zero-based, integer numbers.
     *
     * Examples:
     *
     *    const b = [1, 2, 3, 4, 5]
     *    math.subset(b, math.index([1, 2, 3]))     // returns [2, 3, 4]
     *
     *    const a = math.matrix([[1, 2], [3, 4]])
     *    a.subset(math.index(0, 1))             // returns 2
     *
     * See also:
     *
     *    bignumber, boolean, complex, matrix, number, string, unit
     *
     * @param {...*} ranges   Zero or more ranges or numbers.
     * @return {Index}        Returns the created index
     */
    return typed(name$2W, {
      '...number | string | BigNumber | Range | Array | Matrix': function numberStringBigNumberRangeArrayMatrix(args) {
        var ranges = args.map(function (arg) {
          if (isBigNumber(arg)) {
            return arg.toNumber(); // convert BigNumber to Number
          } else if (Array.isArray(arg) || isMatrix(arg)) {
            return arg.map(function (elem) {
              // convert BigNumber to Number
              return isBigNumber(elem) ? elem.toNumber() : elem;
            });
          } else {
            return arg;
          }
        });
        var res = new Index();
        Index.apply(res, ranges);
        return res;
      }
    });
  });

  // Reserved keywords not allowed to use in the parser
  var keywords = {
    end: true
  };

  function _typeof$7(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$7 = function _typeof(obj) { return typeof obj; }; } else { _typeof$7 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$7(obj); }
  var name$2X = 'Node';
  var dependencies$2Y = ['mathWithTransform'];
  var createNode = /* #__PURE__ */factory(name$2X, dependencies$2Y, function (_ref) {
    var mathWithTransform = _ref.mathWithTransform;

    /**
     * Node
     */
    function Node() {
      if (!(this instanceof Node)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }
    }
    /**
     * Evaluate the node
     * @param {Object} [scope]  Scope to read/write variables
     * @return {*}              Returns the result
     */


    Node.prototype.evaluate = function (scope) {
      return this.compile().evaluate(scope);
    };

    Node.prototype.type = 'Node';
    Node.prototype.isNode = true;
    Node.prototype.comment = '';
    /**
     * Compile the node into an optimized, evauatable JavaScript function
     * @return {{evaluate: function([Object])}} object
     *                Returns an object with a function 'evaluate',
     *                which can be invoked as expr.evaluate([scope: Object]),
     *                where scope is an optional object with
     *                variables.
     */

    Node.prototype.compile = function () {
      var expr = this._compile(mathWithTransform, {});

      var args = {};
      var context = null;

      function evaluate(scope) {
        var s = scope || {};

        _validateScope(s);

        return expr(s, args, context);
      }

      return {
        evaluate: evaluate
      };
    };
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */


    Node.prototype._compile = function (math, argNames) {
      throw new Error('Method _compile should be implemented by type ' + this.type);
    };
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */


    Node.prototype.forEach = function (callback) {
      // must be implemented by each of the Node implementations
      throw new Error('Cannot run forEach on a Node interface');
    };
    /**
     * Create a new Node having it's childs be the results of calling
     * the provided callback function for each of the childs of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {OperatorNode} Returns a transformed copy of the node
     */


    Node.prototype.map = function (callback) {
      // must be implemented by each of the Node implementations
      throw new Error('Cannot run map on a Node interface');
    };
    /**
     * Validate whether an object is a Node, for use with map
     * @param {Node} node
     * @returns {Node} Returns the input if it's a node, else throws an Error
     * @protected
     */


    Node.prototype._ifNode = function (node) {
      if (!isNode(node)) {
        throw new TypeError('Callback function must return a Node');
      }

      return node;
    };
    /**
     * Recursively traverse all nodes in a node tree. Executes given callback for
     * this node and each of its child nodes.
     * @param {function(node: Node, path: string, parent: Node)} callback
     *          A callback called for every node in the node tree.
     */


    Node.prototype.traverse = function (callback) {
      // execute callback for itself
      callback(this, null, null); // eslint-disable-line standard/no-callback-literal
      // recursively traverse over all childs of a node

      function _traverse(node, callback) {
        node.forEach(function (child, path, parent) {
          callback(child, path, parent);

          _traverse(child, callback);
        });
      }

      _traverse(this, callback);
    };
    /**
     * Recursively transform a node tree via a transform function.
     *
     * For example, to replace all nodes of type SymbolNode having name 'x' with a
     * ConstantNode with value 2:
     *
     *     const res = Node.transform(function (node, path, parent) {
     *       if (node && node.isSymbolNode) && (node.name === 'x')) {
     *         return new ConstantNode(2)
     *       }
     *       else {
     *         return node
     *       }
     *     })
     *
     * @param {function(node: Node, path: string, parent: Node) : Node} callback
     *          A mapping function accepting a node, and returning
     *          a replacement for the node or the original node.
     *          Signature: callback(node: Node, index: string, parent: Node) : Node
     * @return {Node} Returns the original node or its replacement
     */


    Node.prototype.transform = function (callback) {
      function _transform(child, path, parent) {
        var replacement = callback(child, path, parent);

        if (replacement !== child) {
          // stop iterating when the node is replaced
          return replacement;
        }

        return child.map(_transform);
      }

      return _transform(this, null, null);
    };
    /**
     * Find any node in the node tree matching given filter function. For example, to
     * find all nodes of type SymbolNode having name 'x':
     *
     *     const results = Node.filter(function (node) {
     *       return (node && node.isSymbolNode) && (node.name === 'x')
     *     })
     *
     * @param {function(node: Node, path: string, parent: Node) : Node} callback
     *            A test function returning true when a node matches, and false
     *            otherwise. Function signature:
     *            callback(node: Node, index: string, parent: Node) : boolean
     * @return {Node[]} nodes       An array with nodes matching given filter criteria
     */


    Node.prototype.filter = function (callback) {
      var nodes = [];
      this.traverse(function (node, path, parent) {
        if (callback(node, path, parent)) {
          nodes.push(node);
        }
      });
      return nodes;
    };
    /**
     * Create a shallow clone of this node
     * @return {Node}
     */


    Node.prototype.clone = function () {
      // must be implemented by each of the Node implementations
      throw new Error('Cannot clone a Node interface');
    };
    /**
     * Create a deep clone of this node
     * @return {Node}
     */


    Node.prototype.cloneDeep = function () {
      return this.map(function (node) {
        return node.cloneDeep();
      });
    };
    /**
     * Deep compare this node with another node.
     * @param {Node} other
     * @return {boolean} Returns true when both nodes are of the same type and
     *                   contain the same values (as do their childs)
     */


    Node.prototype.equals = function (other) {
      return other ? deepStrictEqual(this, other) : false;
    };
    /**
     * Get string representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)"or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */


    Node.prototype.toString = function (options) {
      var customString;

      if (options && _typeof$7(options) === 'object') {
        switch (_typeof$7(options.handler)) {
          case 'object':
          case 'undefined':
            break;

          case 'function':
            customString = options.handler(this, options);
            break;

          default:
            throw new TypeError('Object or function expected as callback');
        }
      }

      if (typeof customString !== 'undefined') {
        return customString;
      }

      return this._toString(options);
    };
    /**
     * Get a JSON representation of the node
     * Both .toJSON() and the static .fromJSON(json) should be implemented by all
     * implementations of Node
     * @returns {Object}
     */


    Node.prototype.toJSON = function () {
      throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);
    };
    /**
     * Get HTML representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)" or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */


    Node.prototype.toHTML = function (options) {
      var customString;

      if (options && _typeof$7(options) === 'object') {
        switch (_typeof$7(options.handler)) {
          case 'object':
          case 'undefined':
            break;

          case 'function':
            customString = options.handler(this, options);
            break;

          default:
            throw new TypeError('Object or function expected as callback');
        }
      }

      if (typeof customString !== 'undefined') {
        return customString;
      }

      return this.toHTML(options);
    };
    /**
     * Internal function to generate the string output.
     * This has to be implemented by every Node
     *
     * @throws {Error}
     */


    Node.prototype._toString = function () {
      // must be implemented by each of the Node implementations
      throw new Error('_toString not implemented for ' + this.type);
    };
    /**
     * Get LaTeX representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)"or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */


    Node.prototype.toTex = function (options) {
      var customTex;

      if (options && _typeof$7(options) === 'object') {
        switch (_typeof$7(options.handler)) {
          case 'object':
          case 'undefined':
            break;

          case 'function':
            customTex = options.handler(this, options);
            break;

          default:
            throw new TypeError('Object or function expected as callback');
        }
      }

      if (typeof customTex !== 'undefined') {
        return customTex;
      }

      return this._toTex(options);
    };
    /**
     * Internal function to generate the LaTeX output.
     * This has to be implemented by every Node
     *
     * @param {Object} [options]
     * @throws {Error}
     */


    Node.prototype._toTex = function (options) {
      // must be implemented by each of the Node implementations
      throw new Error('_toTex not implemented for ' + this.type);
    };
    /**
     * Get identifier.
     * @return {string}
     */


    Node.prototype.getIdentifier = function () {
      return this.type;
    };
    /**
     * Get the content of the current Node.
     * @return {Node} node
     **/


    Node.prototype.getContent = function () {
      return this;
    };
    /**
     * Validate the symbol names of a scope.
     * Throws an error when the scope contains an illegal symbol.
     * @param {Object} scope
     */


    function _validateScope(scope) {
      for (var symbol in scope) {
        if (hasOwnProperty(scope, symbol)) {
          if (symbol in keywords) {
            throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
          }
        }
      }
    }

    return Node;
  }, {
    isClass: true,
    isNode: true
  });

  /**
   * Transform zero-based indices to one-based indices in errors
   * @param {Error} err
   * @returns {Error | IndexError} Returns the transformed error
   */

  function errorTransform(err) {
    if (err && err.isIndexError) {
      return new IndexError(err.index + 1, err.min + 1, err.max !== undefined ? err.max + 1 : undefined);
    }

    return err;
  }

  function _typeof$8(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$8 = function _typeof(obj) { return typeof obj; }; } else { _typeof$8 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$8(obj); }
  function accessFactory(_ref) {
    var subset = _ref.subset;

    /**
     * Retrieve part of an object:
     *
     * - Retrieve a property from an object
     * - Retrieve a part of a string
     * - Retrieve a matrix subset
     *
     * @param {Object | Array | Matrix | string} object
     * @param {Index} index
     * @return {Object | Array | Matrix | string} Returns the subset
     */
    return function access(object, index) {
      try {
        if (Array.isArray(object)) {
          return subset(object, index);
        } else if (object && typeof object.subset === 'function') {
          // Matrix
          return object.subset(index);
        } else if (typeof object === 'string') {
          // TODO: move getStringSubset into a separate util file, use that
          return subset(object, index);
        } else if (_typeof$8(object) === 'object') {
          if (!index.isObjectProperty()) {
            throw new TypeError('Cannot apply a numeric index as object property');
          }

          return getSafeProperty(object, index.getObjectProperty());
        } else {
          throw new TypeError('Cannot apply index: unsupported type of object');
        }
      } catch (err) {
        throw errorTransform(err);
      }
    };
  }

  var name$2Y = 'AccessorNode';
  var dependencies$2Z = ['subset', 'Node'];
  var createAccessorNode = /* #__PURE__ */factory(name$2Y, dependencies$2Z, function (_ref) {
    var subset = _ref.subset,
        Node = _ref.Node;
    var access = accessFactory({
      subset: subset
    });
    /**
     * @constructor AccessorNode
     * @extends {Node}
     * Access an object property or get a matrix subset
     *
     * @param {Node} object                 The object from which to retrieve
     *                                      a property or subset.
     * @param {IndexNode} index             IndexNode containing ranges
     */

    function AccessorNode(object, index) {
      if (!(this instanceof AccessorNode)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      if (!isNode(object)) {
        throw new TypeError('Node expected for parameter "object"');
      }

      if (!isIndexNode(index)) {
        throw new TypeError('IndexNode expected for parameter "index"');
      }

      this.object = object || null;
      this.index = index; // readonly property name

      Object.defineProperty(this, 'name', {
        get: function () {
          if (this.index) {
            return this.index.isObjectProperty() ? this.index.getObjectProperty() : '';
          } else {
            return this.object.name || '';
          }
        }.bind(this),
        set: function set() {
          throw new Error('Cannot assign a new name, name is read-only');
        }
      });
    }

    AccessorNode.prototype = new Node();
    AccessorNode.prototype.type = 'AccessorNode';
    AccessorNode.prototype.isAccessorNode = true;
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */

    AccessorNode.prototype._compile = function (math, argNames) {
      var evalObject = this.object._compile(math, argNames);

      var evalIndex = this.index._compile(math, argNames);

      if (this.index.isObjectProperty()) {
        var prop = this.index.getObjectProperty();
        return function evalAccessorNode(scope, args, context) {
          return getSafeProperty(evalObject(scope, args, context), prop);
        };
      } else {
        return function evalAccessorNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var index = evalIndex(scope, args, object); // we pass object here instead of context

          return access(object, index);
        };
      }
    };
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */


    AccessorNode.prototype.forEach = function (callback) {
      callback(this.object, 'object', this);
      callback(this.index, 'index', this);
    };
    /**
     * Create a new AccessorNode having it's childs be the results of calling
     * the provided callback function for each of the childs of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {AccessorNode} Returns a transformed copy of the node
     */


    AccessorNode.prototype.map = function (callback) {
      return new AccessorNode(this._ifNode(callback(this.object, 'object', this)), this._ifNode(callback(this.index, 'index', this)));
    };
    /**
     * Create a clone of this node, a shallow copy
     * @return {AccessorNode}
     */


    AccessorNode.prototype.clone = function () {
      return new AccessorNode(this.object, this.index);
    };
    /**
     * Get string representation
     * @param {Object} options
     * @return {string}
     */


    AccessorNode.prototype._toString = function (options) {
      var object = this.object.toString(options);

      if (needParenthesis(this.object)) {
        object = '(' + object + ')';
      }

      return object + this.index.toString(options);
    };
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string}
     */


    AccessorNode.prototype.toHTML = function (options) {
      var object = this.object.toHTML(options);

      if (needParenthesis(this.object)) {
        object = '<span class="math-parenthesis math-round-parenthesis">(</span>' + object + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }

      return object + this.index.toHTML(options);
    };
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string}
     */


    AccessorNode.prototype._toTex = function (options) {
      var object = this.object.toTex(options);

      if (needParenthesis(this.object)) {
        object = '\\left(\' + object + \'\\right)';
      }

      return object + this.index.toTex(options);
    };
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */


    AccessorNode.prototype.toJSON = function () {
      return {
        mathjs: 'AccessorNode',
        object: this.object,
        index: this.index
      };
    };
    /**
     * Instantiate an AccessorNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "AccessorNode", object: ..., index: ...}`,
     *                       where mathjs is optional
     * @returns {AccessorNode}
     */


    AccessorNode.fromJSON = function (json) {
      return new AccessorNode(json.object, json.index);
    };
    /**
     * Are parenthesis needed?
     * @private
     */


    function needParenthesis(node) {
      // TODO: maybe make a method on the nodes which tells whether they need parenthesis?
      return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));
    }

    return AccessorNode;
  }, {
    isClass: true,
    isNode: true
  });

  var name$2Z = 'ArrayNode';
  var dependencies$2_ = ['Node'];
  var createArrayNode = /* #__PURE__ */factory(name$2Z, dependencies$2_, function (_ref) {
    var Node = _ref.Node;

    /**
     * @constructor ArrayNode
     * @extends {Node}
     * Holds an 1-dimensional array with items
     * @param {Node[]} [items]   1 dimensional array with items
     */
    function ArrayNode(items) {
      if (!(this instanceof ArrayNode)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      this.items = items || []; // validate input

      if (!Array.isArray(this.items) || !this.items.every(isNode)) {
        throw new TypeError('Array containing Nodes expected');
      }
    }

    ArrayNode.prototype = new Node();
    ArrayNode.prototype.type = 'ArrayNode';
    ArrayNode.prototype.isArrayNode = true;
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */

    ArrayNode.prototype._compile = function (math, argNames) {
      var evalItems = map(this.items, function (item) {
        return item._compile(math, argNames);
      });
      var asMatrix = math.config.matrix !== 'Array';

      if (asMatrix) {
        var matrix = math.matrix;
        return function evalArrayNode(scope, args, context) {
          return matrix(map(evalItems, function (evalItem) {
            return evalItem(scope, args, context);
          }));
        };
      } else {
        return function evalArrayNode(scope, args, context) {
          return map(evalItems, function (evalItem) {
            return evalItem(scope, args, context);
          });
        };
      }
    };
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */


    ArrayNode.prototype.forEach = function (callback) {
      for (var i = 0; i < this.items.length; i++) {
        var node = this.items[i];
        callback(node, 'items[' + i + ']', this);
      }
    };
    /**
     * Create a new ArrayNode having it's childs be the results of calling
     * the provided callback function for each of the childs of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ArrayNode} Returns a transformed copy of the node
     */


    ArrayNode.prototype.map = function (callback) {
      var items = [];

      for (var i = 0; i < this.items.length; i++) {
        items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));
      }

      return new ArrayNode(items);
    };
    /**
     * Create a clone of this node, a shallow copy
     * @return {ArrayNode}
     */


    ArrayNode.prototype.clone = function () {
      return new ArrayNode(this.items.slice(0));
    };
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */


    ArrayNode.prototype._toString = function (options) {
      var items = this.items.map(function (node) {
        return node.toString(options);
      });
      return '[' + items.join(', ') + ']';
    };
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */


    ArrayNode.prototype.toJSON = function () {
      return {
        mathjs: 'ArrayNode',
        items: this.items
      };
    };
    /**
     * Instantiate an ArrayNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ArrayNode", items: [...]}`,
     *                       where mathjs is optional
     * @returns {ArrayNode}
     */


    ArrayNode.fromJSON = function (json) {
      return new ArrayNode(json.items);
    };
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */


    ArrayNode.prototype.toHTML = function (options) {
      var items = this.items.map(function (node) {
        return node.toHTML(options);
      });
      return '<span class="math-parenthesis math-square-parenthesis">[</span>' + items.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
    };
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */


    ArrayNode.prototype._toTex = function (options) {
      var s = '\\begin{bmatrix}';
      this.items.forEach(function (node) {
        if (node.items) {
          s += node.items.map(function (childNode) {
            return childNode.toTex(options);
          }).join('&');
        } else {
          s += node.toTex(options);
        } // new line


        s += '\\\\';
      });
      s += '\\end{bmatrix}';
      return s;
    };

    return ArrayNode;
  }, {
    isClass: true,
    isNode: true
  });

  function _typeof$9(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$9 = function _typeof(obj) { return typeof obj; }; } else { _typeof$9 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$9(obj); }
  function assignFactory(_ref) {
    var subset = _ref.subset,
        matrix = _ref.matrix;

    /**
     * Replace part of an object:
     *
     * - Assign a property to an object
     * - Replace a part of a string
     * - Replace a matrix subset
     *
     * @param {Object | Array | Matrix | string} object
     * @param {Index} index
     * @param {*} value
     * @return {Object | Array | Matrix | string} Returns the original object
     *                                            except in case of a string
     */
    // TODO: change assign to return the value instead of the object
    return function assign(object, index, value) {
      try {
        if (Array.isArray(object)) {
          // we use matrix.subset here instead of the function subset because we must not clone the contents
          return matrix(object).subset(index, value).valueOf();
        } else if (object && typeof object.subset === 'function') {
          // Matrix
          return object.subset(index, value);
        } else if (typeof object === 'string') {
          // TODO: move setStringSubset into a separate util file, use that
          return subset(object, index, value);
        } else if (_typeof$9(object) === 'object') {
          if (!index.isObjectProperty()) {
            throw TypeError('Cannot apply a numeric index as object property');
          }

          setSafeProperty(object, index.getObjectProperty(), value);
          return object;
        } else {
          throw new TypeError('Cannot apply index: unsupported type of object');
        }
      } catch (err) {
        throw errorTransform(err);
      }
    };
  }

  // list of identifiers of nodes in order of their precedence
  var properties = [{
    // assignment
    AssignmentNode: {},
    FunctionAssignmentNode: {}
  }, {
    // conditional expression
    ConditionalNode: {
      latexLeftParens: false,
      latexRightParens: false,
      latexParens: false // conditionals don't need parentheses in LaTeX because
      // they are 2 dimensional

    }
  }, {
    // logical or
    'OperatorNode:or': {
      associativity: 'left',
      associativeWith: []
    }
  }, {
    // logical xor
    'OperatorNode:xor': {
      associativity: 'left',
      associativeWith: []
    }
  }, {
    // logical and
    'OperatorNode:and': {
      associativity: 'left',
      associativeWith: []
    }
  }, {
    // bitwise or
    'OperatorNode:bitOr': {
      associativity: 'left',
      associativeWith: []
    }
  }, {
    // bitwise xor
    'OperatorNode:bitXor': {
      associativity: 'left',
      associativeWith: []
    }
  }, {
    // bitwise and
    'OperatorNode:bitAnd': {
      associativity: 'left',
      associativeWith: []
    }
  }, {
    // relational operators
    'OperatorNode:equal': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:unequal': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:smaller': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:larger': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:smallerEq': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:largerEq': {
      associativity: 'left',
      associativeWith: []
    },
    RelationalNode: {
      associativity: 'left',
      associativeWith: []
    }
  }, {
    // bitshift operators
    'OperatorNode:leftShift': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:rightArithShift': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:rightLogShift': {
      associativity: 'left',
      associativeWith: []
    }
  }, {
    // unit conversion
    'OperatorNode:to': {
      associativity: 'left',
      associativeWith: []
    }
  }, {
    // range
    RangeNode: {}
  }, {
    // addition, subtraction
    'OperatorNode:add': {
      associativity: 'left',
      associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']
    },
    'OperatorNode:subtract': {
      associativity: 'left',
      associativeWith: []
    }
  }, {
    // multiply, divide, modulus
    'OperatorNode:multiply': {
      associativity: 'left',
      associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']
    },
    'OperatorNode:divide': {
      associativity: 'left',
      associativeWith: [],
      latexLeftParens: false,
      latexRightParens: false,
      latexParens: false // fractions don't require parentheses because
      // they're 2 dimensional, so parens aren't needed
      // in LaTeX

    },
    'OperatorNode:dotMultiply': {
      associativity: 'left',
      associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'OperatorNode:dotMultiply', 'OperatorNode:doDivide']
    },
    'OperatorNode:dotDivide': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:mod': {
      associativity: 'left',
      associativeWith: []
    }
  }, {
    // unary prefix operators
    'OperatorNode:unaryPlus': {
      associativity: 'right'
    },
    'OperatorNode:unaryMinus': {
      associativity: 'right'
    },
    'OperatorNode:bitNot': {
      associativity: 'right'
    },
    'OperatorNode:not': {
      associativity: 'right'
    }
  }, {
    // exponentiation
    'OperatorNode:pow': {
      associativity: 'right',
      associativeWith: [],
      latexRightParens: false // the exponent doesn't need parentheses in
      // LaTeX because it's 2 dimensional
      // (it's on top)

    },
    'OperatorNode:dotPow': {
      associativity: 'right',
      associativeWith: []
    }
  }, {
    // factorial
    'OperatorNode:factorial': {
      associativity: 'left'
    }
  }, {
    // matrix transpose
    'OperatorNode:transpose': {
      associativity: 'left'
    }
  }];
  /**
   * Get the precedence of a Node.
   * Higher number for higher precedence, starting with 0.
   * Returns null if the precedence is undefined.
   *
   * @param {Node} _node
   * @param {string} parenthesis
   * @return {number | null}
   */

  function getPrecedence(_node, parenthesis) {
    var node = _node;

    if (parenthesis !== 'keep') {
      // ParenthesisNodes are only ignored when not in 'keep' mode
      node = _node.getContent();
    }

    var identifier = node.getIdentifier();

    for (var i = 0; i < properties.length; i++) {
      if (identifier in properties[i]) {
        return i;
      }
    }

    return null;
  }
  /**
   * Get the associativity of an operator (left or right).
   * Returns a string containing 'left' or 'right' or null if
   * the associativity is not defined.
   *
   * @param {Node}
   * @param {string} parenthesis
   * @return {string|null}
   * @throws {Error}
   */

  function getAssociativity(_node, parenthesis) {
    var node = _node;

    if (parenthesis !== 'keep') {
      // ParenthesisNodes are only ignored when not in 'keep' mode
      node = _node.getContent();
    }

    var identifier = node.getIdentifier();
    var index = getPrecedence(node, parenthesis);

    if (index === null) {
      // node isn't in the list
      return null;
    }

    var property = properties[index][identifier];

    if (hasOwnProperty(property, 'associativity')) {
      if (property.associativity === 'left') {
        return 'left';
      }

      if (property.associativity === 'right') {
        return 'right';
      } // associativity is invalid


      throw Error('\'' + identifier + '\' has the invalid associativity \'' + property.associativity + '\'.');
    } // associativity is undefined


    return null;
  }
  /**
   * Check if an operator is associative with another operator.
   * Returns either true or false or null if not defined.
   *
   * @param {Node} nodeA
   * @param {Node} nodeB
   * @param {string} parenthesis
   * @return {boolean | null}
   */

  function isAssociativeWith(nodeA, nodeB, parenthesis) {
    // ParenthesisNodes are only ignored when not in 'keep' mode
    var a = parenthesis !== 'keep' ? nodeA.getContent() : nodeA;
    var b = parenthesis !== 'keep' ? nodeA.getContent() : nodeB;
    var identifierA = a.getIdentifier();
    var identifierB = b.getIdentifier();
    var index = getPrecedence(a, parenthesis);

    if (index === null) {
      // node isn't in the list
      return null;
    }

    var property = properties[index][identifierA];

    if (hasOwnProperty(property, 'associativeWith') && property.associativeWith instanceof Array) {
      for (var i = 0; i < property.associativeWith.length; i++) {
        if (property.associativeWith[i] === identifierB) {
          return true;
        }
      }

      return false;
    } // associativeWith is not defined


    return null;
  }

  var name$2_ = 'AssignmentNode';
  var dependencies$30 = ['subset', '?matrix', // FIXME: should not be needed at all, should be handled by subset
  'Node'];
  var createAssignmentNode = /* #__PURE__ */factory(name$2_, dependencies$30, function (_ref) {
    var subset = _ref.subset,
        matrix = _ref.matrix,
        Node = _ref.Node;
    var access = accessFactory({
      subset: subset
    });
    var assign = assignFactory({
      subset: subset,
      matrix: matrix
    });
    /**
     * @constructor AssignmentNode
     * @extends {Node}
     *
     * Define a symbol, like `a=3.2`, update a property like `a.b=3.2`, or
     * replace a subset of a matrix like `A[2,2]=42`.
     *
     * Syntax:
     *
     *     new AssignmentNode(symbol, value)
     *     new AssignmentNode(object, index, value)
     *
     * Usage:
     *
     *    new AssignmentNode(new SymbolNode('a'), new ConstantNode(2))                       // a=2
     *    new AssignmentNode(new SymbolNode('a'), new IndexNode('b'), new ConstantNode(2))   // a.b=2
     *    new AssignmentNode(new SymbolNode('a'), new IndexNode(1, 2), new ConstantNode(3))  // a[1,2]=3
     *
     * @param {SymbolNode | AccessorNode} object  Object on which to assign a value
     * @param {IndexNode} [index=null]            Index, property name or matrix
     *                                            index. Optional. If not provided
     *                                            and `object` is a SymbolNode,
     *                                            the property is assigned to the
     *                                            global scope.
     * @param {Node} value                        The value to be assigned
     */

    function AssignmentNode(object, index, value) {
      if (!(this instanceof AssignmentNode)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      this.object = object;
      this.index = value ? index : null;
      this.value = value || index; // validate input

      if (!isSymbolNode(object) && !isAccessorNode(object)) {
        throw new TypeError('SymbolNode or AccessorNode expected as "object"');
      }

      if (isSymbolNode(object) && object.name === 'end') {
        throw new Error('Cannot assign to symbol "end"');
      }

      if (this.index && !isIndexNode(this.index)) {
        // index is optional
        throw new TypeError('IndexNode expected as "index"');
      }

      if (!isNode(this.value)) {
        throw new TypeError('Node expected as "value"');
      } // readonly property name


      Object.defineProperty(this, 'name', {
        get: function () {
          if (this.index) {
            return this.index.isObjectProperty() ? this.index.getObjectProperty() : '';
          } else {
            return this.object.name || '';
          }
        }.bind(this),
        set: function set() {
          throw new Error('Cannot assign a new name, name is read-only');
        }
      });
    }

    AssignmentNode.prototype = new Node();
    AssignmentNode.prototype.type = 'AssignmentNode';
    AssignmentNode.prototype.isAssignmentNode = true;
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */

    AssignmentNode.prototype._compile = function (math, argNames) {
      var evalObject = this.object._compile(math, argNames);

      var evalIndex = this.index ? this.index._compile(math, argNames) : null;

      var evalValue = this.value._compile(math, argNames);

      var name = this.object.name;

      if (!this.index) {
        // apply a variable to the scope, for example `a=2`
        if (!isSymbolNode(this.object)) {
          throw new TypeError('SymbolNode expected as object');
        }

        return function evalAssignmentNode(scope, args, context) {
          return setSafeProperty(scope, name, evalValue(scope, args, context));
        };
      } else if (this.index.isObjectProperty()) {
        // apply an object property for example `a.b=2`
        var prop = this.index.getObjectProperty();
        return function evalAssignmentNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var value = evalValue(scope, args, context);
          return setSafeProperty(object, prop, value);
        };
      } else if (isSymbolNode(this.object)) {
        // update a matrix subset, for example `a[2]=3`
        return function evalAssignmentNode(scope, args, context) {
          var childObject = evalObject(scope, args, context);
          var value = evalValue(scope, args, context);
          var index = evalIndex(scope, args, childObject); // Important:  we pass childObject instead of context

          setSafeProperty(scope, name, assign(childObject, index, value));
          return value;
        };
      } else {
        // isAccessorNode(node.object) === true
        // update a matrix subset, for example `a.b[2]=3`
        // we will not use the compile function of the AccessorNode, but compile it
        // ourselves here as we need the parent object of the AccessorNode:
        // wee need to apply the updated object to parent object
        var evalParentObject = this.object.object._compile(math, argNames);

        if (this.object.index.isObjectProperty()) {
          var parentProp = this.object.index.getObjectProperty();
          return function evalAssignmentNode(scope, args, context) {
            var parent = evalParentObject(scope, args, context);
            var childObject = getSafeProperty(parent, parentProp);
            var index = evalIndex(scope, args, childObject); // Important: we pass childObject instead of context

            var value = evalValue(scope, args, context);
            setSafeProperty(parent, parentProp, assign(childObject, index, value));
            return value;
          };
        } else {
          // if some parameters use the 'end' parameter, we need to calculate the size
          var evalParentIndex = this.object.index._compile(math, argNames);

          return function evalAssignmentNode(scope, args, context) {
            var parent = evalParentObject(scope, args, context);
            var parentIndex = evalParentIndex(scope, args, parent); // Important: we pass parent instead of context

            var childObject = access(parent, parentIndex);
            var index = evalIndex(scope, args, childObject); // Important:  we pass childObject instead of context

            var value = evalValue(scope, args, context);
            assign(parent, parentIndex, assign(childObject, index, value));
            return value;
          };
        }
      }
    };
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */


    AssignmentNode.prototype.forEach = function (callback) {
      callback(this.object, 'object', this);

      if (this.index) {
        callback(this.index, 'index', this);
      }

      callback(this.value, 'value', this);
    };
    /**
     * Create a new AssignmentNode having it's childs be the results of calling
     * the provided callback function for each of the childs of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {AssignmentNode} Returns a transformed copy of the node
     */


    AssignmentNode.prototype.map = function (callback) {
      var object = this._ifNode(callback(this.object, 'object', this));

      var index = this.index ? this._ifNode(callback(this.index, 'index', this)) : null;

      var value = this._ifNode(callback(this.value, 'value', this));

      return new AssignmentNode(object, index, value);
    };
    /**
     * Create a clone of this node, a shallow copy
     * @return {AssignmentNode}
     */


    AssignmentNode.prototype.clone = function () {
      return new AssignmentNode(this.object, this.index, this.value);
    };
    /*
     * Is parenthesis needed?
     * @param {node} node
     * @param {string} [parenthesis='keep']
     * @private
     */


    function needParenthesis(node, parenthesis) {
      if (!parenthesis) {
        parenthesis = 'keep';
      }

      var precedence = getPrecedence(node, parenthesis);
      var exprPrecedence = getPrecedence(node.value, parenthesis);
      return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string}
     */


    AssignmentNode.prototype._toString = function (options) {
      var object = this.object.toString(options);
      var index = this.index ? this.index.toString(options) : '';
      var value = this.value.toString(options);

      if (needParenthesis(this, options && options.parenthesis)) {
        value = '(' + value + ')';
      }

      return object + index + ' = ' + value;
    };
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */


    AssignmentNode.prototype.toJSON = function () {
      return {
        mathjs: 'AssignmentNode',
        object: this.object,
        index: this.index,
        value: this.value
      };
    };
    /**
     * Instantiate an AssignmentNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "AssignmentNode", object: ..., index: ..., value: ...}`,
     *                       where mathjs is optional
     * @returns {AssignmentNode}
     */


    AssignmentNode.fromJSON = function (json) {
      return new AssignmentNode(json.object, json.index, json.value);
    };
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string}
     */


    AssignmentNode.prototype.toHTML = function (options) {
      var object = this.object.toHTML(options);
      var index = this.index ? this.index.toHTML(options) : '';
      var value = this.value.toHTML(options);

      if (needParenthesis(this, options && options.parenthesis)) {
        value = '<span class="math-paranthesis math-round-parenthesis">(</span>' + value + '<span class="math-paranthesis math-round-parenthesis">)</span>';
      }

      return object + index + '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + value;
    };
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string}
     */


    AssignmentNode.prototype._toTex = function (options) {
      var object = this.object.toTex(options);
      var index = this.index ? this.index.toTex(options) : '';
      var value = this.value.toTex(options);

      if (needParenthesis(this, options && options.parenthesis)) {
        value = "\\left(".concat(value, "\\right)");
      }

      return object + index + ':=' + value;
    };

    return AssignmentNode;
  }, {
    isClass: true,
    isNode: true
  });

  var name$30 = 'BlockNode';
  var dependencies$31 = ['ResultSet', 'Node'];
  var createBlockNode = /* #__PURE__ */factory(name$30, dependencies$31, function (_ref) {
    var ResultSet = _ref.ResultSet,
        Node = _ref.Node;

    /**
     * @constructor BlockNode
     * @extends {Node}
     * Holds a set with blocks
     * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks
     *            An array with blocks, where a block is constructed as an Object
     *            with properties block, which is a Node, and visible, which is
     *            a boolean. The property visible is optional and is true by default
     */
    function BlockNode(blocks) {
      if (!(this instanceof BlockNode)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      } // validate input, copy blocks


      if (!Array.isArray(blocks)) throw new Error('Array expected');
      this.blocks = blocks.map(function (block) {
        var node = block && block.node;
        var visible = block && block.visible !== undefined ? block.visible : true;
        if (!isNode(node)) throw new TypeError('Property "node" must be a Node');
        if (typeof visible !== 'boolean') throw new TypeError('Property "visible" must be a boolean');
        return {
          node: node,
          visible: visible
        };
      });
    }

    BlockNode.prototype = new Node();
    BlockNode.prototype.type = 'BlockNode';
    BlockNode.prototype.isBlockNode = true;
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */

    BlockNode.prototype._compile = function (math, argNames) {
      var evalBlocks = map(this.blocks, function (block) {
        return {
          evaluate: block.node._compile(math, argNames),
          visible: block.visible
        };
      });
      return function evalBlockNodes(scope, args, context) {
        var results = [];
        forEach(evalBlocks, function evalBlockNode(block) {
          var result = block.evaluate(scope, args, context);

          if (block.visible) {
            results.push(result);
          }
        });
        return new ResultSet(results);
      };
    };
    /**
     * Execute a callback for each of the child blocks of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */


    BlockNode.prototype.forEach = function (callback) {
      for (var i = 0; i < this.blocks.length; i++) {
        callback(this.blocks[i].node, 'blocks[' + i + '].node', this);
      }
    };
    /**
     * Create a new BlockNode having it's childs be the results of calling
     * the provided callback function for each of the childs of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {BlockNode} Returns a transformed copy of the node
     */


    BlockNode.prototype.map = function (callback) {
      var blocks = [];

      for (var i = 0; i < this.blocks.length; i++) {
        var block = this.blocks[i];

        var node = this._ifNode(callback(block.node, 'blocks[' + i + '].node', this));

        blocks[i] = {
          node: node,
          visible: block.visible
        };
      }

      return new BlockNode(blocks);
    };
    /**
     * Create a clone of this node, a shallow copy
     * @return {BlockNode}
     */


    BlockNode.prototype.clone = function () {
      var blocks = this.blocks.map(function (block) {
        return {
          node: block.node,
          visible: block.visible
        };
      });
      return new BlockNode(blocks);
    };
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */


    BlockNode.prototype._toString = function (options) {
      return this.blocks.map(function (param) {
        return param.node.toString(options) + (param.visible ? '' : ';');
      }).join('\n');
    };
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */


    BlockNode.prototype.toJSON = function () {
      return {
        mathjs: 'BlockNode',
        blocks: this.blocks
      };
    };
    /**
     * Instantiate an BlockNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "BlockNode", blocks: [{node: ..., visible: false}, ...]}`,
     *                       where mathjs is optional
     * @returns {BlockNode}
     */


    BlockNode.fromJSON = function (json) {
      return new BlockNode(json.blocks);
    };
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */


    BlockNode.prototype.toHTML = function (options) {
      return this.blocks.map(function (param) {
        return param.node.toHTML(options) + (param.visible ? '' : '<span class="math-separator">;</span>');
      }).join('<span class="math-separator"><br /></span>');
    };
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */


    BlockNode.prototype._toTex = function (options) {
      return this.blocks.map(function (param) {
        return param.node.toTex(options) + (param.visible ? '' : ';');
      }).join('\\;\\;\n');
    };

    return BlockNode;
  }, {
    isClass: true,
    isNode: true
  });

  var name$31 = 'ConditionalNode';
  var dependencies$32 = ['Node'];
  var createConditionalNode = /* #__PURE__ */factory(name$31, dependencies$32, function (_ref) {
    var Node = _ref.Node;

    /**
     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'
     *
     * @param {Node} condition   Condition, must result in a boolean
     * @param {Node} trueExpr    Expression evaluated when condition is true
     * @param {Node} falseExpr   Expression evaluated when condition is true
     *
     * @constructor ConditionalNode
     * @extends {Node}
     */
    function ConditionalNode(condition, trueExpr, falseExpr) {
      if (!(this instanceof ConditionalNode)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      if (!isNode(condition)) throw new TypeError('Parameter condition must be a Node');
      if (!isNode(trueExpr)) throw new TypeError('Parameter trueExpr must be a Node');
      if (!isNode(falseExpr)) throw new TypeError('Parameter falseExpr must be a Node');
      this.condition = condition;
      this.trueExpr = trueExpr;
      this.falseExpr = falseExpr;
    }

    ConditionalNode.prototype = new Node();
    ConditionalNode.prototype.type = 'ConditionalNode';
    ConditionalNode.prototype.isConditionalNode = true;
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */

    ConditionalNode.prototype._compile = function (math, argNames) {
      var evalCondition = this.condition._compile(math, argNames);

      var evalTrueExpr = this.trueExpr._compile(math, argNames);

      var evalFalseExpr = this.falseExpr._compile(math, argNames);

      return function evalConditionalNode(scope, args, context) {
        return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);
      };
    };
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */


    ConditionalNode.prototype.forEach = function (callback) {
      callback(this.condition, 'condition', this);
      callback(this.trueExpr, 'trueExpr', this);
      callback(this.falseExpr, 'falseExpr', this);
    };
    /**
     * Create a new ConditionalNode having it's childs be the results of calling
     * the provided callback function for each of the childs of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ConditionalNode} Returns a transformed copy of the node
     */


    ConditionalNode.prototype.map = function (callback) {
      return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));
    };
    /**
     * Create a clone of this node, a shallow copy
     * @return {ConditionalNode}
     */


    ConditionalNode.prototype.clone = function () {
      return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);
    };
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */


    ConditionalNode.prototype._toString = function (options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
      var precedence = getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode
      // or have lower or equal precedence
      // NOTE: enclosing all OperatorNodes in parentheses is a decision
      // purely based on aesthetics and readability

      var condition = this.condition.toString(options);
      var conditionPrecedence = getPrecedence(this.condition, parenthesis);

      if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {
        condition = '(' + condition + ')';
      }

      var trueExpr = this.trueExpr.toString(options);
      var truePrecedence = getPrecedence(this.trueExpr, parenthesis);

      if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {
        trueExpr = '(' + trueExpr + ')';
      }

      var falseExpr = this.falseExpr.toString(options);
      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);

      if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {
        falseExpr = '(' + falseExpr + ')';
      }

      return condition + ' ? ' + trueExpr + ' : ' + falseExpr;
    };
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */


    ConditionalNode.prototype.toJSON = function () {
      return {
        mathjs: 'ConditionalNode',
        condition: this.condition,
        trueExpr: this.trueExpr,
        falseExpr: this.falseExpr
      };
    };
    /**
     * Instantiate an ConditionalNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ConditionalNode", "condition": ..., "trueExpr": ..., "falseExpr": ...}`,
     *                       where mathjs is optional
     * @returns {ConditionalNode}
     */


    ConditionalNode.fromJSON = function (json) {
      return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);
    };
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */


    ConditionalNode.prototype.toHTML = function (options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
      var precedence = getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode
      // or have lower or equal precedence
      // NOTE: enclosing all OperatorNodes in parentheses is a decision
      // purely based on aesthetics and readability

      var condition = this.condition.toHTML(options);
      var conditionPrecedence = getPrecedence(this.condition, parenthesis);

      if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {
        condition = '<span class="math-parenthesis math-round-parenthesis">(</span>' + condition + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }

      var trueExpr = this.trueExpr.toHTML(options);
      var truePrecedence = getPrecedence(this.trueExpr, parenthesis);

      if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {
        trueExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + trueExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }

      var falseExpr = this.falseExpr.toHTML(options);
      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);

      if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {
        falseExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + falseExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }

      return condition + '<span class="math-operator math-conditional-operator">?</span>' + trueExpr + '<span class="math-operator math-conditional-operator">:</span>' + falseExpr;
    };
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */


    ConditionalNode.prototype._toTex = function (options) {
      return '\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\quad{\\text{if }\\;' + this.condition.toTex(options) + '}\\\\{' + this.falseExpr.toTex(options) + '}, &\\quad{\\text{otherwise}}\\end{cases}';
    };
    /**
     * Test whether a condition is met
     * @param {*} condition
     * @returns {boolean} true if condition is true or non-zero, else false
     */


    function testCondition(condition) {
      if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {
        return !!condition;
      }

      if (condition) {
        if (isBigNumber(condition)) {
          return !condition.isZero();
        }

        if (isComplex(condition)) {
          return !!(condition.re || condition.im);
        }

        if (isUnit(condition)) {
          return !!condition.value;
        }
      }

      if (condition === null || condition === undefined) {
        return false;
      }

      throw new TypeError('Unsupported type of condition "' + typeOf(condition) + '"');
    }

    return ConditionalNode;
  }, {
    isClass: true,
    isNode: true
  });

  // Map the characters to escape to their escaped values. The list is derived
  // from http://www.cespedes.org/blog/85/how-to-escape-latex-special-characters

  var _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var defaultEscapes = {
    "{": "\\{",
    "}": "\\}",
    "\\": "\\textbackslash{}",
    "#": "\\#",
    $: "\\$",
    "%": "\\%",
    "&": "\\&",
    "^": "\\textasciicircum{}",
    _: "\\_",
    "~": "\\textasciitilde{}"
  };
  var formatEscapes = {
    "\u2013": "\\--",
    "\u2014": "\\---",
    " ": "~",
    "\t": "\\qquad{}",
    "\r\n": "\\newline{}",
    "\n": "\\newline{}"
  };

  var defaultEscapeMapFn = function defaultEscapeMapFn(defaultEscapes, formatEscapes) {
    return _extends$2({}, defaultEscapes, formatEscapes);
  };

  /**
   * Escape a string to be used in LaTeX documents.
   * @param {string} str the string to be escaped.
   * @param {boolean} params.preserveFormatting whether formatting escapes should
   *  be performed (default: false).
   * @param {function} params.escapeMapFn the function to modify the escape maps.
   * @return {string} the escaped string, ready to be used in LaTeX.
   */
  var dist = function (str) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$preserveFormatti = _ref.preserveFormatting,
        preserveFormatting = _ref$preserveFormatti === undefined ? false : _ref$preserveFormatti,
        _ref$escapeMapFn = _ref.escapeMapFn,
        escapeMapFn = _ref$escapeMapFn === undefined ? defaultEscapeMapFn : _ref$escapeMapFn;

    var runningStr = String(str);
    var result = "";

    var escapes = escapeMapFn(_extends$2({}, defaultEscapes), preserveFormatting ? _extends$2({}, formatEscapes) : {});
    var escapeKeys = Object.keys(escapes); // as it is reused later on

    // Algorithm: Go through the string character by character, if it matches
    // with one of the special characters then we'll replace it with the escaped
    // version.

    var _loop = function _loop() {
      var specialCharFound = false;
      escapeKeys.forEach(function (key, index) {
        if (specialCharFound) {
          return;
        }
        if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {
          result += escapes[escapeKeys[index]];
          runningStr = runningStr.slice(key.length, runningStr.length);
          specialCharFound = true;
        }
      });
      if (!specialCharFound) {
        result += runningStr.slice(0, 1);
        runningStr = runningStr.slice(1, runningStr.length);
      }
    };

    while (runningStr) {
      _loop();
    }
    return result;
  };

  /* eslint no-template-curly-in-string: "off" */
  var latexSymbols = {
    // GREEK LETTERS
    Alpha: 'A',
    alpha: '\\alpha',
    Beta: 'B',
    beta: '\\beta',
    Gamma: '\\Gamma',
    gamma: '\\gamma',
    Delta: '\\Delta',
    delta: '\\delta',
    Epsilon: 'E',
    epsilon: '\\epsilon',
    varepsilon: '\\varepsilon',
    Zeta: 'Z',
    zeta: '\\zeta',
    Eta: 'H',
    eta: '\\eta',
    Theta: '\\Theta',
    theta: '\\theta',
    vartheta: '\\vartheta',
    Iota: 'I',
    iota: '\\iota',
    Kappa: 'K',
    kappa: '\\kappa',
    varkappa: '\\varkappa',
    Lambda: '\\Lambda',
    lambda: '\\lambda',
    Mu: 'M',
    mu: '\\mu',
    Nu: 'N',
    nu: '\\nu',
    Xi: '\\Xi',
    xi: '\\xi',
    Omicron: 'O',
    omicron: 'o',
    Pi: '\\Pi',
    pi: '\\pi',
    varpi: '\\varpi',
    Rho: 'P',
    rho: '\\rho',
    varrho: '\\varrho',
    Sigma: '\\Sigma',
    sigma: '\\sigma',
    varsigma: '\\varsigma',
    Tau: 'T',
    tau: '\\tau',
    Upsilon: "\\Upsilon",
    upsilon: "\\upsilon",
    Phi: '\\Phi',
    phi: '\\phi',
    varphi: '\\varphi',
    Chi: 'X',
    chi: '\\chi',
    Psi: '\\Psi',
    psi: '\\psi',
    Omega: '\\Omega',
    omega: '\\omega',
    // logic
    "true": '\\mathrm{True}',
    "false": '\\mathrm{False}',
    // other
    i: 'i',
    // TODO use \i ??
    inf: '\\infty',
    Inf: '\\infty',
    infinity: '\\infty',
    Infinity: '\\infty',
    oo: '\\infty',
    lim: '\\lim',
    undefined: '\\mathbf{?}'
  };
  var latexOperators = {
    transpose: '^\\top',
    ctranspose: '^H',
    factorial: '!',
    pow: '^',
    dotPow: '.^\\wedge',
    // TODO find ideal solution
    unaryPlus: '+',
    unaryMinus: '-',
    bitNot: '\\~',
    // TODO find ideal solution
    not: '\\neg',
    multiply: '\\cdot',
    divide: '\\frac',
    // TODO how to handle that properly?
    dotMultiply: '.\\cdot',
    // TODO find ideal solution
    dotDivide: '.:',
    // TODO find ideal solution
    mod: '\\mod',
    add: '+',
    subtract: '-',
    to: '\\rightarrow',
    leftShift: '<<',
    rightArithShift: '>>',
    rightLogShift: '>>>',
    equal: '=',
    unequal: '\\neq',
    smaller: '<',
    larger: '>',
    smallerEq: '\\leq',
    largerEq: '\\geq',
    bitAnd: '\\&',
    bitXor: "\\underline{|}",
    bitOr: '|',
    and: '\\wedge',
    xor: '\\veebar',
    or: '\\vee'
  };
  var latexFunctions = {
    // arithmetic
    abs: {
      1: '\\left|${args[0]}\\right|'
    },
    add: {
      2: "\\left(${args[0]}".concat(latexOperators.add, "${args[1]}\\right)")
    },
    cbrt: {
      1: '\\sqrt[3]{${args[0]}}'
    },
    ceil: {
      1: '\\left\\lceil${args[0]}\\right\\rceil'
    },
    cube: {
      1: '\\left(${args[0]}\\right)^3'
    },
    divide: {
      2: '\\frac{${args[0]}}{${args[1]}}'
    },
    dotDivide: {
      2: "\\left(${args[0]}".concat(latexOperators.dotDivide, "${args[1]}\\right)")
    },
    dotMultiply: {
      2: "\\left(${args[0]}".concat(latexOperators.dotMultiply, "${args[1]}\\right)")
    },
    dotPow: {
      2: "\\left(${args[0]}".concat(latexOperators.dotPow, "${args[1]}\\right)")
    },
    exp: {
      1: '\\exp\\left(${args[0]}\\right)'
    },
    expm1: "\\left(e".concat(latexOperators.pow, "{${args[0]}}-1\\right)"),
    fix: {
      1: '\\mathrm{${name}}\\left(${args[0]}\\right)'
    },
    floor: {
      1: '\\left\\lfloor${args[0]}\\right\\rfloor'
    },
    gcd: '\\gcd\\left(${args}\\right)',
    hypot: '\\hypot\\left(${args}\\right)',
    log: {
      1: '\\ln\\left(${args[0]}\\right)',
      2: '\\log_{${args[1]}}\\left(${args[0]}\\right)'
    },
    log10: {
      1: '\\log_{10}\\left(${args[0]}\\right)'
    },
    log1p: {
      1: '\\ln\\left(${args[0]}+1\\right)',
      2: '\\log_{${args[1]}}\\left(${args[0]}+1\\right)'
    },
    log2: '\\log_{2}\\left(${args[0]}\\right)',
    mod: {
      2: "\\left(${args[0]}".concat(latexOperators.mod, "${args[1]}\\right)")
    },
    multiply: {
      2: "\\left(${args[0]}".concat(latexOperators.multiply, "${args[1]}\\right)")
    },
    norm: {
      1: '\\left\\|${args[0]}\\right\\|',
      2: undefined // use default template

    },
    nthRoot: {
      2: '\\sqrt[${args[1]}]{${args[0]}}'
    },
    nthRoots: {
      2: '\\{y : $y^{args[1]} = {${args[0]}}\\}'
    },
    pow: {
      2: "\\left(${args[0]}\\right)".concat(latexOperators.pow, "{${args[1]}}")
    },
    round: {
      1: '\\left\\lfloor${args[0]}\\right\\rceil',
      2: undefined // use default template

    },
    sign: {
      1: '\\mathrm{${name}}\\left(${args[0]}\\right)'
    },
    sqrt: {
      1: '\\sqrt{${args[0]}}'
    },
    square: {
      1: '\\left(${args[0]}\\right)^2'
    },
    subtract: {
      2: "\\left(${args[0]}".concat(latexOperators.subtract, "${args[1]}\\right)")
    },
    unaryMinus: {
      1: "".concat(latexOperators.unaryMinus, "\\left(${args[0]}\\right)")
    },
    unaryPlus: {
      1: "".concat(latexOperators.unaryPlus, "\\left(${args[0]}\\right)")
    },
    // bitwise
    bitAnd: {
      2: "\\left(${args[0]}".concat(latexOperators.bitAnd, "${args[1]}\\right)")
    },
    bitNot: {
      1: latexOperators.bitNot + '\\left(${args[0]}\\right)'
    },
    bitOr: {
      2: "\\left(${args[0]}".concat(latexOperators.bitOr, "${args[1]}\\right)")
    },
    bitXor: {
      2: "\\left(${args[0]}".concat(latexOperators.bitXor, "${args[1]}\\right)")
    },
    leftShift: {
      2: "\\left(${args[0]}".concat(latexOperators.leftShift, "${args[1]}\\right)")
    },
    rightArithShift: {
      2: "\\left(${args[0]}".concat(latexOperators.rightArithShift, "${args[1]}\\right)")
    },
    rightLogShift: {
      2: "\\left(${args[0]}".concat(latexOperators.rightLogShift, "${args[1]}\\right)")
    },
    // combinatorics
    bellNumbers: {
      1: '\\mathrm{B}_{${args[0]}}'
    },
    catalan: {
      1: '\\mathrm{C}_{${args[0]}}'
    },
    stirlingS2: {
      2: '\\mathrm{S}\\left(${args}\\right)'
    },
    // complex
    arg: {
      1: '\\arg\\left(${args[0]}\\right)'
    },
    conj: {
      1: '\\left(${args[0]}\\right)^*'
    },
    im: {
      1: '\\Im\\left\\lbrace${args[0]}\\right\\rbrace'
    },
    re: {
      1: '\\Re\\left\\lbrace${args[0]}\\right\\rbrace'
    },
    // logical
    and: {
      2: "\\left(${args[0]}".concat(latexOperators.and, "${args[1]}\\right)")
    },
    not: {
      1: latexOperators.not + '\\left(${args[0]}\\right)'
    },
    or: {
      2: "\\left(${args[0]}".concat(latexOperators.or, "${args[1]}\\right)")
    },
    xor: {
      2: "\\left(${args[0]}".concat(latexOperators.xor, "${args[1]}\\right)")
    },
    // matrix
    cross: {
      2: '\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)'
    },
    ctranspose: {
      1: "\\left(${args[0]}\\right)".concat(latexOperators.ctranspose)
    },
    det: {
      1: '\\det\\left(${args[0]}\\right)'
    },
    dot: {
      2: '\\left(${args[0]}\\cdot${args[1]}\\right)'
    },
    expm: {
      1: '\\exp\\left(${args[0]}\\right)'
    },
    inv: {
      1: '\\left(${args[0]}\\right)^{-1}'
    },
    sqrtm: {
      1: "{${args[0]}}".concat(latexOperators.pow, "{\\frac{1}{2}}")
    },
    trace: {
      1: '\\mathrm{tr}\\left(${args[0]}\\right)'
    },
    transpose: {
      1: "\\left(${args[0]}\\right)".concat(latexOperators.transpose)
    },
    // probability
    combinations: {
      2: '\\binom{${args[0]}}{${args[1]}}'
    },
    combinationsWithRep: {
      2: '\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)'
    },
    factorial: {
      1: "\\left(${args[0]}\\right)".concat(latexOperators.factorial)
    },
    gamma: {
      1: '\\Gamma\\left(${args[0]}\\right)'
    },
    // relational
    equal: {
      2: "\\left(${args[0]}".concat(latexOperators.equal, "${args[1]}\\right)")
    },
    larger: {
      2: "\\left(${args[0]}".concat(latexOperators.larger, "${args[1]}\\right)")
    },
    largerEq: {
      2: "\\left(${args[0]}".concat(latexOperators.largerEq, "${args[1]}\\right)")
    },
    smaller: {
      2: "\\left(${args[0]}".concat(latexOperators.smaller, "${args[1]}\\right)")
    },
    smallerEq: {
      2: "\\left(${args[0]}".concat(latexOperators.smallerEq, "${args[1]}\\right)")
    },
    unequal: {
      2: "\\left(${args[0]}".concat(latexOperators.unequal, "${args[1]}\\right)")
    },
    // special
    erf: {
      1: 'erf\\left(${args[0]}\\right)'
    },
    // statistics
    max: '\\max\\left(${args}\\right)',
    min: '\\min\\left(${args}\\right)',
    variance: '\\mathrm{Var}\\left(${args}\\right)',
    // trigonometry
    acos: {
      1: '\\cos^{-1}\\left(${args[0]}\\right)'
    },
    acosh: {
      1: '\\cosh^{-1}\\left(${args[0]}\\right)'
    },
    acot: {
      1: '\\cot^{-1}\\left(${args[0]}\\right)'
    },
    acoth: {
      1: '\\coth^{-1}\\left(${args[0]}\\right)'
    },
    acsc: {
      1: '\\csc^{-1}\\left(${args[0]}\\right)'
    },
    acsch: {
      1: '\\mathrm{csch}^{-1}\\left(${args[0]}\\right)'
    },
    asec: {
      1: '\\sec^{-1}\\left(${args[0]}\\right)'
    },
    asech: {
      1: '\\mathrm{sech}^{-1}\\left(${args[0]}\\right)'
    },
    asin: {
      1: '\\sin^{-1}\\left(${args[0]}\\right)'
    },
    asinh: {
      1: '\\sinh^{-1}\\left(${args[0]}\\right)'
    },
    atan: {
      1: '\\tan^{-1}\\left(${args[0]}\\right)'
    },
    atan2: {
      2: '\\mathrm{atan2}\\left(${args}\\right)'
    },
    atanh: {
      1: '\\tanh^{-1}\\left(${args[0]}\\right)'
    },
    cos: {
      1: '\\cos\\left(${args[0]}\\right)'
    },
    cosh: {
      1: '\\cosh\\left(${args[0]}\\right)'
    },
    cot: {
      1: '\\cot\\left(${args[0]}\\right)'
    },
    coth: {
      1: '\\coth\\left(${args[0]}\\right)'
    },
    csc: {
      1: '\\csc\\left(${args[0]}\\right)'
    },
    csch: {
      1: '\\mathrm{csch}\\left(${args[0]}\\right)'
    },
    sec: {
      1: '\\sec\\left(${args[0]}\\right)'
    },
    sech: {
      1: '\\mathrm{sech}\\left(${args[0]}\\right)'
    },
    sin: {
      1: '\\sin\\left(${args[0]}\\right)'
    },
    sinh: {
      1: '\\sinh\\left(${args[0]}\\right)'
    },
    tan: {
      1: '\\tan\\left(${args[0]}\\right)'
    },
    tanh: {
      1: '\\tanh\\left(${args[0]}\\right)'
    },
    // unit
    to: {
      2: "\\left(${args[0]}".concat(latexOperators.to, "${args[1]}\\right)")
    },
    // utils
    numeric: function numeric(node, options) {
      // Not sure if this is strictly right but should work correctly for the vast majority of use cases.
      return node.args[0].toTex();
    },
    // type
    number: {
      0: '0',
      1: '\\left(${args[0]}\\right)',
      2: '\\left(\\left(${args[0]}\\right)${args[1]}\\right)'
    },
    string: {
      0: '\\mathtt{""}',
      1: '\\mathrm{string}\\left(${args[0]}\\right)'
    },
    bignumber: {
      0: '0',
      1: '\\left(${args[0]}\\right)'
    },
    complex: {
      0: '0',
      1: '\\left(${args[0]}\\right)',
      2: "\\left(\\left(${args[0]}\\right)+".concat(latexSymbols.i, "\\cdot\\left(${args[1]}\\right)\\right)")
    },
    matrix: {
      0: '\\begin{bmatrix}\\end{bmatrix}',
      1: '\\left(${args[0]}\\right)',
      2: '\\left(${args[0]}\\right)'
    },
    sparse: {
      0: '\\begin{bsparse}\\end{bsparse}',
      1: '\\left(${args[0]}\\right)'
    },
    unit: {
      1: '\\left(${args[0]}\\right)',
      2: '\\left(\\left(${args[0]}\\right)${args[1]}\\right)'
    }
  };
  var defaultTemplate = '\\mathrm{${name}}\\left(${args}\\right)';
  var latexUnits = {
    deg: '^\\circ'
  };
  function escapeLatex(string) {
    return dist(string, {
      preserveFormatting: true
    });
  } // @param {string} name
  // @param {boolean} isUnit

  function toSymbol(name, isUnit) {
    isUnit = typeof isUnit === 'undefined' ? false : isUnit;

    if (isUnit) {
      if (hasOwnProperty(latexUnits, name)) {
        return latexUnits[name];
      }

      return '\\mathrm{' + escapeLatex(name) + '}';
    }

    if (hasOwnProperty(latexSymbols, name)) {
      return latexSymbols[name];
    }

    return escapeLatex(name);
  }

  var name$32 = 'ConstantNode';
  var dependencies$33 = ['Node'];
  var createConstantNode = /* #__PURE__ */factory(name$32, dependencies$33, function (_ref) {
    var Node = _ref.Node;

    /**
     * A ConstantNode holds a constant value like a number or string.
     *
     * Usage:
     *
     *     new ConstantNode(2.3)
     *     new ConstantNode('hello')
     *
     * @param {*} value    Value can be any type (number, BigNumber, string, ...)
     * @constructor ConstantNode
     * @extends {Node}
     */
    function ConstantNode(value) {
      if (!(this instanceof ConstantNode)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      this.value = value;
    }

    ConstantNode.prototype = new Node();
    ConstantNode.prototype.type = 'ConstantNode';
    ConstantNode.prototype.isConstantNode = true;
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */

    ConstantNode.prototype._compile = function (math, argNames) {
      var value = this.value;
      return function evalConstantNode() {
        return value;
      };
    };
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */


    ConstantNode.prototype.forEach = function (callback) {// nothing to do, we don't have childs
    };
    /**
     * Create a new ConstantNode having it's childs be the results of calling
     * the provided callback function for each of the childs of the original node.
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {ConstantNode} Returns a clone of the node
     */


    ConstantNode.prototype.map = function (callback) {
      return this.clone();
    };
    /**
     * Create a clone of this node, a shallow copy
     * @return {ConstantNode}
     */


    ConstantNode.prototype.clone = function () {
      return new ConstantNode(this.value);
    };
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */


    ConstantNode.prototype._toString = function (options) {
      return format$2(this.value, options);
    };
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */


    ConstantNode.prototype.toHTML = function (options) {
      var value = this._toString(options);

      switch (typeOf(this.value)) {
        case 'number':
        case 'BigNumber':
        case 'Fraction':
          return '<span class="math-number">' + value + '</span>';

        case 'string':
          return '<span class="math-string">' + value + '</span>';

        case 'boolean':
          return '<span class="math-boolean">' + value + '</span>';

        case 'null':
          return '<span class="math-null-symbol">' + value + '</span>';

        case 'undefined':
          return '<span class="math-undefined">' + value + '</span>';

        default:
          return '<span class="math-symbol">' + value + '</span>';
      }
    };
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */


    ConstantNode.prototype.toJSON = function () {
      return {
        mathjs: 'ConstantNode',
        value: this.value
      };
    };
    /**
     * Instantiate a ConstantNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "SymbolNode", value: 2.3}`,
     *                       where mathjs is optional
     * @returns {ConstantNode}
     */


    ConstantNode.fromJSON = function (json) {
      return new ConstantNode(json.value);
    };
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */


    ConstantNode.prototype._toTex = function (options) {
      var value = this._toString(options);

      switch (typeOf(this.value)) {
        case 'string':
          return '\\mathtt{' + escapeLatex(value) + '}';

        case 'number':
        case 'BigNumber':
          {
            if (!isFinite(this.value)) {
              return this.value.valueOf() < 0 ? '-\\infty' : '\\infty';
            }

            var index = value.toLowerCase().indexOf('e');

            if (index !== -1) {
              return value.substring(0, index) + '\\cdot10^{' + value.substring(index + 1) + '}';
            }
          }
          return value;

        case 'Fraction':
          return this.value.toLatex();

        default:
          return value;
      }
    };

    return ConstantNode;
  }, {
    isClass: true,
    isNode: true
  });

  var name$33 = 'FunctionAssignmentNode';
  var dependencies$34 = ['typed', 'Node'];
  var createFunctionAssignmentNode = /* #__PURE__ */factory(name$33, dependencies$34, function (_ref) {
    var typed = _ref.typed,
        Node = _ref.Node;

    /**
     * @constructor FunctionAssignmentNode
     * @extends {Node}
     * Function assignment
     *
     * @param {string} name           Function name
     * @param {string[] | Array.<{name: string, type: string}>} params
     *                                Array with function parameter names, or an
     *                                array with objects containing the name
     *                                and type of the parameter
     * @param {Node} expr             The function expression
     */
    function FunctionAssignmentNode(name, params, expr) {
      if (!(this instanceof FunctionAssignmentNode)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      } // validate input


      if (typeof name !== 'string') throw new TypeError('String expected for parameter "name"');
      if (!Array.isArray(params)) throw new TypeError('Array containing strings or objects expected for parameter "params"');
      if (!isNode(expr)) throw new TypeError('Node expected for parameter "expr"');
      if (name in keywords) throw new Error('Illegal function name, "' + name + '" is a reserved keyword');
      this.name = name;
      this.params = params.map(function (param) {
        return param && param.name || param;
      });
      this.types = params.map(function (param) {
        return param && param.type || 'any';
      });
      this.expr = expr;
    }

    FunctionAssignmentNode.prototype = new Node();
    FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';
    FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */

    FunctionAssignmentNode.prototype._compile = function (math, argNames) {
      var childArgNames = Object.create(argNames);
      forEach(this.params, function (param) {
        childArgNames[param] = true;
      }); // compile the function expression with the child args

      var evalExpr = this.expr._compile(math, childArgNames);

      var name = this.name;
      var params = this.params;
      var signature = join(this.types, ',');
      var syntax = name + '(' + join(this.params, ', ') + ')';
      return function evalFunctionAssignmentNode(scope, args, context) {
        var signatures = {};

        signatures[signature] = function () {
          var childArgs = Object.create(args);

          for (var i = 0; i < params.length; i++) {
            childArgs[params[i]] = arguments[i];
          }

          return evalExpr(scope, childArgs, context);
        };

        var fn = typed(name, signatures);
        fn.syntax = syntax;
        setSafeProperty(scope, name, fn);
        return fn;
      };
    };
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */


    FunctionAssignmentNode.prototype.forEach = function (callback) {
      callback(this.expr, 'expr', this);
    };
    /**
     * Create a new FunctionAssignmentNode having it's childs be the results of calling
     * the provided callback function for each of the childs of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {FunctionAssignmentNode} Returns a transformed copy of the node
     */


    FunctionAssignmentNode.prototype.map = function (callback) {
      var expr = this._ifNode(callback(this.expr, 'expr', this));

      return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);
    };
    /**
     * Create a clone of this node, a shallow copy
     * @return {FunctionAssignmentNode}
     */


    FunctionAssignmentNode.prototype.clone = function () {
      return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);
    };
    /**
     * Is parenthesis needed?
     * @param {Node} node
     * @param {Object} parenthesis
     * @private
     */


    function needParenthesis(node, parenthesis) {
      var precedence = getPrecedence(node, parenthesis);
      var exprPrecedence = getPrecedence(node.expr, parenthesis);
      return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;
    }
    /**
     * get string representation
     * @param {Object} options
     * @return {string} str
     */


    FunctionAssignmentNode.prototype._toString = function (options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
      var expr = this.expr.toString(options);

      if (needParenthesis(this, parenthesis)) {
        expr = '(' + expr + ')';
      }

      return this.name + '(' + this.params.join(', ') + ') = ' + expr;
    };
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */


    FunctionAssignmentNode.prototype.toJSON = function () {
      var types = this.types;
      return {
        mathjs: 'FunctionAssignmentNode',
        name: this.name,
        params: this.params.map(function (param, index) {
          return {
            name: param,
            type: types[index]
          };
        }),
        expr: this.expr
      };
    };
    /**
     * Instantiate an FunctionAssignmentNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "FunctionAssignmentNode", name: ..., params: ..., expr: ...}`,
     *                       where mathjs is optional
     * @returns {FunctionAssignmentNode}
     */


    FunctionAssignmentNode.fromJSON = function (json) {
      return new FunctionAssignmentNode(json.name, json.params, json.expr);
    };
    /**
     * get HTML representation
     * @param {Object} options
     * @return {string} str
     */


    FunctionAssignmentNode.prototype.toHTML = function (options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
      var params = [];

      for (var i = 0; i < this.params.length; i++) {
        params.push('<span class="math-symbol math-parameter">' + escape(this.params[i]) + '</span>');
      }

      var expr = this.expr.toHTML(options);

      if (needParenthesis(this, parenthesis)) {
        expr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + expr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }

      return '<span class="math-function">' + escape(this.name) + '</span>' + '<span class="math-parenthesis math-round-parenthesis">(</span>' + params.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + expr;
    };
    /**
     * get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */


    FunctionAssignmentNode.prototype._toTex = function (options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
      var expr = this.expr.toTex(options);

      if (needParenthesis(this, parenthesis)) {
        expr = "\\left(".concat(expr, "\\right)");
      }

      return '\\mathrm{' + this.name + '}\\left(' + this.params.map(toSymbol).join(',') + '\\right):=' + expr;
    };

    return FunctionAssignmentNode;
  }, {
    isClass: true,
    isNode: true
  });

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  var name$34 = 'IndexNode';
  var dependencies$35 = ['Range', 'Node', 'size'];
  var createIndexNode = /* #__PURE__ */factory(name$34, dependencies$35, function (_ref) {
    var Range = _ref.Range,
        Node = _ref.Node,
        size = _ref.size;

    /**
     * @constructor IndexNode
     * @extends Node
     *
     * Describes a subset of a matrix or an object property.
     * Cannot be used on its own, needs to be used within an AccessorNode or
     * AssignmentNode.
     *
     * @param {Node[]} dimensions
     * @param {boolean} [dotNotation=false]  Optional property describing whether
     *                                       this index was written using dot
     *                                       notation like `a.b`, or using bracket
     *                                       notation like `a["b"]` (default).
     *                                       Used to stringify an IndexNode.
     */
    function IndexNode(dimensions, dotNotation) {
      if (!(this instanceof IndexNode)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      this.dimensions = dimensions;
      this.dotNotation = dotNotation || false; // validate input

      if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
      }

      if (this.dotNotation && !this.isObjectProperty()) {
        throw new Error('dotNotation only applicable for object properties');
      }
    }

    IndexNode.prototype = new Node();
    IndexNode.prototype.type = 'IndexNode';
    IndexNode.prototype.isIndexNode = true;
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */

    IndexNode.prototype._compile = function (math, argNames) {
      // TODO: implement support for bignumber (currently bignumbers are silently
      //       reduced to numbers when changing the value to zero-based)
      // TODO: Optimization: when the range values are ConstantNodes,
      //       we can beforehand resolve the zero-based value
      // optimization for a simple object property
      var evalDimensions = map(this.dimensions, function (range, i) {
        if (isRangeNode(range)) {
          if (range.needsEnd()) {
            // create a range containing end (like '4:end')
            var childArgNames = Object.create(argNames);
            childArgNames.end = true;

            var evalStart = range.start._compile(math, childArgNames);

            var evalEnd = range.end._compile(math, childArgNames);

            var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {
              return 1;
            };
            return function evalDimension(scope, args, context) {
              var s = size(context).valueOf();
              var childArgs = Object.create(args);
              childArgs.end = s[i];
              return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));
            };
          } else {
            // create range
            var _evalStart = range.start._compile(math, argNames);

            var _evalEnd = range.end._compile(math, argNames);

            var _evalStep = range.step ? range.step._compile(math, argNames) : function () {
              return 1;
            };

            return function evalDimension(scope, args, context) {
              return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));
            };
          }
        } else if (isSymbolNode(range) && range.name === 'end') {
          // SymbolNode 'end'
          var _childArgNames = Object.create(argNames);

          _childArgNames.end = true;

          var evalRange = range._compile(math, _childArgNames);

          return function evalDimension(scope, args, context) {
            var s = size(context).valueOf();
            var childArgs = Object.create(args);
            childArgs.end = s[i];
            return evalRange(scope, childArgs, context);
          };
        } else {
          // ConstantNode
          var _evalRange = range._compile(math, argNames);

          return function evalDimension(scope, args, context) {
            return _evalRange(scope, args, context);
          };
        }
      });
      var index = getSafeProperty(math, 'index');
      return function evalIndexNode(scope, args, context) {
        var dimensions = map(evalDimensions, function (evalDimension) {
          return evalDimension(scope, args, context);
        });
        return index.apply(void 0, _toConsumableArray(dimensions));
      };
    };
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */


    IndexNode.prototype.forEach = function (callback) {
      for (var i = 0; i < this.dimensions.length; i++) {
        callback(this.dimensions[i], 'dimensions[' + i + ']', this);
      }
    };
    /**
     * Create a new IndexNode having it's childs be the results of calling
     * the provided callback function for each of the childs of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {IndexNode} Returns a transformed copy of the node
     */


    IndexNode.prototype.map = function (callback) {
      var dimensions = [];

      for (var i = 0; i < this.dimensions.length; i++) {
        dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));
      }

      return new IndexNode(dimensions, this.dotNotation);
    };
    /**
     * Create a clone of this node, a shallow copy
     * @return {IndexNode}
     */


    IndexNode.prototype.clone = function () {
      return new IndexNode(this.dimensions.slice(0), this.dotNotation);
    };
    /**
     * Test whether this IndexNode contains a single property name
     * @return {boolean}
     */


    IndexNode.prototype.isObjectProperty = function () {
      return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';
    };
    /**
     * Returns the property name if IndexNode contains a property.
     * If not, returns null.
     * @return {string | null}
     */


    IndexNode.prototype.getObjectProperty = function () {
      return this.isObjectProperty() ? this.dimensions[0].value : null;
    };
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */


    IndexNode.prototype._toString = function (options) {
      // format the parameters like "[1, 0:5]"
      return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';
    };
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */


    IndexNode.prototype.toJSON = function () {
      return {
        mathjs: 'IndexNode',
        dimensions: this.dimensions,
        dotNotation: this.dotNotation
      };
    };
    /**
     * Instantiate an IndexNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "IndexNode", dimensions: [...], dotNotation: false}`,
     *                       where mathjs is optional
     * @returns {IndexNode}
     */


    IndexNode.fromJSON = function (json) {
      return new IndexNode(json.dimensions, json.dotNotation);
    };
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */


    IndexNode.prototype.toHTML = function (options) {
      // format the parameters like "[1, 0:5]"
      var dimensions = [];

      for (var i = 0; i < this.dimensions.length; i++) {
        dimensions[i] = this.dimensions[i].toHTML();
      }

      if (this.dotNotation) {
        return '<span class="math-operator math-accessor-operator">.</span>' + '<span class="math-symbol math-property">' + escape(this.getObjectProperty()) + '</span>';
      } else {
        return '<span class="math-parenthesis math-square-parenthesis">[</span>' + dimensions.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
      }
    };
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */


    IndexNode.prototype._toTex = function (options) {
      var dimensions = this.dimensions.map(function (range) {
        return range.toTex(options);
      });
      return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';
    }; // helper function to create a Range from start, step and end


    function createRange(start, end, step) {
      return new Range(isBigNumber(start) ? start.toNumber() : start, isBigNumber(end) ? end.toNumber() : end, isBigNumber(step) ? step.toNumber() : step);
    }

    return IndexNode;
  }, {
    isClass: true,
    isNode: true
  });

  function _typeof$a(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$a = function _typeof(obj) { return typeof obj; }; } else { _typeof$a = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$a(obj); }
  var name$35 = 'ObjectNode';
  var dependencies$36 = ['Node'];
  var createObjectNode = /* #__PURE__ */factory(name$35, dependencies$36, function (_ref) {
    var Node = _ref.Node;

    /**
     * @constructor ObjectNode
     * @extends {Node}
     * Holds an object with keys/values
     * @param {Object.<string, Node>} [properties]   object with key/value pairs
     */
    function ObjectNode(properties) {
      if (!(this instanceof ObjectNode)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      this.properties = properties || {}; // validate input

      if (properties) {
        if (!(_typeof$a(properties) === 'object') || !Object.keys(properties).every(function (key) {
          return isNode(properties[key]);
        })) {
          throw new TypeError('Object containing Nodes expected');
        }
      }
    }

    ObjectNode.prototype = new Node();
    ObjectNode.prototype.type = 'ObjectNode';
    ObjectNode.prototype.isObjectNode = true;
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */

    ObjectNode.prototype._compile = function (math, argNames) {
      var evalEntries = {};

      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          // we stringify/parse the key here to resolve unicode characters,
          // so you cannot create a key like {"co\\u006Estructor": null}
          var stringifiedKey = stringify(key);
          var parsedKey = JSON.parse(stringifiedKey);

          if (!isSafeProperty(this.properties, parsedKey)) {
            throw new Error('No access to property "' + parsedKey + '"');
          }

          evalEntries[parsedKey] = this.properties[key]._compile(math, argNames);
        }
      }

      return function evalObjectNode(scope, args, context) {
        var obj = {};

        for (var _key in evalEntries) {
          if (hasOwnProperty(evalEntries, _key)) {
            obj[_key] = evalEntries[_key](scope, args, context);
          }
        }

        return obj;
      };
    };
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */


    ObjectNode.prototype.forEach = function (callback) {
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          callback(this.properties[key], 'properties[' + stringify(key) + ']', this);
        }
      }
    };
    /**
     * Create a new ObjectNode having it's childs be the results of calling
     * the provided callback function for each of the childs of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ObjectNode} Returns a transformed copy of the node
     */


    ObjectNode.prototype.map = function (callback) {
      var properties = {};

      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          properties[key] = this._ifNode(callback(this.properties[key], 'properties[' + stringify(key) + ']', this));
        }
      }

      return new ObjectNode(properties);
    };
    /**
     * Create a clone of this node, a shallow copy
     * @return {ObjectNode}
     */


    ObjectNode.prototype.clone = function () {
      var properties = {};

      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          properties[key] = this.properties[key];
        }
      }

      return new ObjectNode(properties);
    };
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */


    ObjectNode.prototype._toString = function (options) {
      var entries = [];

      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          entries.push(stringify(key) + ': ' + this.properties[key].toString(options));
        }
      }

      return '{' + entries.join(', ') + '}';
    };
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */


    ObjectNode.prototype.toJSON = function () {
      return {
        mathjs: 'ObjectNode',
        properties: this.properties
      };
    };
    /**
     * Instantiate an OperatorNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ObjectNode", "properties": {...}}`,
     *                       where mathjs is optional
     * @returns {ObjectNode}
     */


    ObjectNode.fromJSON = function (json) {
      return new ObjectNode(json.properties);
    };
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */


    ObjectNode.prototype.toHTML = function (options) {
      var entries = [];

      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          entries.push('<span class="math-symbol math-property">' + escape(key) + '</span>' + '<span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' + this.properties[key].toHTML(options));
        }
      }

      return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + entries.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
    };
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */


    ObjectNode.prototype._toTex = function (options) {
      var entries = [];

      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          entries.push('\\mathbf{' + key + ':} & ' + this.properties[key].toTex(options) + '\\\\');
        }
      }

      return "\\left\\{\\begin{array}{ll}".concat(entries.join('\n'), "\\end{array}\\right\\}");
    };

    return ObjectNode;
  }, {
    isClass: true,
    isNode: true
  });

  var name$36 = 'OperatorNode';
  var dependencies$37 = ['Node'];
  var createOperatorNode = /* #__PURE__ */factory(name$36, dependencies$37, function (_ref) {
    var Node = _ref.Node;

    /**
     * @constructor OperatorNode
     * @extends {Node}
     * An operator with two arguments, like 2+3
     *
     * @param {string} op           Operator name, for example '+'
     * @param {string} fn           Function name, for example 'add'
     * @param {Node[]} args         Operator arguments
     * @param {boolean} [implicit]  Is this an implicit multiplication?
     */
    function OperatorNode(op, fn, args, implicit) {
      if (!(this instanceof OperatorNode)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      } // validate input


      if (typeof op !== 'string') {
        throw new TypeError('string expected for parameter "op"');
      }

      if (typeof fn !== 'string') {
        throw new TypeError('string expected for parameter "fn"');
      }

      if (!Array.isArray(args) || !args.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      }

      this.implicit = implicit === true;
      this.op = op;
      this.fn = fn;
      this.args = args || [];
    }

    OperatorNode.prototype = new Node();
    OperatorNode.prototype.type = 'OperatorNode';
    OperatorNode.prototype.isOperatorNode = true;
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */

    OperatorNode.prototype._compile = function (math, argNames) {
      // validate fn
      if (typeof this.fn !== 'string' || !isSafeMethod(math, this.fn)) {
        if (!math[this.fn]) {
          throw new Error('Function ' + this.fn + ' missing in provided namespace "math"');
        } else {
          throw new Error('No access to function "' + this.fn + '"');
        }
      }

      var fn = getSafeProperty(math, this.fn);
      var evalArgs = map(this.args, function (arg) {
        return arg._compile(math, argNames);
      });

      if (evalArgs.length === 1) {
        var evalArg0 = evalArgs[0];
        return function evalOperatorNode(scope, args, context) {
          return fn(evalArg0(scope, args, context));
        };
      } else if (evalArgs.length === 2) {
        var _evalArg = evalArgs[0];
        var evalArg1 = evalArgs[1];
        return function evalOperatorNode(scope, args, context) {
          return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));
        };
      } else {
        return function evalOperatorNode(scope, args, context) {
          return fn.apply(null, map(evalArgs, function (evalArg) {
            return evalArg(scope, args, context);
          }));
        };
      }
    };
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */


    OperatorNode.prototype.forEach = function (callback) {
      for (var i = 0; i < this.args.length; i++) {
        callback(this.args[i], 'args[' + i + ']', this);
      }
    };
    /**
     * Create a new OperatorNode having it's childs be the results of calling
     * the provided callback function for each of the childs of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {OperatorNode} Returns a transformed copy of the node
     */


    OperatorNode.prototype.map = function (callback) {
      var args = [];

      for (var i = 0; i < this.args.length; i++) {
        args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));
      }

      return new OperatorNode(this.op, this.fn, args, this.implicit);
    };
    /**
     * Create a clone of this node, a shallow copy
     * @return {OperatorNode}
     */


    OperatorNode.prototype.clone = function () {
      return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit);
    };
    /**
     * Check whether this is an unary OperatorNode:
     * has exactly one argument, like `-a`.
     * @return {boolean} Returns true when an unary operator node, false otherwise.
     */


    OperatorNode.prototype.isUnary = function () {
      return this.args.length === 1;
    };
    /**
     * Check whether this is a binary OperatorNode:
     * has exactly two arguments, like `a + b`.
     * @return {boolean} Returns true when a binary operator node, false otherwise.
     */


    OperatorNode.prototype.isBinary = function () {
      return this.args.length === 2;
    };
    /**
     * Calculate which parentheses are necessary. Gets an OperatorNode
     * (which is the root of the tree) and an Array of Nodes
     * (this.args) and returns an array where 'true' means that an argument
     * has to be enclosed in parentheses whereas 'false' means the opposite.
     *
     * @param {OperatorNode} root
     * @param {string} parenthesis
     * @param {Node[]} args
     * @param {boolean} latex
     * @return {boolean[]}
     * @private
     */


    function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {
      // precedence of the root OperatorNode
      var precedence = getPrecedence(root, parenthesis);
      var associativity = getAssociativity(root, parenthesis);

      if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {
        return args.map(function (arg) {
          switch (arg.getContent().type) {
            // Nodes that don't need extra parentheses
            case 'ArrayNode':
            case 'ConstantNode':
            case 'SymbolNode':
            case 'ParenthesisNode':
              return false;

            default:
              return true;
          }
        });
      }

      var result;

      switch (args.length) {
        case 0:
          result = [];
          break;

        case 1:
          // unary operators
          {
            // precedence of the operand
            var operandPrecedence = getPrecedence(args[0], parenthesis); // handle special cases for LaTeX, where some of the parentheses aren't needed

            if (latex && operandPrecedence !== null) {
              var operandIdentifier;
              var rootIdentifier;

              if (parenthesis === 'keep') {
                operandIdentifier = args[0].getIdentifier();
                rootIdentifier = root.getIdentifier();
              } else {
                // Ignore Parenthesis Nodes when not in 'keep' mode
                operandIdentifier = args[0].getContent().getIdentifier();
                rootIdentifier = root.getContent().getIdentifier();
              }

              if (properties[precedence][rootIdentifier].latexLeftParens === false) {
                result = [false];
                break;
              }

              if (properties[operandPrecedence][operandIdentifier].latexParens === false) {
                result = [false];
                break;
              }
            }

            if (operandPrecedence === null) {
              // if the operand has no defined precedence, no parens are needed
              result = [false];
              break;
            }

            if (operandPrecedence <= precedence) {
              // if the operands precedence is lower, parens are needed
              result = [true];
              break;
            } // otherwise, no parens needed


            result = [false];
          }
          break;

        case 2:
          // binary operators
          {
            var lhsParens; // left hand side needs parenthesis?
            // precedence of the left hand side

            var lhsPrecedence = getPrecedence(args[0], parenthesis); // is the root node associative with the left hand side

            var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);

            if (lhsPrecedence === null) {
              // if the left hand side has no defined precedence, no parens are needed
              // FunctionNode for example
              lhsParens = false;
            } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {
              // In case of equal precedence, if the root node is left associative
              // parens are **never** necessary for the left hand side.
              // If it is right associative however, parens are necessary
              // if the root node isn't associative with the left hand side
              lhsParens = true;
            } else if (lhsPrecedence < precedence) {
              lhsParens = true;
            } else {
              lhsParens = false;
            }

            var rhsParens; // right hand side needs parenthesis?
            // precedence of the right hand side

            var rhsPrecedence = getPrecedence(args[1], parenthesis); // is the root node associative with the right hand side?

            var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);

            if (rhsPrecedence === null) {
              // if the right hand side has no defined precedence, no parens are needed
              // FunctionNode for example
              rhsParens = false;
            } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {
              // In case of equal precedence, if the root node is right associative
              // parens are **never** necessary for the right hand side.
              // If it is left associative however, parens are necessary
              // if the root node isn't associative with the right hand side
              rhsParens = true;
            } else if (rhsPrecedence < precedence) {
              rhsParens = true;
            } else {
              rhsParens = false;
            } // handle special cases for LaTeX, where some of the parentheses aren't needed


            if (latex) {
              var _rootIdentifier;

              var lhsIdentifier;
              var rhsIdentifier;

              if (parenthesis === 'keep') {
                _rootIdentifier = root.getIdentifier();
                lhsIdentifier = root.args[0].getIdentifier();
                rhsIdentifier = root.args[1].getIdentifier();
              } else {
                // Ignore ParenthesisNodes when not in 'keep' mode
                _rootIdentifier = root.getContent().getIdentifier();
                lhsIdentifier = root.args[0].getContent().getIdentifier();
                rhsIdentifier = root.args[1].getContent().getIdentifier();
              }

              if (lhsPrecedence !== null) {
                if (properties[precedence][_rootIdentifier].latexLeftParens === false) {
                  lhsParens = false;
                }

                if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
                  lhsParens = false;
                }
              }

              if (rhsPrecedence !== null) {
                if (properties[precedence][_rootIdentifier].latexRightParens === false) {
                  rhsParens = false;
                }

                if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
                  rhsParens = false;
                }
              }
            }

            result = [lhsParens, rhsParens];
          }
          break;

        default:
          if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {
            result = args.map(function (arg) {
              var argPrecedence = getPrecedence(arg, parenthesis);
              var assocWithArg = isAssociativeWith(root, arg, parenthesis);
              var argAssociativity = getAssociativity(arg, parenthesis);

              if (argPrecedence === null) {
                // if the argument has no defined precedence, no parens are needed
                return false;
              } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {
                return true;
              } else if (argPrecedence < precedence) {
                return true;
              }

              return false;
            });
          }

          break;
      } // handles an edge case of 'auto' parentheses with implicit multiplication of ConstantNode
      // In that case print parentheses for ParenthesisNodes even though they normally wouldn't be
      // printed.


      if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis === 'auto' && implicit === 'hide') {
        result = args.map(function (arg, index) {
          var isParenthesisNode$$1 = arg.getIdentifier() === 'ParenthesisNode';

          if (result[index] || isParenthesisNode$$1) {
            // put in parenthesis?
            return true;
          }

          return false;
        });
      }

      return result;
    }
    /**
     * Get string representation.
     * @param {Object} options
     * @return {string} str
     */


    OperatorNode.prototype._toString = function (options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
      var implicit = options && options.implicit ? options.implicit : 'hide';
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);

      if (args.length === 1) {
        // unary operators
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toString(options);

        if (parens[0]) {
          operand = '(' + operand + ')';
        } // for example for "not", we want a space between operand and argument


        var opIsNamed = /[a-zA-Z]+/.test(this.op);

        if (assoc === 'right') {
          // prefix operator
          return this.op + (opIsNamed ? ' ' : '') + operand;
        } else if (assoc === 'left') {
          // postfix
          return operand + (opIsNamed ? ' ' : '') + this.op;
        } // fall back to postfix


        return operand + this.op;
      } else if (args.length === 2) {
        var lhs = args[0].toString(options); // left hand side

        var rhs = args[1].toString(options); // right hand side

        if (parens[0]) {
          // left hand side in parenthesis?
          lhs = '(' + lhs + ')';
        }

        if (parens[1]) {
          // right hand side in parenthesis?
          rhs = '(' + rhs + ')';
        }

        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {
          return lhs + ' ' + rhs;
        }

        return lhs + ' ' + this.op + ' ' + rhs;
      } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {
        var stringifiedArgs = args.map(function (arg, index) {
          arg = arg.toString(options);

          if (parens[index]) {
            // put in parenthesis?
            arg = '(' + arg + ')';
          }

          return arg;
        });

        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {
          return stringifiedArgs.join(' ');
        }

        return stringifiedArgs.join(' ' + this.op + ' ');
      } else {
        // fallback to formatting as a function call
        return this.fn + '(' + this.args.join(', ') + ')';
      }
    };
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */


    OperatorNode.prototype.toJSON = function () {
      return {
        mathjs: 'OperatorNode',
        op: this.op,
        fn: this.fn,
        args: this.args,
        implicit: this.implicit
      };
    };
    /**
     * Instantiate an OperatorNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "OperatorNode", "op": "+", "fn": "add", "args": [...], "implicit": false}`,
     *                       where mathjs is optional
     * @returns {OperatorNode}
     */


    OperatorNode.fromJSON = function (json) {
      return new OperatorNode(json.op, json.fn, json.args, json.implicit);
    };
    /**
     * Get HTML representation.
     * @param {Object} options
     * @return {string} str
     */


    OperatorNode.prototype.toHTML = function (options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
      var implicit = options && options.implicit ? options.implicit : 'hide';
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);

      if (args.length === 1) {
        // unary operators
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toHTML(options);

        if (parens[0]) {
          operand = '<span class="math-parenthesis math-round-parenthesis">(</span>' + operand + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }

        if (assoc === 'right') {
          // prefix operator
          return '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' + escape(this.op) + '</span>' + operand;
        } else {
          // postfix when assoc === 'left' or undefined
          return operand + '<span class="math-operator math-unary-operator math-righthand-unary-operator">' + escape(this.op) + '</span>';
        }
      } else if (args.length === 2) {
        // binary operatoes
        var lhs = args[0].toHTML(options); // left hand side

        var rhs = args[1].toHTML(options); // right hand side

        if (parens[0]) {
          // left hand side in parenthesis?
          lhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + lhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }

        if (parens[1]) {
          // right hand side in parenthesis?
          rhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + rhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }

        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {
          return lhs + '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' + rhs;
        }

        return lhs + '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + '</span>' + rhs;
      } else {
        var stringifiedArgs = args.map(function (arg, index) {
          arg = arg.toHTML(options);

          if (parens[index]) {
            // put in parenthesis?
            arg = '<span class="math-parenthesis math-round-parenthesis">(</span>' + arg + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }

          return arg;
        });

        if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {
          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {
            return stringifiedArgs.join('<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>');
          }

          return stringifiedArgs.join('<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + '</span>');
        } else {
          // fallback to formatting as a function call
          return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + stringifiedArgs.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
        }
      }
    };
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */


    OperatorNode.prototype._toTex = function (options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
      var implicit = options && options.implicit ? options.implicit : 'hide';
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);
      var op = latexOperators[this.fn];
      op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op

      if (args.length === 1) {
        // unary operators
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toTex(options);

        if (parens[0]) {
          operand = "\\left(".concat(operand, "\\right)");
        }

        if (assoc === 'right') {
          // prefix operator
          return op + operand;
        } else if (assoc === 'left') {
          // postfix operator
          return operand + op;
        } // fall back to postfix


        return operand + op;
      } else if (args.length === 2) {
        // binary operators
        var lhs = args[0]; // left hand side

        var lhsTex = lhs.toTex(options);

        if (parens[0]) {
          lhsTex = "\\left(".concat(lhsTex, "\\right)");
        }

        var rhs = args[1]; // right hand side

        var rhsTex = rhs.toTex(options);

        if (parens[1]) {
          rhsTex = "\\left(".concat(rhsTex, "\\right)");
        } // handle some exceptions (due to the way LaTeX works)


        var lhsIdentifier;

        if (parenthesis === 'keep') {
          lhsIdentifier = lhs.getIdentifier();
        } else {
          // Ignore ParenthesisNodes if in 'keep' mode
          lhsIdentifier = lhs.getContent().getIdentifier();
        }

        switch (this.getIdentifier()) {
          case 'OperatorNode:divide':
            // op contains '\\frac' at this point
            return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';

          case 'OperatorNode:pow':
            lhsTex = '{' + lhsTex + '}';
            rhsTex = '{' + rhsTex + '}';

            switch (lhsIdentifier) {
              case 'ConditionalNode': //

              case 'OperatorNode:divide':
                lhsTex = "\\left(".concat(lhsTex, "\\right)");
            }

            break;

          case 'OperatorNode:multiply':
            if (this.implicit && implicit === 'hide') {
              return lhsTex + '~' + rhsTex;
            }

        }

        return lhsTex + op + rhsTex;
      } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {
        var texifiedArgs = args.map(function (arg, index) {
          arg = arg.toTex(options);

          if (parens[index]) {
            arg = "\\left(".concat(arg, "\\right)");
          }

          return arg;
        });

        if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit) {
          return texifiedArgs.join('~');
        }

        return texifiedArgs.join(op);
      } else {
        // fall back to formatting as a function call
        // as this is a fallback, it doesn't use
        // fancy function names
        return '\\mathrm{' + this.fn + '}\\left(' + args.map(function (arg) {
          return arg.toTex(options);
        }).join(',') + '\\right)';
      }
    };
    /**
     * Get identifier.
     * @return {string}
     */


    OperatorNode.prototype.getIdentifier = function () {
      return this.type + ':' + this.fn;
    };

    return OperatorNode;
  }, {
    isClass: true,
    isNode: true
  });

  var name$37 = 'ParenthesisNode';
  var dependencies$38 = ['Node'];
  var createParenthesisNode = /* #__PURE__ */factory(name$37, dependencies$38, function (_ref) {
    var Node = _ref.Node;

    /**
     * @constructor ParenthesisNode
     * @extends {Node}
     * A parenthesis node describes manual parenthesis from the user input
     * @param {Node} content
     * @extends {Node}
     */
    function ParenthesisNode(content) {
      if (!(this instanceof ParenthesisNode)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      } // validate input


      if (!isNode(content)) {
        throw new TypeError('Node expected for parameter "content"');
      }

      this.content = content;
    }

    ParenthesisNode.prototype = new Node();
    ParenthesisNode.prototype.type = 'ParenthesisNode';
    ParenthesisNode.prototype.isParenthesisNode = true;
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */

    ParenthesisNode.prototype._compile = function (math, argNames) {
      return this.content._compile(math, argNames);
    };
    /**
     * Get the content of the current Node.
     * @return {Node} content
     * @override
     **/


    ParenthesisNode.prototype.getContent = function () {
      return this.content.getContent();
    };
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */


    ParenthesisNode.prototype.forEach = function (callback) {
      callback(this.content, 'content', this);
    };
    /**
     * Create a new ParenthesisNode having it's childs be the results of calling
     * the provided callback function for each of the childs of the original node.
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {ParenthesisNode} Returns a clone of the node
     */


    ParenthesisNode.prototype.map = function (callback) {
      var content = callback(this.content, 'content', this);
      return new ParenthesisNode(content);
    };
    /**
     * Create a clone of this node, a shallow copy
     * @return {ParenthesisNode}
     */


    ParenthesisNode.prototype.clone = function () {
      return new ParenthesisNode(this.content);
    };
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */


    ParenthesisNode.prototype._toString = function (options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {
        return '(' + this.content.toString(options) + ')';
      }

      return this.content.toString(options);
    };
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */


    ParenthesisNode.prototype.toJSON = function () {
      return {
        mathjs: 'ParenthesisNode',
        content: this.content
      };
    };
    /**
     * Instantiate an ParenthesisNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ParenthesisNode", "content": ...}`,
     *                       where mathjs is optional
     * @returns {ParenthesisNode}
     */


    ParenthesisNode.fromJSON = function (json) {
      return new ParenthesisNode(json.content);
    };
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */


    ParenthesisNode.prototype.toHTML = function (options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {
        return '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }

      return this.content.toHTML(options);
    };
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     * @override
     */


    ParenthesisNode.prototype._toTex = function (options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {
        return "\\left(".concat(this.content.toTex(options), "\\right)");
      }

      return this.content.toTex(options);
    };

    return ParenthesisNode;
  }, {
    isClass: true,
    isNode: true
  });

  var name$38 = 'RangeNode';
  var dependencies$39 = ['Node'];
  var createRangeNode = /* #__PURE__ */factory(name$38, dependencies$39, function (_ref) {
    var Node = _ref.Node;

    /**
     * @constructor RangeNode
     * @extends {Node}
     * create a range
     * @param {Node} start  included lower-bound
     * @param {Node} end    included upper-bound
     * @param {Node} [step] optional step
     */
    function RangeNode(start, end, step) {
      if (!(this instanceof RangeNode)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      } // validate inputs


      if (!isNode(start)) throw new TypeError('Node expected');
      if (!isNode(end)) throw new TypeError('Node expected');
      if (step && !isNode(step)) throw new TypeError('Node expected');
      if (arguments.length > 3) throw new Error('Too many arguments');
      this.start = start; // included lower-bound

      this.end = end; // included upper-bound

      this.step = step || null; // optional step
    }

    RangeNode.prototype = new Node();
    RangeNode.prototype.type = 'RangeNode';
    RangeNode.prototype.isRangeNode = true;
    /**
     * Check whether the RangeNode needs the `end` symbol to be defined.
     * This end is the size of the Matrix in current dimension.
     * @return {boolean}
     */

    RangeNode.prototype.needsEnd = function () {
      // find all `end` symbols in this RangeNode
      var endSymbols = this.filter(function (node) {
        return isSymbolNode(node) && node.name === 'end';
      });
      return endSymbols.length > 0;
    };
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */


    RangeNode.prototype._compile = function (math, argNames) {
      var range = math.range;

      var evalStart = this.start._compile(math, argNames);

      var evalEnd = this.end._compile(math, argNames);

      if (this.step) {
        var evalStep = this.step._compile(math, argNames);

        return function evalRangeNode(scope, args, context) {
          return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));
        };
      } else {
        return function evalRangeNode(scope, args, context) {
          return range(evalStart(scope, args, context), evalEnd(scope, args, context));
        };
      }
    };
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */


    RangeNode.prototype.forEach = function (callback) {
      callback(this.start, 'start', this);
      callback(this.end, 'end', this);

      if (this.step) {
        callback(this.step, 'step', this);
      }
    };
    /**
     * Create a new RangeNode having it's childs be the results of calling
     * the provided callback function for each of the childs of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {RangeNode} Returns a transformed copy of the node
     */


    RangeNode.prototype.map = function (callback) {
      return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));
    };
    /**
     * Create a clone of this node, a shallow copy
     * @return {RangeNode}
     */


    RangeNode.prototype.clone = function () {
      return new RangeNode(this.start, this.end, this.step && this.step);
    };
    /**
     * Calculate the necessary parentheses
     * @param {Node} node
     * @param {string} parenthesis
     * @return {Object} parentheses
     * @private
     */


    function calculateNecessaryParentheses(node, parenthesis) {
      var precedence = getPrecedence(node, parenthesis);
      var parens = {};
      var startPrecedence = getPrecedence(node.start, parenthesis);
      parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';

      if (node.step) {
        var stepPrecedence = getPrecedence(node.step, parenthesis);
        parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';
      }

      var endPrecedence = getPrecedence(node.end, parenthesis);
      parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';
      return parens;
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */


    RangeNode.prototype._toString = function (options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
      var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop

      var str;
      var start = this.start.toString(options);

      if (parens.start) {
        start = '(' + start + ')';
      }

      str = start;

      if (this.step) {
        var step = this.step.toString(options);

        if (parens.step) {
          step = '(' + step + ')';
        }

        str += ':' + step;
      }

      var end = this.end.toString(options);

      if (parens.end) {
        end = '(' + end + ')';
      }

      str += ':' + end;
      return str;
    };
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */


    RangeNode.prototype.toJSON = function () {
      return {
        mathjs: 'RangeNode',
        start: this.start,
        end: this.end,
        step: this.step
      };
    };
    /**
     * Instantiate an RangeNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "RangeNode", "start": ..., "end": ..., "step": ...}`,
     *                       where mathjs is optional
     * @returns {RangeNode}
     */


    RangeNode.fromJSON = function (json) {
      return new RangeNode(json.start, json.end, json.step);
    };
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */


    RangeNode.prototype.toHTML = function (options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
      var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop

      var str;
      var start = this.start.toHTML(options);

      if (parens.start) {
        start = '<span class="math-parenthesis math-round-parenthesis">(</span>' + start + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }

      str = start;

      if (this.step) {
        var step = this.step.toHTML(options);

        if (parens.step) {
          step = '<span class="math-parenthesis math-round-parenthesis">(</span>' + step + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }

        str += '<span class="math-operator math-range-operator">:</span>' + step;
      }

      var end = this.end.toHTML(options);

      if (parens.end) {
        end = '<span class="math-parenthesis math-round-parenthesis">(</span>' + end + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }

      str += '<span class="math-operator math-range-operator">:</span>' + end;
      return str;
    };
    /**
     * Get LaTeX representation
     * @params {Object} options
     * @return {string} str
     */


    RangeNode.prototype._toTex = function (options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
      var parens = calculateNecessaryParentheses(this, parenthesis);
      var str = this.start.toTex(options);

      if (parens.start) {
        str = "\\left(".concat(str, "\\right)");
      }

      if (this.step) {
        var step = this.step.toTex(options);

        if (parens.step) {
          step = "\\left(".concat(step, "\\right)");
        }

        str += ':' + step;
      }

      var end = this.end.toTex(options);

      if (parens.end) {
        end = "\\left(".concat(end, "\\right)");
      }

      str += ':' + end;
      return str;
    };

    return RangeNode;
  }, {
    isClass: true,
    isNode: true
  });

  var name$39 = 'RelationalNode';
  var dependencies$3a = ['Node'];
  var createRelationalNode = /* #__PURE__ */factory(name$39, dependencies$3a, function (_ref) {
    var Node = _ref.Node;

    /**
     * A node representing a chained conditional expression, such as 'x > y > z'
     *
     * @param {String[]} conditionals   An array of conditional operators used to compare the parameters
     * @param {Node[]} params   The parameters that will be compared
     *
     * @constructor RelationalNode
     * @extends {Node}
     */
    function RelationalNode(conditionals, params) {
      if (!(this instanceof RelationalNode)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      if (!Array.isArray(conditionals)) throw new TypeError('Parameter conditionals must be an array');
      if (!Array.isArray(params)) throw new TypeError('Parameter params must be an array');
      if (conditionals.length !== params.length - 1) throw new TypeError('Parameter params must contain exactly one more element than parameter conditionals');
      this.conditionals = conditionals;
      this.params = params;
    }

    RelationalNode.prototype = new Node();
    RelationalNode.prototype.type = 'RelationalNode';
    RelationalNode.prototype.isRelationalNode = true;
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */

    RelationalNode.prototype._compile = function (math, argNames) {
      var self = this;
      var compiled = this.params.map(function (p) {
        return p._compile(math, argNames);
      });
      return function evalRelationalNode(scope, args, context) {
        var evalLhs;
        var evalRhs = compiled[0](scope, args, context);

        for (var i = 0; i < self.conditionals.length; i++) {
          evalLhs = evalRhs;
          evalRhs = compiled[i + 1](scope, args, context);
          var condFn = getSafeProperty(math, self.conditionals[i]);

          if (!condFn(evalLhs, evalRhs)) {
            return false;
          }
        }

        return true;
      };
    };
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */


    RelationalNode.prototype.forEach = function (callback) {
      var _this = this;

      this.params.forEach(function (n, i) {
        return callback(n, 'params[' + i + ']', _this);
      }, this);
    };
    /**
     * Create a new RelationalNode having its childs be the results of calling
     * the provided callback function for each of the childs of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {RelationalNode} Returns a transformed copy of the node
     */


    RelationalNode.prototype.map = function (callback) {
      var _this2 = this;

      return new RelationalNode(this.conditionals.slice(), this.params.map(function (n, i) {
        return _this2._ifNode(callback(n, 'params[' + i + ']', _this2));
      }, this));
    };
    /**
     * Create a clone of this node, a shallow copy
     * @return {RelationalNode}
     */


    RelationalNode.prototype.clone = function () {
      return new RelationalNode(this.conditionals, this.params);
    };
    /**
     * Get string representation.
     * @param {Object} options
     * @return {string} str
     */


    RelationalNode.prototype._toString = function (options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
      var precedence = getPrecedence(this, parenthesis);
      var paramStrings = this.params.map(function (p, index) {
        var paramPrecedence = getPrecedence(p, parenthesis);
        return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '(' + p.toString(options) + ')' : p.toString(options);
      });
      var operatorMap = {
        equal: '==',
        unequal: '!=',
        smaller: '<',
        larger: '>',
        smallerEq: '<=',
        largerEq: '>='
      };
      var ret = paramStrings[0];

      for (var i = 0; i < this.conditionals.length; i++) {
        ret += ' ' + operatorMap[this.conditionals[i]] + ' ' + paramStrings[i + 1];
      }

      return ret;
    };
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */


    RelationalNode.prototype.toJSON = function () {
      return {
        mathjs: 'RelationalNode',
        conditionals: this.conditionals,
        params: this.params
      };
    };
    /**
     * Instantiate a RelationalNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "RelationalNode", "condition": ..., "trueExpr": ..., "falseExpr": ...}`,
     *                       where mathjs is optional
     * @returns {RelationalNode}
     */


    RelationalNode.fromJSON = function (json) {
      return new RelationalNode(json.conditionals, json.params);
    };
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */


    RelationalNode.prototype.toHTML = function (options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
      var precedence = getPrecedence(this, parenthesis);
      var paramStrings = this.params.map(function (p, index) {
        var paramPrecedence = getPrecedence(p, parenthesis);
        return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + p.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : p.toHTML(options);
      });
      var operatorMap = {
        equal: '==',
        unequal: '!=',
        smaller: '<',
        larger: '>',
        smallerEq: '<=',
        largerEq: '>='
      };
      var ret = paramStrings[0];

      for (var i = 0; i < this.conditionals.length; i++) {
        ret += '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(operatorMap[this.conditionals[i]]) + '</span>' + paramStrings[i + 1];
      }

      return ret;
    };
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */


    RelationalNode.prototype._toTex = function (options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';
      var precedence = getPrecedence(this, parenthesis);
      var paramStrings = this.params.map(function (p, index) {
        var paramPrecedence = getPrecedence(p, parenthesis);
        return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '\\left(' + p.toTex(options) + '\right)' : p.toTex(options);
      });
      var ret = paramStrings[0];

      for (var i = 0; i < this.conditionals.length; i++) {
        ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];
      }

      return ret;
    };

    return RelationalNode;
  }, {
    isClass: true,
    isNode: true
  });

  var name$3a = 'SymbolNode';
  var dependencies$3b = ['math', '?Unit', 'Node'];
  var createSymbolNode = /* #__PURE__ */factory(name$3a, dependencies$3b, function (_ref) {
    var math = _ref.math,
        Unit = _ref.Unit,
        Node = _ref.Node;

    /**
     * Check whether some name is a valueless unit like "inch".
     * @param {string} name
     * @return {boolean}
     */
    function isValuelessUnit(name) {
      return Unit ? Unit.isValuelessUnit(name) : false;
    }
    /**
     * @constructor SymbolNode
     * @extends {Node}
     * A symbol node can hold and resolve a symbol
     * @param {string} name
     * @extends {Node}
     */


    function SymbolNode(name) {
      if (!(this instanceof SymbolNode)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      } // validate input


      if (typeof name !== 'string') throw new TypeError('String expected for parameter "name"');
      this.name = name;
    }

    SymbolNode.prototype = new Node();
    SymbolNode.prototype.type = 'SymbolNode';
    SymbolNode.prototype.isSymbolNode = true;
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */

    SymbolNode.prototype._compile = function (math, argNames) {
      var name = this.name;

      if (argNames[name] === true) {
        // this is a FunctionAssignment argument
        // (like an x when inside the expression of a function assignment `f(x) = ...`)
        return function (scope, args, context) {
          return args[name];
        };
      } else if (name in math) {
        return function (scope, args, context) {
          return name in scope ? getSafeProperty(scope, name) : getSafeProperty(math, name);
        };
      } else {
        var isUnit = isValuelessUnit(name);
        return function (scope, args, context) {
          return name in scope ? getSafeProperty(scope, name) : isUnit ? new Unit(null, name) : undef(name);
        };
      }
    };
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */


    SymbolNode.prototype.forEach = function (callback) {// nothing to do, we don't have childs
    };
    /**
     * Create a new SymbolNode having it's childs be the results of calling
     * the provided callback function for each of the childs of the original node.
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {SymbolNode} Returns a clone of the node
     */


    SymbolNode.prototype.map = function (callback) {
      return this.clone();
    };
    /**
     * Throws an error 'Undefined symbol {name}'
     * @param {string} name
     */


    function undef(name) {
      throw new Error('Undefined symbol ' + name);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {SymbolNode}
     */


    SymbolNode.prototype.clone = function () {
      return new SymbolNode(this.name);
    };
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */


    SymbolNode.prototype._toString = function (options) {
      return this.name;
    };
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */


    SymbolNode.prototype.toHTML = function (options) {
      var name = escape(this.name);

      if (name === 'true' || name === 'false') {
        return '<span class="math-symbol math-boolean">' + name + '</span>';
      } else if (name === 'i') {
        return '<span class="math-symbol math-imaginary-symbol">' + name + '</span>';
      } else if (name === 'Infinity') {
        return '<span class="math-symbol math-infinity-symbol">' + name + '</span>';
      } else if (name === 'NaN') {
        return '<span class="math-symbol math-nan-symbol">' + name + '</span>';
      } else if (name === 'null') {
        return '<span class="math-symbol math-null-symbol">' + name + '</span>';
      } else if (name === 'undefined') {
        return '<span class="math-symbol math-undefined-symbol">' + name + '</span>';
      }

      return '<span class="math-symbol">' + name + '</span>';
    };
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */


    SymbolNode.prototype.toJSON = function () {
      return {
        mathjs: 'SymbolNode',
        name: this.name
      };
    };
    /**
     * Instantiate a SymbolNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "SymbolNode", name: "x"}`,
     *                       where mathjs is optional
     * @returns {SymbolNode}
     */


    SymbolNode.fromJSON = function (json) {
      return new SymbolNode(json.name);
    };
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     * @override
     */


    SymbolNode.prototype._toTex = function (options) {
      var isUnit = false;

      if (typeof math[this.name] === 'undefined' && isValuelessUnit(this.name)) {
        isUnit = true;
      }

      var symbol = toSymbol(this.name, isUnit);

      if (symbol[0] === '\\') {
        // no space needed if the symbol starts with '\'
        return symbol;
      } // the space prevents symbols from breaking stuff like '\cdot' if it's written right before the symbol


      return ' ' + symbol;
    };

    return SymbolNode;
  }, {
    isClass: true,
    isNode: true
  });

  function _typeof$b(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$b = function _typeof(obj) { return typeof obj; }; } else { _typeof$b = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$b(obj); }

  function _extends$3() { _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }
  var name$3b = 'FunctionNode';
  var dependencies$3c = ['math', 'Node', 'SymbolNode'];
  var createFunctionNode = /* #__PURE__ */factory(name$3b, dependencies$3c, function (_ref) {
    var math = _ref.math,
        Node = _ref.Node,
        SymbolNode = _ref.SymbolNode;

    /**
     * @constructor FunctionNode
     * @extends {./Node}
     * invoke a list with arguments on a node
     * @param {./Node | string} fn Node resolving with a function on which to invoke
     *                             the arguments, typically a SymboNode or AccessorNode
     * @param {./Node[]} args
     */
    function FunctionNode(fn, args) {
      if (!(this instanceof FunctionNode)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      if (typeof fn === 'string') {
        fn = new SymbolNode(fn);
      } // validate input


      if (!isNode(fn)) throw new TypeError('Node expected as parameter "fn"');

      if (!Array.isArray(args) || !args.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      }

      this.fn = fn;
      this.args = args || []; // readonly property name

      Object.defineProperty(this, 'name', {
        get: function () {
          return this.fn.name || '';
        }.bind(this),
        set: function set$$1() {
          throw new Error('Cannot assign a new name, name is read-only');
        }
      });
    }

    FunctionNode.prototype = new Node();
    FunctionNode.prototype.type = 'FunctionNode';
    FunctionNode.prototype.isFunctionNode = true;
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */

    FunctionNode.prototype._compile = function (math, argNames) {
      if (!(this instanceof FunctionNode)) {
        throw new TypeError('No valid FunctionNode');
      } // compile arguments


      var evalArgs = map(this.args, function (arg) {
        return arg._compile(math, argNames);
      });

      if (isSymbolNode(this.fn)) {
        // we can statically determine whether the function has an rawArgs property
        var _name = this.fn.name;
        var fn = _name in math ? getSafeProperty(math, _name) : undefined;
        var isRaw = typeof fn === 'function' && fn.rawArgs === true;

        if (isRaw) {
          // pass unevaluated parameters (nodes) to the function
          // "raw" evaluation
          var rawArgs = this.args;
          return function evalFunctionNode(scope, args, context) {
            return (_name in scope ? getSafeProperty(scope, _name) : fn)(rawArgs, math, _extends$3({}, scope, args));
          };
        } else {
          // "regular" evaluation
          if (evalArgs.length === 1) {
            var evalArg0 = evalArgs[0];
            return function evalFunctionNode(scope, args, context) {
              return (_name in scope ? getSafeProperty(scope, _name) : fn)(evalArg0(scope, args, context));
            };
          } else if (evalArgs.length === 2) {
            var _evalArg = evalArgs[0];
            var evalArg1 = evalArgs[1];
            return function evalFunctionNode(scope, args, context) {
              return (_name in scope ? getSafeProperty(scope, _name) : fn)(_evalArg(scope, args, context), evalArg1(scope, args, context));
            };
          } else {
            return function evalFunctionNode(scope, args, context) {
              return (_name in scope ? getSafeProperty(scope, _name) : fn).apply(null, map(evalArgs, function (evalArg) {
                return evalArg(scope, args, context);
              }));
            };
          }
        }
      } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {
        // execute the function with the right context: the object of the AccessorNode
        var evalObject = this.fn.object._compile(math, argNames);

        var prop = this.fn.index.getObjectProperty();
        var _rawArgs = this.args;
        return function evalFunctionNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          validateSafeMethod(object, prop);
          var isRaw = object[prop] && object[prop].rawArgs;
          return isRaw ? object[prop](_rawArgs, math, _extends$3({}, scope, args)) // "raw" evaluation
          : object[prop].apply(object, map(evalArgs, function (evalArg) {
            // "regular" evaluation
            return evalArg(scope, args, context);
          }));
        };
      } else {
        // node.fn.isAccessorNode && !node.fn.index.isObjectProperty()
        // we have to dynamically determine whether the function has a rawArgs property
        var evalFn = this.fn._compile(math, argNames);

        var _rawArgs2 = this.args;
        return function evalFunctionNode(scope, args, context) {
          var fn = evalFn(scope, args, context);
          var isRaw = fn && fn.rawArgs;
          return isRaw ? fn(_rawArgs2, math, _extends$3({}, scope, args)) // "raw" evaluation
          : fn.apply(fn, map(evalArgs, function (evalArg) {
            // "regular" evaluation
            return evalArg(scope, args, context);
          }));
        };
      }
    };
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */


    FunctionNode.prototype.forEach = function (callback) {
      callback(this.fn, 'fn', this);

      for (var i = 0; i < this.args.length; i++) {
        callback(this.args[i], 'args[' + i + ']', this);
      }
    };
    /**
     * Create a new FunctionNode having it's childs be the results of calling
     * the provided callback function for each of the childs of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {FunctionNode} Returns a transformed copy of the node
     */


    FunctionNode.prototype.map = function (callback) {
      var fn = this._ifNode(callback(this.fn, 'fn', this));

      var args = [];

      for (var i = 0; i < this.args.length; i++) {
        args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));
      }

      return new FunctionNode(fn, args);
    };
    /**
     * Create a clone of this node, a shallow copy
     * @return {FunctionNode}
     */


    FunctionNode.prototype.clone = function () {
      return new FunctionNode(this.fn, this.args.slice(0));
    }; // backup Node's toString function
    // @private


    var nodeToString = FunctionNode.prototype.toString;
    /**
     * Get string representation. (wrapper function)
     * This overrides parts of Node's toString function.
     * If callback is an object containing callbacks, it
     * calls the correct callback for the current node,
     * otherwise it falls back to calling Node's toString
     * function.
     *
     * @param {Object} options
     * @return {string} str
     * @override
     */

    FunctionNode.prototype.toString = function (options) {
      var customString;
      var name = this.fn.toString(options);

      if (options && _typeof$b(options.handler) === 'object' && hasOwnProperty(options.handler, name)) {
        // callback is a map of callback functions
        customString = options.handler[name](this, options);
      }

      if (typeof customString !== 'undefined') {
        return customString;
      } // fall back to Node's toString


      return nodeToString.call(this, options);
    };
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */


    FunctionNode.prototype._toString = function (options) {
      var args = this.args.map(function (arg) {
        return arg.toString(options);
      });
      var fn = isFunctionAssignmentNode(this.fn) ? '(' + this.fn.toString(options) + ')' : this.fn.toString(options); // format the arguments like "add(2, 4.2)"

      return fn + '(' + args.join(', ') + ')';
    };
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */


    FunctionNode.prototype.toJSON = function () {
      return {
        mathjs: 'FunctionNode',
        fn: this.fn,
        args: this.args
      };
    };
    /**
     * Instantiate an AssignmentNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "FunctionNode", fn: ..., args: ...}`,
     *                       where mathjs is optional
     * @returns {FunctionNode}
     */


    FunctionNode.fromJSON = function (json) {
      return new FunctionNode(json.fn, json.args);
    };
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */


    FunctionNode.prototype.toHTML = function (options) {
      var args = this.args.map(function (arg) {
        return arg.toHTML(options);
      }); // format the arguments like "add(2, 4.2)"

      return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + args.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
    };
    /*
     * Expand a LaTeX template
     *
     * @param {string} template
     * @param {Node} node
     * @param {Object} options
     * @private
     **/


    function expandTemplate(template, node, options) {
      var latex = ''; // Match everything of the form ${identifier} or ${identifier[2]} or $$
      // while submatching identifier and 2 (in the second case)

      var regex = new RegExp('\\$(?:\\{([a-z_][a-z_0-9]*)(?:\\[([0-9]+)\\])?\\}|\\$)', 'ig');
      var inputPos = 0; // position in the input string

      var match;

      while ((match = regex.exec(template)) !== null) {
        // go through all matches
        // add everything in front of the match to the LaTeX string
        latex += template.substring(inputPos, match.index);
        inputPos = match.index;

        if (match[0] === '$$') {
          // escaped dollar sign
          latex += '$';
          inputPos++;
        } else {
          // template parameter
          inputPos += match[0].length;
          var property = node[match[1]];

          if (!property) {
            throw new ReferenceError('Template: Property ' + match[1] + ' does not exist.');
          }

          if (match[2] === undefined) {
            // no square brackets
            switch (_typeof$b(property)) {
              case 'string':
                latex += property;
                break;

              case 'object':
                if (isNode(property)) {
                  latex += property.toTex(options);
                } else if (Array.isArray(property)) {
                  // make array of Nodes into comma separated list
                  latex += property.map(function (arg, index) {
                    if (isNode(arg)) {
                      return arg.toTex(options);
                    }

                    throw new TypeError('Template: ' + match[1] + '[' + index + '] is not a Node.');
                  }).join(',');
                } else {
                  throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');
                }

                break;

              default:
                throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');
            }
          } else {
            // with square brackets
            if (isNode(property[match[2]] && property[match[2]])) {
              latex += property[match[2]].toTex(options);
            } else {
              throw new TypeError('Template: ' + match[1] + '[' + match[2] + '] is not a Node.');
            }
          }
        }
      }

      latex += template.slice(inputPos); // append rest of the template

      return latex;
    } // backup Node's toTex function
    // @private


    var nodeToTex = FunctionNode.prototype.toTex;
    /**
     * Get LaTeX representation. (wrapper function)
     * This overrides parts of Node's toTex function.
     * If callback is an object containing callbacks, it
     * calls the correct callback for the current node,
     * otherwise it falls back to calling Node's toTex
     * function.
     *
     * @param {Object} options
     * @return {string}
     */

    FunctionNode.prototype.toTex = function (options) {
      var customTex;

      if (options && _typeof$b(options.handler) === 'object' && hasOwnProperty(options.handler, this.name)) {
        // callback is a map of callback functions
        customTex = options.handler[this.name](this, options);
      }

      if (typeof customTex !== 'undefined') {
        return customTex;
      } // fall back to Node's toTex


      return nodeToTex.call(this, options);
    };
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */


    FunctionNode.prototype._toTex = function (options) {
      var args = this.args.map(function (arg) {
        // get LaTeX of the arguments
        return arg.toTex(options);
      });
      var latexConverter;

      if (latexFunctions[this.name]) {
        latexConverter = latexFunctions[this.name];
      } // toTex property on the function itself


      if (math[this.name] && (typeof math[this.name].toTex === 'function' || _typeof$b(math[this.name].toTex) === 'object' || typeof math[this.name].toTex === 'string')) {
        // .toTex is a callback function
        latexConverter = math[this.name].toTex;
      }

      var customToTex;

      switch (_typeof$b(latexConverter)) {
        case 'function':
          // a callback function
          customToTex = latexConverter(this, options);
          break;

        case 'string':
          // a template string
          customToTex = expandTemplate(latexConverter, this, options);
          break;

        case 'object':
          // an object with different "converters" for different numbers of arguments
          switch (_typeof$b(latexConverter[args.length])) {
            case 'function':
              customToTex = latexConverter[args.length](this, options);
              break;

            case 'string':
              customToTex = expandTemplate(latexConverter[args.length], this, options);
              break;
          }

      }

      if (typeof customToTex !== 'undefined') {
        return customToTex;
      }

      return expandTemplate(defaultTemplate, this, options);
    };
    /**
     * Get identifier.
     * @return {string}
     */


    FunctionNode.prototype.getIdentifier = function () {
      return this.type + ':' + this.name;
    };

    return FunctionNode;
  }, {
    isClass: true,
    isNode: true
  });

  function _extends$4() { _extends$4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$4.apply(this, arguments); }
  var name$3c = 'parse';
  var dependencies$3d = ['typed', 'numeric', 'config', 'AccessorNode', 'ArrayNode', 'AssignmentNode', 'BlockNode', 'ConditionalNode', 'ConstantNode', 'FunctionAssignmentNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'RangeNode', 'RelationalNode', 'SymbolNode'];
  var createParse = /* #__PURE__ */factory(name$3c, dependencies$3d, function (_ref) {
    var typed = _ref.typed,
        numeric = _ref.numeric,
        config = _ref.config,
        AccessorNode = _ref.AccessorNode,
        ArrayNode = _ref.ArrayNode,
        AssignmentNode = _ref.AssignmentNode,
        BlockNode = _ref.BlockNode,
        ConditionalNode = _ref.ConditionalNode,
        ConstantNode = _ref.ConstantNode,
        FunctionAssignmentNode = _ref.FunctionAssignmentNode,
        FunctionNode = _ref.FunctionNode,
        IndexNode = _ref.IndexNode,
        ObjectNode = _ref.ObjectNode,
        OperatorNode = _ref.OperatorNode,
        ParenthesisNode = _ref.ParenthesisNode,
        RangeNode = _ref.RangeNode,
        RelationalNode = _ref.RelationalNode,
        SymbolNode = _ref.SymbolNode;

    /**
     * Parse an expression. Returns a node tree, which can be evaluated by
     * invoking node.evaluate().
     *
     * Note the evaluating arbitrary expressions may involve security risks,
     * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.
     *
     * Syntax:
     *
     *     math.parse(expr)
     *     math.parse(expr, options)
     *     math.parse([expr1, expr2, expr3, ...])
     *     math.parse([expr1, expr2, expr3, ...], options)
     *
     * Example:
     *
     *     const node1 = math.parse('sqrt(3^2 + 4^2)')
     *     node1.compile().evaluate() // 5
     *
     *     let scope = {a:3, b:4}
     *     const node2 = math.parse('a * b') // 12
     *     const code2 = node2.compile()
     *     code2.evaluate(scope) // 12
     *     scope.a = 5
     *     code2.evaluate(scope) // 20
     *
     *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])
     *     nodes[2].compile().evaluate() // 12
     *
     * See also:
     *
     *     evaluate, compile
     *
     * @param {string | string[] | Matrix} expr          Expression to be parsed
     * @param {{nodes: Object<string, Node>}} [options]  Available options:
     *                                                   - `nodes` a set of custom nodes
     * @return {Node | Node[]} node
     * @throws {Error}
     */
    var parse = typed(name$3c, {
      string: function string(expression) {
        return parseStart(expression, {});
      },
      'Array | Matrix': function ArrayMatrix(expressions) {
        return parseMultiple(expressions, {});
      },
      'string, Object': function stringObject(expression, options) {
        var extraNodes = options.nodes !== undefined ? options.nodes : {};
        return parseStart(expression, extraNodes);
      },
      'Array | Matrix, Object': parseMultiple
    });

    function parseMultiple(expressions) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var extraNodes = options.nodes !== undefined ? options.nodes : {}; // parse an array or matrix with expressions

      return deepMap(expressions, function (elem) {
        if (typeof elem !== 'string') throw new TypeError('String expected');
        return parseStart(elem, extraNodes);
      });
    } // token types enumeration


    var TOKENTYPE = {
      NULL: 0,
      DELIMITER: 1,
      NUMBER: 2,
      SYMBOL: 3,
      UNKNOWN: 4
    }; // map with all delimiters

    var DELIMITERS = {
      ',': true,
      '(': true,
      ')': true,
      '[': true,
      ']': true,
      '{': true,
      '}': true,
      '"': true,
      '\'': true,
      ';': true,
      '+': true,
      '-': true,
      '*': true,
      '.*': true,
      '/': true,
      './': true,
      '%': true,
      '^': true,
      '.^': true,
      '~': true,
      '!': true,
      '&': true,
      '|': true,
      '^|': true,
      '=': true,
      ':': true,
      '?': true,
      '==': true,
      '!=': true,
      '<': true,
      '>': true,
      '<=': true,
      '>=': true,
      '<<': true,
      '>>': true,
      '>>>': true
    }; // map with all named delimiters

    var NAMED_DELIMITERS = {
      mod: true,
      to: true,
      "in": true,
      and: true,
      xor: true,
      or: true,
      not: true
    };
    var CONSTANTS = {
      "true": true,
      "false": false,
      "null": null,
      undefined: undefined
    };
    var NUMERIC_CONSTANTS = ['NaN', 'Infinity'];

    function initialState() {
      return {
        extraNodes: {},
        // current extra nodes, must be careful not to mutate
        expression: '',
        // current expression
        comment: '',
        // last parsed comment
        index: 0,
        // current index in expr
        token: '',
        // current token
        tokenType: TOKENTYPE.NULL,
        // type of the token
        nestingLevel: 0,
        // level of nesting inside parameters, used to ignore newline characters
        conditionalLevel: null // when a conditional is being parsed, the level of the conditional is stored here

      };
    }
    /**
     * View upto `length` characters of the expression starting at the current character.
     *
     * @param {Object} state
     * @param {number} [length=1] Number of characters to view
     * @returns {string}
     * @private
     */


    function currentString(state, length) {
      return state.expression.substr(state.index, length);
    }
    /**
     * View the current character. Returns '' if end of expression is reached.
     *
     * @param {Object} state
     * @returns {string}
     * @private
     */


    function currentCharacter(state) {
      return currentString(state, 1);
    }
    /**
     * Get the next character from the expression.
     * The character is stored into the char c. If the end of the expression is
     * reached, the function puts an empty string in c.
     * @private
     */


    function next(state) {
      state.index++;
    }
    /**
     * Preview the previous character from the expression.
     * @return {string} cNext
     * @private
     */


    function prevCharacter(state) {
      return state.expression.charAt(state.index - 1);
    }
    /**
     * Preview the next character from the expression.
     * @return {string} cNext
     * @private
     */


    function nextCharacter(state) {
      return state.expression.charAt(state.index + 1);
    }
    /**
     * Get next token in the current string expr.
     * The token and token type are available as token and tokenType
     * @private
     */


    function getToken(state) {
      state.tokenType = TOKENTYPE.NULL;
      state.token = '';
      state.comment = ''; // skip over whitespaces
      // space, tab, and newline when inside parameters

      while (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {
        next(state);
      } // skip comment


      if (currentCharacter(state) === '#') {
        while (currentCharacter(state) !== '\n' && currentCharacter(state) !== '') {
          state.comment += currentCharacter(state);
          next(state);
        }
      } // check for end of expression


      if (currentCharacter(state) === '') {
        // token is still empty
        state.tokenType = TOKENTYPE.DELIMITER;
        return;
      } // check for new line character


      if (currentCharacter(state) === '\n' && !state.nestingLevel) {
        state.tokenType = TOKENTYPE.DELIMITER;
        state.token = currentCharacter(state);
        next(state);
        return;
      }

      var c1 = currentCharacter(state);
      var c2 = currentString(state, 2);
      var c3 = currentString(state, 3);

      if (c3.length === 3 && DELIMITERS[c3]) {
        state.tokenType = TOKENTYPE.DELIMITER;
        state.token = c3;
        next(state);
        next(state);
        next(state);
        return;
      } // check for delimiters consisting of 2 characters


      if (c2.length === 2 && DELIMITERS[c2]) {
        state.tokenType = TOKENTYPE.DELIMITER;
        state.token = c2;
        next(state);
        next(state);
        return;
      } // check for delimiters consisting of 1 character


      if (DELIMITERS[c1]) {
        state.tokenType = TOKENTYPE.DELIMITER;
        state.token = c1;
        next(state);
        return;
      } // check for a number


      if (parse.isDigitDot(c1)) {
        state.tokenType = TOKENTYPE.NUMBER; // get number, can have a single dot

        if (currentCharacter(state) === '.') {
          state.token += currentCharacter(state);
          next(state);

          if (!parse.isDigit(currentCharacter(state))) {
            // this is no number, it is just a dot (can be dot notation)
            state.tokenType = TOKENTYPE.DELIMITER;
          }
        } else {
          while (parse.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }

          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
        }

        while (parse.isDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        } // check for exponential notation like "2.3e-4", "1.23e50" or "2e+4"


        if (currentCharacter(state) === 'E' || currentCharacter(state) === 'e') {
          if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === '-' || nextCharacter(state) === '+') {
            state.token += currentCharacter(state);
            next(state);

            if (currentCharacter(state) === '+' || currentCharacter(state) === '-') {
              state.token += currentCharacter(state);
              next(state);
            } // Scientific notation MUST be followed by an exponent


            if (!parse.isDigit(currentCharacter(state))) {
              throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
            }

            while (parse.isDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }

            if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
              throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
            }
          } else if (nextCharacter(state) === '.') {
            next(state);
            throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
          }
        }

        return;
      } // check for variables, functions, named operators


      if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {
        while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }

        if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {
          state.tokenType = TOKENTYPE.DELIMITER;
        } else {
          state.tokenType = TOKENTYPE.SYMBOL;
        }

        return;
      } // something unknown is found, wrong characters -> a syntax error


      state.tokenType = TOKENTYPE.UNKNOWN;

      while (currentCharacter(state) !== '') {
        state.token += currentCharacter(state);
        next(state);
      }

      throw createSyntaxError(state, 'Syntax error in part "' + state.token + '"');
    }
    /**
     * Get next token and skip newline tokens
     */


    function getTokenSkipNewline(state) {
      do {
        getToken(state);
      } while (state.token === '\n'); // eslint-disable-line no-unmodified-loop-condition

    }
    /**
     * Open parameters.
     * New line characters will be ignored until closeParams(state) is called
     */


    function openParams(state) {
      state.nestingLevel++;
    }
    /**
     * Close parameters.
     * New line characters will no longer be ignored
     */


    function closeParams(state) {
      state.nestingLevel--;
    }
    /**
     * Checks whether the current character `c` is a valid alpha character:
     *
     * - A latin letter (upper or lower case) Ascii: a-z, A-Z
     * - An underscore                        Ascii: _
     * - A dollar sign                        Ascii: $
     * - A latin letter with accents          Unicode: \u00C0 - \u02AF
     * - A greek letter                       Unicode: \u0370 - \u03FF
     * - A mathematical alphanumeric symbol   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
     *
     * The previous and next characters are needed to determine whether
     * this character is part of a unicode surrogate pair.
     *
     * @param {string} c      Current character in the expression
     * @param {string} cPrev  Previous character
     * @param {string} cNext  Next character
     * @return {boolean}
     */


    parse.isAlpha = function isAlpha(c, cPrev, cNext) {
      return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);
    };
    /**
     * Test whether a character is a valid latin, greek, or letter-like character
     * @param {string} c
     * @return {boolean}
     */


    parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {
      return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c);
    };
    /**
     * Test whether two given 16 bit characters form a surrogate pair of a
     * unicode math symbol.
     *
     * https://unicode-table.com/en/
     * https://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode
     *
     * Note: In ES6 will be unicode aware:
     * https://stackoverflow.com/questions/280712/javascript-unicode-regexes
     * https://mathiasbynens.be/notes/es6-unicode-regex
     *
     * @param {string} high
     * @param {string} low
     * @return {boolean}
     */


    parse.isValidMathSymbol = function isValidMathSymbol(high, low) {
      return /^[\uD835]$/.test(high) && /^[\uDC00-\uDFFF]$/.test(low) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
    };
    /**
     * Check whether given character c is a white space character: space, tab, or enter
     * @param {string} c
     * @param {number} nestingLevel
     * @return {boolean}
     */


    parse.isWhitespace = function isWhitespace(c, nestingLevel) {
      // TODO: also take '\r' carriage return as newline? Or does that give problems on mac?
      return c === ' ' || c === '\t' || c === '\n' && nestingLevel > 0;
    };
    /**
     * Test whether the character c is a decimal mark (dot).
     * This is the case when it's not the start of a delimiter '.*', './', or '.^'
     * @param {string} c
     * @param {string} cNext
     * @return {boolean}
     */


    parse.isDecimalMark = function isDecimalMark(c, cNext) {
      return c === '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';
    };
    /**
     * checks if the given char c is a digit or dot
     * @param {string} c   a string with one character
     * @return {boolean}
     */


    parse.isDigitDot = function isDigitDot(c) {
      return c >= '0' && c <= '9' || c === '.';
    };
    /**
     * checks if the given char c is a digit
     * @param {string} c   a string with one character
     * @return {boolean}
     */


    parse.isDigit = function isDigit(c) {
      return c >= '0' && c <= '9';
    };
    /**
     * Start of the parse levels below, in order of precedence
     * @return {Node} node
     * @private
     */


    function parseStart(expression, extraNodes) {
      var state = initialState();

      _extends$4(state, {
        expression: expression,
        extraNodes: extraNodes
      });

      getToken(state);
      var node = parseBlock(state); // check for garbage at the end of the expression
      // an expression ends with a empty character '' and tokenType DELIMITER

      if (state.token !== '') {
        if (state.tokenType === TOKENTYPE.DELIMITER) {
          // user entered a not existing operator like "//"
          // TODO: give hints for aliases, for example with "<>" give as hint " did you mean !== ?"
          throw createError(state, 'Unexpected operator ' + state.token);
        } else {
          throw createSyntaxError(state, 'Unexpected part "' + state.token + '"');
        }
      }

      return node;
    }
    /**
     * Parse a block with expressions. Expressions can be separated by a newline
     * character '\n', or by a semicolon ';'. In case of a semicolon, no output
     * of the preceding line is returned.
     * @return {Node} node
     * @private
     */


    function parseBlock(state) {
      var node;
      var blocks = [];
      var visible;

      if (state.token !== '' && state.token !== '\n' && state.token !== ';') {
        node = parseAssignment(state);
        node.comment = state.comment;
      } // TODO: simplify this loop


      while (state.token === '\n' || state.token === ';') {
        // eslint-disable-line no-unmodified-loop-condition
        if (blocks.length === 0 && node) {
          visible = state.token !== ';';
          blocks.push({
            node: node,
            visible: visible
          });
        }

        getToken(state);

        if (state.token !== '\n' && state.token !== ';' && state.token !== '') {
          node = parseAssignment(state);
          node.comment = state.comment;
          visible = state.token !== ';';
          blocks.push({
            node: node,
            visible: visible
          });
        }
      }

      if (blocks.length > 0) {
        return new BlockNode(blocks);
      } else {
        if (!node) {
          node = new ConstantNode(undefined);
          node.comment = state.comment;
        }

        return node;
      }
    }
    /**
     * Assignment of a function or variable,
     * - can be a variable like 'a=2.3'
     * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'
     * - defining a function like 'f(x) = x^2'
     * @return {Node} node
     * @private
     */


    function parseAssignment(state) {
      var name, args, value, valid;
      var node = parseConditional(state);

      if (state.token === '=') {
        if (isSymbolNode(node)) {
          // parse a variable assignment like 'a = 2/3'
          name = node.name;
          getTokenSkipNewline(state);
          value = parseAssignment(state);
          return new AssignmentNode(new SymbolNode(name), value);
        } else if (isAccessorNode(node)) {
          // parse a matrix subset assignment like 'A[1,2] = 4'
          getTokenSkipNewline(state);
          value = parseAssignment(state);
          return new AssignmentNode(node.object, node.index, value);
        } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {
          // parse function assignment like 'f(x) = x^2'
          valid = true;
          args = [];
          name = node.name;
          node.args.forEach(function (arg, index) {
            if (isSymbolNode(arg)) {
              args[index] = arg.name;
            } else {
              valid = false;
            }
          });

          if (valid) {
            getTokenSkipNewline(state);
            value = parseAssignment(state);
            return new FunctionAssignmentNode(name, args, value);
          }
        }

        throw createSyntaxError(state, 'Invalid left hand side of assignment operator =');
      }

      return node;
    }
    /**
     * conditional operation
     *
     *     condition ? truePart : falsePart
     *
     * Note: conditional operator is right-associative
     *
     * @return {Node} node
     * @private
     */


    function parseConditional(state) {
      var node = parseLogicalOr(state);

      while (state.token === '?') {
        // eslint-disable-line no-unmodified-loop-condition
        // set a conditional level, the range operator will be ignored as long
        // as conditionalLevel === state.nestingLevel.
        var prev = state.conditionalLevel;
        state.conditionalLevel = state.nestingLevel;
        getTokenSkipNewline(state);
        var condition = node;
        var trueExpr = parseAssignment(state);
        if (state.token !== ':') throw createSyntaxError(state, 'False part of conditional expression expected');
        state.conditionalLevel = null;
        getTokenSkipNewline(state);
        var falseExpr = parseAssignment(state); // Note: check for conditional operator again, right associativity

        node = new ConditionalNode(condition, trueExpr, falseExpr); // restore the previous conditional level

        state.conditionalLevel = prev;
      }

      return node;
    }
    /**
     * logical or, 'x or y'
     * @return {Node} node
     * @private
     */


    function parseLogicalOr(state) {
      var node = parseLogicalXor(state);

      while (state.token === 'or') {
        // eslint-disable-line no-unmodified-loop-condition
        getTokenSkipNewline(state);
        node = new OperatorNode('or', 'or', [node, parseLogicalXor(state)]);
      }

      return node;
    }
    /**
     * logical exclusive or, 'x xor y'
     * @return {Node} node
     * @private
     */


    function parseLogicalXor(state) {
      var node = parseLogicalAnd(state);

      while (state.token === 'xor') {
        // eslint-disable-line no-unmodified-loop-condition
        getTokenSkipNewline(state);
        node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd(state)]);
      }

      return node;
    }
    /**
     * logical and, 'x and y'
     * @return {Node} node
     * @private
     */


    function parseLogicalAnd(state) {
      var node = parseBitwiseOr(state);

      while (state.token === 'and') {
        // eslint-disable-line no-unmodified-loop-condition
        getTokenSkipNewline(state);
        node = new OperatorNode('and', 'and', [node, parseBitwiseOr(state)]);
      }

      return node;
    }
    /**
     * bitwise or, 'x | y'
     * @return {Node} node
     * @private
     */


    function parseBitwiseOr(state) {
      var node = parseBitwiseXor(state);

      while (state.token === '|') {
        // eslint-disable-line no-unmodified-loop-condition
        getTokenSkipNewline(state);
        node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor(state)]);
      }

      return node;
    }
    /**
     * bitwise exclusive or (xor), 'x ^| y'
     * @return {Node} node
     * @private
     */


    function parseBitwiseXor(state) {
      var node = parseBitwiseAnd(state);

      while (state.token === '^|') {
        // eslint-disable-line no-unmodified-loop-condition
        getTokenSkipNewline(state);
        node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd(state)]);
      }

      return node;
    }
    /**
     * bitwise and, 'x & y'
     * @return {Node} node
     * @private
     */


    function parseBitwiseAnd(state) {
      var node = parseRelational(state);

      while (state.token === '&') {
        // eslint-disable-line no-unmodified-loop-condition
        getTokenSkipNewline(state);
        node = new OperatorNode('&', 'bitAnd', [node, parseRelational(state)]);
      }

      return node;
    }
    /**
     * Parse a chained conditional, like 'a > b >= c'
     * @return {Node} node
     */


    function parseRelational(state) {
      var params = [parseShift(state)];
      var conditionals = [];
      var operators = {
        '==': 'equal',
        '!=': 'unequal',
        '<': 'smaller',
        '>': 'larger',
        '<=': 'smallerEq',
        '>=': 'largerEq'
      };

      while (hasOwnProperty(operators, state.token)) {
        // eslint-disable-line no-unmodified-loop-condition
        var cond = {
          name: state.token,
          fn: operators[state.token]
        };
        conditionals.push(cond);
        getTokenSkipNewline(state);
        params.push(parseShift(state));
      }

      if (params.length === 1) {
        return params[0];
      } else if (params.length === 2) {
        return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);
      } else {
        return new RelationalNode(conditionals.map(function (c) {
          return c.fn;
        }), params);
      }
    }
    /**
     * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
     * @return {Node} node
     * @private
     */


    function parseShift(state) {
      var node, name, fn, params;
      node = parseConversion(state);
      var operators = {
        '<<': 'leftShift',
        '>>': 'rightArithShift',
        '>>>': 'rightLogShift'
      };

      while (hasOwnProperty(operators, state.token)) {
        name = state.token;
        fn = operators[name];
        getTokenSkipNewline(state);
        params = [node, parseConversion(state)];
        node = new OperatorNode(name, fn, params);
      }

      return node;
    }
    /**
     * conversion operators 'to' and 'in'
     * @return {Node} node
     * @private
     */


    function parseConversion(state) {
      var node, name, fn, params;
      node = parseRange(state);
      var operators = {
        to: 'to',
        "in": 'to' // alias of 'to'

      };

      while (hasOwnProperty(operators, state.token)) {
        name = state.token;
        fn = operators[name];
        getTokenSkipNewline(state);

        if (name === 'in' && state.token === '') {
          // end of expression -> this is the unit 'in' ('inch')
          node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);
        } else {
          // operator 'a to b' or 'a in b'
          params = [node, parseRange(state)];
          node = new OperatorNode(name, fn, params);
        }
      }

      return node;
    }
    /**
     * parse range, "start:end", "start:step:end", ":", "start:", ":end", etc
     * @return {Node} node
     * @private
     */


    function parseRange(state) {
      var node;
      var params = [];

      if (state.token === ':') {
        // implicit start=1 (one-based)
        node = new ConstantNode(1);
      } else {
        // explicit start
        node = parseAddSubtract(state);
      }

      if (state.token === ':' && state.conditionalLevel !== state.nestingLevel) {
        // we ignore the range operator when a conditional operator is being processed on the same level
        params.push(node); // parse step and end

        while (state.token === ':' && params.length < 3) {
          // eslint-disable-line no-unmodified-loop-condition
          getTokenSkipNewline(state);

          if (state.token === ')' || state.token === ']' || state.token === ',' || state.token === '') {
            // implicit end
            params.push(new SymbolNode('end'));
          } else {
            // explicit end
            params.push(parseAddSubtract(state));
          }
        }

        if (params.length === 3) {
          // params = [start, step, end]
          node = new RangeNode(params[0], params[2], params[1]); // start, end, step
        } else {
          // length === 2
          // params = [start, end]
          node = new RangeNode(params[0], params[1]); // start, end
        }
      }

      return node;
    }
    /**
     * add or subtract
     * @return {Node} node
     * @private
     */


    function parseAddSubtract(state) {
      var node, name, fn, params;
      node = parseMultiplyDivide(state);
      var operators = {
        '+': 'add',
        '-': 'subtract'
      };

      while (hasOwnProperty(operators, state.token)) {
        name = state.token;
        fn = operators[name];
        getTokenSkipNewline(state);
        params = [node, parseMultiplyDivide(state)];
        node = new OperatorNode(name, fn, params);
      }

      return node;
    }
    /**
     * multiply, divide, modulus
     * @return {Node} node
     * @private
     */


    function parseMultiplyDivide(state) {
      var node, last, name, fn;
      node = parseImplicitMultiplication(state);
      last = node;
      var operators = {
        '*': 'multiply',
        '.*': 'dotMultiply',
        '/': 'divide',
        './': 'dotDivide',
        '%': 'mod',
        mod: 'mod'
      };

      while (true) {
        if (hasOwnProperty(operators, state.token)) {
          // explicit operators
          name = state.token;
          fn = operators[name];
          getTokenSkipNewline(state);
          last = parseImplicitMultiplication(state);
          node = new OperatorNode(name, fn, [node, last]);
        } else {
          break;
        }
      }

      return node;
    }
    /**
     * implicit multiplication
     * @return {Node} node
     * @private
     */


    function parseImplicitMultiplication(state) {
      var node, last;
      node = parseRule2(state);
      last = node;

      while (true) {
        if (state.tokenType === TOKENTYPE.SYMBOL || state.token === 'in' && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === '!') || state.token === '(') {
          // parse implicit multiplication
          //
          // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'
          // number:      implicit multiplication like '(2+3)2'
          // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'
          last = parseRule2(state);
          node = new OperatorNode('*', 'multiply', [node, last], true
          /* implicit */
          );
        } else {
          break;
        }
      }

      return node;
    }
    /**
     * Infamous "rule 2" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370
     * Explicit division gets higher precedence than implicit multiplication
     * when the division matches this pattern: [number] / [number] [symbol]
     * @return {Node} node
     * @private
     */


    function parseRule2(state) {
      var node = parseUnary(state);
      var last = node;
      var tokenStates = [];

      while (true) {
        // Match the "number /" part of the pattern "number / number symbol"
        if (state.token === '/' && isConstantNode(last)) {
          // Look ahead to see if the next token is a number
          tokenStates.push(_extends$4({}, state));
          getTokenSkipNewline(state); // Match the "number / number" part of the pattern

          if (state.tokenType === TOKENTYPE.NUMBER) {
            // Look ahead again
            tokenStates.push(_extends$4({}, state));
            getTokenSkipNewline(state); // Match the "symbol" part of the pattern, or a left parenthesis

            if (state.tokenType === TOKENTYPE.SYMBOL || state.token === '(') {
              // We've matched the pattern "number / number symbol".
              // Rewind once and build the "number / number" node; the symbol will be consumed later
              _extends$4(state, tokenStates.pop());

              tokenStates.pop();
              last = parseUnary(state);
              node = new OperatorNode('/', 'divide', [node, last]);
            } else {
              // Not a match, so rewind
              tokenStates.pop();

              _extends$4(state, tokenStates.pop());

              break;
            }
          } else {
            // Not a match, so rewind
            _extends$4(state, tokenStates.pop());

            break;
          }
        } else {
          break;
        }
      }

      return node;
    }
    /**
     * Unary plus and minus, and logical and bitwise not
     * @return {Node} node
     * @private
     */


    function parseUnary(state) {
      var name, params, fn;
      var operators = {
        '-': 'unaryMinus',
        '+': 'unaryPlus',
        '~': 'bitNot',
        not: 'not'
      };

      if (hasOwnProperty(operators, state.token)) {
        fn = operators[state.token];
        name = state.token;
        getTokenSkipNewline(state);
        params = [parseUnary(state)];
        return new OperatorNode(name, fn, params);
      }

      return parsePow(state);
    }
    /**
     * power
     * Note: power operator is right associative
     * @return {Node} node
     * @private
     */


    function parsePow(state) {
      var node, name, fn, params;
      node = parseLeftHandOperators(state);

      if (state.token === '^' || state.token === '.^') {
        name = state.token;
        fn = name === '^' ? 'pow' : 'dotPow';
        getTokenSkipNewline(state);
        params = [node, parseUnary(state)]; // Go back to unary, we can have '2^-3'

        node = new OperatorNode(name, fn, params);
      }

      return node;
    }
    /**
     * Left hand operators: factorial x!, ctranspose x'
     * @return {Node} node
     * @private
     */


    function parseLeftHandOperators(state) {
      var node, name, fn, params;
      node = parseCustomNodes(state);
      var operators = {
        '!': 'factorial',
        '\'': 'ctranspose'
      };

      while (hasOwnProperty(operators, state.token)) {
        name = state.token;
        fn = operators[name];
        getToken(state);
        params = [node];
        node = new OperatorNode(name, fn, params);
        node = parseAccessors(state, node);
      }

      return node;
    }
    /**
     * Parse a custom node handler. A node handler can be used to process
     * nodes in a custom way, for example for handling a plot.
     *
     * A handler must be passed as second argument of the parse function.
     * - must extend math.Node
     * - must contain a function _compile(defs: Object) : string
     * - must contain a function find(filter: Object) : Node[]
     * - must contain a function toString() : string
     * - the constructor is called with a single argument containing all parameters
     *
     * For example:
     *
     *     nodes = {
     *       'plot': PlotHandler
     *     }
     *
     * The constructor of the handler is called as:
     *
     *     node = new PlotHandler(params)
     *
     * The handler will be invoked when evaluating an expression like:
     *
     *     node = math.parse('plot(sin(x), x)', nodes)
     *
     * @return {Node} node
     * @private
     */


    function parseCustomNodes(state) {
      var params = [];

      if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {
        var CustomNode = state.extraNodes[state.token];
        getToken(state); // parse parameters

        if (state.token === '(') {
          params = [];
          openParams(state);
          getToken(state);

          if (state.token !== ')') {
            params.push(parseAssignment(state)); // parse a list with parameters

            while (state.token === ',') {
              // eslint-disable-line no-unmodified-loop-condition
              getToken(state);
              params.push(parseAssignment(state));
            }
          }

          if (state.token !== ')') {
            throw createSyntaxError(state, 'Parenthesis ) expected');
          }

          closeParams(state);
          getToken(state);
        } // create a new custom node
        // noinspection JSValidateTypes


        return new CustomNode(params);
      }

      return parseSymbol(state);
    }
    /**
     * parse symbols: functions, variables, constants, units
     * @return {Node} node
     * @private
     */


    function parseSymbol(state) {
      var node, name;

      if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
        name = state.token;
        getToken(state);

        if (hasOwnProperty(CONSTANTS, name)) {
          // true, false, null, ...
          node = new ConstantNode(CONSTANTS[name]);
        } else if (NUMERIC_CONSTANTS.indexOf(name) !== -1) {
          // NaN, Infinity
          node = new ConstantNode(numeric(name, 'number'));
        } else {
          node = new SymbolNode(name);
        } // parse function parameters and matrix index


        node = parseAccessors(state, node);
        return node;
      }

      return parseDoubleQuotesString(state);
    }
    /**
     * parse accessors:
     * - function invocation in round brackets (...), for example sqrt(2)
     * - index enclosed in square brackets [...], for example A[2,3]
     * - dot notation for properties, like foo.bar
     * @param {Object} state
     * @param {Node} node    Node on which to apply the parameters. If there
     *                       are no parameters in the expression, the node
     *                       itself is returned
     * @param {string[]} [types]  Filter the types of notations
     *                            can be ['(', '[', '.']
     * @return {Node} node
     * @private
     */


    function parseAccessors(state, node, types) {
      var params;

      while ((state.token === '(' || state.token === '[' || state.token === '.') && (!types || types.indexOf(state.token) !== -1)) {
        // eslint-disable-line no-unmodified-loop-condition
        params = [];

        if (state.token === '(') {
          if (isSymbolNode(node) || isAccessorNode(node)) {
            // function invocation like fn(2, 3) or obj.fn(2, 3)
            openParams(state);
            getToken(state);

            if (state.token !== ')') {
              params.push(parseAssignment(state)); // parse a list with parameters

              while (state.token === ',') {
                // eslint-disable-line no-unmodified-loop-condition
                getToken(state);
                params.push(parseAssignment(state));
              }
            }

            if (state.token !== ')') {
              throw createSyntaxError(state, 'Parenthesis ) expected');
            }

            closeParams(state);
            getToken(state);
            node = new FunctionNode(node, params);
          } else {
            // implicit multiplication like (2+3)(4+5) or sqrt(2)(1+2)
            // don't parse it here but let it be handled by parseImplicitMultiplication
            // with correct precedence
            return node;
          }
        } else if (state.token === '[') {
          // index notation like variable[2, 3]
          openParams(state);
          getToken(state);

          if (state.token !== ']') {
            params.push(parseAssignment(state)); // parse a list with parameters

            while (state.token === ',') {
              // eslint-disable-line no-unmodified-loop-condition
              getToken(state);
              params.push(parseAssignment(state));
            }
          }

          if (state.token !== ']') {
            throw createSyntaxError(state, 'Parenthesis ] expected');
          }

          closeParams(state);
          getToken(state);
          node = new AccessorNode(node, new IndexNode(params));
        } else {
          // dot notation like variable.prop
          getToken(state);

          if (state.tokenType !== TOKENTYPE.SYMBOL) {
            throw createSyntaxError(state, 'Property name expected after dot');
          }

          params.push(new ConstantNode(state.token));
          getToken(state);
          var dotNotation = true;
          node = new AccessorNode(node, new IndexNode(params, dotNotation));
        }
      }

      return node;
    }
    /**
     * Parse a double quotes string.
     * @return {Node} node
     * @private
     */


    function parseDoubleQuotesString(state) {
      var node, str;

      if (state.token === '"') {
        str = parseDoubleQuotesStringToken(state); // create constant

        node = new ConstantNode(str); // parse index parameters

        node = parseAccessors(state, node);
        return node;
      }

      return parseSingleQuotesString(state);
    }
    /**
     * Parse a string surrounded by double quotes "..."
     * @return {string}
     */


    function parseDoubleQuotesStringToken(state) {
      var str = '';

      while (currentCharacter(state) !== '' && currentCharacter(state) !== '"') {
        if (currentCharacter(state) === '\\') {
          // escape character, immediately process the next
          // character to prevent stopping at a next '\"'
          str += currentCharacter(state);
          next(state);
        }

        str += currentCharacter(state);
        next(state);
      }

      getToken(state);

      if (state.token !== '"') {
        throw createSyntaxError(state, 'End of string " expected');
      }

      getToken(state);
      return JSON.parse('"' + str + '"'); // unescape escaped characters
    }
    /**
     * Parse a single quotes string.
     * @return {Node} node
     * @private
     */


    function parseSingleQuotesString(state) {
      var node, str;

      if (state.token === '\'') {
        str = parseSingleQuotesStringToken(state); // create constant

        node = new ConstantNode(str); // parse index parameters

        node = parseAccessors(state, node);
        return node;
      }

      return parseMatrix(state);
    }
    /**
     * Parse a string surrounded by single quotes '...'
     * @return {string}
     */


    function parseSingleQuotesStringToken(state) {
      var str = '';

      while (currentCharacter(state) !== '' && currentCharacter(state) !== '\'') {
        if (currentCharacter(state) === '\\') {
          // escape character, immediately process the next
          // character to prevent stopping at a next '\''
          str += currentCharacter(state);
          next(state);
        }

        str += currentCharacter(state);
        next(state);
      }

      getToken(state);

      if (state.token !== '\'') {
        throw createSyntaxError(state, 'End of string \' expected');
      }

      getToken(state);
      return JSON.parse('"' + str + '"'); // unescape escaped characters
    }
    /**
     * parse the matrix
     * @return {Node} node
     * @private
     */


    function parseMatrix(state) {
      var array, params, rows, cols;

      if (state.token === '[') {
        // matrix [...]
        openParams(state);
        getToken(state);

        if (state.token !== ']') {
          // this is a non-empty matrix
          var row = parseRow(state);

          if (state.token === ';') {
            // 2 dimensional array
            rows = 1;
            params = [row]; // the rows of the matrix are separated by dot-comma's

            while (state.token === ';') {
              // eslint-disable-line no-unmodified-loop-condition
              getToken(state);
              params[rows] = parseRow(state);
              rows++;
            }

            if (state.token !== ']') {
              throw createSyntaxError(state, 'End of matrix ] expected');
            }

            closeParams(state);
            getToken(state); // check if the number of columns matches in all rows

            cols = params[0].items.length;

            for (var r = 1; r < rows; r++) {
              if (params[r].items.length !== cols) {
                throw createError(state, 'Column dimensions mismatch ' + '(' + params[r].items.length + ' !== ' + cols + ')');
              }
            }

            array = new ArrayNode(params);
          } else {
            // 1 dimensional vector
            if (state.token !== ']') {
              throw createSyntaxError(state, 'End of matrix ] expected');
            }

            closeParams(state);
            getToken(state);
            array = row;
          }
        } else {
          // this is an empty matrix "[ ]"
          closeParams(state);
          getToken(state);
          array = new ArrayNode([]);
        }

        return parseAccessors(state, array);
      }

      return parseObject(state);
    }
    /**
     * Parse a single comma-separated row from a matrix, like 'a, b, c'
     * @return {ArrayNode} node
     */


    function parseRow(state) {
      var params = [parseAssignment(state)];
      var len = 1;

      while (state.token === ',') {
        // eslint-disable-line no-unmodified-loop-condition
        getToken(state); // parse expression

        params[len] = parseAssignment(state);
        len++;
      }

      return new ArrayNode(params);
    }
    /**
     * parse an object, enclosed in angle brackets{...}, for example {value: 2}
     * @return {Node} node
     * @private
     */


    function parseObject(state) {
      if (state.token === '{') {
        openParams(state);
        var key;
        var properties = {};

        do {
          getToken(state);

          if (state.token !== '}') {
            // parse key
            if (state.token === '"') {
              key = parseDoubleQuotesStringToken(state);
            } else if (state.token === '\'') {
              key = parseSingleQuotesStringToken(state);
            } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
              key = state.token;
              getToken(state);
            } else {
              throw createSyntaxError(state, 'Symbol or string expected as object key');
            } // parse key/value separator


            if (state.token !== ':') {
              throw createSyntaxError(state, 'Colon : expected after object key');
            }

            getToken(state); // parse key

            properties[key] = parseAssignment(state);
          }
        } while (state.token === ','); // eslint-disable-line no-unmodified-loop-condition


        if (state.token !== '}') {
          throw createSyntaxError(state, 'Comma , or bracket } expected after object value');
        }

        closeParams(state);
        getToken(state);
        var node = new ObjectNode(properties); // parse index parameters

        node = parseAccessors(state, node);
        return node;
      }

      return parseNumber(state);
    }
    /**
     * parse a number
     * @return {Node} node
     * @private
     */


    function parseNumber(state) {
      var numberStr;

      if (state.tokenType === TOKENTYPE.NUMBER) {
        // this is a number
        numberStr = state.token;
        getToken(state);
        return new ConstantNode(numeric(numberStr, config.number));
      }

      return parseParentheses(state);
    }
    /**
     * parentheses
     * @return {Node} node
     * @private
     */


    function parseParentheses(state) {
      var node; // check if it is a parenthesized expression

      if (state.token === '(') {
        // parentheses (...)
        openParams(state);
        getToken(state);
        node = parseAssignment(state); // start again

        if (state.token !== ')') {
          throw createSyntaxError(state, 'Parenthesis ) expected');
        }

        closeParams(state);
        getToken(state);
        node = new ParenthesisNode(node);
        node = parseAccessors(state, node);
        return node;
      }

      return parseEnd(state);
    }
    /**
     * Evaluated when the expression is not yet ended but expected to end
     * @return {Node} res
     * @private
     */


    function parseEnd(state) {
      if (state.token === '') {
        // syntax error or unexpected end of expression
        throw createSyntaxError(state, 'Unexpected end of expression');
      } else {
        throw createSyntaxError(state, 'Value expected');
      }
    }
    /**
     * Shortcut for getting the current row value (one based)
     * Returns the line of the currently handled expression
     * @private
     */

    /* TODO: implement keeping track on the row number
    function row () {
      return null
    }
    */

    /**
     * Shortcut for getting the current col value (one based)
     * Returns the column (position) where the last state.token starts
     * @private
     */


    function col(state) {
      return state.index - state.token.length + 1;
    }
    /**
     * Create an error
     * @param {Object} state
     * @param {string} message
     * @return {SyntaxError} instantiated error
     * @private
     */


    function createSyntaxError(state, message) {
      var c = col(state);
      var error = new SyntaxError(message + ' (char ' + c + ')');
      error["char"] = c;
      return error;
    }
    /**
     * Create an error
     * @param {Object} state
     * @param {string} message
     * @return {Error} instantiated error
     * @private
     */


    function createError(state, message) {
      var c = col(state);
      var error = new SyntaxError(message + ' (char ' + c + ')');
      error["char"] = c;
      return error;
    }

    return parse;
  });

  var name$3d = 'compile';
  var dependencies$3e = ['typed', 'parse'];
  var createCompile = /* #__PURE__ */factory(name$3d, dependencies$3e, function (_ref) {
    var typed = _ref.typed,
        parse = _ref.parse;

    /**
     * Parse and compile an expression.
     * Returns a an object with a function `evaluate([scope])` to evaluate the
     * compiled expression.
     *
     * Syntax:
     *
     *     math.compile(expr)                       // returns one node
     *     math.compile([expr1, expr2, expr3, ...]) // returns an array with nodes
     *
     * Examples:
     *
     *     const code1 = math.compile('sqrt(3^2 + 4^2)')
     *     code1.evaluate() // 5
     *
     *     let scope = {a: 3, b: 4}
     *     const code2 = math.compile('a * b') // 12
     *     code2.evaluate(scope) // 12
     *     scope.a = 5
     *     code2.evaluate(scope) // 20
     *
     *     const nodes = math.compile(['a = 3', 'b = 4', 'a * b'])
     *     nodes[2].evaluate() // 12
     *
     * See also:
     *
     *    parse, evaluate
     *
     * @param {string | string[] | Array | Matrix} expr
     *            The expression to be compiled
     * @return {{evaluate: Function} | Array.<{evaluate: Function}>} code
     *            An object with the compiled expression
     * @throws {Error}
     */
    return typed(name$3d, {
      string: function string(expr) {
        return parse(expr).compile();
      },
      'Array | Matrix': function ArrayMatrix(expr) {
        return deepMap(expr, function (entry) {
          return parse(entry).compile();
        });
      }
    });
  });

  var name$3e = 'evaluate';
  var dependencies$3f = ['typed', 'parse'];
  var createEvaluate = /* #__PURE__ */factory(name$3e, dependencies$3f, function (_ref) {
    var typed = _ref.typed,
        parse = _ref.parse;

    /**
     * Evaluate an expression.
     *
     * Note the evaluating arbitrary expressions may involve security risks,
     * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.
     *
     * Syntax:
     *
     *     math.evaluate(expr)
     *     math.evaluate(expr, scope)
     *     math.evaluate([expr1, expr2, expr3, ...])
     *     math.evaluate([expr1, expr2, expr3, ...], scope)
     *
     * Example:
     *
     *     math.evaluate('(2+3)/4')                // 1.25
     *     math.evaluate('sqrt(3^2 + 4^2)')        // 5
     *     math.evaluate('sqrt(-4)')               // 2i
     *     math.evaluate(['a=3', 'b=4', 'a*b'])    // [3, 4, 12]
     *
     *     let scope = {a:3, b:4}
     *     math.evaluate('a * b', scope)           // 12
     *
     * See also:
     *
     *    parse, compile
     *
     * @param {string | string[] | Matrix} expr   The expression to be evaluated
     * @param {Object} [scope]                    Scope to read/write variables
     * @return {*} The result of the expression
     * @throws {Error}
     */
    return typed(name$3e, {
      string: function string(expr) {
        var scope = {};
        return parse(expr).compile().evaluate(scope);
      },
      'string, Object': function stringObject(expr, scope) {
        return parse(expr).compile().evaluate(scope);
      },
      'Array | Matrix': function ArrayMatrix(expr) {
        var scope = {};
        return deepMap(expr, function (entry) {
          return parse(entry).compile().evaluate(scope);
        });
      },
      'Array | Matrix, Object': function ArrayMatrixObject(expr, scope) {
        return deepMap(expr, function (entry) {
          return parse(entry).compile().evaluate(scope);
        });
      }
    });
  });

  var name$3f = 'Parser';
  var dependencies$3g = ['parse'];
  var createParserClass = /* #__PURE__ */factory(name$3f, dependencies$3g, function (_ref) {
    var parse = _ref.parse;

    /**
     * @constructor Parser
     * Parser contains methods to evaluate or parse expressions, and has a number
     * of convenience methods to get, set, and remove variables from memory. Parser
     * keeps a scope containing variables in memory, which is used for all
     * evaluations.
     *
     * Methods:
     *    const result = parser.evaluate(expr)  // evaluate an expression
     *    const value = parser.get(name)        // retrieve a variable from the parser
     *    const values = parser.getAll()        // retrieve all defined variables
     *    parser.set(name, value)               // set a variable in the parser
     *    parser.remove(name)                   // clear a variable from the
     *                                          // parsers scope
     *    parser.clear()                        // clear the parsers scope
     *
     * Example usage:
     *    const parser = new Parser()
     *    // Note: there is a convenience method which can be used instead:
     *    // const parser = new math.parser()
     *
     *    // evaluate expressions
     *    parser.evaluate('sqrt(3^2 + 4^2)')        // 5
     *    parser.evaluate('sqrt(-4)')               // 2i
     *    parser.evaluate('2 inch in cm')           // 5.08 cm
     *    parser.evaluate('cos(45 deg)')            // 0.7071067811865476
     *
     *    // define variables and functions
     *    parser.evaluate('x = 7 / 2')              // 3.5
     *    parser.evaluate('x + 3')                  // 6.5
     *    parser.evaluate('function f(x, y) = x^y') // f(x, y)
     *    parser.evaluate('f(2, 3)')                // 8
     *
     *    // get and set variables and functions
     *    const x = parser.get('x')                 // 7
     *    const f = parser.get('f')                 // function
     *    const g = f(3, 2)                         // 9
     *    parser.set('h', 500)
     *    const i = parser.evaluate('h / 2')        // 250
     *    parser.set('hello', function (name) {
     *        return 'hello, ' + name + '!'
     *    })
     *    parser.evaluate('hello("user")')          // "hello, user!"
     *
     *    // clear defined functions and variables
     *    parser.clear()
     *
     */
    function Parser() {
      if (!(this instanceof Parser)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      this.scope = {};
    }
    /**
     * Attach type information
     */


    Parser.prototype.type = 'Parser';
    Parser.prototype.isParser = true;
    /**
     * Parse and evaluate the given expression
     * @param {string} expr   A string containing an expression, for example "2+3"
     * @return {*} result     The result, or undefined when the expression was empty
     * @throws {Error}
     */

    Parser.prototype.evaluate = function (expr) {
      // TODO: validate arguments
      return parse(expr).compile().evaluate(this.scope);
    };
    /**
     * Get a variable (a function or variable) by name from the parsers scope.
     * Returns undefined when not found
     * @param {string} name
     * @return {* | undefined} value
     */


    Parser.prototype.get = function (name) {
      // TODO: validate arguments
      return name in this.scope ? getSafeProperty(this.scope, name) : undefined;
    };
    /**
     * Get a map with all defined variables
     * @return {Object} values
     */


    Parser.prototype.getAll = function () {
      return extend({}, this.scope);
    };
    /**
     * Set a symbol (a function or variable) by name from the parsers scope.
     * @param {string} name
     * @param {* | undefined} value
     */


    Parser.prototype.set = function (name, value) {
      // TODO: validate arguments
      return setSafeProperty(this.scope, name, value);
    };
    /**
     * Remove a variable from the parsers scope
     * @param {string} name
     */


    Parser.prototype.remove = function (name) {
      // TODO: validate arguments
      delete this.scope[name];
    };
    /**
     * Clear the scope with variables and functions
     */


    Parser.prototype.clear = function () {
      for (var _name in this.scope) {
        if (hasOwnProperty(this.scope, _name)) {
          delete this.scope[_name];
        }
      }
    };

    return Parser;
  }, {
    isClass: true
  });

  var name$3g = 'parser';
  var dependencies$3h = ['typed', 'Parser'];
  var createParser = /* #__PURE__ */factory(name$3g, dependencies$3h, function (_ref) {
    var typed = _ref.typed,
        Parser = _ref.Parser;

    /**
     * Create a parser. The function creates a new `math.Parser` object.
     *
     * Syntax:
     *
     *    math.parser()
     *
     * Examples:
     *
     *     const parser = new math.parser()
     *
     *     // evaluate expressions
     *     const a = parser.evaluate('sqrt(3^2 + 4^2)') // 5
     *     const b = parser.evaluate('sqrt(-4)')        // 2i
     *     const c = parser.evaluate('2 inch in cm')    // 5.08 cm
     *     const d = parser.evaluate('cos(45 deg)')     // 0.7071067811865476
     *
     *     // define variables and functions
     *     parser.evaluate('x = 7 / 2')                 // 3.5
     *     parser.evaluate('x + 3')                     // 6.5
     *     parser.evaluate('function f(x, y) = x^y')    // f(x, y)
     *     parser.evaluate('f(2, 3)')                   // 8
     *
     *     // get and set variables and functions
     *     const x = parser.get('x')                // 7
     *     const f = parser.get('f')                // function
     *     const g = f(3, 2)                        // 9
     *     parser.set('h', 500)
     *     const i = parser.evaluate('h / 2')       // 250
     *     parser.set('hello', function (name) {
     *       return 'hello, ' + name + '!'
     *     })
     *     parser.evaluate('hello("user")')         // "hello, user!"
     *
     *     // clear defined functions and variables
     *     parser.clear()
     *
     * See also:
     *
     *    evaluate, compile, parse
     *
     * @return {Parser} Parser
     */
    return typed(name$3g, {
      '': function _() {
        return new Parser();
      }
    });
  });

  var name$3h = 'lup';
  var dependencies$3i = ['typed', 'matrix', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'larger', 'equalScalar', 'unaryMinus', 'DenseMatrix', 'SparseMatrix', 'Spa'];
  var createLup = /* #__PURE__ */factory(name$3h, dependencies$3i, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        abs = _ref.abs,
        addScalar = _ref.addScalar,
        divideScalar = _ref.divideScalar,
        multiplyScalar = _ref.multiplyScalar,
        subtract = _ref.subtract,
        larger = _ref.larger,
        equalScalar = _ref.equalScalar,
        unaryMinus = _ref.unaryMinus,
        DenseMatrix = _ref.DenseMatrix,
        SparseMatrix = _ref.SparseMatrix,
        Spa = _ref.Spa;

    /**
     * Calculate the Matrix LU decomposition with partial pivoting. Matrix `A` is decomposed in two matrices (`L`, `U`) and a
     * row permutation vector `p` where `A[p,:] = L * U`
     *
     * Syntax:
     *
     *    math.lup(A)
     *
     * Example:
     *
     *    const m = [[2, 1], [1, 4]]
     *    const r = math.lup(m)
     *    // r = {
     *    //   L: [[1, 0], [0.5, 1]],
     *    //   U: [[2, 1], [0, 3.5]],
     *    //   P: [0, 1]
     *    // }
     *
     * See also:
     *
     *    slu, lsolve, lusolve, usolve
     *
     * @param {Matrix | Array} A    A two dimensional matrix or array for which to get the LUP decomposition.
     *
     * @return {{L: Array | Matrix, U: Array | Matrix, P: Array.<number>}} The lower triangular matrix, the upper triangular matrix and the permutation matrix.
     */
    return typed(name$3h, {
      DenseMatrix: function DenseMatrix(m) {
        return _denseLUP(m);
      },
      SparseMatrix: function SparseMatrix(m) {
        return _sparseLUP(m);
      },
      Array: function Array(a) {
        // create dense matrix from array
        var m = matrix(a); // lup, use matrix implementation

        var r = _denseLUP(m); // result


        return {
          L: r.L.valueOf(),
          U: r.U.valueOf(),
          p: r.p
        };
      }
    });

    function _denseLUP(m) {
      // rows & columns
      var rows = m._size[0];
      var columns = m._size[1]; // minimum rows and columns

      var n = Math.min(rows, columns); // matrix array, clone original data

      var data = clone(m._data); // l matrix arrays

      var ldata = [];
      var lsize = [rows, n]; // u matrix arrays

      var udata = [];
      var usize = [n, columns]; // vars

      var i, j, k; // permutation vector

      var p = [];

      for (i = 0; i < rows; i++) {
        p[i] = i;
      } // loop columns


      for (j = 0; j < columns; j++) {
        // skip first column in upper triangular matrix
        if (j > 0) {
          // loop rows
          for (i = 0; i < rows; i++) {
            // min i,j
            var min = Math.min(i, j); // v[i, j]

            var s = 0; // loop up to min

            for (k = 0; k < min; k++) {
              // s = l[i, k] - data[k, j]
              s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));
            }

            data[i][j] = subtract(data[i][j], s);
          }
        } // row with larger value in cvector, row >= j


        var pi = j;
        var pabsv = 0;
        var vjj = 0; // loop rows

        for (i = j; i < rows; i++) {
          // data @ i, j
          var v = data[i][j]; // absolute value

          var absv = abs(v); // value is greater than pivote value

          if (larger(absv, pabsv)) {
            // store row
            pi = i; // update max value

            pabsv = absv; // value @ [j, j]

            vjj = v;
          }
        } // swap rows (j <-> pi)


        if (j !== pi) {
          // swap values j <-> pi in p
          p[j] = [p[pi], p[pi] = p[j]][0]; // swap j <-> pi in data

          DenseMatrix._swapRows(j, pi, data);
        } // check column is in lower triangular matrix


        if (j < rows) {
          // loop rows (lower triangular matrix)
          for (i = j + 1; i < rows; i++) {
            // value @ i, j
            var vij = data[i][j];

            if (!equalScalar(vij, 0)) {
              // update data
              data[i][j] = divideScalar(data[i][j], vjj);
            }
          }
        }
      } // loop columns


      for (j = 0; j < columns; j++) {
        // loop rows
        for (i = 0; i < rows; i++) {
          // initialize row in arrays
          if (j === 0) {
            // check row exists in upper triangular matrix
            if (i < columns) {
              // U
              udata[i] = [];
            } // L


            ldata[i] = [];
          } // check we are in the upper triangular matrix


          if (i < j) {
            // check row exists in upper triangular matrix
            if (i < columns) {
              // U
              udata[i][j] = data[i][j];
            } // check column exists in lower triangular matrix


            if (j < rows) {
              // L
              ldata[i][j] = 0;
            }

            continue;
          } // diagonal value


          if (i === j) {
            // check row exists in upper triangular matrix
            if (i < columns) {
              // U
              udata[i][j] = data[i][j];
            } // check column exists in lower triangular matrix


            if (j < rows) {
              // L
              ldata[i][j] = 1;
            }

            continue;
          } // check row exists in upper triangular matrix


          if (i < columns) {
            // U
            udata[i][j] = 0;
          } // check column exists in lower triangular matrix


          if (j < rows) {
            // L
            ldata[i][j] = data[i][j];
          }
        }
      } // l matrix


      var l = new DenseMatrix({
        data: ldata,
        size: lsize
      }); // u matrix

      var u = new DenseMatrix({
        data: udata,
        size: usize
      }); // p vector

      var pv = [];

      for (i = 0, n = p.length; i < n; i++) {
        pv[p[i]] = i;
      } // return matrices


      return {
        L: l,
        U: u,
        p: pv,
        toString: function toString() {
          return 'L: ' + this.L.toString() + '\nU: ' + this.U.toString() + '\nP: ' + this.p;
        }
      };
    }

    function _sparseLUP(m) {
      // rows & columns
      var rows = m._size[0];
      var columns = m._size[1]; // minimum rows and columns

      var n = Math.min(rows, columns); // matrix arrays (will not be modified, thanks to permutation vector)

      var values$$1 = m._values;
      var index = m._index;
      var ptr = m._ptr; // l matrix arrays

      var lvalues = [];
      var lindex = [];
      var lptr = [];
      var lsize = [rows, n]; // u matrix arrays

      var uvalues = [];
      var uindex = [];
      var uptr = [];
      var usize = [n, columns]; // vars

      var i, j, k; // permutation vectors, (current index -> original index) and (original index -> current index)

      var pvCo = [];
      var pvOc = [];

      for (i = 0; i < rows; i++) {
        pvCo[i] = i;
        pvOc[i] = i;
      } // swap indices in permutation vectors (condition x < y)!


      var swapIndeces = function swapIndeces(x, y) {
        // find pv indeces getting data from x and y
        var kx = pvOc[x];
        var ky = pvOc[y]; // update permutation vector current -> original

        pvCo[kx] = y;
        pvCo[ky] = x; // update permutation vector original -> current

        pvOc[x] = ky;
        pvOc[y] = kx;
      }; // loop columns


      var _loop = function _loop() {
        // sparse accumulator
        var spa = new Spa(); // check lower triangular matrix has a value @ column j

        if (j < rows) {
          // update ptr
          lptr.push(lvalues.length); // first value in j column for lower triangular matrix

          lvalues.push(1);
          lindex.push(j);
        } // update ptr


        uptr.push(uvalues.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]

        var k0 = ptr[j];
        var k1 = ptr[j + 1]; // copy column j into sparse accumulator

        for (k = k0; k < k1; k++) {
          // row
          i = index[k]; // copy column values into sparse accumulator (use permutation vector)

          spa.set(pvCo[i], values$$1[k]);
        } // skip first column in upper triangular matrix


        if (j > 0) {
          // loop rows in column j (above diagonal)
          spa.forEach(0, j - 1, function (k, vkj) {
            // loop rows in column k (L)
            SparseMatrix._forEachRow(k, lvalues, lindex, lptr, function (i, vik) {
              // check row is below k
              if (i > k) {
                // update spa value
                spa.accumulate(i, unaryMinus(multiplyScalar(vik, vkj)));
              }
            });
          });
        } // row with larger value in spa, row >= j


        var pi = j;
        var vjj = spa.get(j);
        var pabsv = abs(vjj); // loop values in spa (order by row, below diagonal)

        spa.forEach(j + 1, rows - 1, function (x, v) {
          // absolute value
          var absv = abs(v); // value is greater than pivote value

          if (larger(absv, pabsv)) {
            // store row
            pi = x; // update max value

            pabsv = absv; // value @ [j, j]

            vjj = v;
          }
        }); // swap rows (j <-> pi)

        if (j !== pi) {
          // swap values j <-> pi in L
          SparseMatrix._swapRows(j, pi, lsize[1], lvalues, lindex, lptr); // swap values j <-> pi in U


          SparseMatrix._swapRows(j, pi, usize[1], uvalues, uindex, uptr); // swap values in spa


          spa.swap(j, pi); // update permutation vector (swap values @ j, pi)

          swapIndeces(j, pi);
        } // loop values in spa (order by row)


        spa.forEach(0, rows - 1, function (x, v) {
          // check we are above diagonal
          if (x <= j) {
            // update upper triangular matrix
            uvalues.push(v);
            uindex.push(x);
          } else {
            // update value
            v = divideScalar(v, vjj); // check value is non zero

            if (!equalScalar(v, 0)) {
              // update lower triangular matrix
              lvalues.push(v);
              lindex.push(x);
            }
          }
        });
      };

      for (j = 0; j < columns; j++) {
        _loop();
      } // update ptrs


      uptr.push(uvalues.length);
      lptr.push(lvalues.length); // return matrices

      return {
        L: new SparseMatrix({
          values: lvalues,
          index: lindex,
          ptr: lptr,
          size: lsize
        }),
        U: new SparseMatrix({
          values: uvalues,
          index: uindex,
          ptr: uptr,
          size: usize
        }),
        p: pvCo,
        toString: function toString() {
          return 'L: ' + this.L.toString() + '\nU: ' + this.U.toString() + '\nP: ' + this.p;
        }
      };
    }
  });

  function _extends$5() { _extends$5 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$5.apply(this, arguments); }
  var name$3i = 'qr';
  var dependencies$3j = ['typed', 'matrix', 'zeros', 'identity', 'isZero', 'equal', 'sign', 'sqrt', 'conj', 'unaryMinus', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'complex'];
  var createQr = /* #__PURE__ */factory(name$3i, dependencies$3j, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        zeros = _ref.zeros,
        identity = _ref.identity,
        isZero = _ref.isZero,
        equal = _ref.equal,
        sign = _ref.sign,
        sqrt = _ref.sqrt,
        conj = _ref.conj,
        unaryMinus = _ref.unaryMinus,
        addScalar = _ref.addScalar,
        divideScalar = _ref.divideScalar,
        multiplyScalar = _ref.multiplyScalar,
        subtract = _ref.subtract,
        complex = _ref.complex;

    /**
     * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in
     * two matrices (`Q`, `R`) where `Q` is an
     * orthogonal matrix and `R` is an upper triangular matrix.
     *
     * Syntax:
     *
     *    math.qr(A)
     *
     * Example:
     *
     *    const m = [
     *      [1, -1,  4],
     *      [1,  4, -2],
     *      [1,  4,  2],
     *      [1,  -1, 0]
     *    ]
     *    const result = math.qr(m)
     *    // r = {
     *    //   Q: [
     *    //     [0.5, -0.5,   0.5],
     *    //     [0.5,  0.5,  -0.5],
     *    //     [0.5,  0.5,   0.5],
     *    //     [0.5, -0.5,  -0.5],
     *    //   ],
     *    //   R: [
     *    //     [2, 3,  2],
     *    //     [0, 5, -2],
     *    //     [0, 0,  4],
     *    //     [0, 0,  0]
     *    //   ]
     *    // }
     *
     * See also:
     *
     *    lup, lusolve
     *
     * @param {Matrix | Array} A    A two dimensional matrix or array
     * for which to get the QR decomposition.
     *
     * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal
     * matrix and R: the upper triangular matrix
     */
    return _extends$5(typed(name$3i, {
      DenseMatrix: function DenseMatrix(m) {
        return _denseQR(m);
      },
      SparseMatrix: function SparseMatrix(m) {
        return _sparseQR(m);
      },
      Array: function Array(a) {
        // create dense matrix from array
        var m = matrix(a); // lup, use matrix implementation

        var r = _denseQR(m); // result


        return {
          Q: r.Q.valueOf(),
          R: r.R.valueOf()
        };
      }
    }), {
      _denseQRimpl: _denseQRimpl
    });

    function _denseQRimpl(m) {
      // rows & columns (m x n)
      var rows = m._size[0]; // m

      var cols = m._size[1]; // n

      var Q = identity([rows], 'dense');
      var Qdata = Q._data;
      var R = m.clone();
      var Rdata = R._data; // vars

      var i, j, k;
      var w = zeros([rows], '');

      for (k = 0; k < Math.min(cols, rows); ++k) {
        /*
         * **k-th Household matrix**
         *
         * The matrix I - 2*v*transpose(v)
         * x     = first column of A
         * x1    = first element of x
         * alpha = x1 / |x1| * |x|
         * e1    = tranpose([1, 0, 0, ...])
         * u     = x - alpha * e1
         * v     = u / |u|
         *
         * Household matrix = I - 2 * v * tranpose(v)
         *
         *  * Initially Q = I and R = A.
         *  * Household matrix is a reflection in a plane normal to v which
         *    will zero out all but the top right element in R.
         *  * Appplying reflection to both Q and R will not change product.
         *  * Repeat this process on the (1,1) minor to get R as an upper
         *    triangular matrix.
         *  * Reflections leave the magnitude of the columns of Q unchanged
         *    so Q remains othoganal.
         *
         */
        var pivot = Rdata[k][k];
        var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign(pivot));
        var conjSgn = conj(sgn);
        var alphaSquared = 0;

        for (i = k; i < rows; i++) {
          alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));
        }

        var alpha = multiplyScalar(sgn, sqrt(alphaSquared));

        if (!isZero(alpha)) {
          // first element in vector u
          var u1 = subtract(pivot, alpha); // w = v * u1 / |u|    (only elements k to (rows-1) are used)

          w[k] = 1;

          for (i = k + 1; i < rows; i++) {
            w[i] = divideScalar(Rdata[i][k], u1);
          } // tau = - conj(u1 / alpha)


          var tau = unaryMinus(conj(divideScalar(u1, alpha)));
          var s = void 0;
          /*
           * tau and w have been choosen so that
           *
           * 2 * v * tranpose(v) = tau * w * tranpose(w)
           */

          /*
           * -- calculate R = R - tau * w * tranpose(w) * R --
           * Only do calculation with rows k to (rows-1)
           * Additionally columns 0 to (k-1) will not be changed by this
           *   multiplication so do not bother recalculating them
           */

          for (j = k; j < cols; j++) {
            s = 0.0; // calculate jth element of [tranpose(w) * R]

            for (i = k; i < rows; i++) {
              s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));
            } // calculate the jth element of [tau * transpose(w) * R]


            s = multiplyScalar(s, tau);

            for (i = k; i < rows; i++) {
              Rdata[i][j] = multiplyScalar(subtract(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);
            }
          }
          /*
           * -- calculate Q = Q - tau * Q * w * transpose(w) --
           * Q is a square matrix (rows x rows)
           * Only do calculation with columns k to (rows-1)
           * Additionally rows 0 to (k-1) will not be changed by this
           *   multiplication so do not bother recalculating them
           */


          for (i = 0; i < rows; i++) {
            s = 0.0; // calculate ith element of [Q * w]

            for (j = k; j < rows; j++) {
              s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));
            } // calculate the ith element of [tau * Q * w]


            s = multiplyScalar(s, tau);

            for (j = k; j < rows; ++j) {
              Qdata[i][j] = divideScalar(subtract(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);
            }
          }
        }
      } // return matrices


      return {
        Q: Q,
        R: R,
        toString: function toString() {
          return 'Q: ' + this.Q.toString() + '\nR: ' + this.R.toString();
        }
      };
    }

    function _denseQR(m) {
      var ret = _denseQRimpl(m);

      var Rdata = ret.R._data;

      if (m._data.length > 0) {
        var zero = Rdata[0][0].type === 'Complex' ? complex(0) : 0;

        for (var i = 0; i < Rdata.length; ++i) {
          for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {
            Rdata[i][j] = zero;
          }
        }
      }

      return ret;
    }

    function _sparseQR(m) {
      throw new Error('qr not implemented for sparse matrices yet');
    }
  });

  /**
   * Permutes a sparse matrix C = P * A * Q
   *
   * @param {SparseMatrix}  a         The Matrix A
   * @param {Array}   pinv            The row permutation vector
   * @param {Array}   q               The column permutation vector
   * @param {boolean} values          Create a pattern matrix (false), values and pattern otherwise
   *
   * @return {Matrix}                 C = P * A * Q, null on error
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  function csPermute(a, pinv, q, values) {
    // a arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype; // rows & columns

    var m = asize[0];
    var n = asize[1]; // c arrays

    var cvalues = values && a._values ? [] : null;
    var cindex = []; // (aptr[n])

    var cptr = []; // (n + 1)
    // initialize vars

    var nz = 0; // loop columns

    for (var k = 0; k < n; k++) {
      // column k of C is column q[k] of A
      cptr[k] = nz; // apply column permutation

      var j = q ? q[k] : k; // loop values in column j of A

      for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {
        // row i of A is row pinv[i] of C
        var r = pinv ? pinv[aindex[t]] : aindex[t]; // index

        cindex[nz] = r; // check we need to populate values

        if (cvalues) {
          cvalues[nz] = avalues[t];
        } // increment number of nonzero elements


        nz++;
      }
    } // finalize the last column of C


    cptr[n] = nz; // return C matrix

    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [m, n],
      datatype: adt
    });
  }

  /**
   * Depth-first search and postorder of a tree rooted at node j
   *
   * @param {Number}  j               The tree node
   * @param {Number}  k
   * @param {Array}   w               The workspace array
   * @param {Number}  head            The index offset within the workspace for the head array
   * @param {Number}  next            The index offset within the workspace for the next array
   * @param {Array}   post            The post ordering array
   * @param {Number}  stack           The index offset within the workspace for the stack array
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  function csTdfs(j, k, w, head, next, post, stack) {
    // variables
    var top = 0; // place j on the stack

    w[stack] = j; // while (stack is not empty)

    while (top >= 0) {
      // p = top of stack
      var p = w[stack + top]; // i = youngest child of p

      var i = w[head + p];

      if (i === -1) {
        // p has no unordered children left
        top--; // node p is the kth postordered node

        post[k++] = p;
      } else {
        // remove i from children of p
        w[head + p] = w[next + i]; // increment top

        ++top; // start dfs on child node i

        w[stack + top] = i;
      }
    }

    return k;
  }

  /**
   * Post order a tree of forest
   *
   * @param {Array}   parent          The tree or forest
   * @param {Number}  n               Number of columns
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */

  function csPost(parent, n) {
    // check inputs
    if (!parent) {
      return null;
    } // vars


    var k = 0;
    var j; // allocate result

    var post = []; // (n)
    // workspace, head: first n entries, next: next n entries, stack: last n entries

    var w = []; // (3 * n)

    var head = 0;
    var next = n;
    var stack = 2 * n; // initialize workspace

    for (j = 0; j < n; j++) {
      // empty linked lists
      w[head + j] = -1;
    } // traverse nodes in reverse order


    for (j = n - 1; j >= 0; j--) {
      // check j is a root
      if (parent[j] === -1) {
        continue;
      } // add j to list of its parent


      w[next + j] = w[head + parent[j]];
      w[head + parent[j]] = j;
    } // loop nodes


    for (j = 0; j < n; j++) {
      // skip j if it is not a root
      if (parent[j] !== -1) {
        continue;
      } // depth-first search


      k = csTdfs(j, k, w, head, next, post, stack);
    }

    return post;
  }

  /**
   * Computes the elimination tree of Matrix A (using triu(A)) or the
   * elimination tree of A'A without forming A'A.
   *
   * @param {Matrix}  a               The A Matrix
   * @param {boolean} ata             A value of true the function computes the etree of A'A
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  function csEtree(a, ata) {
    // check inputs
    if (!a) {
      return null;
    } // a arrays


    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size; // rows & columns

    var m = asize[0];
    var n = asize[1]; // allocate result

    var parent = []; // (n)
    // allocate workspace

    var w = []; // (n + (ata ? m : 0))

    var ancestor = 0; // first n entries in w

    var prev = n; // last m entries (ata = true)

    var i, inext; // check we are calculating A'A

    if (ata) {
      // initialize workspace
      for (i = 0; i < m; i++) {
        w[prev + i] = -1;
      }
    } // loop columns


    for (var k = 0; k < n; k++) {
      // node k has no parent yet
      parent[k] = -1; // nor does k have an ancestor

      w[ancestor + k] = -1; // values in column k

      for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
        // row
        var r = aindex[p]; // node

        i = ata ? w[prev + r] : r; // traverse from i to k

        for (; i !== -1 && i < k; i = inext) {
          // inext = ancestor of i
          inext = w[ancestor + i]; // path compression

          w[ancestor + i] = k; // check no anc., parent is k

          if (inext === -1) {
            parent[i] = k;
          }
        }

        if (ata) {
          w[prev + r] = k;
        }
      }
    }

    return parent;
  }

  /**
   * Keeps entries in the matrix when the callback function returns true, removes the entry otherwise
   *
   * @param {Matrix}   a              The sparse matrix
   * @param {function} callback       The callback function, function will be invoked with the following args:
   *                                    - The entry row
   *                                    - The entry column
   *                                    - The entry value
   *                                    - The state parameter
   * @param {any}      other          The state
   *
   * @return                          The number of nonzero elements in the matrix
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  function csFkeep(a, callback, other) {
    // a arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size; // columns

    var n = asize[1]; // nonzero items

    var nz = 0; // loop columns

    for (var j = 0; j < n; j++) {
      // get current location of col j
      var p = aptr[j]; // record new location of col j

      aptr[j] = nz;

      for (; p < aptr[j + 1]; p++) {
        // check we need to keep this item
        if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
          // keep A(i,j)
          aindex[nz] = aindex[p]; // check we need to process values (pattern only)

          if (avalues) {
            avalues[nz] = avalues[p];
          } // increment nonzero items


          nz++;
        }
      }
    } // finalize A


    aptr[n] = nz; // trim arrays

    aindex.splice(nz, aindex.length - nz); // check we need to process values (pattern only)

    if (avalues) {
      avalues.splice(nz, avalues.length - nz);
    } // return number of nonzero items


    return nz;
  }

  /**
   * This function "flips" its input about the integer -1.
   *
   * @param {Number}  i               The value to flip
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  function csFlip(i) {
    // flip the value
    return -i - 2;
  }

  var name$3j = 'csAmd';
  var dependencies$3k = ['add', 'multiply', 'transpose'];
  var createCsAmd = /* #__PURE__ */factory(name$3j, dependencies$3k, function (_ref) {
    var add = _ref.add,
        multiply = _ref.multiply,
        transpose = _ref.transpose;

    /**
     * Approximate minimum degree ordering. The minimum degree algorithm is a widely used
     * heuristic for finding a permutation P so that P*A*P' has fewer nonzeros in its factorization
     * than A. It is a gready method that selects the sparsest pivot row and column during the course
     * of a right looking sparse Cholesky factorization.
     *
     * Reference: http://faculty.cse.tamu.edu/davis/publications.html
     *
     * @param {Number} order    0: Natural, 1: Cholesky, 2: LU, 3: QR
     * @param {Matrix} m        Sparse Matrix
     */
    return function csAmd(order, a) {
      // check input parameters
      if (!a || order <= 0 || order > 3) {
        return null;
      } // a matrix arrays


      var asize = a._size; // rows and columns

      var m = asize[0];
      var n = asize[1]; // initialize vars

      var lemax = 0; // dense threshold

      var dense = Math.max(16, 10 * Math.sqrt(n));
      dense = Math.min(n - 2, dense); // create target matrix C

      var cm = _createTargetMatrix(order, a, m, n, dense); // drop diagonal entries


      csFkeep(cm, _diag, null); // C matrix arrays

      var cindex = cm._index;
      var cptr = cm._ptr; // number of nonzero elements in C

      var cnz = cptr[n]; // allocate result (n+1)

      var P = []; // create workspace (8 * (n + 1))

      var W = [];
      var len = 0; // first n + 1 entries

      var nv = n + 1; // next n + 1 entries

      var next = 2 * (n + 1); // next n + 1 entries

      var head = 3 * (n + 1); // next n + 1 entries

      var elen = 4 * (n + 1); // next n + 1 entries

      var degree = 5 * (n + 1); // next n + 1 entries

      var w = 6 * (n + 1); // next n + 1 entries

      var hhead = 7 * (n + 1); // last n + 1 entries
      // use P as workspace for last

      var last = P; // initialize quotient graph

      var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree); // initialize degree lists


      var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next); // minimum degree node


      var mindeg = 0; // vars

      var i, j, k, k1, k2, e, pj, ln, nvi, pk, eln, p1, p2, pn, h, d; // while (selecting pivots) do

      while (nel < n) {
        // select node of minimum approximate degree. amd() is now ready to start eliminating the graph. It first
        // finds a node k of minimum degree and removes it from its degree list. The variable nel keeps track of thow
        // many nodes have been eliminated.
        for (k = -1; mindeg < n && (k = W[head + mindeg]) === -1; mindeg++) {
        }

        if (W[next + k] !== -1) {
          last[W[next + k]] = -1;
        } // remove k from degree list


        W[head + mindeg] = W[next + k]; // elenk = |Ek|

        var elenk = W[elen + k]; // # of nodes k represents

        var nvk = W[nv + k]; // W[nv + k] nodes of A eliminated

        nel += nvk; // Construct a new element. The new element Lk is constructed in place if |Ek| = 0. nv[i] is
        // negated for all nodes i in Lk to flag them as members of this set. Each node i is removed from the
        // degree lists. All elements e in Ek are absorved into element k.

        var dk = 0; // flag k as in Lk

        W[nv + k] = -nvk;
        var p = cptr[k]; // do in place if W[elen + k] === 0

        var pk1 = elenk === 0 ? p : cnz;
        var pk2 = pk1;

        for (k1 = 1; k1 <= elenk + 1; k1++) {
          if (k1 > elenk) {
            // search the nodes in k
            e = k; // list of nodes starts at cindex[pj]

            pj = p; // length of list of nodes in k

            ln = W[len + k] - elenk;
          } else {
            // search the nodes in e
            e = cindex[p++];
            pj = cptr[e]; // length of list of nodes in e

            ln = W[len + e];
          }

          for (k2 = 1; k2 <= ln; k2++) {
            i = cindex[pj++]; // check  node i dead, or seen

            if ((nvi = W[nv + i]) <= 0) {
              continue;
            } // W[degree + Lk] += size of node i


            dk += nvi; // negate W[nv + i] to denote i in Lk

            W[nv + i] = -nvi; // place i in Lk

            cindex[pk2++] = i;

            if (W[next + i] !== -1) {
              last[W[next + i]] = last[i];
            } // check we need to remove i from degree list


            if (last[i] !== -1) {
              W[next + last[i]] = W[next + i];
            } else {
              W[head + W[degree + i]] = W[next + i];
            }
          }

          if (e !== k) {
            // absorb e into k
            cptr[e] = csFlip(k); // e is now a dead element

            W[w + e] = 0;
          }
        } // cindex[cnz...nzmax] is free


        if (elenk !== 0) {
          cnz = pk2;
        } // external degree of k - |Lk\i|


        W[degree + k] = dk; // element k is in cindex[pk1..pk2-1]

        cptr[k] = pk1;
        W[len + k] = pk2 - pk1; // k is now an element

        W[elen + k] = -2; // Find set differences. The scan1 function now computes the set differences |Le \ Lk| for all elements e. At the start of the
        // scan, no entry in the w array is greater than or equal to mark.
        // clear w if necessary

        mark = _wclear(mark, lemax, W, w, n); // scan 1: find |Le\Lk|

        for (pk = pk1; pk < pk2; pk++) {
          i = cindex[pk]; // check if W[elen + i] empty, skip it

          if ((eln = W[elen + i]) <= 0) {
            continue;
          } // W[nv + i] was negated


          nvi = -W[nv + i];
          var wnvi = mark - nvi; // scan Ei

          for (p = cptr[i], p1 = cptr[i] + eln - 1; p <= p1; p++) {
            e = cindex[p];

            if (W[w + e] >= mark) {
              // decrement |Le\Lk|
              W[w + e] -= nvi;
            } else if (W[w + e] !== 0) {
              // ensure e is a live element, 1st time e seen in scan 1
              W[w + e] = W[degree + e] + wnvi;
            }
          }
        } // degree update
        // The second pass computes the approximate degree di, prunes the sets Ei and Ai, and computes a hash
        // function h(i) for all nodes in Lk.
        // scan2: degree update


        for (pk = pk1; pk < pk2; pk++) {
          // consider node i in Lk
          i = cindex[pk];
          p1 = cptr[i];
          p2 = p1 + W[elen + i] - 1;
          pn = p1; // scan Ei

          for (h = 0, d = 0, p = p1; p <= p2; p++) {
            e = cindex[p]; // check e is an unabsorbed element

            if (W[w + e] !== 0) {
              // dext = |Le\Lk|
              var dext = W[w + e] - mark;

              if (dext > 0) {
                // sum up the set differences
                d += dext; // keep e in Ei

                cindex[pn++] = e; // compute the hash of node i

                h += e;
              } else {
                // aggressive absorb. e->k
                cptr[e] = csFlip(k); // e is a dead element

                W[w + e] = 0;
              }
            }
          } // W[elen + i] = |Ei|


          W[elen + i] = pn - p1 + 1;
          var p3 = pn;
          var p4 = p1 + W[len + i]; // prune edges in Ai

          for (p = p2 + 1; p < p4; p++) {
            j = cindex[p]; // check node j dead or in Lk

            var nvj = W[nv + j];

            if (nvj <= 0) {
              continue;
            } // degree(i) += |j|


            d += nvj; // place j in node list of i

            cindex[pn++] = j; // compute hash for node i

            h += j;
          } // check for mass elimination


          if (d === 0) {
            // absorb i into k
            cptr[i] = csFlip(k);
            nvi = -W[nv + i]; // |Lk| -= |i|

            dk -= nvi; // |k| += W[nv + i]

            nvk += nvi;
            nel += nvi;
            W[nv + i] = 0; // node i is dead

            W[elen + i] = -1;
          } else {
            // update degree(i)
            W[degree + i] = Math.min(W[degree + i], d); // move first node to end

            cindex[pn] = cindex[p3]; // move 1st el. to end of Ei

            cindex[p3] = cindex[p1]; // add k as 1st element in of Ei

            cindex[p1] = k; // new len of adj. list of node i

            W[len + i] = pn - p1 + 1; // finalize hash of i

            h = (h < 0 ? -h : h) % n; // place i in hash bucket

            W[next + i] = W[hhead + h];
            W[hhead + h] = i; // save hash of i in last[i]

            last[i] = h;
          }
        } // finalize |Lk|


        W[degree + k] = dk;
        lemax = Math.max(lemax, dk); // clear w

        mark = _wclear(mark + lemax, lemax, W, w, n); // Supernode detection. Supernode detection relies on the hash function h(i) computed for each node i.
        // If two nodes have identical adjacency lists, their hash functions wil be identical.

        for (pk = pk1; pk < pk2; pk++) {
          i = cindex[pk]; // check i is dead, skip it

          if (W[nv + i] >= 0) {
            continue;
          } // scan hash bucket of node i


          h = last[i];
          i = W[hhead + h]; // hash bucket will be empty

          W[hhead + h] = -1;

          for (; i !== -1 && W[next + i] !== -1; i = W[next + i], mark++) {
            ln = W[len + i];
            eln = W[elen + i];

            for (p = cptr[i] + 1; p <= cptr[i] + ln - 1; p++) {
              W[w + cindex[p]] = mark;
            }

            var jlast = i; // compare i with all j

            for (j = W[next + i]; j !== -1;) {
              var ok = W[len + j] === ln && W[elen + j] === eln;

              for (p = cptr[j] + 1; ok && p <= cptr[j] + ln - 1; p++) {
                // compare i and j
                if (W[w + cindex[p]] !== mark) {
                  ok = 0;
                }
              } // check i and j are identical


              if (ok) {
                // absorb j into i
                cptr[j] = csFlip(i);
                W[nv + i] += W[nv + j];
                W[nv + j] = 0; // node j is dead

                W[elen + j] = -1; // delete j from hash bucket

                j = W[next + j];
                W[next + jlast] = j;
              } else {
                // j and i are different
                jlast = j;
                j = W[next + j];
              }
            }
          }
        } // Finalize new element. The elimination of node k is nearly complete. All nodes i in Lk are scanned one last time.
        // Node i is removed from Lk if it is dead. The flagged status of nv[i] is cleared.


        for (p = pk1, pk = pk1; pk < pk2; pk++) {
          i = cindex[pk]; // check  i is dead, skip it

          if ((nvi = -W[nv + i]) <= 0) {
            continue;
          } // restore W[nv + i]


          W[nv + i] = nvi; // compute external degree(i)

          d = W[degree + i] + dk - nvi;
          d = Math.min(d, n - nel - nvi);

          if (W[head + d] !== -1) {
            last[W[head + d]] = i;
          } // put i back in degree list


          W[next + i] = W[head + d];
          last[i] = -1;
          W[head + d] = i; // find new minimum degree

          mindeg = Math.min(mindeg, d);
          W[degree + i] = d; // place i in Lk

          cindex[p++] = i;
        } // # nodes absorbed into k


        W[nv + k] = nvk; // length of adj list of element k

        if ((W[len + k] = p - pk1) === 0) {
          // k is a root of the tree
          cptr[k] = -1; // k is now a dead element

          W[w + k] = 0;
        }

        if (elenk !== 0) {
          // free unused space in Lk
          cnz = p;
        }
      } // Postordering. The elimination is complete, but no permutation has been computed. All that is left
      // of the graph is the assembly tree (ptr) and a set of dead nodes and elements (i is a dead node if
      // nv[i] is zero and a dead element if nv[i] > 0). It is from this information only that the final permutation
      // is computed. The tree is restored by unflipping all of ptr.
      // fix assembly tree


      for (i = 0; i < n; i++) {
        cptr[i] = csFlip(cptr[i]);
      }

      for (j = 0; j <= n; j++) {
        W[head + j] = -1;
      } // place unordered nodes in lists


      for (j = n; j >= 0; j--) {
        // skip if j is an element
        if (W[nv + j] > 0) {
          continue;
        } // place j in list of its parent


        W[next + j] = W[head + cptr[j]];
        W[head + cptr[j]] = j;
      } // place elements in lists


      for (e = n; e >= 0; e--) {
        // skip unless e is an element
        if (W[nv + e] <= 0) {
          continue;
        }

        if (cptr[e] !== -1) {
          // place e in list of its parent
          W[next + e] = W[head + cptr[e]];
          W[head + cptr[e]] = e;
        }
      } // postorder the assembly tree


      for (k = 0, i = 0; i <= n; i++) {
        if (cptr[i] === -1) {
          k = csTdfs(i, k, W, head, next, P, w);
        }
      } // remove last item in array


      P.splice(P.length - 1, 1); // return P

      return P;
    };
    /**
     * Creates the matrix that will be used by the approximate minimum degree ordering algorithm. The function accepts the matrix M as input and returns a permutation
     * vector P. The amd algorithm operates on a symmetrix matrix, so one of three symmetric matrices is formed.
     *
     * Order: 0
     *   A natural ordering P=null matrix is returned.
     *
     * Order: 1
     *   Matrix must be square. This is appropriate for a Cholesky or LU factorization.
     *   P = M + M'
     *
     * Order: 2
     *   Dense columns from M' are dropped, M recreated from M'. This is appropriatefor LU factorization of unsymmetric matrices.
     *   P = M' * M
     *
     * Order: 3
     *   This is best used for QR factorization or LU factorization is matrix M has no dense rows. A dense row is a row with more than 10*sqr(columns) entries.
     *   P = M' * M
     */

    function _createTargetMatrix(order, a, m, n, dense) {
      // compute A'
      var at = transpose(a); // check order = 1, matrix must be square

      if (order === 1 && n === m) {
        // C = A + A'
        return add(a, at);
      } // check order = 2, drop dense columns from M'


      if (order === 2) {
        // transpose arrays
        var tindex = at._index;
        var tptr = at._ptr; // new column index

        var p2 = 0; // loop A' columns (rows)

        for (var j = 0; j < m; j++) {
          // column j of AT starts here
          var p = tptr[j]; // new column j starts here

          tptr[j] = p2; // skip dense col j

          if (tptr[j + 1] - p > dense) {
            continue;
          } // map rows in column j of A


          for (var p1 = tptr[j + 1]; p < p1; p++) {
            tindex[p2++] = tindex[p];
          }
        } // finalize AT


        tptr[m] = p2; // recreate A from new transpose matrix

        a = transpose(at); // use A' * A

        return multiply(at, a);
      } // use A' * A, square or rectangular matrix


      return multiply(at, a);
    }
    /**
     * Initialize quotient graph. There are four kind of nodes and elements that must be represented:
     *
     *  - A live node is a node i (or a supernode) that has not been selected as a pivot nad has not been merged into another supernode.
     *  - A dead node i is one that has been removed from the graph, having been absorved into r = flip(ptr[i]).
     *  - A live element e is one that is in the graph, having been formed when node e was selected as the pivot.
     *  - A dead element e is one that has benn absorved into a subsequent element s = flip(ptr[e]).
     */


    function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
      // Initialize quotient graph
      for (var k = 0; k < n; k++) {
        W[len + k] = cptr[k + 1] - cptr[k];
      }

      W[len + n] = 0; // initialize workspace

      for (var i = 0; i <= n; i++) {
        // degree list i is empty
        W[head + i] = -1;
        last[i] = -1;
        W[next + i] = -1; // hash list i is empty

        W[hhead + i] = -1; // node i is just one node

        W[nv + i] = 1; // node i is alive

        W[w + i] = 1; // Ek of node i is empty

        W[elen + i] = 0; // degree of node i

        W[degree + i] = W[len + i];
      } // clear w


      var mark = _wclear(0, 0, W, w, n); // n is a dead element


      W[elen + n] = -2; // n is a root of assembly tree

      cptr[n] = -1; // n is a dead element

      W[w + n] = 0; // return mark

      return mark;
    }
    /**
     * Initialize degree lists. Each node is placed in its degree lists. Nodes of zero degree are eliminated immediately. Nodes with
     * degree >= dense are alsol eliminated and merged into a placeholder node n, a dead element. Thes nodes will appera last in the
     * output permutation p.
     */


    function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
      // result
      var nel = 0; // loop columns

      for (var i = 0; i < n; i++) {
        // degree @ i
        var d = W[degree + i]; // check node i is empty

        if (d === 0) {
          // element i is dead
          W[elen + i] = -2;
          nel++; // i is a root of assembly tree

          cptr[i] = -1;
          W[w + i] = 0;
        } else if (d > dense) {
          // absorb i into element n
          W[nv + i] = 0; // node i is dead

          W[elen + i] = -1;
          nel++;
          cptr[i] = csFlip(n);
          W[nv + n]++;
        } else {
          var h = W[head + d];

          if (h !== -1) {
            last[h] = i;
          } // put node i in degree list d


          W[next + i] = W[head + d];
          W[head + d] = i;
        }
      }

      return nel;
    }

    function _wclear(mark, lemax, W, w, n) {
      if (mark < 2 || mark + lemax < 0) {
        for (var k = 0; k < n; k++) {
          if (W[w + k] !== 0) {
            W[w + k] = 1;
          }
        }

        mark = 2;
      } // at this point, W [0..n-1] < mark holds


      return mark;
    }

    function _diag(i, j) {
      return i !== j;
    }
  });

  /**
   * This function determines if j is a leaf of the ith row subtree.
   * Consider A(i,j), node j in ith row subtree and return lca(jprev,j)
   *
   * @param {Number}  i               The ith row subtree
   * @param {Number}  j               The node to test
   * @param {Array}   w               The workspace array
   * @param {Number}  first           The index offset within the workspace for the first array
   * @param {Number}  maxfirst        The index offset within the workspace for the maxfirst array
   * @param {Number}  prevleaf        The index offset within the workspace for the prevleaf array
   * @param {Number}  ancestor        The index offset within the workspace for the ancestor array
   *
   * @return {Object}
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  function csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {
    var s, sparent; // our result

    var jleaf = 0;
    var q; // check j is a leaf

    if (i <= j || w[first + j] <= w[maxfirst + i]) {
      return -1;
    } // update max first[j] seen so far


    w[maxfirst + i] = w[first + j]; // jprev = previous leaf of ith subtree

    var jprev = w[prevleaf + i];
    w[prevleaf + i] = j; // check j is first or subsequent leaf

    if (jprev === -1) {
      // 1st leaf, q = root of ith subtree
      jleaf = 1;
      q = i;
    } else {
      // update jleaf
      jleaf = 2; // q = least common ancester (jprev,j)

      for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) {
      }

      for (s = jprev; s !== q; s = sparent) {
        // path compression
        sparent = w[ancestor + s];
        w[ancestor + s] = q;
      }
    }

    return {
      jleaf: jleaf,
      q: q
    };
  }

  var name$3k = 'csCounts';
  var dependencies$3l = ['transpose'];
  var createCsCounts = /* #__PURE__ */factory(name$3k, dependencies$3l, function (_ref) {
    var transpose = _ref.transpose;

    /**
     * Computes the column counts using the upper triangular part of A.
     * It transposes A internally, none of the input parameters are modified.
     *
     * @param {Matrix} a           The sparse matrix A
     *
     * @param {Matrix} ata         Count the columns of A'A instead
     *
     * @return                     An array of size n of the column counts or null on error
     *
     * Reference: http://faculty.cse.tamu.edu/davis/publications.html
     */
    return function (a, parent, post, ata) {
      // check inputs
      if (!a || !parent || !post) {
        return null;
      } // a matrix arrays


      var asize = a._size; // rows and columns

      var m = asize[0];
      var n = asize[1]; // variables

      var i, j, k, J, p, p0, p1; // workspace size

      var s = 4 * n + (ata ? n + m + 1 : 0); // allocate workspace

      var w = []; // (s)

      var ancestor = 0; // first n entries

      var maxfirst = n; // next n entries

      var prevleaf = 2 * n; // next n entries

      var first = 3 * n; // next n entries

      var head = 4 * n; // next n + 1 entries (used when ata is true)

      var next = 5 * n + 1; // last entries in workspace
      // clear workspace w[0..s-1]

      for (k = 0; k < s; k++) {
        w[k] = -1;
      } // allocate result


      var colcount = []; // (n)
      // AT = A'

      var at = transpose(a); // at arrays

      var tindex = at._index;
      var tptr = at._ptr; // find w[first + j]

      for (k = 0; k < n; k++) {
        j = post[k]; // colcount[j]=1 if j is a leaf

        colcount[j] = w[first + j] === -1 ? 1 : 0;

        for (; j !== -1 && w[first + j] === -1; j = parent[j]) {
          w[first + j] = k;
        }
      } // initialize ata if needed


      if (ata) {
        // invert post
        for (k = 0; k < n; k++) {
          w[post[k]] = k;
        } // loop rows (columns in AT)


        for (i = 0; i < m; i++) {
          // values in column i of AT
          for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {
            k = Math.min(k, w[tindex[p]]);
          } // place row i in linked list k


          w[next + i] = w[head + k];
          w[head + k] = i;
        }
      } // each node in its own set


      for (i = 0; i < n; i++) {
        w[ancestor + i] = i;
      }

      for (k = 0; k < n; k++) {
        // j is the kth node in postordered etree
        j = post[k]; // check j is not a root

        if (parent[j] !== -1) {
          colcount[parent[j]]--;
        } // J=j for LL'=A case


        for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {
          for (p = tptr[J]; p < tptr[J + 1]; p++) {
            i = tindex[p];
            var r = csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor); // check A(i,j) is in skeleton

            if (r.jleaf >= 1) {
              colcount[j]++;
            } // check account for overlap in q


            if (r.jleaf === 2) {
              colcount[r.q]--;
            }
          }
        }

        if (parent[j] !== -1) {
          w[ancestor + j] = parent[j];
        }
      } // sum up colcount's of each child


      for (j = 0; j < n; j++) {
        if (parent[j] !== -1) {
          colcount[parent[j]] += colcount[j];
        }
      }

      return colcount;
    };
  });

  var name$3l = 'csSqr';
  var dependencies$3m = ['add', 'multiply', 'transpose'];
  var createCsSqr = /* #__PURE__ */factory(name$3l, dependencies$3m, function (_ref) {
    var add = _ref.add,
        multiply = _ref.multiply,
        transpose = _ref.transpose;
    var csAmd = createCsAmd({
      add: add,
      multiply: multiply,
      transpose: transpose
    });
    var csCounts = createCsCounts({
      transpose: transpose
    });
    /**
     * Symbolic ordering and analysis for QR and LU decompositions.
     *
     * @param {Number}  order           The ordering strategy (see csAmd for more details)
     * @param {Matrix}  a               The A matrix
     * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or
     *                                  symbolic ordering and analysis for LU decomposition (false)
     *
     * @return {Object}                 The Symbolic ordering and analysis for matrix A
     *
     * Reference: http://faculty.cse.tamu.edu/davis/publications.html
     */

    return function csSqr(order, a, qr) {
      // a arrays
      var aptr = a._ptr;
      var asize = a._size; // columns

      var n = asize[1]; // vars

      var k; // symbolic analysis result

      var s = {}; // fill-reducing ordering

      s.q = csAmd(order, a); // validate results

      if (order && !s.q) {
        return null;
      } // QR symbolic analysis


      if (qr) {
        // apply permutations if needed
        var c = order ? csPermute(a, null, s.q, 0) : a; // etree of C'*C, where C=A(:,q)

        s.parent = csEtree(c, 1); // post order elimination tree

        var post = csPost(s.parent, n); // col counts chol(C'*C)

        s.cp = csCounts(c, s.parent, post, 1); // check we have everything needed to calculate number of nonzero elements

        if (c && s.parent && s.cp && _vcount(c, s)) {
          // calculate number of nonzero elements
          for (s.unz = 0, k = 0; k < n; k++) {
            s.unz += s.cp[k];
          }
        }
      } else {
        // for LU factorization only, guess nnz(L) and nnz(U)
        s.unz = 4 * aptr[n] + n;
        s.lnz = s.unz;
      } // return result S


      return s;
    };
    /**
     * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent
     */

    function _vcount(a, s) {
      // a arrays
      var aptr = a._ptr;
      var aindex = a._index;
      var asize = a._size; // rows & columns

      var m = asize[0];
      var n = asize[1]; // initialize s arrays

      s.pinv = []; // (m + n)

      s.leftmost = []; // (m)
      // vars

      var parent = s.parent;
      var pinv = s.pinv;
      var leftmost = s.leftmost; // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries

      var w = []; // (m + 3 * n)

      var next = 0;
      var head = m;
      var tail = m + n;
      var nque = m + 2 * n; // vars

      var i, k, p, p0, p1; // initialize w

      for (k = 0; k < n; k++) {
        // queue k is empty
        w[head + k] = -1;
        w[tail + k] = -1;
        w[nque + k] = 0;
      } // initialize row arrays


      for (i = 0; i < m; i++) {
        leftmost[i] = -1;
      } // loop columns backwards


      for (k = n - 1; k >= 0; k--) {
        // values & index for column k
        for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
          // leftmost[i] = min(find(A(i,:)))
          leftmost[aindex[p]] = k;
        }
      } // scan rows in reverse order


      for (i = m - 1; i >= 0; i--) {
        // row i is not yet ordered
        pinv[i] = -1;
        k = leftmost[i]; // check row i is empty

        if (k === -1) {
          continue;
        } // first row in queue k


        if (w[nque + k]++ === 0) {
          w[tail + k] = i;
        } // put i at head of queue k


        w[next + i] = w[head + k];
        w[head + k] = i;
      }

      s.lnz = 0;
      s.m2 = m; // find row permutation and nnz(V)

      for (k = 0; k < n; k++) {
        // remove row i from queue k
        i = w[head + k]; // count V(k,k) as nonzero

        s.lnz++; // add a fictitious row

        if (i < 0) {
          i = s.m2++;
        } // associate row i with V(:,k)


        pinv[i] = k; // skip if V(k+1:m,k) is empty

        if (--nque[k] <= 0) {
          continue;
        } // nque[k] is nnz (V(k+1:m,k))


        s.lnz += w[nque + k]; // move all rows to parent of k

        var pa = parent[k];

        if (pa !== -1) {
          if (w[nque + pa] === 0) {
            w[tail + pa] = w[tail + k];
          }

          w[next + w[tail + k]] = w[head + pa];
          w[head + pa] = w[next + i];
          w[nque + pa] += w[nque + k];
        }
      }

      for (i = 0; i < m; i++) {
        if (pinv[i] < 0) {
          pinv[i] = k++;
        }
      }

      return true;
    }
  });

  /**
   * Checks if the node at w[j] is marked
   *
   * @param {Array}   w               The array
   * @param {Number}  j               The array index
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */
  function csMarked(w, j) {
    // check node is marked
    return w[j] < 0;
  }

  /**
   * Marks the node at w[j]
   *
   * @param {Array}   w               The array
   * @param {Number}  j               The array index
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */

  function csMark(w, j) {
    // mark w[j]
    w[j] = csFlip(w[j]);
  }

  /**
   * Flips the value if it is negative of returns the same value otherwise.
   *
   * @param {Number}  i               The value to flip
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */

  function csUnflip(i) {
    // flip the value if it is negative
    return i < 0 ? csFlip(i) : i;
  }

  /**
   * Depth-first search computes the nonzero pattern xi of the directed graph G (Matrix) starting
   * at nodes in B (see csReach()).
   *
   * @param {Number}  j               The starting node for the DFS algorithm
   * @param {Matrix}  g               The G matrix to search, ptr array modified, then restored
   * @param {Number}  top             Start index in stack xi[top..n-1]
   * @param {Number}  k               The kth column in B
   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n
   *                                  The first n entries is the nonzero pattern, the last n entries is the stack
   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b
   *
   * @return {Number}                 New value of top
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */

  function csDfs(j, g, top, xi, pinv) {
    // g arrays
    var index = g._index;
    var ptr = g._ptr;
    var size = g._size; // columns

    var n = size[1]; // vars

    var i, p, p2; // initialize head

    var head = 0; // initialize the recursion stack

    xi[0] = j; // loop

    while (head >= 0) {
      // get j from the top of the recursion stack
      j = xi[head]; // apply permutation vector

      var jnew = pinv ? pinv[j] : j; // check node j is marked

      if (!csMarked(ptr, j)) {
        // mark node j as visited
        csMark(ptr, j); // update stack (last n entries in xi)

        xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);
      } // node j done if no unvisited neighbors


      var done = 1; // examine all neighbors of j, stack (last n entries in xi)

      for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p < p2; p++) {
        // consider neighbor node i
        i = index[p]; // check we have visited node i, skip it

        if (csMarked(ptr, i)) {
          continue;
        } // pause depth-first search of node j, update stack (last n entries in xi)


        xi[n + head] = p; // start dfs at node i

        xi[++head] = i; // node j is not done

        done = 0; // break, to start dfs(i)

        break;
      } // check depth-first search at node j is done


      if (done) {
        // remove j from the recursion stack
        head--; // and place in the output stack

        xi[--top] = j;
      }
    }

    return top;
  }

  /**
   * The csReach function computes X = Reach(B), where B is the nonzero pattern of the n-by-1
   * sparse column of vector b. The function returns the set of nodes reachable from any node in B. The
   * nonzero pattern xi of the solution x to the sparse linear system Lx=b is given by X=Reach(B).
   *
   * @param {Matrix}  g               The G matrix
   * @param {Matrix}  b               The B matrix
   * @param {Number}  k               The kth column in B
   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n
   *                                  The first n entries is the nonzero pattern, the last n entries is the stack
   * @param {Array}   pinv            The inverse row permutation vector
   *
   * @return {Number}                 The index for the nonzero pattern
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */

  function csReach(g, b, k, xi, pinv) {
    // g arrays
    var gptr = g._ptr;
    var gsize = g._size; // b arrays

    var bindex = b._index;
    var bptr = b._ptr; // columns

    var n = gsize[1]; // vars

    var p, p0, p1; // initialize top

    var top = n; // loop column indeces in B

    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
      // node i
      var i = bindex[p]; // check node i is marked

      if (!csMarked(gptr, i)) {
        // start a dfs at unmarked node i
        top = csDfs(i, g, top, xi, pinv);
      }
    } // loop columns from top -> n - 1


    for (p = top; p < n; p++) {
      // restore G
      csMark(gptr, xi[p]);
    }

    return top;
  }

  var name$3m = 'csSpsolve';
  var dependencies$3n = ['divideScalar', 'multiply', 'subtract'];
  var createCsSpsolve = /* #__PURE__ */factory(name$3m, dependencies$3n, function (_ref) {
    var divideScalar = _ref.divideScalar,
        multiply = _ref.multiply,
        subtract = _ref.subtract;

    /**
     * The function csSpsolve() computes the solution to G * x = bk, where bk is the
     * kth column of B. When lo is true, the function assumes G = L is lower triangular with the
     * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U
     * is upper triangular with the diagonal entry as the last entry in each column.
     *
     * @param {Matrix}  g               The G matrix
     * @param {Matrix}  b               The B matrix
     * @param {Number}  k               The kth column in B
     * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n
     *                                  The first n entries is the nonzero pattern, the last n entries is the stack
     * @param {Array}   x               The soluton to the linear system G * x = b
     * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b
     * @param {boolean} lo              The lower (true) upper triangular (false) flag
     *
     * @return {Number}                 The index for the nonzero pattern
     *
     * Reference: http://faculty.cse.tamu.edu/davis/publications.html
     */
    return function csSpsolve(g, b, k, xi, x, pinv, lo) {
      // g arrays
      var gvalues = g._values;
      var gindex = g._index;
      var gptr = g._ptr;
      var gsize = g._size; // columns

      var n = gsize[1]; // b arrays

      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr; // vars

      var p, p0, p1, q; // xi[top..n-1] = csReach(B(:,k))

      var top = csReach(g, b, k, xi, pinv); // clear x

      for (p = top; p < n; p++) {
        x[xi[p]] = 0;
      } // scatter b


      for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
        x[bindex[p]] = bvalues[p];
      } // loop columns


      for (var px = top; px < n; px++) {
        // x array index for px
        var j = xi[px]; // apply permutation vector (U x = b), j maps to column J of G

        var J = pinv ? pinv[j] : j; // check column J is empty

        if (J < 0) {
          continue;
        } // column value indeces in G, p0 <= p < p1


        p0 = gptr[J];
        p1 = gptr[J + 1]; // x(j) /= G(j,j)

        x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]); // first entry L(j,j)

        p = lo ? p0 + 1 : p0;
        q = lo ? p1 : p1 - 1; // loop

        for (; p < q; p++) {
          // row
          var i = gindex[p]; // x(i) -= G(i,j) * x(j)

          x[i] = subtract(x[i], multiply(gvalues[p], x[j]));
        }
      } // return top of stack


      return top;
    };
  });

  var name$3n = 'csLu';
  var dependencies$3o = ['abs', 'divideScalar', 'multiply', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];
  var createCsLu = /* #__PURE__ */factory(name$3n, dependencies$3o, function (_ref) {
    var abs = _ref.abs,
        divideScalar = _ref.divideScalar,
        multiply = _ref.multiply,
        subtract = _ref.subtract,
        larger = _ref.larger,
        largerEq = _ref.largerEq,
        SparseMatrix = _ref.SparseMatrix;
    var csSpsolve = createCsSpsolve({
      divideScalar: divideScalar,
      multiply: multiply,
      subtract: subtract
    });
    /**
     * Computes the numeric LU factorization of the sparse matrix A. Implements a Left-looking LU factorization
     * algorithm that computes L and U one column at a tume. At the kth step, it access columns 1 to k-1 of L
     * and column k of A. Given the fill-reducing column ordering q (see parameter s) computes L, U and pinv so
     * L * U = A(p, q), where p is the inverse of pinv.
     *
     * @param {Matrix}  m               The A Matrix to factorize
     * @param {Object}  s               The symbolic analysis from csSqr(). Provides the fill-reducing
     *                                  column ordering q
     * @param {Number}  tol             Partial pivoting threshold (1 for partial pivoting)
     *
     * @return {Number}                 The numeric LU factorization of A or null
     *
     * Reference: http://faculty.cse.tamu.edu/davis/publications.html
     */

    return function csLu(m, s, tol) {
      // validate input
      if (!m) {
        return null;
      } // m arrays


      var size = m._size; // columns

      var n = size[1]; // symbolic analysis result

      var q;
      var lnz = 100;
      var unz = 100; // update symbolic analysis parameters

      if (s) {
        q = s.q;
        lnz = s.lnz || lnz;
        unz = s.unz || unz;
      } // L arrays


      var lvalues = []; // (lnz)

      var lindex = []; // (lnz)

      var lptr = []; // (n + 1)
      // L

      var L = new SparseMatrix({
        values: lvalues,
        index: lindex,
        ptr: lptr,
        size: [n, n]
      }); // U arrays

      var uvalues = []; // (unz)

      var uindex = []; // (unz)

      var uptr = []; // (n + 1)
      // U

      var U = new SparseMatrix({
        values: uvalues,
        index: uindex,
        ptr: uptr,
        size: [n, n]
      }); // inverse of permutation vector

      var pinv = []; // (n)
      // vars

      var i, p; // allocate arrays

      var x = []; // (n)

      var xi = []; // (2 * n)
      // initialize variables

      for (i = 0; i < n; i++) {
        // clear workspace
        x[i] = 0; // no rows pivotal yet

        pinv[i] = -1; // no cols of L yet

        lptr[i + 1] = 0;
      } // reset number of nonzero elements in L and U


      lnz = 0;
      unz = 0; // compute L(:,k) and U(:,k)

      for (var k = 0; k < n; k++) {
        // update ptr
        lptr[k] = lnz;
        uptr[k] = unz; // apply column permutations if needed

        var col = q ? q[k] : k; // solve triangular system, x = L\A(:,col)

        var top = csSpsolve(L, m, col, xi, x, pinv, 1); // find pivot

        var ipiv = -1;
        var a = -1; // loop xi[] from top -> n

        for (p = top; p < n; p++) {
          // x[i] is nonzero
          i = xi[p]; // check row i is not yet pivotal

          if (pinv[i] < 0) {
            // absolute value of x[i]
            var xabs = abs(x[i]); // check absoulte value is greater than pivot value

            if (larger(xabs, a)) {
              // largest pivot candidate so far
              a = xabs;
              ipiv = i;
            }
          } else {
            // x(i) is the entry U(pinv[i],k)
            uindex[unz] = pinv[i];
            uvalues[unz++] = x[i];
          }
        } // validate we found a valid pivot


        if (ipiv === -1 || a <= 0) {
          return null;
        } // update actual pivot column, give preference to diagonal value


        if (pinv[col] < 0 && largerEq(abs(x[col]), multiply(a, tol))) {
          ipiv = col;
        } // the chosen pivot


        var pivot = x[ipiv]; // last entry in U(:,k) is U(k,k)

        uindex[unz] = k;
        uvalues[unz++] = pivot; // ipiv is the kth pivot row

        pinv[ipiv] = k; // first entry in L(:,k) is L(k,k) = 1

        lindex[lnz] = ipiv;
        lvalues[lnz++] = 1; // L(k+1:n,k) = x / pivot

        for (p = top; p < n; p++) {
          // row
          i = xi[p]; // check x(i) is an entry in L(:,k)

          if (pinv[i] < 0) {
            // save unpermuted row in L
            lindex[lnz] = i; // scale pivot column

            lvalues[lnz++] = divideScalar(x[i], pivot);
          } // x[0..n-1] = 0 for next k


          x[i] = 0;
        }
      } // update ptr


      lptr[n] = lnz;
      uptr[n] = unz; // fix row indices of L for final pinv

      for (p = 0; p < lnz; p++) {
        lindex[p] = pinv[lindex[p]];
      } // trim arrays


      lvalues.splice(lnz, lvalues.length - lnz);
      lindex.splice(lnz, lindex.length - lnz);
      uvalues.splice(unz, uvalues.length - unz);
      uindex.splice(unz, uindex.length - unz); // return LU factor

      return {
        L: L,
        U: U,
        pinv: pinv
      };
    };
  });

  var name$3o = 'slu';
  var dependencies$3p = ['typed', 'abs', 'add', 'multiply', 'transpose', 'divideScalar', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];
  var createSlu = /* #__PURE__ */factory(name$3o, dependencies$3p, function (_ref) {
    var typed = _ref.typed,
        abs = _ref.abs,
        add = _ref.add,
        multiply = _ref.multiply,
        transpose = _ref.transpose,
        divideScalar = _ref.divideScalar,
        subtract = _ref.subtract,
        larger = _ref.larger,
        largerEq = _ref.largerEq,
        SparseMatrix = _ref.SparseMatrix;
    var csSqr = createCsSqr({
      add: add,
      multiply: multiply,
      transpose: transpose
    });
    var csLu = createCsLu({
      abs: abs,
      divideScalar: divideScalar,
      multiply: multiply,
      subtract: subtract,
      larger: larger,
      largerEq: largerEq,
      SparseMatrix: SparseMatrix
    });
    /**
     * Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix `A` is decomposed in two matrices (`L`, `U`) and two permutation vectors (`pinv`, `q`) where
     *
     * `P * A * Q = L * U`
     *
     * Syntax:
     *
     *    math.slu(A, order, threshold)
     *
     * Examples:
     *
     *    const A = math.sparse([[4,3], [6, 3]])
     *    math.slu(A, 1, 0.001)
     *    // returns:
     *    // {
     *    //   L: [[1, 0], [1.5, 1]]
     *    //   U: [[4, 3], [0, -1.5]]
     *    //   p: [0, 1]
     *    //   q: [0, 1]
     *    // }
     *
     * See also:
     *
     *    lup, lsolve, usolve, lusolve
     *
     * @param {SparseMatrix} A              A two dimensional sparse matrix for which to get the LU decomposition.
     * @param {Number}       order          The Symbolic Ordering and Analysis order:
     *                                       0 - Natural ordering, no permutation vector q is returned
     *                                       1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A'
     *                                       2 - Symbolic ordering and analisis is performed on M = A' * A. Dense columns from A' are dropped, A recreated from A'.
     *                                           This is appropriatefor LU factorization of unsymmetric matrices.
     *                                       3 - Symbolic ordering and analisis is performed on M = A' * A. This is best used for LU factorization is matrix M has no dense rows.
     *                                           A dense row is a row with more than 10*sqr(columns) entries.
     * @param {Number}       threshold       Partial pivoting threshold (1 for partial pivoting)
     *
     * @return {Object} The lower triangular matrix, the upper triangular matrix and the permutation vectors.
     */

    return typed(name$3o, {
      'SparseMatrix, number, number': function SparseMatrixNumberNumber(a, order, threshold) {
        // verify order
        if (!isInteger(order) || order < 0 || order > 3) {
          throw new Error('Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]');
        } // verify threshold


        if (threshold < 0 || threshold > 1) {
          throw new Error('Partial pivoting threshold must be a number from 0 to 1');
        } // perform symbolic ordering and analysis


        var s = csSqr(order, a, false); // perform lu decomposition

        var f = csLu(a, s, threshold); // return decomposition

        return {
          L: f.L,
          U: f.U,
          p: f.pinv,
          q: s.q,
          toString: function toString() {
            return 'L: ' + this.L.toString() + '\nU: ' + this.U.toString() + '\np: ' + this.p.toString() + (this.q ? '\nq: ' + this.q.toString() : '') + '\n';
          }
        };
      }
    });
  });

  /**
   * Permutes a vector; x = P'b. In MATLAB notation, x(p)=b.
   *
   * @param {Array} p           The permutation vector of length n. null value denotes identity
   * @param {Array} b           The input vector
   *
   * @return {Array}            The output vector x = P'b
   */
  function csIpvec(p, b) {
    // vars
    var k;
    var n = b.length;
    var x = []; // check permutation vector was provided, p = null denotes identity

    if (p) {
      // loop vector
      for (k = 0; k < n; k++) {
        // apply permutation
        x[p[k]] = b[k];
      }
    } else {
      // loop vector
      for (k = 0; k < n; k++) {
        // x[i] = b[i]
        x[k] = b[k];
      }
    }

    return x;
  }

  var name$3p = 'lusolve';
  var dependencies$3q = ['typed', 'matrix', 'lup', 'slu', 'usolve', 'lsolve', 'DenseMatrix'];
  var createLusolve = /* #__PURE__ */factory(name$3p, dependencies$3q, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        lup = _ref.lup,
        slu = _ref.slu,
        usolve = _ref.usolve,
        lsolve = _ref.lsolve,
        DenseMatrix = _ref.DenseMatrix;
    var solveValidation = createSolveValidation({
      DenseMatrix: DenseMatrix
    });
    /**
     * Solves the linear system `A * x = b` where `A` is an [n x n] matrix and `b` is a [n] column vector.
     *
     * Syntax:
     *
     *    math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b
     *    math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)
     *
     * Examples:
     *
     *    const m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]
     *
     *    const x = math.lusolve(m, [-1, -1, -1, -1])        // x = [[-1], [-0.5], [-1/3], [-0.25]]
     *
     *    const f = math.lup(m)
     *    const x1 = math.lusolve(f, [-1, -1, -1, -1])       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]
     *    const x2 = math.lusolve(f, [1, 2, 1, -1])          // x2 = [[1], [1], [1/3], [-0.25]]
     *
     *    const a = [[-2, 3], [2, 1]]
     *    const b = [11, 9]
     *    const x = math.lusolve(a, b)  // [[2], [5]]
     *
     * See also:
     *
     *    lup, slu, lsolve, usolve
     *
     * @param {Matrix | Array | Object} A      Invertible Matrix or the Matrix LU decomposition
     * @param {Matrix | Array} b               Column Vector
     * @param {number} [order]                 The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix
     * @param {Number} [threshold]             Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.
     *
     * @return {DenseMatrix | Array}           Column vector with the solution to the linear system A * x = b
     */

    return typed(name$3p, {
      'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {
        // convert a to matrix
        a = matrix(a); // matrix lup decomposition

        var d = lup(a); // solve

        var x = _lusolve(d.L, d.U, d.p, null, b); // convert result to array


        return x.valueOf();
      },
      'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(a, b) {
        // matrix lup decomposition
        var d = lup(a); // solve

        return _lusolve(d.L, d.U, d.p, null, b);
      },
      'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(a, b) {
        // matrix lup decomposition
        var d = lup(a); // solve

        return _lusolve(d.L, d.U, d.p, null, b);
      },
      'SparseMatrix, Array | Matrix, number, number': function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {
        // matrix lu decomposition
        var d = slu(a, order, threshold); // solve

        return _lusolve(d.L, d.U, d.p, d.q, b);
      },
      'Object, Array | Matrix': function ObjectArrayMatrix(d, b) {
        // solve
        return _lusolve(d.L, d.U, d.p, d.q, b);
      }
    });

    function _toMatrix(a) {
      // check it is a matrix
      if (isMatrix(a)) {
        return a;
      } // check array


      if (isArray(a)) {
        return matrix(a);
      } // throw


      throw new TypeError('Invalid Matrix LU decomposition');
    }

    function _lusolve(l, u, p, q, b) {
      // verify L, U, P
      l = _toMatrix(l);
      u = _toMatrix(u); // validate matrix and vector

      b = solveValidation(l, b, false); // apply row permutations if needed (b is a DenseMatrix)

      if (p) {
        b._data = csIpvec(p, b._data);
      } // use forward substitution to resolve L * y = b


      var y = lsolve(l, b); // use backward substitution to resolve U * x = y

      var x = usolve(u, y); // apply column permutations if needed (x is a DenseMatrix)

      if (q) {
        x._data = csIpvec(q, x._data);
      } // return solution


      return x;
    }
  });

  var name$3q = 'Help';
  var dependencies$3r = ['parse'];
  var createHelpClass = /* #__PURE__ */factory(name$3q, dependencies$3r, function (_ref) {
    var parse = _ref.parse;

    /**
     * Documentation object
     * @param {Object} doc  Object containing properties:
     *                      {string} name
     *                      {string} category
     *                      {string} description
     *                      {string[]} syntax
     *                      {string[]} examples
     *                      {string[]} seealso
     * @constructor
     */
    function Help(doc) {
      if (!(this instanceof Help)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      if (!doc) throw new Error('Argument "doc" missing');
      this.doc = doc;
    }
    /**
     * Attach type information
     */


    Help.prototype.type = 'Help';
    Help.prototype.isHelp = true;
    /**
     * Generate a string representation of the Help object
     * @return {string} Returns a string
     * @private
     */

    Help.prototype.toString = function () {
      var doc = this.doc || {};
      var desc = '\n';

      if (doc.name) {
        desc += 'Name: ' + doc.name + '\n\n';
      }

      if (doc.category) {
        desc += 'Category: ' + doc.category + '\n\n';
      }

      if (doc.description) {
        desc += 'Description:\n    ' + doc.description + '\n\n';
      }

      if (doc.syntax) {
        desc += 'Syntax:\n    ' + doc.syntax.join('\n    ') + '\n\n';
      }

      if (doc.examples) {
        desc += 'Examples:\n';
        var scope = {};

        for (var i = 0; i < doc.examples.length; i++) {
          var expr = doc.examples[i];
          desc += '    ' + expr + '\n';
          var res = void 0;

          try {
            // note: res can be undefined when `expr` is an empty string
            res = parse(expr).compile().evaluate(scope);
          } catch (e) {
            res = e;
          }

          if (res !== undefined && !isHelp(res)) {
            desc += '        ' + format$2(res, {
              precision: 14
            }) + '\n';
          }
        }

        desc += '\n';
      }

      if (doc.seealso && doc.seealso.length) {
        desc += 'See also: ' + doc.seealso.join(', ') + '\n';
      }

      return desc;
    };
    /**
     * Export the help object to JSON
     */


    Help.prototype.toJSON = function () {
      var obj = clone(this.doc);
      obj.mathjs = 'Help';
      return obj;
    };
    /**
     * Instantiate a Help object from a JSON object
     * @param {Object} json
     * @returns {Help} Returns a new Help object
     */


    Help.fromJSON = function (json) {
      var doc = {};
      Object.keys(json).filter(function (prop) {
        return prop !== 'mathjs';
      }).forEach(function (prop) {
        doc[prop] = json[prop];
      });
      return new Help(doc);
    };
    /**
     * Returns a string representation of the Help object
     */


    Help.prototype.valueOf = Help.prototype.toString;
    return Help;
  }, {
    isClass: true
  });

  var name$3r = 'Chain';
  var dependencies$3s = ['?on', 'math'];
  var createChainClass = /* #__PURE__ */factory(name$3r, dependencies$3s, function (_ref) {
    var on = _ref.on,
        math = _ref.math;

    /**
     * @constructor Chain
     * Wrap any value in a chain, allowing to perform chained operations on
     * the value.
     *
     * All methods available in the math.js library can be called upon the chain,
     * and then will be evaluated with the value itself as first argument.
     * The chain can be closed by executing chain.done(), which will return
     * the final value.
     *
     * The Chain has a number of special functions:
     * - done()             Finalize the chained operation and return the
     *                      chain's value.
     * - valueOf()          The same as done()
     * - toString()         Returns a string representation of the chain's value.
     *
     * @param {*} [value]
     */
    function Chain(value) {
      if (!(this instanceof Chain)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }

      if (isChain(value)) {
        this.value = value.value;
      } else {
        this.value = value;
      }
    }
    /**
     * Attach type information
     */


    Chain.prototype.type = 'Chain';
    Chain.prototype.isChain = true;
    /**
     * Close the chain. Returns the final value.
     * Does the same as method valueOf()
     * @returns {*} value
     */

    Chain.prototype.done = function () {
      return this.value;
    };
    /**
     * Close the chain. Returns the final value.
     * Does the same as method done()
     * @returns {*} value
     */


    Chain.prototype.valueOf = function () {
      return this.value;
    };
    /**
     * Get a string representation of the value in the chain
     * @returns {string}
     */


    Chain.prototype.toString = function () {
      return format$2(this.value);
    };
    /**
     * Get a JSON representation of the chain
     * @returns {Object}
     */


    Chain.prototype.toJSON = function () {
      return {
        mathjs: 'Chain',
        value: this.value
      };
    };
    /**
     * Instantiate a Chain from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "Chain", value: ...}`,
     *                       where mathjs is optional
     * @returns {Chain}
     */


    Chain.fromJSON = function (json) {
      return new Chain(json.value);
    };
    /**
     * Create a proxy method for the chain
     * @param {string} name
     * @param {Function} fn      The function to be proxied
     *                           If fn is no function, it is silently ignored.
     * @private
     */


    function createProxy(name, fn) {
      if (typeof fn === 'function') {
        Chain.prototype[name] = chainify(fn);
      }
    }
    /**
     * Create a proxy method for the chain
     * @param {string} name
     * @param {function} resolver   The function resolving with the
     *                              function to be proxied
     * @private
     */


    function createLazyProxy(name, resolver) {
      lazy(Chain.prototype, name, function outerResolver() {
        var fn = resolver();

        if (typeof fn === 'function') {
          return chainify(fn);
        }

        return undefined; // if not a function, ignore
      });
    }
    /**
     * Make a function chainable
     * @param {function} fn
     * @return {Function} chain function
     * @private
     */


    function chainify(fn) {
      return function () {
        var args = [this.value]; // `this` will be the context of a Chain instance

        for (var i = 0; i < arguments.length; i++) {
          args[i + 1] = arguments[i];
        }

        return new Chain(fn.apply(fn, args));
      };
    }
    /**
     * Create a proxy for a single method, or an object with multiple methods.
     * Example usage:
     *
     *   Chain.createProxy('add', function add (x, y) {...})
     *   Chain.createProxy({
     *     add:      function add (x, y) {...},
     *     subtract: function subtract (x, y) {...}
     *   }
     *
     * @param {string | Object} arg0   A name (string), or an object with
     *                                 functions
     * @param {*} [arg1]               A function, when arg0 is a name
     */


    Chain.createProxy = function (arg0, arg1) {
      if (typeof arg0 === 'string') {
        // createProxy(name, value)
        createProxy(arg0, arg1);
      } else {
        var _loop = function _loop(_name) {
          if (hasOwnProperty(arg0, _name) && excludedNames[_name] === undefined) {
            createLazyProxy(_name, function () {
              return arg0[_name];
            });
          }
        };

        // createProxy(values)
        for (var _name in arg0) {
          _loop(_name);
        }
      }
    };

    var excludedNames = {
      expression: true,
      docs: true,
      type: true,
      classes: true,
      json: true,
      error: true,
      isChain: true // conflicts with the property isChain of a Chain instance

    }; // create proxy for everything that is in math.js

    Chain.createProxy(math); // register on the import event, automatically add a proxy for every imported function.

    if (on) {
      on('import', function (name, resolver, path) {
        if (!path) {
          // an imported function (not a data type or something special)
          createLazyProxy(name, resolver);
        }
      });
    }

    return Chain;
  }, {
    isClass: true
  });

  var bignumberDocs = {
    name: 'bignumber',
    category: 'Construction',
    syntax: ['bignumber(x)'],
    description: 'Create a big number from a number or string.',
    examples: ['0.1 + 0.2', 'bignumber(0.1) + bignumber(0.2)', 'bignumber("7.2")', 'bignumber("7.2e500")', 'bignumber([0.1, 0.2, 0.3])'],
    seealso: ['boolean', 'complex', 'fraction', 'index', 'matrix', 'string', 'unit']
  };

  var typeOfDocs = {
    name: 'typeOf',
    category: 'Utils',
    syntax: ['typeOf(x)'],
    description: 'Get the type of a variable.',
    examples: ['typeOf(3.5)', 'typeOf(2 - 4i)', 'typeOf(45 deg)', 'typeOf("hello world")'],
    seealso: ['getMatrixDataType']
  };

  var isZeroDocs = {
    name: 'isZero',
    category: 'Utils',
    syntax: ['isZero(x)'],
    description: 'Test whether a value is zero.',
    examples: ['isZero(2)', 'isZero(0)', 'isZero(-4)', 'isZero([3, 0, -2, 0])'],
    seealso: ['isInteger', 'isNumeric', 'isNegative', 'isPositive']
  };

  var isPrimeDocs = {
    name: 'isPrime',
    category: 'Utils',
    syntax: ['isPrime(x)'],
    description: 'Test whether a value is prime: has no divisors other than itself and one.',
    examples: ['isPrime(3)', 'isPrime(-2)', 'isPrime([2, 17, 100])'],
    seealso: ['isInteger', 'isNumeric', 'isNegative', 'isZero']
  };

  var isPositiveDocs = {
    name: 'isPositive',
    category: 'Utils',
    syntax: ['isPositive(x)'],
    description: 'Test whether a value is positive: larger than zero.',
    examples: ['isPositive(2)', 'isPositive(0)', 'isPositive(-4)', 'isPositive([3, 0.5, -2])'],
    seealso: ['isInteger', 'isNumeric', 'isNegative', 'isZero']
  };

  var isNumericDocs = {
    name: 'isNumeric',
    category: 'Utils',
    syntax: ['isNumeric(x)'],
    description: 'Test whether a value is a numeric value. ' + 'Returns true when the input is a number, BigNumber, Fraction, or boolean.',
    examples: ['isNumeric(2)', 'isNumeric("2")', 'hasNumericValue("2")', 'isNumeric(0)', 'isNumeric(bignumber(500))', 'isNumeric(fraction(0.125))', 'isNumeric(2 + 3i)', 'isNumeric([2.3, "foo", false])'],
    seealso: ['isInteger', 'isZero', 'isNegative', 'isPositive', 'isNaN', 'hasNumericValue']
  };

  var hasNumericValueDocs = {
    name: 'hasNumericValue',
    category: 'Utils',
    syntax: ['hasNumericValue(x)'],
    description: 'Test whether a value is an numeric value. ' + 'In case of a string, true is returned if the string contains a numeric value.',
    examples: ['hasNumericValue(2)', 'hasNumericValue("2")', 'isNumeric("2")', 'hasNumericValue(0)', 'hasNumericValue(bignumber(500))', 'hasNumericValue(fraction(0.125))', 'hasNumericValue(2 + 3i)', 'hasNumericValue([2.3, "foo", false])'],
    seealso: ['isInteger', 'isZero', 'isNegative', 'isPositive', 'isNaN', 'isNumeric']
  };

  var isNegativeDocs = {
    name: 'isNegative',
    category: 'Utils',
    syntax: ['isNegative(x)'],
    description: 'Test whether a value is negative: smaller than zero.',
    examples: ['isNegative(2)', 'isNegative(0)', 'isNegative(-4)', 'isNegative([3, 0.5, -2])'],
    seealso: ['isInteger', 'isNumeric', 'isPositive', 'isZero']
  };

  var isIntegerDocs = {
    name: 'isInteger',
    category: 'Utils',
    syntax: ['isInteger(x)'],
    description: 'Test whether a value is an integer number.',
    examples: ['isInteger(2)', 'isInteger(3.5)', 'isInteger([3, 0.5, -2])'],
    seealso: ['isNegative', 'isNumeric', 'isPositive', 'isZero']
  };

  var isNaNDocs = {
    name: 'isNaN',
    category: 'Utils',
    syntax: ['isNaN(x)'],
    description: 'Test whether a value is NaN (not a number)',
    examples: ['isNaN(2)', 'isNaN(0 / 0)', 'isNaN(NaN)', 'isNaN(Infinity)'],
    seealso: ['isNegative', 'isNumeric', 'isPositive', 'isZero']
  };

  var formatDocs = {
    name: 'format',
    category: 'Utils',
    syntax: ['format(value)', 'format(value, precision)'],
    description: 'Format a value of any type as string.',
    examples: ['format(2.3)', 'format(3 - 4i)', 'format([])', 'format(pi, 3)'],
    seealso: ['print']
  };

  var cloneDocs = {
    name: 'clone',
    category: 'Utils',
    syntax: ['clone(x)'],
    description: 'Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices',
    examples: ['clone(3.5)', 'clone(2 - 4i)', 'clone(45 deg)', 'clone([1, 2; 3, 4])', 'clone("hello world")'],
    seealso: []
  };

  var toDocs = {
    name: 'to',
    category: 'Units',
    syntax: ['x to unit', 'to(x, unit)'],
    description: 'Change the unit of a value.',
    examples: ['5 inch to cm', '3.2kg to g', '16 bytes in bits'],
    seealso: []
  };

  var tanhDocs = {
    name: 'tanh',
    category: 'Trigonometry',
    syntax: ['tanh(x)'],
    description: 'Compute the hyperbolic tangent of x in radians.',
    examples: ['tanh(0.5)', 'sinh(0.5) / cosh(0.5)'],
    seealso: ['sinh', 'cosh']
  };

  var tanDocs = {
    name: 'tan',
    category: 'Trigonometry',
    syntax: ['tan(x)'],
    description: 'Compute the tangent of x in radians.',
    examples: ['tan(0.5)', 'sin(0.5) / cos(0.5)', 'tan(pi / 4)', 'tan(45 deg)'],
    seealso: ['atan', 'sin', 'cos']
  };

  var sinhDocs = {
    name: 'sinh',
    category: 'Trigonometry',
    syntax: ['sinh(x)'],
    description: 'Compute the hyperbolic sine of x in radians.',
    examples: ['sinh(0.5)'],
    seealso: ['cosh', 'tanh']
  };

  var sechDocs = {
    name: 'sech',
    category: 'Trigonometry',
    syntax: ['sech(x)'],
    description: 'Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)',
    examples: ['sech(2)', '1 / cosh(2)'],
    seealso: ['coth', 'csch', 'cosh']
  };

  var secDocs = {
    name: 'sec',
    category: 'Trigonometry',
    syntax: ['sec(x)'],
    description: 'Compute the secant of x in radians. Defined as 1/cos(x)',
    examples: ['sec(2)', '1 / cos(2)'],
    seealso: ['cot', 'csc', 'cos']
  };

  var cschDocs = {
    name: 'csch',
    category: 'Trigonometry',
    syntax: ['csch(x)'],
    description: 'Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)',
    examples: ['csch(2)', '1 / sinh(2)'],
    seealso: ['sech', 'coth', 'sinh']
  };

  var cscDocs = {
    name: 'csc',
    category: 'Trigonometry',
    syntax: ['csc(x)'],
    description: 'Compute the cosecant of x in radians. Defined as 1/sin(x)',
    examples: ['csc(2)', '1 / sin(2)'],
    seealso: ['sec', 'cot', 'sin']
  };

  var cothDocs = {
    name: 'coth',
    category: 'Trigonometry',
    syntax: ['coth(x)'],
    description: 'Compute the hyperbolic cotangent of x in radians.',
    examples: ['coth(2)', '1 / tanh(2)'],
    seealso: ['sech', 'csch', 'tanh']
  };

  var cotDocs = {
    name: 'cot',
    category: 'Trigonometry',
    syntax: ['cot(x)'],
    description: 'Compute the cotangent of x in radians. Defined as 1/tan(x)',
    examples: ['cot(2)', '1 / tan(2)'],
    seealso: ['sec', 'csc', 'tan']
  };

  var coshDocs = {
    name: 'cosh',
    category: 'Trigonometry',
    syntax: ['cosh(x)'],
    description: 'Compute the hyperbolic cosine of x in radians.',
    examples: ['cosh(0.5)'],
    seealso: ['sinh', 'tanh', 'coth']
  };

  var cosDocs = {
    name: 'cos',
    category: 'Trigonometry',
    syntax: ['cos(x)'],
    description: 'Compute the cosine of x in radians.',
    examples: ['cos(2)', 'cos(pi / 4) ^ 2', 'cos(180 deg)', 'cos(60 deg)', 'sin(0.2)^2 + cos(0.2)^2'],
    seealso: ['acos', 'sin', 'tan']
  };

  var atan2Docs = {
    name: 'atan2',
    category: 'Trigonometry',
    syntax: ['atan2(y, x)'],
    description: 'Computes the principal value of the arc tangent of y/x in radians.',
    examples: ['atan2(2, 2) / pi', 'angle = 60 deg in rad', 'x = cos(angle)', 'y = sin(angle)', 'atan2(y, x)'],
    seealso: ['sin', 'cos', 'tan']
  };

  var atanhDocs = {
    name: 'atanh',
    category: 'Trigonometry',
    syntax: ['atanh(x)'],
    description: 'Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.',
    examples: ['atanh(0.5)'],
    seealso: ['acosh', 'asinh']
  };

  var atanDocs = {
    name: 'atan',
    category: 'Trigonometry',
    syntax: ['atan(x)'],
    description: 'Compute the inverse tangent of a value in radians.',
    examples: ['atan(0.5)', 'atan(tan(0.5))'],
    seealso: ['tan', 'acos', 'asin']
  };

  var asinhDocs = {
    name: 'asinh',
    category: 'Trigonometry',
    syntax: ['asinh(x)'],
    description: 'Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.',
    examples: ['asinh(0.5)'],
    seealso: ['acosh', 'atanh']
  };

  var asinDocs = {
    name: 'asin',
    category: 'Trigonometry',
    syntax: ['asin(x)'],
    description: 'Compute the inverse sine of a value in radians.',
    examples: ['asin(0.5)', 'asin(sin(0.5))'],
    seealso: ['sin', 'acos', 'atan']
  };

  var asechDocs = {
    name: 'asech',
    category: 'Trigonometry',
    syntax: ['asech(x)'],
    description: 'Calculate the inverse secant of a value.',
    examples: ['asech(0.5)'],
    seealso: ['acsch', 'acoth']
  };

  var asecDocs = {
    name: 'asec',
    category: 'Trigonometry',
    syntax: ['asec(x)'],
    description: 'Calculate the inverse secant of a value.',
    examples: ['asec(0.5)', 'asec(sec(0.5))', 'asec(2)'],
    seealso: ['acos', 'acot', 'acsc']
  };

  var acschDocs = {
    name: 'acsch',
    category: 'Trigonometry',
    syntax: ['acsch(x)'],
    description: 'Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.',
    examples: ['acsch(0.5)'],
    seealso: ['asech', 'acoth']
  };

  var acscDocs = {
    name: 'acsc',
    category: 'Trigonometry',
    syntax: ['acsc(x)'],
    description: 'Calculate the inverse cotangent of a value.',
    examples: ['acsc(2)', 'acsc(csc(0.5))', 'acsc(0.5)'],
    seealso: ['csc', 'asin', 'asec']
  };

  var acothDocs = {
    name: 'acoth',
    category: 'Trigonometry',
    syntax: ['acoth(x)'],
    description: 'Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.',
    examples: ['acoth(2)', 'acoth(0.5)'],
    seealso: ['acsch', 'asech']
  };

  var acotDocs = {
    name: 'acot',
    category: 'Trigonometry',
    syntax: ['acot(x)'],
    description: 'Calculate the inverse cotangent of a value.',
    examples: ['acot(0.5)', 'acot(cot(0.5))', 'acot(2)'],
    seealso: ['cot', 'atan']
  };

  var acoshDocs = {
    name: 'acosh',
    category: 'Trigonometry',
    syntax: ['acosh(x)'],
    description: 'Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.',
    examples: ['acosh(1.5)'],
    seealso: ['cosh', 'asinh', 'atanh']
  };

  var acosDocs = {
    name: 'acos',
    category: 'Trigonometry',
    syntax: ['acos(x)'],
    description: 'Compute the inverse cosine of a value in radians.',
    examples: ['acos(0.5)', 'acos(cos(2.3))'],
    seealso: ['cos', 'atan', 'asin']
  };

  var sumDocs = {
    name: 'sum',
    category: 'Statistics',
    syntax: ['sum(a, b, c, ...)', 'sum(A)'],
    description: 'Compute the sum of all values.',
    examples: ['sum(2, 3, 4, 1)', 'sum([2, 3, 4, 1])', 'sum([2, 5; 4, 3])'],
    seealso: ['max', 'mean', 'median', 'min', 'prod', 'std', 'sum', 'variance']
  };

  var stdDocs = {
    name: 'std',
    category: 'Statistics',
    syntax: ['std(a, b, c, ...)', 'std(A)', 'std(A, normalization)'],
    description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
    examples: ['std(2, 4, 6)', 'std([2, 4, 6, 8])', 'std([2, 4, 6, 8], "uncorrected")', 'std([2, 4, 6, 8], "biased")', 'std([1, 2, 3; 4, 5, 6])'],
    seealso: ['max', 'mean', 'min', 'median', 'prod', 'sum', 'variance']
  };

  var quantileSeqDocs = {
    name: 'quantileSeq',
    category: 'Statistics',
    syntax: ['quantileSeq(A, prob[, sorted])', 'quantileSeq(A, [prob1, prob2, ...][, sorted])', 'quantileSeq(A, N[, sorted])'],
    description: 'Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.',
    examples: ['quantileSeq([3, -1, 5, 7], 0.5)', 'quantileSeq([3, -1, 5, 7], [1/3, 2/3])', 'quantileSeq([3, -1, 5, 7], 2)', 'quantileSeq([-1, 3, 5, 7], 0.5, true)'],
    seealso: ['mean', 'median', 'min', 'max', 'prod', 'std', 'sum', 'variance']
  };

  var prodDocs = {
    name: 'prod',
    category: 'Statistics',
    syntax: ['prod(a, b, c, ...)', 'prod(A)'],
    description: 'Compute the product of all values.',
    examples: ['prod(2, 3, 4)', 'prod([2, 3, 4])', 'prod([2, 5; 4, 3])'],
    seealso: ['max', 'mean', 'min', 'median', 'min', 'std', 'sum', 'variance']
  };

  var modeDocs = {
    name: 'mode',
    category: 'Statistics',
    syntax: ['mode(a, b, c, ...)', 'mode(A)', 'mode(A, a, b, B, c, ...)'],
    description: 'Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.',
    examples: ['mode(2, 1, 4, 3, 1)', 'mode([1, 2.7, 3.2, 4, 2.7])', 'mode(1, 4, 6, 1, 6)'],
    seealso: ['max', 'mean', 'min', 'median', 'prod', 'std', 'sum', 'variance']
  };

  var minDocs = {
    name: 'min',
    category: 'Statistics',
    syntax: ['min(a, b, c, ...)', 'min(A)', 'min(A, dim)'],
    description: 'Compute the minimum value of a list of values.',
    examples: ['min(2, 3, 4, 1)', 'min([2, 3, 4, 1])', 'min([2, 5; 4, 3])', 'min([2, 5; 4, 3], 1)', 'min([2, 5; 4, 3], 2)', 'min(2.7, 7.1, -4.5, 2.0, 4.1)', 'max(2.7, 7.1, -4.5, 2.0, 4.1)'],
    seealso: ['max', 'mean', 'median', 'prod', 'std', 'sum', 'variance']
  };

  var medianDocs = {
    name: 'median',
    category: 'Statistics',
    syntax: ['median(a, b, c, ...)', 'median(A)'],
    description: 'Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.',
    examples: ['median(5, 2, 7)', 'median([3, -1, 5, 7])'],
    seealso: ['max', 'mean', 'min', 'prod', 'std', 'sum', 'variance', 'quantileSeq']
  };

  var meanDocs = {
    name: 'mean',
    category: 'Statistics',
    syntax: ['mean(a, b, c, ...)', 'mean(A)', 'mean(A, dim)'],
    description: 'Compute the arithmetic mean of a list of values.',
    examples: ['mean(2, 3, 4, 1)', 'mean([2, 3, 4, 1])', 'mean([2, 5; 4, 3])', 'mean([2, 5; 4, 3], 1)', 'mean([2, 5; 4, 3], 2)', 'mean([1.0, 2.7, 3.2, 4.0])'],
    seealso: ['max', 'median', 'min', 'prod', 'std', 'sum', 'variance']
  };

  var maxDocs = {
    name: 'max',
    category: 'Statistics',
    syntax: ['max(a, b, c, ...)', 'max(A)', 'max(A, dim)'],
    description: 'Compute the maximum value of a list of values.',
    examples: ['max(2, 3, 4, 1)', 'max([2, 3, 4, 1])', 'max([2, 5; 4, 3])', 'max([2, 5; 4, 3], 1)', 'max([2, 5; 4, 3], 2)', 'max(2.7, 7.1, -4.5, 2.0, 4.1)', 'min(2.7, 7.1, -4.5, 2.0, 4.1)'],
    seealso: ['mean', 'median', 'min', 'prod', 'std', 'sum', 'variance']
  };

  var madDocs = {
    name: 'mad',
    category: 'Statistics',
    syntax: ['mad(a, b, c, ...)', 'mad(A)'],
    description: 'Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.',
    examples: ['mad(10, 20, 30)', 'mad([1, 2, 3])'],
    seealso: ['mean', 'median', 'std', 'abs']
  };

  var erfDocs = {
    name: 'erf',
    category: 'Special',
    syntax: ['erf(x)'],
    description: 'Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x',
    examples: ['erf(0.2)', 'erf(-0.5)', 'erf(4)'],
    seealso: []
  };

  var setUnionDocs = {
    name: 'setUnion',
    category: 'Set',
    syntax: ['setUnion(set1, set2)'],
    description: 'Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.',
    examples: ['setUnion([1, 2, 3, 4], [3, 4, 5, 6])', 'setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])'],
    seealso: ['setIntersect', 'setDifference']
  };

  var setSymDifferenceDocs = {
    name: 'setSymDifference',
    category: 'Set',
    syntax: ['setSymDifference(set1, set2)'],
    description: 'Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.',
    examples: ['setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])', 'setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])'],
    seealso: ['setUnion', 'setIntersect', 'setDifference']
  };

  var setSizeDocs = {
    name: 'setSize',
    category: 'Set',
    syntax: ['setSize(set)', 'setSize(set, unique)'],
    description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
    examples: ['setSize([1, 2, 2, 4])', 'setSize([1, 2, 2, 4], true)'],
    seealso: ['setUnion', 'setIntersect', 'setDifference']
  };

  var setPowersetDocs = {
    name: 'setPowerset',
    category: 'Set',
    syntax: ['setPowerset(set)'],
    description: 'Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.',
    examples: ['setPowerset([1, 2, 3])'],
    seealso: ['setCartesian']
  };

  var setMultiplicityDocs = {
    name: 'setMultiplicity',
    category: 'Set',
    syntax: ['setMultiplicity(element, set)'],
    description: 'Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.',
    examples: ['setMultiplicity(1, [1, 2, 2, 4])', 'setMultiplicity(2, [1, 2, 2, 4])'],
    seealso: ['setDistinct', 'setSize']
  };

  var setIsSubsetDocs = {
    name: 'setIsSubset',
    category: 'Set',
    syntax: ['setIsSubset(set1, set2)'],
    description: 'Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.',
    examples: ['setIsSubset([1, 2], [3, 4, 5, 6])', 'setIsSubset([3, 4], [3, 4, 5, 6])'],
    seealso: ['setUnion', 'setIntersect', 'setDifference']
  };

  var setIntersectDocs = {
    name: 'setIntersect',
    category: 'Set',
    syntax: ['setIntersect(set1, set2)'],
    description: 'Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.',
    examples: ['setIntersect([1, 2, 3, 4], [3, 4, 5, 6])', 'setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])'],
    seealso: ['setUnion', 'setDifference']
  };

  var setDistinctDocs = {
    name: 'setDistinct',
    category: 'Set',
    syntax: ['setDistinct(set)'],
    description: 'Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.',
    examples: ['setDistinct([1, 1, 1, 2, 2, 3])'],
    seealso: ['setMultiplicity']
  };

  var setDifferenceDocs = {
    name: 'setDifference',
    category: 'Set',
    syntax: ['setDifference(set1, set2)'],
    description: 'Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.',
    examples: ['setDifference([1, 2, 3, 4], [3, 4, 5, 6])', 'setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])'],
    seealso: ['setUnion', 'setIntersect', 'setSymDifference']
  };

  var setCartesianDocs = {
    name: 'setCartesian',
    category: 'Set',
    syntax: ['setCartesian(set1, set2)'],
    description: 'Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.',
    examples: ['setCartesian([1, 2], [3, 4])'],
    seealso: ['setUnion', 'setIntersect', 'setDifference', 'setPowerset']
  };

  var unequalDocs = {
    name: 'unequal',
    category: 'Relational',
    syntax: ['x != y', 'unequal(x, y)'],
    description: 'Check unequality of two values. Returns true if the values are unequal, and false if they are equal.',
    examples: ['2+2 != 3', '2+2 != 4', 'a = 3.2', 'b = 6-2.8', 'a != b', '50cm != 0.5m', '5 cm != 2 inch'],
    seealso: ['equal', 'smaller', 'larger', 'smallerEq', 'largerEq', 'compare', 'deepEqual']
  };

  var smallerEqDocs = {
    name: 'smallerEq',
    category: 'Relational',
    syntax: ['x <= y', 'smallerEq(x, y)'],
    description: 'Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.',
    examples: ['2 <= 1+1', '2 < 1+1', 'a = 3.2', 'b = 6-2.8', '(a <= b)'],
    seealso: ['equal', 'unequal', 'larger', 'smaller', 'largerEq', 'compare']
  };

  var smallerDocs = {
    name: 'smaller',
    category: 'Relational',
    syntax: ['x < y', 'smaller(x, y)'],
    description: 'Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.',
    examples: ['2 < 3', '5 < 2*2', 'a = 3.3', 'b = 6-2.8', '(a < b)', '5 cm < 2 inch'],
    seealso: ['equal', 'unequal', 'larger', 'smallerEq', 'largerEq', 'compare']
  };

  var largerEqDocs = {
    name: 'largerEq',
    category: 'Relational',
    syntax: ['x >= y', 'largerEq(x, y)'],
    description: 'Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.',
    examples: ['2 >= 1+1', '2 > 1+1', 'a = 3.2', 'b = 6-2.8', '(a >= b)'],
    seealso: ['equal', 'unequal', 'smallerEq', 'smaller', 'compare']
  };

  var largerDocs = {
    name: 'larger',
    category: 'Relational',
    syntax: ['x > y', 'larger(x, y)'],
    description: 'Check if value x is larger than y. Returns true if x is larger than y, and false if not.',
    examples: ['2 > 3', '5 > 2*2', 'a = 3.3', 'b = 6-2.8', '(a > b)', '(b < a)', '5 cm > 2 inch'],
    seealso: ['equal', 'unequal', 'smaller', 'smallerEq', 'largerEq', 'compare']
  };

  var equalTextDocs = {
    name: 'equalText',
    category: 'Relational',
    syntax: ['equalText(x, y)'],
    description: 'Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.',
    examples: ['equalText("Hello", "Hello")', 'equalText("a", "A")', 'equal("2e3", "2000")', 'equalText("2e3", "2000")', 'equalText("B", ["A", "B", "C"])'],
    seealso: ['compare', 'compareNatural', 'compareText', 'equal']
  };

  var equalDocs = {
    name: 'equal',
    category: 'Relational',
    syntax: ['x == y', 'equal(x, y)'],
    description: 'Check equality of two values. Returns true if the values are equal, and false if not.',
    examples: ['2+2 == 3', '2+2 == 4', 'a = 3.2', 'b = 6-2.8', 'a == b', '50cm == 0.5m'],
    seealso: ['unequal', 'smaller', 'larger', 'smallerEq', 'largerEq', 'compare', 'deepEqual', 'equalText']
  };

  var deepEqualDocs = {
    name: 'deepEqual',
    category: 'Relational',
    syntax: ['deepEqual(x, y)'],
    description: 'Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.',
    examples: ['deepEqual([1,3,4], [1,3,4])', 'deepEqual([1,3,4], [1,3])'],
    seealso: ['equal', 'unequal', 'smaller', 'larger', 'smallerEq', 'largerEq', 'compare']
  };

  var compareTextDocs = {
    name: 'compareText',
    category: 'Relational',
    syntax: ['compareText(x, y)'],
    description: 'Compare two strings lexically. Comparison is case sensitive. ' + 'Returns 1 when x > y, -1 when x < y, and 0 when x == y.',
    examples: ['compareText("B", "A")', 'compareText("A", "B")', 'compareText("A", "A")', 'compareText("2", "10")', 'compare("2", "10")', 'compare(2, 10)', 'compareNatural("2", "10")', 'compareText("B", ["A", "B", "C"])'],
    seealso: ['compare', 'compareNatural']
  };

  var compareNaturalDocs = {
    name: 'compareNatural',
    category: 'Relational',
    syntax: ['compareNatural(x, y)'],
    description: 'Compare two values of any type in a deterministic, natural way. ' + 'Returns 1 when x > y, -1 when x < y, and 0 when x == y.',
    examples: ['compareNatural(2, 3)', 'compareNatural(3, 2)', 'compareNatural(2, 2)', 'compareNatural(5cm, 40mm)', 'compareNatural("2", "10")', 'compareNatural(2 + 3i, 2 + 4i)', 'compareNatural([1, 2, 4], [1, 2, 3])', 'compareNatural([1, 5], [1, 2, 3])', 'compareNatural([1, 2], [1, 2])', 'compareNatural({a: 2}, {a: 4})'],
    seealso: ['equal', 'unequal', 'smaller', 'smallerEq', 'largerEq', 'compare', 'compareText']
  };

  var compareDocs = {
    name: 'compare',
    category: 'Relational',
    syntax: ['compare(x, y)'],
    description: 'Compare two values. ' + 'Returns 1 when x > y, -1 when x < y, and 0 when x == y.',
    examples: ['compare(2, 3)', 'compare(3, 2)', 'compare(2, 2)', 'compare(5cm, 40mm)', 'compare(2, [1, 2, 3])'],
    seealso: ['equal', 'unequal', 'smaller', 'smallerEq', 'largerEq', 'compareNatural', 'compareText']
  };

  var randomIntDocs = {
    name: 'randomInt',
    category: 'Probability',
    syntax: ['randomInt(max)', 'randomInt(min, max)', 'randomInt(size)', 'randomInt(size, max)', 'randomInt(size, min, max)'],
    description: 'Return a random integer number',
    examples: ['randomInt(10, 20)', 'randomInt([2, 3], 10)'],
    seealso: ['pickRandom', 'random']
  };

  var randomDocs = {
    name: 'random',
    category: 'Probability',
    syntax: ['random()', 'random(max)', 'random(min, max)', 'random(size)', 'random(size, max)', 'random(size, min, max)'],
    description: 'Return a random number.',
    examples: ['random()', 'random(10, 20)', 'random([2, 3])'],
    seealso: ['pickRandom', 'randomInt']
  };

  var pickRandomDocs = {
    name: 'pickRandom',
    category: 'Probability',
    syntax: ['pickRandom(array)', 'pickRandom(array, number)', 'pickRandom(array, weights)', 'pickRandom(array, number, weights)', 'pickRandom(array, weights, number)'],
    description: 'Pick a random entry from a given array.',
    examples: ['pickRandom(0:10)', 'pickRandom([1, 3, 1, 6])', 'pickRandom([1, 3, 1, 6], 2)', 'pickRandom([1, 3, 1, 6], [2, 3, 2, 1])', 'pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])', 'pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)'],
    seealso: ['random', 'randomInt']
  };

  var permutationsDocs = {
    name: 'permutations',
    category: 'Probability',
    syntax: ['permutations(n)', 'permutations(n, k)'],
    description: 'Compute the number of permutations of n items taken k at a time',
    examples: ['permutations(5)', 'permutations(5, 3)'],
    seealso: ['combinations', 'combinationsWithRep', 'factorial']
  };

  var multinomialDocs = {
    name: 'multinomial',
    category: 'Probability',
    syntax: ['multinomial(A)'],
    description: 'Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.',
    examples: ['multinomial([1, 2, 1])'],
    seealso: ['combinations', 'factorial']
  };

  var kldivergenceDocs = {
    name: 'kldivergence',
    category: 'Probability',
    syntax: ['kldivergence(x, y)'],
    description: 'Calculate the Kullback-Leibler (KL) divergence  between two distributions.',
    examples: ['kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])'],
    seealso: []
  };

  var gammaDocs = {
    name: 'gamma',
    category: 'Probability',
    syntax: ['gamma(n)'],
    description: 'Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.',
    examples: ['gamma(4)', '3!', 'gamma(1/2)', 'sqrt(pi)'],
    seealso: ['factorial']
  };

  var factorialDocs = {
    name: 'factorial',
    category: 'Probability',
    syntax: ['n!', 'factorial(n)'],
    description: 'Compute the factorial of a value',
    examples: ['5!', '5 * 4 * 3 * 2 * 1', '3!'],
    seealso: ['combinations', 'combinationsWithRep', 'permutations', 'gamma']
  };

  var combinationsDocs = {
    name: 'combinations',
    category: 'Probability',
    syntax: ['combinations(n, k)'],
    description: 'Compute the number of combinations of n items taken k at a time',
    examples: ['combinations(7, 5)'],
    seealso: ['combinationsWithRep', 'permutations', 'factorial']
  };

  var combinationsWithRepDocs = {
    name: 'combinationsWithRep',
    category: 'Probability',
    syntax: ['combinationsWithRep(n, k)'],
    description: 'Compute the number of combinations of n items taken k at a time with replacements.',
    examples: ['combinationsWithRep(7, 5)'],
    seealso: ['combinations', 'permutations', 'factorial']
  };

  var zerosDocs = {
    name: 'zeros',
    category: 'Matrix',
    syntax: ['zeros(m)', 'zeros(m, n)', 'zeros(m, n, p, ...)', 'zeros([m])', 'zeros([m, n])', 'zeros([m, n, p, ...])'],
    description: 'Create a matrix containing zeros.',
    examples: ['zeros(3)', 'zeros(3, 5)', 'a = [1, 2, 3; 4, 5, 6]', 'zeros(size(a))'],
    seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose']
  };

  var transposeDocs = {
    name: 'transpose',
    category: 'Matrix',
    syntax: ['x\'', 'transpose(x)'],
    description: 'Transpose a matrix',
    examples: ['a = [1, 2, 3; 4, 5, 6]', 'a\'', 'transpose(a)'],
    seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'zeros']
  };

  var traceDocs = {
    name: 'trace',
    category: 'Matrix',
    syntax: ['trace(A)'],
    description: 'Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.',
    examples: ['A = [1, 2, 3; -1, 2, 3; 2, 0, 3]', 'trace(A)'],
    seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'transpose', 'zeros']
  };

  var subsetDocs = {
    name: 'subset',
    category: 'Matrix',
    syntax: ['value(index)', 'value(index) = replacement', 'subset(value, [index])', 'subset(value, [index], replacement)'],
    description: 'Get or set a subset of a matrix or string. ' + 'Indexes are one-based. ' + 'Both the ranges lower-bound and upper-bound are included.',
    examples: ['d = [1, 2; 3, 4]', 'e = []', 'e[1, 1:2] = [5, 6]', 'e[2, :] = [7, 8]', 'f = d * e', 'f[2, 1]', 'f[:, 1]'],
    seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'ones', 'range', 'size', 'squeeze', 'trace', 'transpose', 'zeros']
  };

  var squeezeDocs = {
    name: 'squeeze',
    category: 'Matrix',
    syntax: ['squeeze(x)'],
    description: 'Remove inner and outer singleton dimensions from a matrix.',
    examples: ['a = zeros(3,2,1)', 'size(squeeze(a))', 'b = zeros(1,1,3)', 'size(squeeze(b))'],
    seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'ones', 'range', 'size', 'subset', 'trace', 'transpose', 'zeros']
  };

  var sortDocs = {
    name: 'sort',
    category: 'Matrix',
    syntax: ['sort(x)', 'sort(x, compare)'],
    description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
    examples: ['sort([5, 10, 1])', 'sort(["C", "B", "A", "D"])', 'sortByLength(a, b) = size(a)[1] - size(b)[1]', 'sort(["Langdon", "Tom", "Sara"], sortByLength)', 'sort(["10", "1", "2"], "natural")'],
    seealso: ['map', 'filter', 'forEach']
  };

  var sizeDocs = {
    name: 'size',
    category: 'Matrix',
    syntax: ['size(x)'],
    description: 'Calculate the size of a matrix.',
    examples: ['size(2.3)', 'size("hello world")', 'a = [1, 2; 3, 4; 5, 6]', 'size(a)', 'size(1:6)'],
    seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'ones', 'range', 'squeeze', 'subset', 'trace', 'transpose', 'zeros']
  };

  var reshapeDocs = {
    name: 'reshape',
    category: 'Matrix',
    syntax: ['reshape(x, sizes)'],
    description: 'Reshape a multi dimensional array to fit the specified dimensions.',
    examples: ['reshape([1, 2, 3, 4, 5, 6], [2, 3])', 'reshape([[1, 2], [3, 4]], [1, 4])', 'reshape([[1, 2], [3, 4]], [4])'],
    seealso: ['size', 'squeeze', 'resize']
  };

  var resizeDocs = {
    name: 'resize',
    category: 'Matrix',
    syntax: ['resize(x, size)', 'resize(x, size, defaultValue)'],
    description: 'Resize a matrix.',
    examples: ['resize([1,2,3,4,5], [3])', 'resize([1,2,3], [5])', 'resize([1,2,3], [5], -1)', 'resize(2, [2, 3])', 'resize("hello", [8], "!")'],
    seealso: ['size', 'subset', 'squeeze', 'reshape']
  };

  var rangeDocs = {
    name: 'range',
    category: 'Type',
    syntax: ['start:end', 'start:step:end', 'range(start, end)', 'range(start, end, step)', 'range(string)'],
    description: 'Create a range. Lower bound of the range is included, upper bound is excluded.',
    examples: ['1:5', '3:-1:-3', 'range(3, 7)', 'range(0, 12, 2)', 'range("4:10")', 'a = [1, 2, 3, 4; 5, 6, 7, 8]', 'a[1:2, 1:2]'],
    seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'ones', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros']
  };

  var partitionSelectDocs = {
    name: 'partitionSelect',
    category: 'Matrix',
    syntax: ['partitionSelect(x, k)', 'partitionSelect(x, k, compare)'],
    description: 'Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.',
    examples: ['partitionSelect([5, 10, 1], 2)', 'partitionSelect(["C", "B", "A", "D"], 1)'],
    seealso: ['sort']
  };

  var onesDocs = {
    name: 'ones',
    category: 'Matrix',
    syntax: ['ones(m)', 'ones(m, n)', 'ones(m, n, p, ...)', 'ones([m])', 'ones([m, n])', 'ones([m, n, p, ...])'],
    description: 'Create a matrix containing ones.',
    examples: ['ones(3)', 'ones(3, 5)', 'ones([2,3]) * 4.5', 'a = [1, 2, 3; 4, 5, 6]', 'ones(size(a))'],
    seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros']
  };

  var mapDocs = {
    name: 'map',
    category: 'Matrix',
    syntax: ['map(x, callback)'],
    description: 'Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.',
    examples: ['map([1, 2, 3], square)'],
    seealso: ['filter', 'forEach']
  };

  var kronDocs = {
    name: 'kron',
    category: 'Matrix',
    syntax: ['kron(x, y)'],
    description: 'Calculates the kronecker product of 2 matrices or vectors.',
    examples: ['kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])', 'kron([1,1], [2,3,4])'],
    seealso: ['multiply', 'dot', 'cross']
  };

  var invDocs = {
    name: 'inv',
    category: 'Matrix',
    syntax: ['inv(x)'],
    description: 'Calculate the inverse of a matrix',
    examples: ['inv([1, 2; 3, 4])', 'inv(4)', '1 / 4'],
    seealso: ['concat', 'det', 'diag', 'identity', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros']
  };

  var forEachDocs = {
    name: 'forEach',
    category: 'Matrix',
    syntax: ['forEach(x, callback)'],
    description: 'Iterates over all elements of a matrix/array, and executes the given callback function.',
    examples: ['forEach([1, 2, 3], function(val) { console.log(val) })'],
    seealso: ['map', 'sort', 'filter']
  };

  var flattenDocs = {
    name: 'flatten',
    category: 'Matrix',
    syntax: ['flatten(x)'],
    description: 'Flatten a multi dimensional matrix into a single dimensional matrix.',
    examples: ['a = [1, 2, 3; 4, 5, 6]', 'size(a)', 'b = flatten(a)', 'size(b)'],
    seealso: ['concat', 'resize', 'size', 'squeeze']
  };

  var filterDocs = {
    name: 'filter',
    category: 'Matrix',
    syntax: ['filter(x, test)'],
    description: 'Filter items in a matrix.',
    examples: ['isPositive(x) = x > 0', 'filter([6, -2, -1, 4, 3], isPositive)', 'filter([6, -2, 0, 1, 0], x != 0)'],
    seealso: ['sort', 'map', 'forEach']
  };

  var identityDocs = {
    name: 'identity',
    category: 'Matrix',
    syntax: ['identity(n)', 'identity(m, n)', 'identity([m, n])'],
    description: 'Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.',
    examples: ['identity(3)', 'identity(3, 5)', 'a = [1, 2, 3; 4, 5, 6]', 'identity(size(a))'],
    seealso: ['concat', 'det', 'diag', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros']
  };

  var getMatrixDataTypeDocs = {
    name: 'getMatrixDataType',
    category: 'Matrix',
    syntax: ['getMatrixDataType(x)'],
    description: 'Find the data type of all elements in a matrix or array, ' + 'for example "number" if all items are a number ' + 'and "Complex" if all values are complex numbers. ' + 'If a matrix contains more than one data type, it will return "mixed".',
    examples: ['getMatrixDataType([1, 2, 3])', 'getMatrixDataType([[5 cm], [2 inch]])', 'getMatrixDataType([1, "text"])', 'getMatrixDataType([1, bignumber(4)])'],
    seealso: ['matrix', 'sparse', 'typeOf']
  };

  var dotDocs = {
    name: 'dot',
    category: 'Matrix',
    syntax: ['dot(A, B)', 'A * B'],
    description: 'Calculate the dot product of two vectors. ' + 'The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] ' + 'is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn',
    examples: ['dot([2, 4, 1], [2, 2, 3])', '[2, 4, 1] * [2, 2, 3]'],
    seealso: ['multiply', 'cross']
  };

  var diagDocs = {
    name: 'diag',
    category: 'Matrix',
    syntax: ['diag(x)', 'diag(x, k)'],
    description: 'Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.',
    examples: ['diag(1:3)', 'diag(1:3, 1)', 'a = [1, 2, 3; 4, 5, 6; 7, 8, 9]', 'diag(a)'],
    seealso: ['concat', 'det', 'identity', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros']
  };

  var detDocs = {
    name: 'det',
    category: 'Matrix',
    syntax: ['det(x)'],
    description: 'Calculate the determinant of a matrix',
    examples: ['det([1, 2; 3, 4])', 'det([-2, 2, 3; -1, 1, 3; 2, 0, -1])'],
    seealso: ['concat', 'diag', 'identity', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros']
  };

  var ctransposeDocs = {
    name: 'ctranspose',
    category: 'Matrix',
    syntax: ['x\'', 'ctranspose(x)'],
    description: 'Complex Conjugate and Transpose a matrix',
    examples: ['a = [1, 2, 3; 4, 5, 6]', 'a\'', 'ctranspose(a)'],
    seealso: ['concat', 'det', 'diag', 'identity', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'zeros']
  };

  var crossDocs = {
    name: 'cross',
    category: 'Matrix',
    syntax: ['cross(A, B)'],
    description: 'Calculate the cross product for two vectors in three dimensional space.',
    examples: ['cross([1, 1, 0],  [0, 1, 1])', 'cross([3, -3, 1], [4, 9, 2])', 'cross([2, 3, 4],  [5, 6, 7])'],
    seealso: ['multiply', 'dot']
  };

  var concatDocs = {
    name: 'concat',
    category: 'Matrix',
    syntax: ['concat(A, B, C, ...)', 'concat(A, B, C, ..., dim)'],
    description: 'Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.',
    examples: ['A = [1, 2; 5, 6]', 'B = [3, 4; 7, 8]', 'concat(A, B)', 'concat(A, B, 1)', 'concat(A, B, 2)'],
    seealso: ['det', 'diag', 'identity', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros']
  };

  var xorDocs = {
    name: 'xor',
    category: 'Logical',
    syntax: ['x xor y', 'xor(x, y)'],
    description: 'Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.',
    examples: ['true xor false', 'false xor false', 'true xor true', '0 xor 4'],
    seealso: ['not', 'and', 'or']
  };

  var orDocs = {
    name: 'or',
    category: 'Logical',
    syntax: ['x or y', 'or(x, y)'],
    description: 'Logical or. Test if at least one value is defined with a nonzero/nonempty value.',
    examples: ['true or false', 'false or false', '0 or 4'],
    seealso: ['not', 'and', 'xor']
  };

  var notDocs = {
    name: 'not',
    category: 'Logical',
    syntax: ['not x', 'not(x)'],
    description: 'Logical not. Flips the boolean value of given argument.',
    examples: ['not true', 'not false', 'not 2', 'not 0'],
    seealso: ['and', 'or', 'xor']
  };

  var andDocs = {
    name: 'and',
    category: 'Logical',
    syntax: ['x and y', 'and(x, y)'],
    description: 'Logical and. Test whether two values are both defined with a nonzero/nonempty value.',
    examples: ['true and false', 'true and true', '2 and 4'],
    seealso: ['not', 'or', 'xor']
  };

  var intersectDocs = {
    name: 'intersect',
    category: 'Geometry',
    syntax: ['intersect(expr1, expr2, expr3, expr4)', 'intersect(expr1, expr2, expr3)'],
    description: 'Computes the intersection point of lines and/or planes.',
    examples: ['intersect([0, 0], [10, 10], [10, 0], [0, 10])', 'intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])'],
    seealso: []
  };

  var distanceDocs = {
    name: 'distance',
    category: 'Geometry',
    syntax: ['distance([x1, y1], [x2, y2])', 'distance([[x1, y1], [x2, y2]])'],
    description: 'Calculates the Euclidean distance between two points.',
    examples: ['distance([0,0], [4,4])', 'distance([[0,0], [4,4]])'],
    seealso: []
  };

  var helpDocs = {
    name: 'help',
    category: 'Expression',
    syntax: ['help(object)', 'help(string)'],
    description: 'Display documentation on a function or data type.',
    examples: ['help(sqrt)', 'help("complex")'],
    seealso: []
  };

  var evaluateDocs = {
    name: 'evaluate',
    category: 'Expression',
    syntax: ['evaluate(expression)', 'evaluate([expr1, expr2, expr3, ...])'],
    description: 'Evaluate an expression or an array with expressions.',
    examples: ['evaluate("2 + 3")', 'evaluate("sqrt(" + 4 + ")")'],
    seealso: []
  };

  var imDocs = {
    name: 'im',
    category: 'Complex',
    syntax: ['im(x)'],
    description: 'Get the imaginary part of a complex number.',
    examples: ['im(2 + 3i)', 're(2 + 3i)', 'im(-5.2i)', 'im(2.4)'],
    seealso: ['re', 'conj', 'abs', 'arg']
  };

  var reDocs = {
    name: 're',
    category: 'Complex',
    syntax: ['re(x)'],
    description: 'Get the real part of a complex number.',
    examples: ['re(2 + 3i)', 'im(2 + 3i)', 're(-5.2i)', 're(2.4)'],
    seealso: ['im', 'conj', 'abs', 'arg']
  };

  var conjDocs = {
    name: 'conj',
    category: 'Complex',
    syntax: ['conj(x)'],
    description: 'Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.',
    examples: ['conj(2 + 3i)', 'conj(2 - 3i)', 'conj(-5.2i)'],
    seealso: ['re', 'im', 'abs', 'arg']
  };

  var argDocs = {
    name: 'arg',
    category: 'Complex',
    syntax: ['arg(x)'],
    description: 'Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).',
    examples: ['arg(2 + 2i)', 'atan2(3, 2)', 'arg(2 + 3i)'],
    seealso: ['re', 'im', 'conj', 'abs']
  };

  var typedDocs = {
    name: 'typed',
    category: 'Core',
    syntax: ['typed(signatures)', 'typed(name, signatures)'],
    description: 'Create a typed function.',
    examples: ['double = typed({ "number, number": f(x)=x+x })', 'double(2)', 'double("hello")'],
    seealso: []
  };

  var importDocs = {
    name: 'import',
    category: 'Core',
    syntax: ['import(functions)', 'import(functions, options)'],
    description: 'Import functions or constants from an object.',
    examples: ['import({myFn: f(x)=x^2, myConstant: 32 })', 'myFn(2)', 'myConstant'],
    seealso: []
  };

  var configDocs = {
    name: 'config',
    category: 'Core',
    syntax: ['config()', 'config(options)'],
    description: 'Get configuration or change configuration.',
    examples: ['config()', '1/3 + 1/4', 'config({number: "Fraction"})', '1/3 + 1/4'],
    seealso: []
  };

  var stirlingS2Docs = {
    name: 'stirlingS2',
    category: 'Combinatorics',
    syntax: ['stirlingS2(n, k)'],
    description: 'he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.',
    examples: ['stirlingS2(5, 3)'],
    seealso: ['bellNumbers']
  };

  var compositionDocs = {
    name: 'composition',
    category: 'Combinatorics',
    syntax: ['composition(n, k)'],
    description: 'The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.',
    examples: ['composition(5, 3)'],
    seealso: ['combinations']
  };

  var catalanDocs = {
    name: 'catalan',
    category: 'Combinatorics',
    syntax: ['catalan(n)'],
    description: 'The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.',
    examples: ['catalan(3)', 'catalan(8)'],
    seealso: ['bellNumbers']
  };

  var bellNumbersDocs = {
    name: 'bellNumbers',
    category: 'Combinatorics',
    syntax: ['bellNumbers(n)'],
    description: 'The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.',
    examples: ['bellNumbers(3)', 'bellNumbers(8)'],
    seealso: ['stirlingS2']
  };

  var rightLogShiftDocs = {
    name: 'rightLogShift',
    category: 'Bitwise',
    syntax: ['x >>> y', 'rightLogShift(x, y)'],
    description: 'Bitwise right logical shift of a value x by y number of bits.',
    examples: ['8 >>> 1', '4 << 1', '-12 >>> 2'],
    seealso: ['bitAnd', 'bitNot', 'bitOr', 'bitXor', 'leftShift', 'rightArithShift']
  };

  var rightArithShiftDocs = {
    name: 'rightArithShift',
    category: 'Bitwise',
    syntax: ['x >> y', 'rightArithShift(x, y)'],
    description: 'Bitwise right arithmetic shift of a value x by y number of bits.',
    examples: ['8 >> 1', '4 << 1', '-12 >> 2'],
    seealso: ['bitAnd', 'bitNot', 'bitOr', 'bitXor', 'leftShift', 'rightLogShift']
  };

  var leftShiftDocs = {
    name: 'leftShift',
    category: 'Bitwise',
    syntax: ['x << y', 'leftShift(x, y)'],
    description: 'Bitwise left logical shift of a value x by y number of bits.',
    examples: ['4 << 1', '8 >> 1'],
    seealso: ['bitAnd', 'bitNot', 'bitOr', 'bitXor', 'rightArithShift', 'rightLogShift']
  };

  var bitXorDocs = {
    name: 'bitXor',
    category: 'Bitwise',
    syntax: ['bitXor(x, y)'],
    description: 'Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.',
    examples: ['bitOr(1, 2)', 'bitXor([2, 3, 4], 4)'],
    seealso: ['bitAnd', 'bitNot', 'bitOr', 'leftShift', 'rightArithShift', 'rightLogShift']
  };

  var bitOrDocs = {
    name: 'bitOr',
    category: 'Bitwise',
    syntax: ['x | y', 'bitOr(x, y)'],
    description: 'Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.',
    examples: ['5 | 3', 'bitOr([1, 2, 3], 4)'],
    seealso: ['bitAnd', 'bitNot', 'bitXor', 'leftShift', 'rightArithShift', 'rightLogShift']
  };

  var bitNotDocs = {
    name: 'bitNot',
    category: 'Bitwise',
    syntax: ['~x', 'bitNot(x)'],
    description: 'Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.',
    examples: ['~1', '~2', 'bitNot([2, -3, 4])'],
    seealso: ['bitAnd', 'bitOr', 'bitXor', 'leftShift', 'rightArithShift', 'rightLogShift']
  };

  var bitAndDocs = {
    name: 'bitAnd',
    category: 'Bitwise',
    syntax: ['x & y', 'bitAnd(x, y)'],
    description: 'Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0',
    examples: ['5 & 3', 'bitAnd(53, 131)', '[1, 12, 31] & 42'],
    seealso: ['bitNot', 'bitOr', 'bitXor', 'leftShift', 'rightArithShift', 'rightLogShift']
  };

  var xgcdDocs = {
    name: 'xgcd',
    category: 'Arithmetic',
    syntax: ['xgcd(a, b)'],
    description: 'Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.',
    examples: ['xgcd(8, 12)', 'gcd(8, 12)', 'xgcd(36163, 21199)'],
    seealso: ['gcd', 'lcm']
  };

  var unaryPlusDocs = {
    name: 'unaryPlus',
    category: 'Operators',
    syntax: ['+x', 'unaryPlus(x)'],
    description: 'Converts booleans and strings to numbers.',
    examples: ['+true', '+"2"'],
    seealso: ['add', 'subtract', 'unaryMinus']
  };

  var unaryMinusDocs = {
    name: 'unaryMinus',
    category: 'Operators',
    syntax: ['-x', 'unaryMinus(x)'],
    description: 'Inverse the sign of a value. Converts booleans and strings to numbers.',
    examples: ['-4.5', '-(-5.6)', '-"22"'],
    seealso: ['add', 'subtract', 'unaryPlus']
  };

  var squareDocs = {
    name: 'square',
    category: 'Arithmetic',
    syntax: ['square(x)'],
    description: 'Compute the square of a value. The square of x is x * x.',
    examples: ['square(3)', 'sqrt(9)', '3^2', '3 * 3'],
    seealso: ['multiply', 'pow', 'sqrt', 'cube']
  };

  var sqrtmDocs = {
    name: 'sqrtm',
    category: 'Arithmetic',
    syntax: ['sqrtm(x)'],
    description: 'Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.',
    examples: ['sqrtm([[1, 2], [3, 4]])'],
    seealso: ['sqrt', 'abs', 'square', 'multiply']
  };

  var sqrtDocs = {
    name: 'sqrt',
    category: 'Arithmetic',
    syntax: ['sqrt(x)'],
    description: 'Compute the square root value. If x = y * y, then y is the square root of x.',
    examples: ['sqrt(25)', '5 * 5', 'sqrt(-1)'],
    seealso: ['square', 'sqrtm', 'multiply', 'nthRoot', 'nthRoots', 'pow']
  };

  var signDocs = {
    name: 'sign',
    category: 'Arithmetic',
    syntax: ['sign(x)'],
    description: 'Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.',
    examples: ['sign(3.5)', 'sign(-4.2)', 'sign(0)'],
    seealso: ['abs']
  };

  var roundDocs = {
    name: 'round',
    category: 'Arithmetic',
    syntax: ['round(x)', 'round(x, n)'],
    description: 'round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.',
    examples: ['round(3.2)', 'round(3.8)', 'round(-4.2)', 'round(-4.8)', 'round(pi, 3)', 'round(123.45678, 2)'],
    seealso: ['ceil', 'floor', 'fix']
  };

  var powDocs = {
    name: 'pow',
    category: 'Operators',
    syntax: ['x ^ y', 'pow(x, y)'],
    description: 'Calculates the power of x to y, x^y.',
    examples: ['2^3', '2*2*2', '1 + e ^ (pi * i)'],
    seealso: ['multiply', 'nthRoot', 'nthRoots', 'sqrt']
  };

  var nthRootsDocs = {
    name: 'nthRoots',
    category: 'Arithmetic',
    syntax: ['nthRoots(A)', 'nthRoots(A, root)'],
    description: '' + 'Calculate the nth roots of a value. ' + 'An nth root of a positive real number A, ' + 'is a positive real solution of the equation "x^root = A". ' + 'This function returns an array of complex values.',
    examples: ['nthRoots(1)', 'nthRoots(1, 3)'],
    seealso: ['sqrt', 'pow', 'nthRoot']
  };

  var nthRootDocs = {
    name: 'nthRoot',
    category: 'Arithmetic',
    syntax: ['nthRoot(a)', 'nthRoot(a, root)'],
    description: 'Calculate the nth root of a value. ' + 'The principal nth root of a positive real number A, ' + 'is the positive real solution of the equation "x^root = A".',
    examples: ['4 ^ 3', 'nthRoot(64, 3)', 'nthRoot(9, 2)', 'sqrt(9)'],
    seealso: ['nthRoots', 'pow', 'sqrt']
  };

  var normDocs = {
    name: 'norm',
    category: 'Arithmetic',
    syntax: ['norm(x)', 'norm(x, p)'],
    description: 'Calculate the norm of a number, vector or matrix.',
    examples: ['abs(-3.5)', 'norm(-3.5)', 'norm(3 - 4i)', 'norm([1, 2, -3], Infinity)', 'norm([1, 2, -3], -Infinity)', 'norm([3, 4], 2)', 'norm([[1, 2], [3, 4]], 1)', 'norm([[1, 2], [3, 4]], "inf")', 'norm([[1, 2], [3, 4]], "fro")']
  };

  var multiplyDocs = {
    name: 'multiply',
    category: 'Operators',
    syntax: ['x * y', 'multiply(x, y)'],
    description: 'multiply two values.',
    examples: ['a = 2.1 * 3.4', 'a / 3.4', '2 * 3 + 4', '2 * (3 + 4)', '3 * 2.1 km'],
    seealso: ['divide']
  };

  var modDocs = {
    name: 'mod',
    category: 'Operators',
    syntax: ['x % y', 'x mod y', 'mod(x, y)'],
    description: 'Calculates the modulus, the remainder of an integer division.',
    examples: ['7 % 3', '11 % 2', '10 mod 4', 'isOdd(x) = x % 2', 'isOdd(2)', 'isOdd(3)'],
    seealso: ['divide']
  };

  var log10Docs = {
    name: 'log10',
    category: 'Arithmetic',
    syntax: ['log10(x)'],
    description: 'Compute the 10-base logarithm of a value.',
    examples: ['log10(0.00001)', 'log10(10000)', '10 ^ 4', 'log(10000) / log(10)', 'log(10000, 10)'],
    seealso: ['exp', 'log']
  };

  var log1pDocs = {
    name: 'log1p',
    category: 'Arithmetic',
    syntax: ['log1p(x)', 'log1p(x, base)'],
    description: 'Calculate the logarithm of a `value+1`',
    examples: ['log1p(2.5)', 'exp(log1p(1.4))', 'pow(10, 4)', 'log1p(9999, 10)', 'log1p(9999) / log(10)'],
    seealso: ['exp', 'log', 'log2', 'log10']
  };

  var log2Docs = {
    name: 'log2',
    category: 'Arithmetic',
    syntax: ['log2(x)'],
    description: 'Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.',
    examples: ['log2(0.03125)', 'log2(16)', 'log2(16) / log2(2)', 'pow(2, 4)'],
    seealso: ['exp', 'log1p', 'log', 'log10']
  };

  var logDocs = {
    name: 'log',
    category: 'Arithmetic',
    syntax: ['log(x)', 'log(x, base)'],
    description: 'Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).',
    examples: ['log(3.5)', 'a = log(2.4)', 'exp(a)', '10 ^ 4', 'log(10000, 10)', 'log(10000) / log(10)', 'b = log(1024, 2)', '2 ^ b'],
    seealso: ['exp', 'log1p', 'log2', 'log10']
  };

  var lcmDocs = {
    name: 'lcm',
    category: 'Arithmetic',
    syntax: ['lcm(x, y)'],
    description: 'Compute the least common multiple.',
    examples: ['lcm(4, 6)', 'lcm(6, 21)', 'lcm(6, 21, 5)'],
    seealso: ['gcd']
  };

  var hypotDocs = {
    name: 'hypot',
    category: 'Arithmetic',
    syntax: ['hypot(a, b, c, ...)', 'hypot([a, b, c, ...])'],
    description: 'Calculate the hypotenusa of a list with values. ',
    examples: ['hypot(3, 4)', 'sqrt(3^2 + 4^2)', 'hypot(-2)', 'hypot([3, 4, 5])'],
    seealso: ['abs', 'norm']
  };

  var gcdDocs = {
    name: 'gcd',
    category: 'Arithmetic',
    syntax: ['gcd(a, b)', 'gcd(a, b, c, ...)'],
    description: 'Compute the greatest common divisor.',
    examples: ['gcd(8, 12)', 'gcd(-4, 6)', 'gcd(25, 15, -10)'],
    seealso: ['lcm', 'xgcd']
  };

  var floorDocs = {
    name: 'floor',
    category: 'Arithmetic',
    syntax: ['floor(x)'],
    description: 'Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.',
    examples: ['floor(3.2)', 'floor(3.8)', 'floor(-4.2)'],
    seealso: ['ceil', 'fix', 'round']
  };

  var fixDocs = {
    name: 'fix',
    category: 'Arithmetic',
    syntax: ['fix(x)'],
    description: 'Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.',
    examples: ['fix(3.2)', 'fix(3.8)', 'fix(-4.2)', 'fix(-4.8)'],
    seealso: ['ceil', 'floor', 'round']
  };

  var expm1Docs = {
    name: 'expm1',
    category: 'Arithmetic',
    syntax: ['expm1(x)'],
    description: 'Calculate the value of subtracting 1 from the exponential value.',
    examples: ['expm1(2)', 'pow(e, 2) - 1', 'log(expm1(2) + 1)'],
    seealso: ['exp', 'pow', 'log']
  };

  var expmDocs = {
    name: 'expm',
    category: 'Arithmetic',
    syntax: ['exp(x)'],
    description: 'Compute the matrix exponential, expm(A) = e^A. ' + 'The matrix must be square. ' + 'Not to be confused with exp(a), which performs element-wise exponentiation.',
    examples: ['expm([[0,2],[0,0]])'],
    seealso: ['exp']
  };

  var eigsDocs = {
    name: 'eigs',
    category: 'Matrix',
    syntax: ['eigs(x)'],
    description: 'Calculate the eigenvalues and eigenvectors of a real symmetric matrix',
    examples: ['eigs([[5, 2.3], [2.3, 1]])'],
    seealso: ['inv']
  };

  var expDocs = {
    name: 'exp',
    category: 'Arithmetic',
    syntax: ['exp(x)'],
    description: 'Calculate the exponent of a value.',
    examples: ['exp(1.3)', 'e ^ 1.3', 'log(exp(1.3))', 'x = 2.4', '(exp(i*x) == cos(x) + i*sin(x))   # Euler\'s formula'],
    seealso: ['expm', 'expm1', 'pow', 'log']
  };

  var dotMultiplyDocs = {
    name: 'dotMultiply',
    category: 'Operators',
    syntax: ['x .* y', 'dotMultiply(x, y)'],
    description: 'Multiply two values element wise.',
    examples: ['a = [1, 2, 3; 4, 5, 6]', 'b = [2, 1, 1; 3, 2, 5]', 'a .* b'],
    seealso: ['multiply', 'divide', 'dotDivide']
  };

  var dotDivideDocs = {
    name: 'dotDivide',
    category: 'Operators',
    syntax: ['x ./ y', 'dotDivide(x, y)'],
    description: 'Divide two values element wise.',
    examples: ['a = [1, 2, 3; 4, 5, 6]', 'b = [2, 1, 1; 3, 2, 5]', 'a ./ b'],
    seealso: ['multiply', 'dotMultiply', 'divide']
  };

  var divideDocs = {
    name: 'divide',
    category: 'Operators',
    syntax: ['x / y', 'divide(x, y)'],
    description: 'Divide two values.',
    examples: ['a = 2 / 3', 'a * 3', '4.5 / 2', '3 + 4 / 2', '(3 + 4) / 2', '18 km / 4.5'],
    seealso: ['multiply']
  };

  var cubeDocs = {
    name: 'cube',
    category: 'Arithmetic',
    syntax: ['cube(x)'],
    description: 'Compute the cube of a value. The cube of x is x * x * x.',
    examples: ['cube(2)', '2^3', '2 * 2 * 2'],
    seealso: ['multiply', 'square', 'pow']
  };

  var ceilDocs = {
    name: 'ceil',
    category: 'Arithmetic',
    syntax: ['ceil(x)'],
    description: 'Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.',
    examples: ['ceil(3.2)', 'ceil(3.8)', 'ceil(-4.2)'],
    seealso: ['floor', 'fix', 'round']
  };

  var cbrtDocs = {
    name: 'cbrt',
    category: 'Arithmetic',
    syntax: ['cbrt(x)', 'cbrt(x, allRoots)'],
    description: 'Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned',
    examples: ['cbrt(64)', 'cube(4)', 'cbrt(-8)', 'cbrt(2 + 3i)', 'cbrt(8i)', 'cbrt(8i, true)', 'cbrt(27 m^3)'],
    seealso: ['square', 'sqrt', 'cube', 'multiply']
  };

  var addDocs = {
    name: 'add',
    category: 'Operators',
    syntax: ['x + y', 'add(x, y)'],
    description: 'Add two values.',
    examples: ['a = 2.1 + 3.6', 'a - 3.6', '3 + 2i', '3 cm + 2 inch', '"2.3" + "4"'],
    seealso: ['subtract']
  };

  var absDocs = {
    name: 'abs',
    category: 'Arithmetic',
    syntax: ['abs(x)'],
    description: 'Compute the absolute value.',
    examples: ['abs(3.5)', 'abs(-4.2)'],
    seealso: ['sign']
  };

  var qrDocs = {
    name: 'qr',
    category: 'Algebra',
    syntax: ['qr(A)'],
    description: 'Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.',
    examples: ['qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])'],
    seealso: ['lup', 'slu', 'matrix']
  };

  var usolveDocs = {
    name: 'usolve',
    category: 'Algebra',
    syntax: ['x=usolve(U, b)'],
    description: 'Solves the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.',
    examples: ['x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])'],
    seealso: ['lup', 'lusolve', 'lsolve', 'matrix', 'sparse']
  };

  var sluDocs = {
    name: 'slu',
    category: 'Algebra',
    syntax: ['slu(A, order, threshold)'],
    description: 'Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U',
    examples: ['slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)'],
    seealso: ['lusolve', 'lsolve', 'usolve', 'matrix', 'sparse', 'lup', 'qr']
  };

  var rationalizeDocs = {
    name: 'rationalize',
    category: 'Algebra',
    syntax: ['rationalize(expr)', 'rationalize(expr, scope)', 'rationalize(expr, scope, detailed)'],
    description: 'Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.',
    examples: ['rationalize("2x/y - y/(x+1)")', 'rationalize("2x/y - y/(x+1)", true)'],
    seealso: ['simplify']
  };

  var simplifyDocs = {
    name: 'simplify',
    category: 'Algebra',
    syntax: ['simplify(expr)', 'simplify(expr, rules)'],
    description: 'Simplify an expression tree.',
    examples: ['simplify("3 + 2 / 4")', 'simplify("2x + x")', 'f = parse("x * (x + 2 + x)")', 'simplified = simplify(f)', 'simplified.evaluate({x: 2})'],
    seealso: ['derivative', 'parse', 'evaluate']
  };

  var lupDocs = {
    name: 'lup',
    category: 'Algebra',
    syntax: ['lup(m)'],
    description: 'Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U',
    examples: ['lup([[2, 1], [1, 4]])', 'lup(matrix([[2, 1], [1, 4]]))', 'lup(sparse([[2, 1], [1, 4]]))'],
    seealso: ['lusolve', 'lsolve', 'usolve', 'matrix', 'sparse', 'slu', 'qr']
  };

  var lsolveDocs = {
    name: 'lsolve',
    category: 'Algebra',
    syntax: ['x=lsolve(L, b)'],
    description: 'Solves the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.',
    examples: ['a = [-2, 3; 2, 1]', 'b = [11, 9]', 'x = lsolve(a, b)'],
    seealso: ['lup', 'lusolve', 'usolve', 'matrix', 'sparse']
  };

  var derivativeDocs = {
    name: 'derivative',
    category: 'Algebra',
    syntax: ['derivative(expr, variable)', 'derivative(expr, variable, {simplify: boolean})'],
    description: 'Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.',
    examples: ['derivative("2x^3", "x")', 'derivative("2x^3", "x", {simplify: false})', 'derivative("2x^2 + 3x + 4", "x")', 'derivative("sin(2x)", "x")', 'f = parse("x^2 + x")', 'x = parse("x")', 'df = derivative(f, x)', 'df.evaluate({x: 3})'],
    seealso: ['simplify', 'parse', 'evaluate']
  };

  var versionDocs = {
    name: 'version',
    category: 'Constants',
    syntax: ['version'],
    description: 'A string with the version number of math.js',
    examples: ['version'],
    seealso: []
  };

  var trueDocs = {
    name: 'true',
    category: 'Constants',
    syntax: ['true'],
    description: 'Boolean value true',
    examples: ['true'],
    seealso: ['false']
  };

  var tauDocs = {
    name: 'tau',
    category: 'Constants',
    syntax: ['tau'],
    description: 'Tau is the ratio constant of a circle\'s circumference to radius, equal to 2 * pi, approximately 6.2832.',
    examples: ['tau', '2 * pi'],
    seealso: ['pi']
  };

  var SQRT2Docs = {
    name: 'SQRT2',
    category: 'Constants',
    syntax: ['SQRT2'],
    description: 'Returns the square root of 2, approximately equal to 1.414',
    examples: ['SQRT2', 'sqrt(2)'],
    seealso: []
  };

  var SQRT12Docs = {
    name: 'SQRT1_2',
    category: 'Constants',
    syntax: ['SQRT1_2'],
    description: 'Returns the square root of 1/2, approximately equal to 0.707',
    examples: ['SQRT1_2', 'sqrt(1/2)'],
    seealso: []
  };

  var phiDocs = {
    name: 'phi',
    category: 'Constants',
    syntax: ['phi'],
    description: 'Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...',
    examples: ['phi'],
    seealso: []
  };

  var piDocs = {
    name: 'pi',
    category: 'Constants',
    syntax: ['pi'],
    description: 'The number pi is a mathematical constant that is the ratio of a circle\'s circumference to its diameter, and is approximately equal to 3.14159',
    examples: ['pi', 'sin(pi/2)'],
    seealso: ['tau']
  };

  var nullDocs = {
    name: 'null',
    category: 'Constants',
    syntax: ['null'],
    description: 'Value null',
    examples: ['null'],
    seealso: ['true', 'false']
  };

  var NaNDocs = {
    name: 'NaN',
    category: 'Constants',
    syntax: ['NaN'],
    description: 'Not a number',
    examples: ['NaN', '0 / 0'],
    seealso: []
  };

  var LOG10EDocs = {
    name: 'LOG10E',
    category: 'Constants',
    syntax: ['LOG10E'],
    description: 'Returns the base-10 logarithm of E, approximately equal to 0.434',
    examples: ['LOG10E', 'log(e, 10)'],
    seealso: []
  };

  var LOG2EDocs = {
    name: 'LOG2E',
    category: 'Constants',
    syntax: ['LOG2E'],
    description: 'Returns the base-2 logarithm of E, approximately equal to 1.442',
    examples: ['LOG2E', 'log(e, 2)'],
    seealso: []
  };

  var LN10Docs = {
    name: 'LN10',
    category: 'Constants',
    syntax: ['LN10'],
    description: 'Returns the natural logarithm of 10, approximately equal to 2.302',
    examples: ['LN10', 'log(10)'],
    seealso: []
  };

  var LN2Docs = {
    name: 'LN2',
    category: 'Constants',
    syntax: ['LN2'],
    description: 'Returns the natural logarithm of 2, approximately equal to 0.693',
    examples: ['LN2', 'log(2)'],
    seealso: []
  };

  var InfinityDocs = {
    name: 'Infinity',
    category: 'Constants',
    syntax: ['Infinity'],
    description: 'Infinity, a number which is larger than the maximum number that can be handled by a floating point number.',
    examples: ['Infinity', '1 / 0'],
    seealso: []
  };

  var iDocs = {
    name: 'i',
    category: 'Constants',
    syntax: ['i'],
    description: 'Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.',
    examples: ['i', 'i * i', 'sqrt(-1)'],
    seealso: []
  };

  var falseDocs = {
    name: 'false',
    category: 'Constants',
    syntax: ['false'],
    description: 'Boolean value false',
    examples: ['false'],
    seealso: ['true']
  };

  var eDocs = {
    name: 'e',
    category: 'Constants',
    syntax: ['e'],
    description: 'Euler\'s number, the base of the natural logarithm. Approximately equal to 2.71828',
    examples: ['e', 'e ^ 2', 'exp(2)', 'log(e)'],
    seealso: ['exp']
  };

  var unitDocs = {
    name: 'unit',
    category: 'Construction',
    syntax: ['value unit', 'unit(value, unit)', 'unit(string)'],
    description: 'Create a unit.',
    examples: ['5.5 mm', '3 inch', 'unit(7.1, "kilogram")', 'unit("23 deg")'],
    seealso: ['bignumber', 'boolean', 'complex', 'index', 'matrix', 'number', 'string']
  };

  var stringDocs = {
    name: 'string',
    category: 'Construction',
    syntax: ['"text"', 'string(x)'],
    description: 'Create a string or convert a value to a string',
    examples: ['"Hello World!"', 'string(4.2)', 'string(3 + 2i)'],
    seealso: ['bignumber', 'boolean', 'complex', 'index', 'matrix', 'number', 'unit']
  };

  var splitUnitDocs = {
    name: 'splitUnit',
    category: 'Construction',
    syntax: ['splitUnit(unit: Unit, parts: Unit[])'],
    description: 'Split a unit in an array of units whose sum is equal to the original unit.',
    examples: ['splitUnit(1 m, ["feet", "inch"])'],
    seealso: ['unit', 'createUnit']
  };

  var sparseDocs = {
    name: 'sparse',
    category: 'Construction',
    syntax: ['sparse()', 'sparse([a1, b1, ...; a1, b2, ...])', 'sparse([a1, b1, ...; a1, b2, ...], "number")'],
    description: 'Create a sparse matrix.',
    examples: ['sparse()', 'sparse([3, 4; 5, 6])', 'sparse([3, 0; 5, 0], "number")'],
    seealso: ['bignumber', 'boolean', 'complex', 'index', 'number', 'string', 'unit', 'matrix']
  };

  var numberDocs = {
    name: 'number',
    category: 'Construction',
    syntax: ['x', 'number(x)', 'number(unit, valuelessUnit)'],
    description: 'Create a number or convert a string or boolean into a number.',
    examples: ['2', '2e3', '4.05', 'number(2)', 'number("7.2")', 'number(true)', 'number([true, false, true, true])', 'number(unit("52cm"), "m")'],
    seealso: ['bignumber', 'boolean', 'complex', 'fraction', 'index', 'matrix', 'string', 'unit']
  };

  var matrixDocs = {
    name: 'matrix',
    category: 'Construction',
    syntax: ['[]', '[a1, b1, ...; a2, b2, ...]', 'matrix()', 'matrix("dense")', 'matrix([...])'],
    description: 'Create a matrix.',
    examples: ['[]', '[1, 2, 3]', '[1, 2, 3; 4, 5, 6]', 'matrix()', 'matrix([3, 4])', 'matrix([3, 4; 5, 6], "sparse")', 'matrix([3, 4; 5, 6], "sparse", "number")'],
    seealso: ['bignumber', 'boolean', 'complex', 'index', 'number', 'string', 'unit', 'sparse']
  };

  var indexDocs = {
    name: 'index',
    category: 'Construction',
    syntax: ['[start]', '[start:end]', '[start:step:end]', '[start1, start 2, ...]', '[start1:end1, start2:end2, ...]', '[start1:step1:end1, start2:step2:end2, ...]'],
    description: 'Create an index to get or replace a subset of a matrix',
    examples: ['[]', '[1, 2, 3]', 'A = [1, 2, 3; 4, 5, 6]', 'A[1, :]', 'A[1, 2] = 50', 'A[0:2, 0:2] = ones(2, 2)'],
    seealso: ['bignumber', 'boolean', 'complex', 'matrix,', 'number', 'range', 'string', 'unit']
  };

  var fractionDocs = {
    name: 'fraction',
    category: 'Construction',
    syntax: ['fraction(num)', 'fraction(num,den)'],
    description: 'Create a fraction from a number or from a numerator and denominator.',
    examples: ['fraction(0.125)', 'fraction(1, 3) + fraction(2, 5)'],
    seealso: ['bignumber', 'boolean', 'complex', 'index', 'matrix', 'string', 'unit']
  };

  var createUnitDocs = {
    name: 'createUnit',
    category: 'Construction',
    syntax: ['createUnit(definitions)', 'createUnit(name, definition)'],
    description: 'Create a user-defined unit and register it with the Unit type.',
    examples: ['createUnit("foo")', 'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})', 'createUnit("mph", "1 mile/hour")'],
    seealso: ['unit', 'splitUnit']
  };

  var complexDocs = {
    name: 'complex',
    category: 'Construction',
    syntax: ['complex()', 'complex(re, im)', 'complex(string)'],
    description: 'Create a complex number.',
    examples: ['complex()', 'complex(2, 3)', 'complex("7 - 2i")'],
    seealso: ['bignumber', 'boolean', 'index', 'matrix', 'number', 'string', 'unit']
  };

  var booleanDocs = {
    name: 'boolean',
    category: 'Construction',
    syntax: ['x', 'boolean(x)'],
    description: 'Convert a string or number into a boolean.',
    examples: ['boolean(0)', 'boolean(1)', 'boolean(3)', 'boolean("true")', 'boolean("false")', 'boolean([1, 0, 1, 1])'],
    seealso: ['bignumber', 'complex', 'index', 'matrix', 'number', 'string', 'unit']
  };

  var dotPowDocs = {
    name: 'dotPow',
    category: 'Operators',
    syntax: ['x .^ y', 'dotPow(x, y)'],
    description: 'Calculates the power of x to y element wise.',
    examples: ['a = [1, 2, 3; 4, 5, 6]', 'a .^ 2'],
    seealso: ['pow']
  };

  var lusolveDocs = {
    name: 'lusolve',
    category: 'Algebra',
    syntax: ['x=lusolve(A, b)', 'x=lusolve(lu, b)'],
    description: 'Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.',
    examples: ['a = [-2, 3; 2, 1]', 'b = [11, 9]', 'x = lusolve(a, b)'],
    seealso: ['lup', 'slu', 'lsolve', 'usolve', 'matrix', 'sparse']
  };

  var subtractDocs = {
    name: 'subtract',
    category: 'Operators',
    syntax: ['x - y', 'subtract(x, y)'],
    description: 'subtract two values.',
    examples: ['a = 5.3 - 2', 'a + 2', '2/3 - 1/6', '2 * 3 - 3', '2.1 km - 500m'],
    seealso: ['add']
  };

  var varianceDocs = {
    name: 'variance',
    category: 'Statistics',
    syntax: ['variance(a, b, c, ...)', 'variance(A)', 'variance(A, normalization)'],
    description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
    examples: ['variance(2, 4, 6)', 'variance([2, 4, 6, 8])', 'variance([2, 4, 6, 8], "uncorrected")', 'variance([2, 4, 6, 8], "biased")', 'variance([1, 2, 3; 4, 5, 6])'],
    seealso: ['max', 'mean', 'min', 'median', 'min', 'prod', 'std', 'sum']
  };

  var sinDocs = {
    name: 'sin',
    category: 'Trigonometry',
    syntax: ['sin(x)'],
    description: 'Compute the sine of x in radians.',
    examples: ['sin(2)', 'sin(pi / 4) ^ 2', 'sin(90 deg)', 'sin(30 deg)', 'sin(0.2)^2 + cos(0.2)^2'],
    seealso: ['asin', 'cos', 'tan']
  };

  var numericDocs = {
    name: 'numeric',
    category: 'Utils',
    syntax: ['numeric(x)'],
    description: 'Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.',
    examples: ['numeric("4")', 'numeric("4", "number")', 'numeric("4", "BigNumber")', 'numeric("4", "Fraction)', 'numeric(4, "Fraction")', 'numeric(fraction(2, 5), "number)'],
    seealso: ['number', 'fraction', 'bignumber', 'string', 'format']
  };

  var columnDocs = {
    name: 'column',
    category: 'Matrix',
    syntax: ['column(x, index)'],
    description: 'Return a column from a matrix or array.',
    examples: ['A = [[1, 2], [3, 4]]', 'column(A, 1)', 'column(A, 2)'],
    seealso: ['row']
  };

  var rowDocs = {
    name: 'row',
    category: 'Matrix',
    syntax: ['row(x, index)'],
    description: 'Return a row from a matrix or array.',
    examples: ['A = [[1, 2], [3, 4]]', 'row(A, 1)', 'row(A, 2)'],
    seealso: ['column']
  };

  var embeddedDocs = {
    // construction functions
    bignumber: bignumberDocs,
    "boolean": booleanDocs,
    complex: complexDocs,
    createUnit: createUnitDocs,
    fraction: fractionDocs,
    index: indexDocs,
    matrix: matrixDocs,
    number: numberDocs,
    sparse: sparseDocs,
    splitUnit: splitUnitDocs,
    string: stringDocs,
    unit: unitDocs,
    // constants
    e: eDocs,
    E: eDocs,
    "false": falseDocs,
    i: iDocs,
    Infinity: InfinityDocs,
    LN2: LN2Docs,
    LN10: LN10Docs,
    LOG2E: LOG2EDocs,
    LOG10E: LOG10EDocs,
    NaN: NaNDocs,
    "null": nullDocs,
    pi: piDocs,
    PI: piDocs,
    phi: phiDocs,
    SQRT1_2: SQRT12Docs,
    SQRT2: SQRT2Docs,
    tau: tauDocs,
    "true": trueDocs,
    version: versionDocs,
    // physical constants
    // TODO: more detailed docs for physical constants
    speedOfLight: {
      description: 'Speed of light in vacuum',
      examples: ['speedOfLight']
    },
    gravitationConstant: {
      description: 'Newtonian constant of gravitation',
      examples: ['gravitationConstant']
    },
    planckConstant: {
      description: 'Planck constant',
      examples: ['planckConstant']
    },
    reducedPlanckConstant: {
      description: 'Reduced Planck constant',
      examples: ['reducedPlanckConstant']
    },
    magneticConstant: {
      description: 'Magnetic constant (vacuum permeability)',
      examples: ['magneticConstant']
    },
    electricConstant: {
      description: 'Electric constant (vacuum permeability)',
      examples: ['electricConstant']
    },
    vacuumImpedance: {
      description: 'Characteristic impedance of vacuum',
      examples: ['vacuumImpedance']
    },
    coulomb: {
      description: 'Coulomb\'s constant',
      examples: ['coulomb']
    },
    elementaryCharge: {
      description: 'Elementary charge',
      examples: ['elementaryCharge']
    },
    bohrMagneton: {
      description: 'Borh magneton',
      examples: ['bohrMagneton']
    },
    conductanceQuantum: {
      description: 'Conductance quantum',
      examples: ['conductanceQuantum']
    },
    inverseConductanceQuantum: {
      description: 'Inverse conductance quantum',
      examples: ['inverseConductanceQuantum']
    },
    // josephson: {description: 'Josephson constant', examples: ['josephson']},
    magneticFluxQuantum: {
      description: 'Magnetic flux quantum',
      examples: ['magneticFluxQuantum']
    },
    nuclearMagneton: {
      description: 'Nuclear magneton',
      examples: ['nuclearMagneton']
    },
    klitzing: {
      description: 'Von Klitzing constant',
      examples: ['klitzing']
    },
    bohrRadius: {
      description: 'Borh radius',
      examples: ['bohrRadius']
    },
    classicalElectronRadius: {
      description: 'Classical electron radius',
      examples: ['classicalElectronRadius']
    },
    electronMass: {
      description: 'Electron mass',
      examples: ['electronMass']
    },
    fermiCoupling: {
      description: 'Fermi coupling constant',
      examples: ['fermiCoupling']
    },
    fineStructure: {
      description: 'Fine-structure constant',
      examples: ['fineStructure']
    },
    hartreeEnergy: {
      description: 'Hartree energy',
      examples: ['hartreeEnergy']
    },
    protonMass: {
      description: 'Proton mass',
      examples: ['protonMass']
    },
    deuteronMass: {
      description: 'Deuteron Mass',
      examples: ['deuteronMass']
    },
    neutronMass: {
      description: 'Neutron mass',
      examples: ['neutronMass']
    },
    quantumOfCirculation: {
      description: 'Quantum of circulation',
      examples: ['quantumOfCirculation']
    },
    rydberg: {
      description: 'Rydberg constant',
      examples: ['rydberg']
    },
    thomsonCrossSection: {
      description: 'Thomson cross section',
      examples: ['thomsonCrossSection']
    },
    weakMixingAngle: {
      description: 'Weak mixing angle',
      examples: ['weakMixingAngle']
    },
    efimovFactor: {
      description: 'Efimov factor',
      examples: ['efimovFactor']
    },
    atomicMass: {
      description: 'Atomic mass constant',
      examples: ['atomicMass']
    },
    avogadro: {
      description: 'Avogadro\'s number',
      examples: ['avogadro']
    },
    boltzmann: {
      description: 'Boltzmann constant',
      examples: ['boltzmann']
    },
    faraday: {
      description: 'Faraday constant',
      examples: ['faraday']
    },
    firstRadiation: {
      description: 'First radiation constant',
      examples: ['firstRadiation']
    },
    loschmidt: {
      description: 'Loschmidt constant at T=273.15 K and p=101.325 kPa',
      examples: ['loschmidt']
    },
    gasConstant: {
      description: 'Gas constant',
      examples: ['gasConstant']
    },
    molarPlanckConstant: {
      description: 'Molar Planck constant',
      examples: ['molarPlanckConstant']
    },
    molarVolume: {
      description: 'Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa',
      examples: ['molarVolume']
    },
    sackurTetrode: {
      description: 'Sackur-Tetrode constant at T=1 K and p=101.325 kPa',
      examples: ['sackurTetrode']
    },
    secondRadiation: {
      description: 'Second radiation constant',
      examples: ['secondRadiation']
    },
    stefanBoltzmann: {
      description: 'Stefan-Boltzmann constant',
      examples: ['stefanBoltzmann']
    },
    wienDisplacement: {
      description: 'Wien displacement law constant',
      examples: ['wienDisplacement']
    },
    // spectralRadiance: {description: 'First radiation constant for spectral radiance', examples: ['spectralRadiance']},
    molarMass: {
      description: 'Molar mass constant',
      examples: ['molarMass']
    },
    molarMassC12: {
      description: 'Molar mass constant of carbon-12',
      examples: ['molarMassC12']
    },
    gravity: {
      description: 'Standard acceleration of gravity (standard acceleration of free-fall on Earth)',
      examples: ['gravity']
    },
    planckLength: {
      description: 'Planck length',
      examples: ['planckLength']
    },
    planckMass: {
      description: 'Planck mass',
      examples: ['planckMass']
    },
    planckTime: {
      description: 'Planck time',
      examples: ['planckTime']
    },
    planckCharge: {
      description: 'Planck charge',
      examples: ['planckCharge']
    },
    planckTemperature: {
      description: 'Planck temperature',
      examples: ['planckTemperature']
    },
    // functions - algebra
    derivative: derivativeDocs,
    lsolve: lsolveDocs,
    lup: lupDocs,
    lusolve: lusolveDocs,
    simplify: simplifyDocs,
    rationalize: rationalizeDocs,
    slu: sluDocs,
    usolve: usolveDocs,
    qr: qrDocs,
    // functions - arithmetic
    abs: absDocs,
    add: addDocs,
    cbrt: cbrtDocs,
    ceil: ceilDocs,
    cube: cubeDocs,
    divide: divideDocs,
    dotDivide: dotDivideDocs,
    dotMultiply: dotMultiplyDocs,
    dotPow: dotPowDocs,
    exp: expDocs,
    expm: expmDocs,
    expm1: expm1Docs,
    fix: fixDocs,
    floor: floorDocs,
    gcd: gcdDocs,
    hypot: hypotDocs,
    lcm: lcmDocs,
    log: logDocs,
    log2: log2Docs,
    log1p: log1pDocs,
    log10: log10Docs,
    mod: modDocs,
    multiply: multiplyDocs,
    norm: normDocs,
    nthRoot: nthRootDocs,
    nthRoots: nthRootsDocs,
    pow: powDocs,
    round: roundDocs,
    sign: signDocs,
    sqrt: sqrtDocs,
    sqrtm: sqrtmDocs,
    square: squareDocs,
    subtract: subtractDocs,
    unaryMinus: unaryMinusDocs,
    unaryPlus: unaryPlusDocs,
    xgcd: xgcdDocs,
    // functions - bitwise
    bitAnd: bitAndDocs,
    bitNot: bitNotDocs,
    bitOr: bitOrDocs,
    bitXor: bitXorDocs,
    leftShift: leftShiftDocs,
    rightArithShift: rightArithShiftDocs,
    rightLogShift: rightLogShiftDocs,
    // functions - combinatorics
    bellNumbers: bellNumbersDocs,
    catalan: catalanDocs,
    composition: compositionDocs,
    stirlingS2: stirlingS2Docs,
    // functions - core
    config: configDocs,
    "import": importDocs,
    typed: typedDocs,
    // functions - complex
    arg: argDocs,
    conj: conjDocs,
    re: reDocs,
    im: imDocs,
    // functions - expression
    evaluate: evaluateDocs,
    help: helpDocs,
    // functions - geometry
    distance: distanceDocs,
    intersect: intersectDocs,
    // functions - logical
    and: andDocs,
    not: notDocs,
    or: orDocs,
    xor: xorDocs,
    // functions - matrix
    concat: concatDocs,
    cross: crossDocs,
    column: columnDocs,
    ctranspose: ctransposeDocs,
    det: detDocs,
    diag: diagDocs,
    dot: dotDocs,
    getMatrixDataType: getMatrixDataTypeDocs,
    identity: identityDocs,
    filter: filterDocs,
    flatten: flattenDocs,
    forEach: forEachDocs,
    inv: invDocs,
    eigs: eigsDocs,
    kron: kronDocs,
    map: mapDocs,
    ones: onesDocs,
    partitionSelect: partitionSelectDocs,
    range: rangeDocs,
    resize: resizeDocs,
    reshape: reshapeDocs,
    row: rowDocs,
    size: sizeDocs,
    sort: sortDocs,
    squeeze: squeezeDocs,
    subset: subsetDocs,
    trace: traceDocs,
    transpose: transposeDocs,
    zeros: zerosDocs,
    // functions - probability
    combinations: combinationsDocs,
    combinationsWithRep: combinationsWithRepDocs,
    // distribution: distributionDocs,
    factorial: factorialDocs,
    gamma: gammaDocs,
    kldivergence: kldivergenceDocs,
    multinomial: multinomialDocs,
    permutations: permutationsDocs,
    pickRandom: pickRandomDocs,
    random: randomDocs,
    randomInt: randomIntDocs,
    // functions - relational
    compare: compareDocs,
    compareNatural: compareNaturalDocs,
    compareText: compareTextDocs,
    deepEqual: deepEqualDocs,
    equal: equalDocs,
    equalText: equalTextDocs,
    larger: largerDocs,
    largerEq: largerEqDocs,
    smaller: smallerDocs,
    smallerEq: smallerEqDocs,
    unequal: unequalDocs,
    // functions - set
    setCartesian: setCartesianDocs,
    setDifference: setDifferenceDocs,
    setDistinct: setDistinctDocs,
    setIntersect: setIntersectDocs,
    setIsSubset: setIsSubsetDocs,
    setMultiplicity: setMultiplicityDocs,
    setPowerset: setPowersetDocs,
    setSize: setSizeDocs,
    setSymDifference: setSymDifferenceDocs,
    setUnion: setUnionDocs,
    // functions - special
    erf: erfDocs,
    // functions - statistics
    mad: madDocs,
    max: maxDocs,
    mean: meanDocs,
    median: medianDocs,
    min: minDocs,
    mode: modeDocs,
    prod: prodDocs,
    quantileSeq: quantileSeqDocs,
    std: stdDocs,
    sum: sumDocs,
    variance: varianceDocs,
    // functions - trigonometry
    acos: acosDocs,
    acosh: acoshDocs,
    acot: acotDocs,
    acoth: acothDocs,
    acsc: acscDocs,
    acsch: acschDocs,
    asec: asecDocs,
    asech: asechDocs,
    asin: asinDocs,
    asinh: asinhDocs,
    atan: atanDocs,
    atanh: atanhDocs,
    atan2: atan2Docs,
    cos: cosDocs,
    cosh: coshDocs,
    cot: cotDocs,
    coth: cothDocs,
    csc: cscDocs,
    csch: cschDocs,
    sec: secDocs,
    sech: sechDocs,
    sin: sinDocs,
    sinh: sinhDocs,
    tan: tanDocs,
    tanh: tanhDocs,
    // functions - units
    to: toDocs,
    // functions - utils
    clone: cloneDocs,
    format: formatDocs,
    isNaN: isNaNDocs,
    isInteger: isIntegerDocs,
    isNegative: isNegativeDocs,
    isNumeric: isNumericDocs,
    hasNumericValue: hasNumericValueDocs,
    isPositive: isPositiveDocs,
    isPrime: isPrimeDocs,
    isZero: isZeroDocs,
    // print: printDocs // TODO: add documentation for print as soon as the parser supports objects.
    typeOf: typeOfDocs,
    numeric: numericDocs
  };

  var name$3s = 'help';
  var dependencies$3t = ['typed', 'mathWithTransform', 'Help'];
  var createHelp = /* #__PURE__ */factory(name$3s, dependencies$3t, function (_ref) {
    var typed = _ref.typed,
        mathWithTransform = _ref.mathWithTransform,
        Help = _ref.Help;

    /**
     * Retrieve help on a function or data type.
     * Help files are retrieved from the embedded documentation in math.docs.
     *
     * Syntax:
     *
     *    math.help(search)
     *
     * Examples:
     *
     *    console.log(math.help('sin').toString())
     *    console.log(math.help(math.add).toString())
     *    console.log(math.help(math.add).toJSON())
     *
     * @param {Function | string | Object} search   A function or function name
     *                                              for which to get help
     * @return {Help} A help object
     */
    return typed(name$3s, {
      any: function any(search) {
        var prop;
        var searchName = search;

        if (typeof search !== 'string') {
          for (prop in mathWithTransform) {
            // search in functions and constants
            if (hasOwnProperty(mathWithTransform, prop) && search === mathWithTransform[prop]) {
              searchName = prop;
              break;
            }
          }
          /* TODO: implement help for data types
           if (!text) {
           // search data type
           for (prop in math.type) {
           if (hasOwnProperty(math, prop)) {
           if (search === math.type[prop]) {
           text = prop
           break
           }
           }
           }
           }
           */

        }

        var doc = getSafeProperty(embeddedDocs, searchName);

        if (!doc) {
          var searchText = typeof searchName === 'function' ? searchName.name : searchName;
          throw new Error('No documentation found on "' + searchText + '"');
        }

        return new Help(doc);
      }
    });
  });

  var name$3t = 'chain';
  var dependencies$3u = ['typed', 'Chain'];
  var createChain = /* #__PURE__ */factory(name$3t, dependencies$3u, function (_ref) {
    var typed = _ref.typed,
        Chain = _ref.Chain;

    /**
     * Wrap any value in a chain, allowing to perform chained operations on
     * the value.
     *
     * All methods available in the math.js library can be called upon the chain,
     * and then will be evaluated with the value itself as first argument.
     * The chain can be closed by executing `chain.done()`, which returns
     * the final value.
     *
     * The chain has a number of special functions:
     *
     * - `done()`     Finalize the chain and return the chain's value.
     * - `valueOf()`  The same as `done()`
     * - `toString()` Executes `math.format()` onto the chain's value, returning
     *                a string representation of the value.
     *
     * Syntax:
     *
     *    math.chain(value)
     *
     * Examples:
     *
     *     math.chain(3)
     *         .add(4)
     *         .subtract(2)
     *         .done()     // 5
     *
     *     math.chain( [[1, 2], [3, 4]] )
     *         .subset(math.index(0, 0), 8)
     *         .multiply(3)
     *         .done()     // [[24, 6], [9, 12]]
     *
     * @param {*} [value]   A value of any type on which to start a chained operation.
     * @return {math.Chain} The created chain
     */
    return typed(name$3t, {
      '': function _() {
        return new Chain();
      },
      any: function any(value) {
        return new Chain(value);
      }
    });
  });

  var name$3u = 'det';
  var dependencies$3v = ['typed', 'matrix', 'subtract', 'multiply', 'unaryMinus', 'lup'];
  var createDet = /* #__PURE__ */factory(name$3u, dependencies$3v, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        subtract = _ref.subtract,
        multiply = _ref.multiply,
        unaryMinus = _ref.unaryMinus,
        lup = _ref.lup;

    /**
     * Calculate the determinant of a matrix.
     *
     * Syntax:
     *
     *    math.det(x)
     *
     * Examples:
     *
     *    math.det([[1, 2], [3, 4]]) // returns -2
     *
     *    const A = [
     *      [-2, 2, 3],
     *      [-1, 1, 3],
     *      [2, 0, -1]
     *    ]
     *    math.det(A) // returns 6
     *
     * See also:
     *
     *    inv
     *
     * @param {Array | Matrix} x  A matrix
     * @return {number} The determinant of `x`
     */
    return typed(name$3u, {
      any: function any(x) {
        return clone(x);
      },
      'Array | Matrix': function det(x) {
        var size;

        if (isMatrix(x)) {
          size = x.size();
        } else if (Array.isArray(x)) {
          x = matrix(x);
          size = x.size();
        } else {
          // a scalar
          size = [];
        }

        switch (size.length) {
          case 0:
            // scalar
            return clone(x);

          case 1:
            // vector
            if (size[0] === 1) {
              return clone(x.valueOf()[0]);
            } else {
              throw new RangeError('Matrix must be square ' + '(size: ' + format$2(size) + ')');
            }

          case 2:
            {
              // two dimensional array
              var rows = size[0];
              var cols = size[1];

              if (rows === cols) {
                return _det(x.clone().valueOf(), rows, cols);
              } else {
                throw new RangeError('Matrix must be square ' + '(size: ' + format$2(size) + ')');
              }
            }

          default:
            // multi dimensional array
            throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format$2(size) + ')');
        }
      }
    });
    /**
     * Calculate the determinant of a matrix
     * @param {Array[]} matrix  A square, two dimensional matrix
     * @param {number} rows     Number of rows of the matrix (zero-based)
     * @param {number} cols     Number of columns of the matrix (zero-based)
     * @returns {number} det
     * @private
     */

    function _det(matrix, rows, cols) {
      if (rows === 1) {
        // this is a 1 x 1 matrix
        return clone(matrix[0][0]);
      } else if (rows === 2) {
        // this is a 2 x 2 matrix
        // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12
        return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));
      } else {
        // Compute the LU decomposition
        var decomp = lup(matrix); // The determinant is the product of the diagonal entries of U (and those of L, but they are all 1)

        var det = decomp.U[0][0];

        for (var _i = 1; _i < rows; _i++) {
          det = multiply(det, decomp.U[_i][_i]);
        } // The determinant will be multiplied by 1 or -1 depending on the parity of the permutation matrix.
        // This can be determined by counting the cycles. This is roughly a linear time algorithm.


        var evenCycles = 0;
        var i = 0;
        var visited = [];

        while (true) {
          while (visited[i]) {
            i++;
          }

          if (i >= rows) break;
          var j = i;
          var cycleLen = 0;

          while (!visited[decomp.p[j]]) {
            visited[decomp.p[j]] = true;
            j = decomp.p[j];
            cycleLen++;
          }

          if (cycleLen % 2 === 0) {
            evenCycles++;
          }
        }

        return evenCycles % 2 === 0 ? det : unaryMinus(det);
      }
    }
  });

  var name$3v = 'inv';
  var dependencies$3w = ['typed', 'matrix', 'divideScalar', 'addScalar', 'multiply', 'unaryMinus', 'det', 'identity', 'abs'];
  var createInv = /* #__PURE__ */factory(name$3v, dependencies$3w, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        divideScalar = _ref.divideScalar,
        addScalar = _ref.addScalar,
        multiply = _ref.multiply,
        unaryMinus = _ref.unaryMinus,
        det = _ref.det,
        identity = _ref.identity,
        abs = _ref.abs;

    /**
     * Calculate the inverse of a square matrix.
     *
     * Syntax:
     *
     *     math.inv(x)
     *
     * Examples:
     *
     *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]
     *     math.inv(4)                 // returns 0.25
     *     1 / 4                       // returns 0.25
     *
     * See also:
     *
     *     det, transpose
     *
     * @param {number | Complex | Array | Matrix} x     Matrix to be inversed
     * @return {number | Complex | Array | Matrix} The inverse of `x`.
     */
    return typed(name$3v, {
      'Array | Matrix': function ArrayMatrix(x) {
        var size = isMatrix(x) ? x.size() : arraySize(x);

        switch (size.length) {
          case 1:
            // vector
            if (size[0] === 1) {
              if (isMatrix(x)) {
                return matrix([divideScalar(1, x.valueOf()[0])]);
              } else {
                return [divideScalar(1, x[0])];
              }
            } else {
              throw new RangeError('Matrix must be square ' + '(size: ' + format$2(size) + ')');
            }

          case 2:
            // two dimensional array
            {
              var rows = size[0];
              var cols = size[1];

              if (rows === cols) {
                if (isMatrix(x)) {
                  return matrix(_inv(x.valueOf(), rows, cols), x.storage());
                } else {
                  // return an Array
                  return _inv(x, rows, cols);
                }
              } else {
                throw new RangeError('Matrix must be square ' + '(size: ' + format$2(size) + ')');
              }
            }

          default:
            // multi dimensional array
            throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format$2(size) + ')');
        }
      },
      any: function any(x) {
        // scalar
        return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers
      }
    });
    /**
     * Calculate the inverse of a square matrix
     * @param {Array[]} mat     A square matrix
     * @param {number} rows     Number of rows
     * @param {number} cols     Number of columns, must equal rows
     * @return {Array[]} inv    Inverse matrix
     * @private
     */

    function _inv(mat, rows, cols) {
      var r, s, f, value, temp;

      if (rows === 1) {
        // this is a 1 x 1 matrix
        value = mat[0][0];

        if (value === 0) {
          throw Error('Cannot calculate inverse, determinant is zero');
        }

        return [[divideScalar(1, value)]];
      } else if (rows === 2) {
        // this is a 2 x 2 matrix
        var d = det(mat);

        if (d === 0) {
          throw Error('Cannot calculate inverse, determinant is zero');
        }

        return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];
      } else {
        // this is a matrix of 3 x 3 or larger
        // calculate inverse using gauss-jordan elimination
        //      https://en.wikipedia.org/wiki/Gaussian_elimination
        //      http://mathworld.wolfram.com/MatrixInverse.html
        //      http://math.uww.edu/~mcfarlat/inverse.htm
        // make a copy of the matrix (only the arrays, not of the elements)
        var A = mat.concat();

        for (r = 0; r < rows; r++) {
          A[r] = A[r].concat();
        } // create an identity matrix which in the end will contain the
        // matrix inverse


        var B = identity(rows).valueOf(); // loop over all columns, and perform row reductions

        for (var c = 0; c < cols; c++) {
          // Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]
          var ABig = abs(A[c][c]);
          var rBig = c;
          r = c + 1;

          while (r < rows) {
            if (abs(A[r][c]) > ABig) {
              ABig = abs(A[r][c]);
              rBig = r;
            }

            r++;
          }

          if (ABig === 0) {
            throw Error('Cannot calculate inverse, determinant is zero');
          }

          r = rBig;

          if (r !== c) {
            temp = A[c];
            A[c] = A[r];
            A[r] = temp;
            temp = B[c];
            B[c] = B[r];
            B[r] = temp;
          } // eliminate non-zero values on the other rows at column c


          var Ac = A[c];
          var Bc = B[c];

          for (r = 0; r < rows; r++) {
            var Ar = A[r];
            var Br = B[r];

            if (r !== c) {
              // eliminate value at column c and row r
              if (Ar[c] !== 0) {
                f = divideScalar(unaryMinus(Ar[c]), Ac[c]); // add (f * row c) to row r to eliminate the value
                // at column c

                for (s = c; s < cols; s++) {
                  Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));
                }

                for (s = 0; s < cols; s++) {
                  Br[s] = addScalar(Br[s], multiply(f, Bc[s]));
                }
              }
            } else {
              // normalize value at Acc to 1,
              // divide each value on row r with the value at Acc
              f = Ac[c];

              for (s = c; s < cols; s++) {
                Ar[s] = divideScalar(Ar[s], f);
              }

              for (s = 0; s < cols; s++) {
                Br[s] = divideScalar(Br[s], f);
              }
            }
          }
        }

        return B;
      }
    }
  });

  var name$3w = 'eigs';
  var dependencies$3x = ['config', 'typed', 'matrix', 'addScalar', 'equal', 'subtract', 'abs', 'atan', 'cos', 'sin', 'multiplyScalar', 'inv', 'bignumber', 'multiply', 'add'];
  var createEigs = /* #__PURE__ */factory(name$3w, dependencies$3x, function (_ref) {
    var config = _ref.config,
        typed = _ref.typed,
        matrix = _ref.matrix,
        addScalar = _ref.addScalar,
        subtract = _ref.subtract,
        equal = _ref.equal,
        abs = _ref.abs,
        atan = _ref.atan,
        cos = _ref.cos,
        sin = _ref.sin,
        multiplyScalar = _ref.multiplyScalar,
        inv = _ref.inv,
        bignumber = _ref.bignumber,
        multiply = _ref.multiply,
        add = _ref.add;

    /**
     * Compute eigenvalue and eigenvector of a real symmetric matrix.
     * Only applicable to two dimensional symmetric matrices. Uses Jacobi
     * Algorithm. Matrix containing mixed type ('number', 'bignumber', 'fraction')
     * of elements are not supported. Input matrix or 2D array should contain all elements
     * of either 'number', 'bignumber' or 'fraction' type. For 'number' and 'fraction', the
     * eigenvalues are of 'number' type. For 'bignumber' the eigenvalues are of ''bignumber' type.
     * Eigenvectors are always of 'number' type.
     *
     * Syntax:
     *
     *     math.eigs(x)
     *
     * Examples:
     *
     *     const H = [[5, 2.3], [2.3, 1]]
     *     const ans = math.eigs(H) // returns {values: [E1,E2...sorted], vectors: [v1,v2.... corresponding vectors as columns]}
     *     const E = ans.values
     *     const U = ans.vectors
     *     math.multiply(H, math.column(U, 0)) // returns math.multiply(E[0], math.column(U, 0))
     *     const UTxHxU = math.multiply(math.transpose(U), H, U) // rotates H to the eigen-representation
     *     E[0] == UTxHxU[0][0]  // returns true
     * See also:
     *
     *     inv
     *
     * @param {Array | Matrix} x  Matrix to be diagonalized
     * @return {{values: Array, vectors: Array} | {values: Matrix, vectors: Matrix}} Object containing eigenvalues (Array or Matrix) and eigenvectors (2D Array/Matrix with eigenvectors as columns).
     */
    return typed('eigs', {
      Array: function Array(x) {
        // check array size
        var mat = matrix(x);
        var size = mat.size();

        if (size.length !== 2 || size[0] !== size[1]) {
          throw new RangeError('Matrix must be square ' + '(size: ' + format$2(size) + ')');
        } // use dense 2D matrix implementation


        var ans = checkAndSubmit(mat, size[0]);
        return {
          values: ans[0],
          vectors: ans[1]
        };
      },
      Matrix: function Matrix(x) {
        // use dense 2D array implementation
        // dense matrix
        var size = x.size();

        if (size.length !== 2 || size[0] !== size[1]) {
          throw new RangeError('Matrix must be square ' + '(size: ' + format$2(size) + ')');
        }

        var ans = checkAndSubmit(x, size[0]);
        return {
          values: matrix(ans[0]),
          vectors: matrix(ans[1])
        };
      }
    }); // Is the matrix
    // symmetric ?

    function isSymmetric(x, n) {
      for (var i = 0; i < n; i++) {
        for (var j = i; j < n; j++) {
          // not symmtric
          if (!equal(x[i][j], x[j][i])) {
            throw new TypeError('Input matrix is not symmetric');
          }
        }
      }
    } // check input for possible problems
    // and perform diagonalization efficiently for
    // specific type of number


    function checkAndSubmit(x, n) {
      var type = x.datatype(); // type check

      if (type === undefined) {
        type = x.getDataType();
      }

      if (type !== 'number' && type !== 'BigNumber' && type !== 'Fraction') {
        if (type === 'mixed') {
          throw new TypeError('Mixed matrix element type is not supported');
        } else {
          throw new TypeError('Matrix element type not supported (' + type + ')');
        }
      } else {
        isSymmetric(x.toArray(), n);
      } // perform efficient calculation for 'numbers'


      if (type === 'number') {
        return diag(x.toArray());
      } else if (type === 'Fraction') {
        var xArr = x.toArray(); // convert fraction to numbers

        for (var i = 0; i < n; i++) {
          for (var j = i; j < n; j++) {
            xArr[i][j] = xArr[i][j].valueOf();
            xArr[j][i] = xArr[i][j];
          }
        }

        return diag(x.toArray());
      } else if (type === 'BigNumber') {
        return diagBig(x.toArray());
      }
    } // diagonalization implementation for number (efficient)


    function diag(x) {
      var N = x.length;
      var e0 = Math.abs(config.epsilon / N);
      var psi;
      var Sij = new Array(N); // Sij is Identity Matrix

      for (var i = 0; i < N; i++) {
        Sij[i] = createArray(N, 0);
        Sij[i][i] = 1.0;
      } // initial error


      var Vab = getAij(x);

      while (Math.abs(Vab[1]) >= Math.abs(e0)) {
        var _i = Vab[0][0];
        var j = Vab[0][1];
        psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
        x = x1(x, psi, _i, j);
        Sij = Sij1(Sij, psi, _i, j);
        Vab = getAij(x);
      }

      var Ei = createArray(N, 0); // eigenvalues

      for (var _i2 = 0; _i2 < N; _i2++) {
        Ei[_i2] = x[_i2][_i2];
      }

      return sorting(clone(Ei), clone(Sij));
    } // diagonalization implementation for bigNumber


    function diagBig(x) {
      var N = x.length;
      var e0 = abs(config.epsilon / N);
      var psi;
      var Sij = new Array(N); // Sij is Identity Matrix

      for (var i = 0; i < N; i++) {
        Sij[i] = createArray(N, 0);
        Sij[i][i] = 1.0;
      } // initial error


      var Vab = getAijBig(x);

      while (abs(Vab[1]) >= abs(e0)) {
        var _i3 = Vab[0][0];
        var j = Vab[0][1];
        psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
        x = x1Big(x, psi, _i3, j);
        Sij = Sij1Big(Sij, psi, _i3, j);
        Vab = getAijBig(x);
      }

      var Ei = createArray(N, 0); // eigenvalues

      for (var _i4 = 0; _i4 < N; _i4++) {
        Ei[_i4] = x[_i4][_i4];
      } // return [clone(Ei), clone(Sij)]


      return sorting(clone(Ei), clone(Sij));
    } // get angle


    function getTheta(aii, ajj, aij) {
      var denom = ajj - aii;

      if (Math.abs(denom) <= config.epsilon) {
        return Math.PI / 4;
      } else {
        return 0.5 * Math.atan(2 * aij / (ajj - aii));
      }
    } // get angle


    function getThetaBig(aii, ajj, aij) {
      var denom = subtract(ajj, aii);

      if (abs(denom) <= config.epsilon) {
        return bignumber(-1).acos().div(4);
      } else {
        return multiplyScalar(0.5, atan(multiply(2, aij, inv(denom))));
      }
    } // update eigvec


    function Sij1(Sij, theta, i, j) {
      var N = Sij.length;
      var c = Math.cos(theta);
      var s = Math.sin(theta);
      var Ski = createArray(N, 0);
      var Skj = createArray(N, 0);

      for (var k = 0; k < N; k++) {
        Ski[k] = c * Sij[k][i] - s * Sij[k][j];
        Skj[k] = s * Sij[k][i] + c * Sij[k][j];
      }

      for (var _k = 0; _k < N; _k++) {
        Sij[_k][i] = Ski[_k];
        Sij[_k][j] = Skj[_k];
      }

      return Sij;
    } // update eigvec for overlap


    function Sij1Big(Sij, theta, i, j) {
      var N = Sij.length;
      var c = cos(theta);
      var s = sin(theta);
      var Ski = createArray(N, bignumber(0));
      var Skj = createArray(N, bignumber(0));

      for (var k = 0; k < N; k++) {
        Ski[k] = subtract(multiplyScalar(c, Sij[k][i]), multiplyScalar(s, Sij[k][j]));
        Skj[k] = addScalar(multiplyScalar(s, Sij[k][i]), multiplyScalar(c, Sij[k][j]));
      }

      for (var _k2 = 0; _k2 < N; _k2++) {
        Sij[_k2][i] = Ski[_k2];
        Sij[_k2][j] = Skj[_k2];
      }

      return Sij;
    } // update matrix


    function x1Big(Hij, theta, i, j) {
      var N = Hij.length;
      var c = bignumber(cos(theta));
      var s = bignumber(sin(theta));
      var c2 = multiplyScalar(c, c);
      var s2 = multiplyScalar(s, s);
      var Aki = createArray(N, bignumber(0));
      var Akj = createArray(N, bignumber(0)); // 2cs Hij

      var csHij = multiply(bignumber(2), c, s, Hij[i][j]); //  Aii

      var Aii = addScalar(subtract(multiplyScalar(c2, Hij[i][i]), csHij), multiplyScalar(s2, Hij[j][j]));
      var Ajj = add(multiplyScalar(s2, Hij[i][i]), csHij, multiplyScalar(c2, Hij[j][j])); // 0  to i

      for (var k = 0; k < N; k++) {
        Aki[k] = subtract(multiplyScalar(c, Hij[i][k]), multiplyScalar(s, Hij[j][k]));
        Akj[k] = addScalar(multiplyScalar(s, Hij[i][k]), multiplyScalar(c, Hij[j][k]));
      } // Modify Hij


      Hij[i][i] = Aii;
      Hij[j][j] = Ajj;
      Hij[i][j] = bignumber(0);
      Hij[j][i] = bignumber(0); // 0  to i

      for (var _k3 = 0; _k3 < N; _k3++) {
        if (_k3 !== i && _k3 !== j) {
          Hij[i][_k3] = Aki[_k3];
          Hij[_k3][i] = Aki[_k3];
          Hij[j][_k3] = Akj[_k3];
          Hij[_k3][j] = Akj[_k3];
        }
      }

      return Hij;
    } // update matrix


    function x1(Hij, theta, i, j) {
      var N = Hij.length;
      var c = Math.cos(theta);
      var s = Math.sin(theta);
      var c2 = c * c;
      var s2 = s * s;
      var Aki = createArray(N, 0);
      var Akj = createArray(N, 0); //  Aii

      var Aii = c2 * Hij[i][i] - 2 * c * s * Hij[i][j] + s2 * Hij[j][j];
      var Ajj = s2 * Hij[i][i] + 2 * c * s * Hij[i][j] + c2 * Hij[j][j]; // 0  to i

      for (var k = 0; k < N; k++) {
        Aki[k] = c * Hij[i][k] - s * Hij[j][k];
        Akj[k] = s * Hij[i][k] + c * Hij[j][k];
      } // Modify Hij


      Hij[i][i] = Aii;
      Hij[j][j] = Ajj;
      Hij[i][j] = 0;
      Hij[j][i] = 0; // 0  to i

      for (var _k4 = 0; _k4 < N; _k4++) {
        if (_k4 !== i && _k4 !== j) {
          Hij[i][_k4] = Aki[_k4];
          Hij[_k4][i] = Aki[_k4];
          Hij[j][_k4] = Akj[_k4];
          Hij[_k4][j] = Akj[_k4];
        }
      }

      return Hij;
    } // get max off-diagonal value from Upper Diagonal


    function getAij(Mij) {
      var N = Mij.length;
      var maxMij = 0;
      var maxIJ = [0, 1];

      for (var i = 0; i < N; i++) {
        for (var j = i + 1; j < N; j++) {
          if (Math.abs(maxMij) < Math.abs(Mij[i][j])) {
            maxMij = Math.abs(Mij[i][j]);
            maxIJ = [i, j];
          }
        }
      }

      return [maxIJ, maxMij];
    } // get max off-diagonal value from Upper Diagonal


    function getAijBig(Mij) {
      var N = Mij.length;
      var maxMij = 0;
      var maxIJ = [0, 1];

      for (var i = 0; i < N; i++) {
        for (var j = i + 1; j < N; j++) {
          if (abs(maxMij) < abs(Mij[i][j])) {
            maxMij = abs(Mij[i][j]);
            maxIJ = [i, j];
          }
        }
      }

      return [maxIJ, maxMij];
    } // sort results


    function sorting(E, S) {
      var N = E.length;
      var Ef = Array(N);
      var Sf = Array(N);

      for (var k = 0; k < N; k++) {
        Sf[k] = Array(N);
      }

      for (var i = 0; i < N; i++) {
        var minID = 0;
        var minE = E[0];

        for (var j = 0; j < E.length; j++) {
          if (E[j] < minE) {
            minID = j;
            minE = E[minID];
          }
        }

        Ef[i] = E.splice(minID, 1)[0];

        for (var _k5 = 0; _k5 < N; _k5++) {
          Sf[_k5][i] = S[_k5][minID];

          S[_k5].splice(minID, 1);
        }
      }

      return [clone(Ef), clone(Sf)];
    }
    /**
     * Create an array of a certain size and fill all items with an initial value
     * @param {number} size
     * @param {number} value
     * @return {number[]}
     */


    function createArray(size, value) {
      // TODO: as soon as all browsers support Array.fill, use that instead (IE doesn't support it)
      var array = new Array(size);

      for (var i = 0; i < size; i++) {
        array[i] = value;
      }

      return array;
    }
  });

  var name$3x = 'expm';
  var dependencies$3y = ['typed', 'abs', 'add', 'identity', 'inv', 'multiply'];
  var createExpm = /* #__PURE__ */factory(name$3x, dependencies$3y, function (_ref) {
    var typed = _ref.typed,
        abs = _ref.abs,
        add = _ref.add,
        identity = _ref.identity,
        inv = _ref.inv,
        multiply = _ref.multiply;

    /**
     * Compute the matrix exponential, expm(A) = e^A. The matrix must be square.
     * Not to be confused with exp(a), which performs element-wise
     * exponentiation.
     *
     * The exponential is calculated using the Pad approximant with scaling and
     * squaring; see "Nineteen Dubious Ways to Compute the Exponential of a
     * Matrix," by Moler and Van Loan.
     *
     * Syntax:
     *
     *     math.expm(x)
     *
     * Examples:
     *
     *     const A = [[0,2],[0,0]]
     *     math.expm(A)        // returns [[1,2],[0,1]]
     *
     * See also:
     *
     *     exp
     *
     * @param {Matrix} x  A square Matrix
     * @return {Matrix}   The exponential of x
     */
    return typed(name$3x, {
      Matrix: function Matrix(A) {
        // Check matrix size
        var size = A.size();

        if (size.length !== 2 || size[0] !== size[1]) {
          throw new RangeError('Matrix must be square ' + '(size: ' + format$2(size) + ')');
        }

        var n = size[0]; // Desired accuracy of the approximant (The actual accuracy
        // will be affected by round-off error)

        var eps = 1e-15; // The Pad approximant is not so accurate when the values of A
        // are "large", so scale A by powers of two. Then compute the
        // exponential, and square the result repeatedly according to
        // the identity e^A = (e^(A/m))^m
        // Compute infinity-norm of A, ||A||, to see how "big" it is

        var infNorm = infinityNorm(A); // Find the optimal scaling factor and number of terms in the
        // Pad approximant to reach the desired accuracy

        var params = findParams(infNorm, eps);
        var q = params.q;
        var j = params.j; // The Pade approximation to e^A is:
        // Rqq(A) = Dqq(A) ^ -1 * Nqq(A)
        // where
        // Nqq(A) = sum(i=0, q, (2q-i)!p! / [ (2q)!i!(q-i)! ] A^i
        // Dqq(A) = sum(i=0, q, (2q-i)!q! / [ (2q)!i!(q-i)! ] (-A)^i
        // Scale A by 1 / 2^j

        var Apos = multiply(A, Math.pow(2, -j)); // The i=0 term is just the identity matrix

        var N = identity(n);
        var D = identity(n); // Initialization (i=0)

        var factor = 1; // Initialization (i=1)

        var AposToI = Apos; // Cloning not necessary

        var alternate = -1;

        for (var i = 1; i <= q; i++) {
          if (i > 1) {
            AposToI = multiply(AposToI, Apos);
            alternate = -alternate;
          }

          factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);
          N = add(N, multiply(factor, AposToI));
          D = add(D, multiply(factor * alternate, AposToI));
        }

        var R = multiply(inv(D), N); // Square j times

        for (var _i = 0; _i < j; _i++) {
          R = multiply(R, R);
        }

        return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;
      }
    });

    function infinityNorm(A) {
      var n = A.size()[0];
      var infNorm = 0;

      for (var i = 0; i < n; i++) {
        var rowSum = 0;

        for (var j = 0; j < n; j++) {
          rowSum += abs(A.get([i, j]));
        }

        infNorm = Math.max(rowSum, infNorm);
      }

      return infNorm;
    }
    /**
     * Find the best parameters for the Pade approximant given
     * the matrix norm and desired accuracy. Returns the first acceptable
     * combination in order of increasing computational load.
     */


    function findParams(infNorm, eps) {
      var maxSearchSize = 30;

      for (var k = 0; k < maxSearchSize; k++) {
        for (var q = 0; q <= k; q++) {
          var j = k - q;

          if (errorEstimate(infNorm, q, j) < eps) {
            return {
              q: q,
              j: j
            };
          }
        }
      }

      throw new Error('Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)');
    }
    /**
     * Returns the estimated error of the Pade approximant for the given
     * parameters.
     */


    function errorEstimate(infNorm, q, j) {
      var qfac = 1;

      for (var i = 2; i <= q; i++) {
        qfac *= i;
      }

      var twoqfac = qfac;

      for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {
        twoqfac *= _i2;
      }

      var twoqp1fac = twoqfac * (2 * q + 1);
      return 8.0 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
    }
  });

  var name$3y = 'sqrtm';
  var dependencies$3z = ['typed', 'abs', 'add', 'multiply', 'sqrt', 'subtract', 'inv', 'size', 'max', 'identity'];
  var createSqrtm = /* #__PURE__ */factory(name$3y, dependencies$3z, function (_ref) {
    var typed = _ref.typed,
        abs = _ref.abs,
        add = _ref.add,
        multiply = _ref.multiply,
        sqrt = _ref.sqrt,
        subtract = _ref.subtract,
        inv = _ref.inv,
        size = _ref.size,
        max = _ref.max,
        identity = _ref.identity;
    var _maxIterations = 1e3;
    var _tolerance = 1e-6;
    /**
     * Calculate the principal square root matrix using the DenmanBeavers iterative method
     *
     * https://en.wikipedia.org/wiki/Square_root_of_a_matrix#By_DenmanBeavers_iteration
     *
     * @param  {Array | Matrix} A   The square matrix `A`
     * @return {Array | Matrix}     The principal square root of matrix `A`
     * @private
     */

    function _denmanBeavers(A) {
      var error;
      var iterations = 0;
      var Y = A;
      var Z = identity(size(A));

      do {
        var Yk = Y;
        Y = multiply(0.5, add(Yk, inv(Z)));
        Z = multiply(0.5, add(Z, inv(Yk)));
        error = max(abs(subtract(Y, Yk)));

        if (error > _tolerance && ++iterations > _maxIterations) {
          throw new Error('computing square root of matrix: iterative method could not converge');
        }
      } while (error > _tolerance);

      return Y;
    }
    /**
     * Calculate the principal square root of a square matrix.
     * The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.
     *
     * https://en.wikipedia.org/wiki/Square_root_of_a_matrix
     *
     * Syntax:
     *
     *     X = math.sqrtm(A)
     *
     * Examples:
     *
     *     math.sqrtm([[1, 2], [3, 4]]) // returns [[-2, 1], [1.5, -0.5]]
     *
     * See also:
     *
     *     sqrt, pow
     *
     * @param  {Array | Matrix} A   The square matrix `A`
     * @return {Array | Matrix}     The principal square root of matrix `A`
     */


    return typed(name$3y, {
      'Array | Matrix': function ArrayMatrix(A) {
        var size = isMatrix(A) ? A.size() : arraySize(A);

        switch (size.length) {
          case 1:
            // Single element Array | Matrix
            if (size[0] === 1) {
              return sqrt(A);
            } else {
              throw new RangeError('Matrix must be square ' + '(size: ' + format$2(size) + ')');
            }

          case 2:
            {
              // Two-dimensional Array | Matrix
              var rows = size[0];
              var cols = size[1];

              if (rows === cols) {
                return _denmanBeavers(A);
              } else {
                throw new RangeError('Matrix must be square ' + '(size: ' + format$2(size) + ')');
              }
            }
        }
      }
    });
  });

  var name$3z = 'divide';
  var dependencies$3A = ['typed', 'matrix', 'multiply', 'equalScalar', 'divideScalar', 'inv'];
  var createDivide = /* #__PURE__ */factory(name$3z, dependencies$3A, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        multiply = _ref.multiply,
        equalScalar = _ref.equalScalar,
        divideScalar = _ref.divideScalar,
        inv = _ref.inv;
    var algorithm11 = createAlgorithm11({
      typed: typed,
      equalScalar: equalScalar
    });
    var algorithm14 = createAlgorithm14({
      typed: typed
    });
    /**
     * Divide two values, `x / y`.
     * To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.
     *
     * Syntax:
     *
     *    math.divide(x, y)
     *
     * Examples:
     *
     *    math.divide(2, 3)            // returns number 0.6666666666666666
     *
     *    const a = math.complex(5, 14)
     *    const b = math.complex(4, 1)
     *    math.divide(a, b)            // returns Complex 2 + 3i
     *
     *    const c = [[7, -6], [13, -4]]
     *    const d = [[1, 2], [4, 3]]
     *    math.divide(c, d)            // returns Array [[-9, 4], [-11, 6]]
     *
     *    const e = math.unit('18 km')
     *    math.divide(e, 4.5)          // returns Unit 4 km
     *
     * See also:
     *
     *    multiply
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x   Numerator
     * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} y          Denominator
     * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                      Quotient, `x / y`
     */

    return typed('divide', extend({
      // we extend the signatures of divideScalar with signatures dealing with matrices
      'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(x, y) {
        // TODO: implement matrix right division using pseudo inverse
        // https://www.mathworks.nl/help/matlab/ref/mrdivide.html
        // https://www.gnu.org/software/octave/doc/interpreter/Arithmetic-Ops.html
        // https://stackoverflow.com/questions/12263932/how-does-gnu-octave-matrix-division-work-getting-unexpected-behaviour
        return multiply(x, inv(y));
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, divideScalar, false);
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm11(x, y, divideScalar, false);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, divideScalar, false).valueOf();
      },
      'any, Array | Matrix': function anyArrayMatrix(x, y) {
        return multiply(x, inv(y));
      }
    }, divideScalar.signatures));
  });

  var name$3A = 'distance';
  var dependencies$3B = ['typed', 'addScalar', 'subtract', 'divideScalar', 'multiplyScalar', 'unaryMinus', 'sqrt', 'abs'];
  var createDistance = /* #__PURE__ */factory(name$3A, dependencies$3B, function (_ref) {
    var typed = _ref.typed,
        addScalar = _ref.addScalar,
        subtract = _ref.subtract,
        multiplyScalar = _ref.multiplyScalar,
        divideScalar = _ref.divideScalar,
        unaryMinus = _ref.unaryMinus,
        sqrt = _ref.sqrt,
        abs = _ref.abs;

    /**
      * Calculates:
      *    The eucledian distance between two points in N-dimensional spaces.
      *    Distance between point and a line in 2 and 3 dimensional spaces.
      *    Pairwise distance between a set of 2D or 3D points
      * NOTE:
      *    When substituting coefficients of a line(a, b and c), use ax + by + c = 0 instead of ax + by = c
      *    For parametric equation of a 3D line, x0, y0, z0, a, b, c are from: (xx0, yy0, zz0) = t(a, b, c)
      *
      * Syntax:
      *    math.distance([x1, y1], [x2, y2])
      *-   math.distance({pointOneX: 4, pointOneY: 5}, {pointTwoX: 2, pointTwoY: 7})
      *    math.distance([x1, y1, z1], [x2, y2, z2])
      *    math.distance({pointOneX: 4, pointOneY: 5, pointOneZ: 8}, {pointTwoX: 2, pointTwoY: 7, pointTwoZ: 9})
      *    math.distance([x1, y1, ... , N1], [x2, y2, ... , N2])
      *    math.distance([[A], [B], [C]...])
      *    math.distance([x1, y1], [LinePtX1, LinePtY1], [LinePtX2, LinePtY2])
      *    math.distance({pointX: 1, pointY: 4}, {lineOnePtX: 6, lineOnePtY: 3}, {lineTwoPtX: 2, lineTwoPtY: 8})
      *    math.distance([x1, y1, z1], [LinePtX1, LinePtY1, LinePtZ1], [LinePtX2, LinePtY2, LinePtZ2])
      *    math.distance({pointX: 1, pointY: 4, pointZ: 7}, {lineOnePtX: 6, lineOnePtY: 3, lineOnePtZ: 4}, {lineTwoPtX: 2, lineTwoPtY: 8, lineTwoPtZ: 5})
      *    math.distance([x1, y1], [xCoeffLine, yCoeffLine, constant])
      *    math.distance({pointX: 10, pointY: 10}, {xCoeffLine: 8, yCoeffLine: 1, constant: 3})
      *    math.distance([x1, y1, z1], [x0, y0, z0, a-tCoeff, b-tCoeff, c-tCoeff]) point and parametric equation of 3D line
      *    math.distance([x, y, z], [x0, y0, z0, a, b, c])
      *    math.distance({pointX: 2, pointY: 5, pointZ: 9}, {x0: 4, y0: 6, z0: 3, a: 4, b: 2, c: 0})
      *
      * Examples:
      *    math.distance([0,0], [4,4])                     // Returns 5.6569
      *    math.distance(
      *     {pointOneX: 0, pointOneY: 0},
      *     {pointTwoX: 10, pointTwoY: 10})                // Returns 14.142135623730951
      *    math.distance([1, 0, 1], [4, -2, 2])            // Returns 3.74166
      *    math.distance(
      *     {pointOneX: 4, pointOneY: 5, pointOneZ: 8},
      *     {pointTwoX: 2, pointTwoY: 7, pointTwoZ: 9})    // Returns 3
      *    math.distance([1, 0, 1, 0], [0, -1, 0, -1])     // Returns 2
      *    math.distance([[1, 2], [1, 2], [1, 3]])         // Returns [0, 1, 1]
      *    math.distance([[1,2,4], [1,2,6], [8,1,3]])      // Returns [2, 7.14142842854285, 7.681145747868608]
      *    math.distance([10, 10], [8, 1, 3])              // Returns 11.535230316796387
      *    math.distance([10, 10], [2, 3], [-8, 0])        // Returns 8.759953130362847
      *    math.distance(
      *     {pointX: 1, pointY: 4},
      *     {lineOnePtX: 6, lineOnePtY: 3},
      *     {lineTwoPtX: 2, lineTwoPtY: 8})                // Returns 2.720549372624744
      *    math.distance([2, 3, 1], [1, 1, 2, 5, 0, 1])    // Returns 2.3204774044612857
      *    math.distance(
      *     {pointX: 2, pointY: 3, pointZ: 1},
      *     {x0: 1, y0: 1, z0: 2, a: 5, b: 0, c: 1}        // Returns 2.3204774044612857
      *
      * @param {Array | Matrix | Object} x    Co-ordinates of first point
      * @param {Array | Matrix | Object} y    Co-ordinates of second point
      * @return {Number | BigNumber} Returns the distance from two/three points
    */
    return typed(name$3A, {
      'Array, Array, Array': function ArrayArrayArray(x, y, z) {
        // Point to Line 2D (x=Point, y=LinePoint1, z=LinePoint2)
        if (x.length === 2 && y.length === 2 && z.length === 2) {
          if (!_2d(x)) {
            throw new TypeError('Array with 2 numbers or BigNumbers expected for first argument');
          }

          if (!_2d(y)) {
            throw new TypeError('Array with 2 numbers or BigNumbers expected for second argument');
          }

          if (!_2d(z)) {
            throw new TypeError('Array with 2 numbers or BigNumbers expected for third argument');
          }

          var m = divideScalar(subtract(z[1], z[0]), subtract(y[1], y[0]));
          var xCoeff = multiplyScalar(multiplyScalar(m, m), y[0]);
          var yCoeff = unaryMinus(multiplyScalar(m, y[0]));
          var constant = x[1];
          return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
        } else {
          throw new TypeError('Invalid Arguments: Try again');
        }
      },
      'Object, Object, Object': function ObjectObjectObject(x, y, z) {
        if (Object.keys(x).length === 2 && Object.keys(y).length === 2 && Object.keys(z).length === 2) {
          if (!_2d(x)) {
            throw new TypeError('Values of pointX and pointY should be numbers or BigNumbers');
          }

          if (!_2d(y)) {
            throw new TypeError('Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers');
          }

          if (!_2d(z)) {
            throw new TypeError('Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers');
          }

          if ('pointX' in x && 'pointY' in x && 'lineOnePtX' in y && 'lineOnePtY' in y && 'lineTwoPtX' in z && 'lineTwoPtY' in z) {
            var m = divideScalar(subtract(z.lineTwoPtY, z.lineTwoPtX), subtract(y.lineOnePtY, y.lineOnePtX));
            var xCoeff = multiplyScalar(multiplyScalar(m, m), y.lineOnePtX);
            var yCoeff = unaryMinus(multiplyScalar(m, y.lineOnePtX));
            var constant = x.pointX;
            return _distancePointLine2D(x.pointX, x.pointY, xCoeff, yCoeff, constant);
          } else {
            throw new TypeError('Key names do not match');
          }
        } else {
          throw new TypeError('Invalid Arguments: Try again');
        }
      },
      'Array, Array': function ArrayArray(x, y) {
        // Point to Line 2D (x=[pointX, pointY], y=[x-coeff, y-coeff, const])
        if (x.length === 2 && y.length === 3) {
          if (!_2d(x)) {
            throw new TypeError('Array with 2 numbers or BigNumbers expected for first argument');
          }

          if (!_3d(y)) {
            throw new TypeError('Array with 3 numbers or BigNumbers expected for second argument');
          }

          return _distancePointLine2D(x[0], x[1], y[0], y[1], y[2]);
        } else if (x.length === 3 && y.length === 6) {
          // Point to Line 3D
          if (!_3d(x)) {
            throw new TypeError('Array with 3 numbers or BigNumbers expected for first argument');
          }

          if (!_parametricLine(y)) {
            throw new TypeError('Array with 6 numbers or BigNumbers expected for second argument');
          }

          return _distancePointLine3D(x[0], x[1], x[2], y[0], y[1], y[2], y[3], y[4], y[5]);
        } else if (x.length === y.length && x.length > 0) {
          // Point to Point N-dimensions
          if (!_containsOnlyNumbers(x)) {
            throw new TypeError('All values of an array should be numbers or BigNumbers');
          }

          if (!_containsOnlyNumbers(y)) {
            throw new TypeError('All values of an array should be numbers or BigNumbers');
          }

          return _euclideanDistance(x, y);
        } else {
          throw new TypeError('Invalid Arguments: Try again');
        }
      },
      'Object, Object': function ObjectObject(x, y) {
        if (Object.keys(x).length === 2 && Object.keys(y).length === 3) {
          if (!_2d(x)) {
            throw new TypeError('Values of pointX and pointY should be numbers or BigNumbers');
          }

          if (!_3d(y)) {
            throw new TypeError('Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers');
          }

          if ('pointX' in x && 'pointY' in x && 'xCoeffLine' in y && 'yCoeffLine' in y && 'constant' in y) {
            return _distancePointLine2D(x.pointX, x.pointY, y.xCoeffLine, y.yCoeffLine, y.constant);
          } else {
            throw new TypeError('Key names do not match');
          }
        } else if (Object.keys(x).length === 3 && Object.keys(y).length === 6) {
          // Point to Line 3D
          if (!_3d(x)) {
            throw new TypeError('Values of pointX, pointY and pointZ should be numbers or BigNumbers');
          }

          if (!_parametricLine(y)) {
            throw new TypeError('Values of x0, y0, z0, a, b and c should be numbers or BigNumbers');
          }

          if ('pointX' in x && 'pointY' in x && 'x0' in y && 'y0' in y && 'z0' in y && 'a' in y && 'b' in y && 'c' in y) {
            return _distancePointLine3D(x.pointX, x.pointY, x.pointZ, y.x0, y.y0, y.z0, y.a, y.b, y.c);
          } else {
            throw new TypeError('Key names do not match');
          }
        } else if (Object.keys(x).length === 2 && Object.keys(y).length === 2) {
          // Point to Point 2D
          if (!_2d(x)) {
            throw new TypeError('Values of pointOneX and pointOneY should be numbers or BigNumbers');
          }

          if (!_2d(y)) {
            throw new TypeError('Values of pointTwoX and pointTwoY should be numbers or BigNumbers');
          }

          if ('pointOneX' in x && 'pointOneY' in x && 'pointTwoX' in y && 'pointTwoY' in y) {
            return _euclideanDistance([x.pointOneX, x.pointOneY], [y.pointTwoX, y.pointTwoY]);
          } else {
            throw new TypeError('Key names do not match');
          }
        } else if (Object.keys(x).length === 3 && Object.keys(y).length === 3) {
          // Point to Point 3D
          if (!_3d(x)) {
            throw new TypeError('Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers');
          }

          if (!_3d(y)) {
            throw new TypeError('Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers');
          }

          if ('pointOneX' in x && 'pointOneY' in x && 'pointOneZ' in x && 'pointTwoX' in y && 'pointTwoY' in y && 'pointTwoZ' in y) {
            return _euclideanDistance([x.pointOneX, x.pointOneY, x.pointOneZ], [y.pointTwoX, y.pointTwoY, y.pointTwoZ]);
          } else {
            throw new TypeError('Key names do not match');
          }
        } else {
          throw new TypeError('Invalid Arguments: Try again');
        }
      },
      Array: function Array(arr) {
        if (!_pairwise(arr)) {
          throw new TypeError('Incorrect array format entered for pairwise distance calculation');
        }

        return _distancePairwise(arr);
      }
    });

    function _isNumber(a) {
      // distance supports numbers and bignumbers
      return typeof a === 'number' || isBigNumber(a);
    }

    function _2d(a) {
      // checks if the number of arguments are correct in count and are valid (should be numbers)
      if (a.constructor !== Array) {
        a = _objectToArray(a);
      }

      return _isNumber(a[0]) && _isNumber(a[1]);
    }

    function _3d(a) {
      // checks if the number of arguments are correct in count and are valid (should be numbers)
      if (a.constructor !== Array) {
        a = _objectToArray(a);
      }

      return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]);
    }

    function _containsOnlyNumbers(a) {
      // checks if the number of arguments are correct in count and are valid (should be numbers)
      if (!Array.isArray(a)) {
        a = _objectToArray(a);
      }

      return a.every(_isNumber);
    }

    function _parametricLine(a) {
      if (a.constructor !== Array) {
        a = _objectToArray(a);
      }

      return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]) && _isNumber(a[3]) && _isNumber(a[4]) && _isNumber(a[5]);
    }

    function _objectToArray(o) {
      var keys = Object.keys(o);
      var a = [];

      for (var i = 0; i < keys.length; i++) {
        a.push(o[keys[i]]);
      }

      return a;
    }

    function _pairwise(a) {
      // checks for valid arguments passed to _distancePairwise(Array)
      if (a[0].length === 2 && _isNumber(a[0][0]) && _isNumber(a[0][1])) {
        if (a.some(function (aI) {
          return aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]);
        })) {
          return false;
        }
      } else if (a[0].length === 3 && _isNumber(a[0][0]) && _isNumber(a[0][1]) && _isNumber(a[0][2])) {
        if (a.some(function (aI) {
          return aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]);
        })) {
          return false;
        }
      } else {
        return false;
      }

      return true;
    }

    function _distancePointLine2D(x, y, a, b, c) {
      var num = abs(addScalar(addScalar(multiplyScalar(a, x), multiplyScalar(b, y)), c));
      var den = sqrt(addScalar(multiplyScalar(a, a), multiplyScalar(b, b)));
      return divideScalar(num, den);
    }

    function _distancePointLine3D(x, y, z, x0, y0, z0, a, b, c) {
      var num = [subtract(multiplyScalar(subtract(y0, y), c), multiplyScalar(subtract(z0, z), b)), subtract(multiplyScalar(subtract(z0, z), a), multiplyScalar(subtract(x0, x), c)), subtract(multiplyScalar(subtract(x0, x), b), multiplyScalar(subtract(y0, y), a))];
      num = sqrt(addScalar(addScalar(multiplyScalar(num[0], num[0]), multiplyScalar(num[1], num[1])), multiplyScalar(num[2], num[2])));
      var den = sqrt(addScalar(addScalar(multiplyScalar(a, a), multiplyScalar(b, b)), multiplyScalar(c, c)));
      return divideScalar(num, den);
    }

    function _euclideanDistance(x, y) {
      var vectorSize = x.length;
      var result = 0;
      var diff = 0;

      for (var i = 0; i < vectorSize; i++) {
        diff = subtract(x[i], y[i]);
        result = addScalar(multiplyScalar(diff, diff), result);
      }

      return sqrt(result);
    }

    function _distancePairwise(a) {
      var result = [];
      var pointA = [];
      var pointB = [];

      for (var i = 0; i < a.length - 1; i++) {
        for (var j = i + 1; j < a.length; j++) {
          if (a[0].length === 2) {
            pointA = [a[i][0], a[i][1]];
            pointB = [a[j][0], a[j][1]];
          } else if (a[0].length === 3) {
            pointA = [a[i][0], a[i][1], a[i][2]];
            pointB = [a[j][0], a[j][1], a[j][2]];
          }

          result.push(_euclideanDistance(pointA, pointB));
        }
      }

      return result;
    }
  });

  var name$3B = 'intersect';
  var dependencies$3C = ['typed', 'config', 'abs', 'add', 'addScalar', 'matrix', 'multiply', 'multiplyScalar', 'divideScalar', 'subtract', 'smaller', 'equalScalar'];
  var createIntersect = /* #__PURE__ */factory(name$3B, dependencies$3C, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        abs = _ref.abs,
        add = _ref.add,
        addScalar = _ref.addScalar,
        matrix = _ref.matrix,
        multiply = _ref.multiply,
        multiplyScalar = _ref.multiplyScalar,
        divideScalar = _ref.divideScalar,
        subtract = _ref.subtract,
        smaller = _ref.smaller,
        equalScalar = _ref.equalScalar;

    /**
     * Calculates the point of intersection of two lines in two or three dimensions
     * and of a line and a plane in three dimensions. The inputs are in the form of
     * arrays or 1 dimensional matrices. The line intersection functions return null
     * if the lines do not meet.
     *
     * Note: Fill the plane coefficients as `x + y + z = c` and not as `x + y + z + c = 0`.
     *
     * Syntax:
     *
     *    math.intersect(endPoint1Line1, endPoint2Line1, endPoint1Line2, endPoint2Line2)
     *    math.intersect(endPoint1, endPoint2, planeCoefficients)
     *
     * Examples:
     *
     *    math.intersect([0, 0], [10, 10], [10, 0], [0, 10])              // Returns [5, 5]
     *    math.intersect([0, 0, 0], [10, 10, 0], [10, 0, 0], [0, 10, 0])  // Returns [5, 5, 0]
     *    math.intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])            // Returns [7, -4, 3]
     *
     * @param  {Array | Matrix} w   Co-ordinates of first end-point of first line
     * @param  {Array | Matrix} x   Co-ordinates of second end-point of first line
     * @param  {Array | Matrix} y   Co-ordinates of first end-point of second line
     *                              OR Co-efficients of the plane's equation
     * @param  {Array | Matrix} z   Co-ordinates of second end-point of second line
     *                              OR null if the calculation is for line and plane
     * @return {Array}              Returns the point of intersection of lines/lines-planes
     */
    return typed('intersect', {
      'Array, Array, Array': function ArrayArrayArray(x, y, plane) {
        if (!_3d(x)) {
          throw new TypeError('Array with 3 numbers or BigNumbers expected for first argument');
        }

        if (!_3d(y)) {
          throw new TypeError('Array with 3 numbers or BigNumbers expected for second argument');
        }

        if (!_4d(plane)) {
          throw new TypeError('Array with 4 numbers expected as third argument');
        }

        return _intersectLinePlane(x[0], x[1], x[2], y[0], y[1], y[2], plane[0], plane[1], plane[2], plane[3]);
      },
      'Array, Array, Array, Array': function ArrayArrayArrayArray(w, x, y, z) {
        if (w.length === 2) {
          if (!_2d(w)) {
            throw new TypeError('Array with 2 numbers or BigNumbers expected for first argument');
          }

          if (!_2d(x)) {
            throw new TypeError('Array with 2 numbers or BigNumbers expected for second argument');
          }

          if (!_2d(y)) {
            throw new TypeError('Array with 2 numbers or BigNumbers expected for third argument');
          }

          if (!_2d(z)) {
            throw new TypeError('Array with 2 numbers or BigNumbers expected for fourth argument');
          }

          return _intersect2d(w, x, y, z);
        } else if (w.length === 3) {
          if (!_3d(w)) {
            throw new TypeError('Array with 3 numbers or BigNumbers expected for first argument');
          }

          if (!_3d(x)) {
            throw new TypeError('Array with 3 numbers or BigNumbers expected for second argument');
          }

          if (!_3d(y)) {
            throw new TypeError('Array with 3 numbers or BigNumbers expected for third argument');
          }

          if (!_3d(z)) {
            throw new TypeError('Array with 3 numbers or BigNumbers expected for fourth argument');
          }

          return _intersect3d(w[0], w[1], w[2], x[0], x[1], x[2], y[0], y[1], y[2], z[0], z[1], z[2]);
        } else {
          throw new TypeError('Arrays with two or thee dimensional points expected');
        }
      },
      'Matrix, Matrix, Matrix': function MatrixMatrixMatrix(x, y, plane) {
        return matrix(this(x.valueOf(), y.valueOf(), plane.valueOf()));
      },
      'Matrix, Matrix, Matrix, Matrix': function MatrixMatrixMatrixMatrix(w, x, y, z) {
        // TODO: output matrix type should match input matrix type
        return matrix(this(w.valueOf(), x.valueOf(), y.valueOf(), z.valueOf()));
      }
    });

    function _isNumeric(a) {
      // intersect supports numbers and bignumbers
      return typeof a === 'number' || isBigNumber(a);
    }

    function _2d(x) {
      return x.length === 2 && _isNumeric(x[0]) && _isNumeric(x[1]);
    }

    function _3d(x) {
      return x.length === 3 && _isNumeric(x[0]) && _isNumeric(x[1]) && _isNumeric(x[2]);
    }

    function _4d(x) {
      return x.length === 4 && _isNumeric(x[0]) && _isNumeric(x[1]) && _isNumeric(x[2]) && _isNumeric(x[3]);
    }

    function _intersect2d(p1a, p1b, p2a, p2b) {
      var o1 = p1a;
      var o2 = p2a;
      var d1 = subtract(o1, p1b);
      var d2 = subtract(o2, p2b);
      var det = subtract(multiplyScalar(d1[0], d2[1]), multiplyScalar(d2[0], d1[1]));

      if (smaller(abs(det), config.epsilon)) {
        return null;
      }

      var d20o11 = multiplyScalar(d2[0], o1[1]);
      var d21o10 = multiplyScalar(d2[1], o1[0]);
      var d20o21 = multiplyScalar(d2[0], o2[1]);
      var d21o20 = multiplyScalar(d2[1], o2[0]);
      var t = divideScalar(addScalar(subtract(subtract(d20o11, d21o10), d20o21), d21o20), det);
      return add(multiply(d1, t), o1);
    }

    function _intersect3dHelper(a, b, c, d, e, f, g, h, i, j, k, l) {
      // (a - b)*(c - d) + (e - f)*(g - h) + (i - j)*(k - l)
      var add1 = multiplyScalar(subtract(a, b), subtract(c, d));
      var add2 = multiplyScalar(subtract(e, f), subtract(g, h));
      var add3 = multiplyScalar(subtract(i, j), subtract(k, l));
      return addScalar(addScalar(add1, add2), add3);
    }

    function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
      var d1343 = _intersect3dHelper(x1, x3, x4, x3, y1, y3, y4, y3, z1, z3, z4, z3);

      var d4321 = _intersect3dHelper(x4, x3, x2, x1, y4, y3, y2, y1, z4, z3, z2, z1);

      var d1321 = _intersect3dHelper(x1, x3, x2, x1, y1, y3, y2, y1, z1, z3, z2, z1);

      var d4343 = _intersect3dHelper(x4, x3, x4, x3, y4, y3, y4, y3, z4, z3, z4, z3);

      var d2121 = _intersect3dHelper(x2, x1, x2, x1, y2, y1, y2, y1, z2, z1, z2, z1);

      var ta = divideScalar(subtract(multiplyScalar(d1343, d4321), multiplyScalar(d1321, d4343)), subtract(multiplyScalar(d2121, d4343), multiplyScalar(d4321, d4321)));
      var tb = divideScalar(addScalar(d1343, multiplyScalar(ta, d4321)), d4343);
      var pax = addScalar(x1, multiplyScalar(ta, subtract(x2, x1)));
      var pay = addScalar(y1, multiplyScalar(ta, subtract(y2, y1)));
      var paz = addScalar(z1, multiplyScalar(ta, subtract(z2, z1)));
      var pbx = addScalar(x3, multiplyScalar(tb, subtract(x4, x3)));
      var pby = addScalar(y3, multiplyScalar(tb, subtract(y4, y3)));
      var pbz = addScalar(z3, multiplyScalar(tb, subtract(z4, z3)));

      if (equalScalar(pax, pbx) && equalScalar(pay, pby) && equalScalar(paz, pbz)) {
        return [pax, pay, paz];
      } else {
        return null;
      }
    }

    function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y, z, c) {
      var x1x = multiplyScalar(x1, x);
      var x2x = multiplyScalar(x2, x);
      var y1y = multiplyScalar(y1, y);
      var y2y = multiplyScalar(y2, y);
      var z1z = multiplyScalar(z1, z);
      var z2z = multiplyScalar(z2, z);
      var t = divideScalar(subtract(subtract(subtract(c, x1x), y1y), z1z), subtract(subtract(subtract(addScalar(addScalar(x2x, y2y), z2z), x1x), y1y), z1z));
      var px = addScalar(x1, multiplyScalar(t, subtract(x2, x1)));
      var py = addScalar(y1, multiplyScalar(t, subtract(y2, y1)));
      var pz = addScalar(z1, multiplyScalar(t, subtract(z2, z1)));
      return [px, py, pz]; // TODO: Add cases when line is parallel to the plane:
      //       (a) no intersection,
      //       (b) line contained in plane
    }
  });

  var name$3C = 'sum';
  var dependencies$3D = ['typed', 'config', 'add', 'numeric'];
  var createSum = /* #__PURE__ */factory(name$3C, dependencies$3D, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        add = _ref.add,
        numeric = _ref.numeric;

    /**
     * Compute the sum of a matrix or a list with values.
     * In case of a (multi dimensional) array or matrix, the sum of all
     * elements will be calculated.
     *
     * Syntax:
     *
     *     math.sum(a, b, c, ...)
     *     math.sum(A)
     *
     * Examples:
     *
     *     math.sum(2, 1, 4, 3)               // returns 10
     *     math.sum([2, 1, 4, 3])             // returns 10
     *     math.sum([[2, 5], [4, 3], [1, 7]]) // returns 22
     *
     * See also:
     *
     *    mean, median, min, max, prod, std, variance
     *
     * @param {... *} args  A single matrix or or multiple scalar values
     * @return {*} The sum of all values
     */
    return typed(name$3C, {
      // sum([a, b, c, d, ...])
      'Array | Matrix': _sum,
      // sum([a, b, c, d, ...], dim)
      'Array | Matrix, number | BigNumber': _nsumDim,
      // sum(a, b, c, d, ...)
      '...': function _(args) {
        if (containsCollections(args)) {
          throw new TypeError('Scalar values expected in function sum');
        }

        return _sum(args);
      }
    });
    /**
     * Recursively calculate the sum of an n-dimensional array
     * @param {Array | Matrix} array
     * @return {number} sum
     * @private
     */

    function _sum(array) {
      var sum;
      deepForEach(array, function (value) {
        try {
          sum = sum === undefined ? value : add(sum, value);
        } catch (err) {
          throw improveErrorMessage(err, 'sum', value);
        }
      }); // make sure returning numeric value: parse a string into a numeric value

      if (sum === undefined) {
        sum = numeric(0, config.number);
      }

      if (typeof sum === 'string') {
        sum = numeric(sum, config.number);
      }

      return sum;
    }

    function _nsumDim(array, dim) {
      try {
        var sum = reduce(array, dim, add);
        return sum;
      } catch (err) {
        throw improveErrorMessage(err, 'sum');
      }
    }
  });

  var name$3D = 'mean';
  var dependencies$3E = ['typed', 'add', 'divide'];
  var createMean = /* #__PURE__ */factory(name$3D, dependencies$3E, function (_ref) {
    var typed = _ref.typed,
        add = _ref.add,
        divide = _ref.divide;

    /**
     * Compute the mean value of matrix or a list with values.
     * In case of a multi dimensional array, the mean of the flattened array
     * will be calculated. When `dim` is provided, the maximum over the selected
     * dimension will be calculated. Parameter `dim` is zero-based.
     *
     * Syntax:
     *
     *     math.mean(a, b, c, ...)
     *     math.mean(A)
     *     math.mean(A, dim)
     *
     * Examples:
     *
     *     math.mean(2, 1, 4, 3)                     // returns 2.5
     *     math.mean([1, 2.7, 3.2, 4])               // returns 2.725
     *
     *     math.mean([[2, 5], [6, 3], [1, 7]], 0)    // returns [3, 5]
     *     math.mean([[2, 5], [6, 3], [1, 7]], 1)    // returns [3.5, 4.5, 4]
     *
     * See also:
     *
     *     median, min, max, sum, prod, std, variance
     *
     * @param {... *} args  A single matrix or or multiple scalar values
     * @return {*} The mean of all values
     */
    return typed(name$3D, {
      // mean([a, b, c, d, ...])
      'Array | Matrix': _mean,
      // mean([a, b, c, d, ...], dim)
      'Array | Matrix, number | BigNumber': _nmeanDim,
      // mean(a, b, c, d, ...)
      '...': function _(args) {
        if (containsCollections(args)) {
          throw new TypeError('Scalar values expected in function mean');
        }

        return _mean(args);
      }
    });
    /**
     * Calculate the mean value in an n-dimensional array, returning a
     * n-1 dimensional array
     * @param {Array} array
     * @param {number} dim
     * @return {number} mean
     * @private
     */

    function _nmeanDim(array, dim) {
      try {
        var sum = reduce(array, dim, add);
        var s = Array.isArray(array) ? arraySize(array) : array.size();
        return divide(sum, s[dim]);
      } catch (err) {
        throw improveErrorMessage(err, 'mean');
      }
    }
    /**
     * Recursively calculate the mean value in an n-dimensional array
     * @param {Array} array
     * @return {number} mean
     * @private
     */


    function _mean(array) {
      var sum;
      var num = 0;
      deepForEach(array, function (value) {
        try {
          sum = sum === undefined ? value : add(sum, value);
          num++;
        } catch (err) {
          throw improveErrorMessage(err, 'mean', value);
        }
      });

      if (num === 0) {
        throw new Error('Cannot calculate the mean of an empty array');
      }

      return divide(sum, num);
    }
  });

  var name$3E = 'median';
  var dependencies$3F = ['typed', 'add', 'divide', 'compare', 'partitionSelect'];
  var createMedian = /* #__PURE__ */factory(name$3E, dependencies$3F, function (_ref) {
    var typed = _ref.typed,
        add = _ref.add,
        divide = _ref.divide,
        compare = _ref.compare,
        partitionSelect = _ref.partitionSelect;

    /**
     * Recursively calculate the median of an n-dimensional array
     * @param {Array} array
     * @return {Number} median
     * @private
     */
    function _median(array) {
      try {
        array = flatten(array.valueOf());
        var num = array.length;

        if (num === 0) {
          throw new Error('Cannot calculate median of an empty array');
        }

        if (num % 2 === 0) {
          // even: return the average of the two middle values
          var mid = num / 2 - 1;
          var right = partitionSelect(array, mid + 1); // array now partitioned at mid + 1, take max of left part

          var left = array[mid];

          for (var i = 0; i < mid; ++i) {
            if (compare(array[i], left) > 0) {
              left = array[i];
            }
          }

          return middle2(left, right);
        } else {
          // odd: return the middle value
          var m = partitionSelect(array, (num - 1) / 2);
          return middle(m);
        }
      } catch (err) {
        throw improveErrorMessage(err, 'median');
      }
    } // helper function to type check the middle value of the array


    var middle = typed({
      'number | BigNumber | Complex | Unit': function numberBigNumberComplexUnit(value) {
        return value;
      }
    }); // helper function to type check the two middle value of the array

    var middle2 = typed({
      'number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit': function numberBigNumberComplexUnitNumberBigNumberComplexUnit(left, right) {
        return divide(add(left, right), 2);
      }
    });
    /**
     * Compute the median of a matrix or a list with values. The values are
     * sorted and the middle value is returned. In case of an even number of
     * values, the average of the two middle values is returned.
     * Supported types of values are: Number, BigNumber, Unit
     *
     * In case of a (multi dimensional) array or matrix, the median of all
     * elements will be calculated.
     *
     * Syntax:
     *
     *     math.median(a, b, c, ...)
     *     math.median(A)
     *
     * Examples:
     *
     *     math.median(5, 2, 7)        // returns 5
     *     math.median([3, -1, 5, 7])  // returns 4
     *
     * See also:
     *
     *     mean, min, max, sum, prod, std, variance, quantileSeq
     *
     * @param {... *} args  A single matrix or or multiple scalar values
     * @return {*} The median
     */

    return typed(name$3E, {
      // median([a, b, c, d, ...])
      'Array | Matrix': _median,
      // median([a, b, c, d, ...], dim)
      'Array | Matrix, number | BigNumber': function ArrayMatrixNumberBigNumber(array, dim) {
        // TODO: implement median(A, dim)
        throw new Error('median(A, dim) is not yet supported'); // return reduce(arguments[0], arguments[1], ...)
      },
      // median(a, b, c, d, ...)
      '...': function _(args) {
        if (containsCollections(args)) {
          throw new TypeError('Scalar values expected in function median');
        }

        return _median(args);
      }
    });
  });

  var name$3F = 'mad';
  var dependencies$3G = ['typed', 'abs', 'map', 'median', 'subtract'];
  var createMad = /* #__PURE__ */factory(name$3F, dependencies$3G, function (_ref) {
    var typed = _ref.typed,
        abs = _ref.abs,
        map$$1 = _ref.map,
        median = _ref.median,
        subtract = _ref.subtract;

    /**
     * Compute the median absolute deviation of a matrix or a list with values.
     * The median absolute deviation is defined as the median of the absolute
     * deviations from the median.
     *
     * Syntax:
     *
     *     math.mad(a, b, c, ...)
     *     math.mad(A)
     *
     * Examples:
     *
     *     math.mad(10, 20, 30)             // returns 10
     *     math.mad([1, 2, 3])              // returns 1
     *     math.mad([[1, 2, 3], [4, 5, 6]]) // returns 1.5
     *
     * See also:
     *
     *     median, mean, std, abs
     *
     * @param {Array | Matrix} array
     *                        A single matrix or multiple scalar values.
     * @return {*} The median absolute deviation.
     */
    return typed(name$3F, {
      // mad([a, b, c, d, ...])
      'Array | Matrix': _mad,
      // mad(a, b, c, d, ...)
      '...': function _(args) {
        return _mad(args);
      }
    });

    function _mad(array) {
      array = flatten(array.valueOf());

      if (array.length === 0) {
        throw new Error('Cannot calculate median absolute deviation (mad) of an empty array');
      }

      try {
        var med = median(array);
        return median(map$$1(array, function (value) {
          return abs(subtract(value, med));
        }));
      } catch (err) {
        if (err instanceof TypeError && err.message.indexOf('median') !== -1) {
          throw new TypeError(err.message.replace('median', 'mad'));
        } else {
          throw improveErrorMessage(err, 'mad');
        }
      }
    }
  });

  var DEFAULT_NORMALIZATION = 'unbiased';
  var name$3G = 'variance';
  var dependencies$3H = ['typed', 'add', 'subtract', 'multiply', 'divide', 'apply', 'isNaN'];
  var createVariance = /* #__PURE__ */factory(name$3G, dependencies$3H, function (_ref) {
    var typed = _ref.typed,
        add = _ref.add,
        subtract = _ref.subtract,
        multiply = _ref.multiply,
        divide = _ref.divide,
        apply = _ref.apply,
        isNaN = _ref.isNaN;

    /**
     * Compute the variance of a matrix or a  list with values.
     * In case of a (multi dimensional) array or matrix, the variance over all
     * elements will be calculated.
     *
     * Additionally, it is possible to compute the variance along the rows
     * or columns of a matrix by specifying the dimension as the second argument.
     *
     * Optionally, the type of normalization can be specified as the final
     * parameter. The parameter `normalization` can be one of the following values:
     *
     * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
     * - 'uncorrected'        The sum of squared errors is divided by n
     * - 'biased'             The sum of squared errors is divided by (n + 1)
     *
     *
     * Note that older browser may not like the variable name `var`. In that
     * case, the function can be called as `math['var'](...)` instead of
     * `math.var(...)`.
     *
     * Syntax:
     *
     *     math.variance(a, b, c, ...)
     *     math.variance(A)
     *     math.variance(A, normalization)
     *     math.variance(A, dimension)
     *     math.variance(A, dimension, normalization)
     *
     * Examples:
     *
     *     math.variance(2, 4, 6)                     // returns 4
     *     math.variance([2, 4, 6, 8])                // returns 6.666666666666667
     *     math.variance([2, 4, 6, 8], 'uncorrected') // returns 5
     *     math.variance([2, 4, 6, 8], 'biased')      // returns 4
     *
     *     math.variance([[1, 2, 3], [4, 5, 6]])      // returns 3.5
     *     math.variance([[1, 2, 3], [4, 6, 8]], 0)   // returns [4.5, 8, 12.5]
     *     math.variance([[1, 2, 3], [4, 6, 8]], 1)   // returns [1, 4]
     *     math.variance([[1, 2, 3], [4, 6, 8]], 1, 'biased') // returns [0.5, 2]
     *
     * See also:
     *
     *    mean, median, max, min, prod, std, sum
     *
     * @param {Array | Matrix} array
     *                        A single matrix or or multiple scalar values
     * @param {string} [normalization='unbiased']
     *                        Determines how to normalize the variance.
     *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.
     * @param dimension {number | BigNumber}
     *                        Determines the axis to compute the variance for a matrix
     * @return {*} The variance
     */
    return typed(name$3G, {
      // variance([a, b, c, d, ...])
      'Array | Matrix': function ArrayMatrix(array) {
        return _var(array, DEFAULT_NORMALIZATION);
      },
      // variance([a, b, c, d, ...], normalization)
      'Array | Matrix, string': _var,
      // variance([a, b, c, c, ...], dim)
      'Array | Matrix, number | BigNumber': function ArrayMatrixNumberBigNumber(array, dim) {
        return _varDim(array, dim, DEFAULT_NORMALIZATION);
      },
      // variance([a, b, c, c, ...], dim, normalization)
      'Array | Matrix, number | BigNumber, string': _varDim,
      // variance(a, b, c, d, ...)
      '...': function _(args) {
        return _var(args, DEFAULT_NORMALIZATION);
      }
    });
    /**
     * Recursively calculate the variance of an n-dimensional array
     * @param {Array} array
     * @param {string} normalization
     *                        Determines how to normalize the variance:
     *                        - 'unbiased'    The sum of squared errors is divided by (n - 1)
     *                        - 'uncorrected' The sum of squared errors is divided by n
     *                        - 'biased'      The sum of squared errors is divided by (n + 1)
     * @return {number | BigNumber} variance
     * @private
     */

    function _var(array, normalization) {
      var sum = 0;
      var num = 0;

      if (array.length === 0) {
        throw new SyntaxError('Function variance requires one or more parameters (0 provided)');
      } // calculate the mean and number of elements


      deepForEach(array, function (value) {
        try {
          sum = add(sum, value);
          num++;
        } catch (err) {
          throw improveErrorMessage(err, 'variance', value);
        }
      });
      if (num === 0) throw new Error('Cannot calculate variance of an empty array');
      var mean = divide(sum, num); // calculate the variance

      sum = 0;
      deepForEach(array, function (value) {
        var diff = subtract(value, mean);
        sum = add(sum, multiply(diff, diff));
      });

      if (isNaN(sum)) {
        return sum;
      }

      switch (normalization) {
        case 'uncorrected':
          return divide(sum, num);

        case 'biased':
          return divide(sum, num + 1);

        case 'unbiased':
          {
            var zero = isBigNumber(sum) ? sum.mul(0) : 0;
            return num === 1 ? zero : divide(sum, num - 1);
          }

        default:
          throw new Error('Unknown normalization "' + normalization + '". ' + 'Choose "unbiased" (default), "uncorrected", or "biased".');
      }
    }

    function _varDim(array, dim, normalization) {
      try {
        if (array.length === 0) {
          throw new SyntaxError('Function variance requires one or more parameters (0 provided)');
        }

        return apply(array, dim, function (x) {
          return _var(x, normalization);
        });
      } catch (err) {
        throw improveErrorMessage(err, 'variance');
      }
    }
  });

  var name$3H = 'quantileSeq';
  var dependencies$3I = ['typed', 'add', 'multiply', 'partitionSelect', 'compare'];
  var createQuantileSeq = /* #__PURE__ */factory(name$3H, dependencies$3I, function (_ref) {
    var typed = _ref.typed,
        add = _ref.add,
        multiply = _ref.multiply,
        partitionSelect = _ref.partitionSelect,
        compare = _ref.compare;

    /**
     * Compute the prob order quantile of a matrix or a list with values.
     * The sequence is sorted and the middle value is returned.
     * Supported types of sequence values are: Number, BigNumber, Unit
     * Supported types of probability are: Number, BigNumber
     *
     * In case of a (multi dimensional) array or matrix, the prob order quantile
     * of all elements will be calculated.
     *
     * Syntax:
     *
     *     math.quantileSeq(A, prob[, sorted])
     *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])
     *     math.quantileSeq(A, N[, sorted])
     *
     * Examples:
     *
     *     math.quantileSeq([3, -1, 5, 7], 0.5)         // returns 4
     *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3])  // returns [3, 5]
     *     math.quantileSeq([3, -1, 5, 7], 2)           // returns [3, 5]
     *     math.quantileSeq([-1, 3, 5, 7], 0.5, true)   // returns 4
     *
     * See also:
     *
     *     median, mean, min, max, sum, prod, std, variance
     *
     * @param {Array, Matrix} data                A single matrix or Array
     * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is
     *                                            the amount of evenly distributed steps of
     *                                            probabilities; only one of these options can
     *                                            be provided
     * @param {Boolean} sorted=false              is data sorted in ascending order
     * @return {Number, BigNumber, Unit, Array}   Quantile(s)
     */
    function quantileSeq(data, probOrN, sorted) {
      var probArr, dataArr, one;

      if (arguments.length < 2 || arguments.length > 3) {
        throw new SyntaxError('Function quantileSeq requires two or three parameters');
      }

      if (isCollection(data)) {
        sorted = sorted || false;

        if (typeof sorted === 'boolean') {
          dataArr = data.valueOf();

          if (isNumber(probOrN)) {
            if (probOrN < 0) {
              throw new Error('N/prob must be non-negative');
            }

            if (probOrN <= 1) {
              // quantileSeq([a, b, c, d, ...], prob[,sorted])
              return _quantileSeq(dataArr, probOrN, sorted);
            }

            if (probOrN > 1) {
              // quantileSeq([a, b, c, d, ...], N[,sorted])
              if (!isInteger(probOrN)) {
                throw new Error('N must be a positive integer');
              }

              var nPlusOne = probOrN + 1;
              probArr = new Array(probOrN);

              for (var i = 0; i < probOrN;) {
                probArr[i] = _quantileSeq(dataArr, ++i / nPlusOne, sorted);
              }

              return probArr;
            }
          }

          if (isBigNumber(probOrN)) {
            var BigNumber = probOrN.constructor;

            if (probOrN.isNegative()) {
              throw new Error('N/prob must be non-negative');
            }

            one = new BigNumber(1);

            if (probOrN.lte(one)) {
              // quantileSeq([a, b, c, d, ...], prob[,sorted])
              return new BigNumber(_quantileSeq(dataArr, probOrN, sorted));
            }

            if (probOrN.gt(one)) {
              // quantileSeq([a, b, c, d, ...], N[,sorted])
              if (!probOrN.isInteger()) {
                throw new Error('N must be a positive integer');
              } // largest possible Array length is 2^32-1
              // 2^32 < 10^15, thus safe conversion guaranteed


              var intN = probOrN.toNumber();

              if (intN > 4294967295) {
                throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');
              }

              var _nPlusOne = new BigNumber(intN + 1);

              probArr = new Array(intN);

              for (var _i = 0; _i < intN;) {
                probArr[_i] = new BigNumber(_quantileSeq(dataArr, new BigNumber(++_i).div(_nPlusOne), sorted));
              }

              return probArr;
            }
          }

          if (Array.isArray(probOrN)) {
            // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])
            probArr = new Array(probOrN.length);

            for (var _i2 = 0; _i2 < probArr.length; ++_i2) {
              var currProb = probOrN[_i2];

              if (isNumber(currProb)) {
                if (currProb < 0 || currProb > 1) {
                  throw new Error('Probability must be between 0 and 1, inclusive');
                }
              } else if (isBigNumber(currProb)) {
                one = new currProb.constructor(1);

                if (currProb.isNegative() || currProb.gt(one)) {
                  throw new Error('Probability must be between 0 and 1, inclusive');
                }
              } else {
                throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function
              }

              probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);
            }

            return probArr;
          }

          throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function
        }

        throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function
      }

      throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function
    }
    /**
     * Calculate the prob order quantile of an n-dimensional array.
     *
     * @param {Array} array
     * @param {Number, BigNumber} prob
     * @param {Boolean} sorted
     * @return {Number, BigNumber, Unit} prob order quantile
     * @private
     */


    function _quantileSeq(array, prob, sorted) {
      var flat = flatten(array);
      var len = flat.length;

      if (len === 0) {
        throw new Error('Cannot calculate quantile of an empty sequence');
      }

      if (isNumber(prob)) {
        var _index = prob * (len - 1);

        var _fracPart = _index % 1;

        if (_fracPart === 0) {
          var value = sorted ? flat[_index] : partitionSelect(flat, _index);
          validate$$1(value);
          return value;
        }

        var _integerPart = Math.floor(_index);

        var _left;

        var _right;

        if (sorted) {
          _left = flat[_integerPart];
          _right = flat[_integerPart + 1];
        } else {
          _right = partitionSelect(flat, _integerPart + 1); // max of partition is kth largest

          _left = flat[_integerPart];

          for (var i = 0; i < _integerPart; ++i) {
            if (compare(flat[i], _left) > 0) {
              _left = flat[i];
            }
          }
        }

        validate$$1(_left);
        validate$$1(_right); // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]

        return add(multiply(_left, 1 - _fracPart), multiply(_right, _fracPart));
      } // If prob is a BigNumber


      var index = prob.times(len - 1);

      if (index.isInteger()) {
        index = index.toNumber();

        var _value = sorted ? flat[index] : partitionSelect(flat, index);

        validate$$1(_value);
        return _value;
      }

      var integerPart = index.floor();
      var fracPart = index.minus(integerPart);
      var integerPartNumber = integerPart.toNumber();
      var left;
      var right;

      if (sorted) {
        left = flat[integerPartNumber];
        right = flat[integerPartNumber + 1];
      } else {
        right = partitionSelect(flat, integerPartNumber + 1); // max of partition is kth largest

        left = flat[integerPartNumber];

        for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {
          if (compare(flat[_i3], left) > 0) {
            left = flat[_i3];
          }
        }
      }

      validate$$1(left);
      validate$$1(right); // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]

      var one = new fracPart.constructor(1);
      return add(multiply(left, one.minus(fracPart)), multiply(right, fracPart));
    }
    /**
     * Check if array value types are valid, throw error otherwise.
     * @param {number | BigNumber | Unit} x
     * @param {number | BigNumber | Unit} x
     * @private
     */


    var validate$$1 = typed({
      'number | BigNumber | Unit': function numberBigNumberUnit(x) {
        return x;
      }
    });
    return quantileSeq;
  });

  var name$3I = 'std';
  var dependencies$3J = ['typed', 'sqrt', 'variance'];
  var createStd = /* #__PURE__ */factory(name$3I, dependencies$3J, function (_ref) {
    var typed = _ref.typed,
        sqrt = _ref.sqrt,
        variance = _ref.variance;

    /**
     * Compute the standard deviation of a matrix or a  list with values.
     * The standard deviations is defined as the square root of the variance:
     * `std(A) = sqrt(variance(A))`.
     * In case of a (multi dimensional) array or matrix, the standard deviation
     * over all elements will be calculated by default, unless an axis is specified
     * in which case the standard deviation will be computed along that axis.
     *
     * Additionally, it is possible to compute the standard deviation along the rows
     * or columns of a matrix by specifying the dimension as the second argument.
     *
     * Optionally, the type of normalization can be specified as the final
     * parameter. The parameter `normalization` can be one of the following values:
     *
     * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
     * - 'uncorrected'        The sum of squared errors is divided by n
     * - 'biased'             The sum of squared errors is divided by (n + 1)
     *
     *
     * Syntax:
     *
     *     math.std(a, b, c, ...)
     *     math.std(A)
     *     math.std(A, normalization)
     *     math.std(A, dimension)
     *     math.std(A, dimension, normalization)
     *
     * Examples:
     *
     *     math.std(2, 4, 6)                     // returns 2
     *     math.std([2, 4, 6, 8])                // returns 2.581988897471611
     *     math.std([2, 4, 6, 8], 'uncorrected') // returns 2.23606797749979
     *     math.std([2, 4, 6, 8], 'biased')      // returns 2
     *
     *     math.std([[1, 2, 3], [4, 5, 6]])      // returns 1.8708286933869707
     *     math.std([[1, 2, 3], [4, 6, 8]], 0)    // returns [2.1213203435596424, 2.8284271247461903, 3.5355339059327378]
     *     math.std([[1, 2, 3], [4, 6, 8]], 1)    // returns [1, 2]
     *     math.std([[1, 2, 3], [4, 6, 8]], 1, 'biased') // returns [0.7071067811865476, 1.4142135623730951]
     *
     * See also:
     *
     *    mean, median, max, min, prod, sum, variance
     *
     * @param {Array | Matrix} array
     *                        A single matrix or or multiple scalar values
     * @param {string} [normalization='unbiased']
     *                        Determines how to normalize the variance.
     *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.
     * @param dimension {number | BigNumber}
     *                        Determines the axis to compute the standard deviation for a matrix
     * @return {*} The standard deviation
     */
    return typed(name$3I, {
      // std([a, b, c, d, ...])
      'Array | Matrix': _std,
      // std([a, b, c, d, ...], normalization)
      'Array | Matrix, string': _std,
      // std([a, b, c, c, ...], dim)
      'Array | Matrix, number | BigNumber': _std,
      // std([a, b, c, c, ...], dim, normalization)
      'Array | Matrix, number | BigNumber, string': _std,
      // std(a, b, c, d, ...)
      '...': function _(args) {
        return _std(args);
      }
    });

    function _std(array, normalization) {
      if (array.length === 0) {
        throw new SyntaxError('Function std requires one or more parameters (0 provided)');
      }

      try {
        return sqrt(variance.apply(null, arguments));
      } catch (err) {
        if (err instanceof TypeError && err.message.indexOf(' variance') !== -1) {
          throw new TypeError(err.message.replace(' variance', ' std'));
        } else {
          throw err;
        }
      }
    }
  });

  var name$3J = 'combinations';
  var dependencies$3K = ['typed'];
  var createCombinations = /* #__PURE__ */factory(name$3J, dependencies$3K, function (_ref) {
    var typed = _ref.typed;

    /**
     * Compute the number of ways of picking `k` unordered outcomes from `n`
     * possibilities.
     *
     * Combinations only takes integer arguments.
     * The following condition must be enforced: k <= n.
     *
     * Syntax:
     *
     *     math.combinations(n, k)
     *
     * Examples:
     *
     *    math.combinations(7, 5) // returns 21
     *
     * See also:
     *
     *    combinationsWithRep, permutations, factorial
     *
     * @param {number | BigNumber} n    Total number of objects in the set
     * @param {number | BigNumber} k    Number of objects in the subset
     * @return {number | BigNumber}     Number of possible combinations.
     */
    return typed(name$3J, {
      'number, number': combinationsNumber,
      'BigNumber, BigNumber': function BigNumberBigNumber(n, k) {
        var BigNumber = n.constructor;
        var result, i;
        var nMinusk = n.minus(k);
        var one = new BigNumber(1);

        if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
          throw new TypeError('Positive integer value expected in function combinations');
        }

        if (k.gt(n)) {
          throw new TypeError('k must be less than n in function combinations');
        }

        result = one;

        if (k.lt(nMinusk)) {
          for (i = one; i.lte(nMinusk); i = i.plus(one)) {
            result = result.times(k.plus(i)).dividedBy(i);
          }
        } else {
          for (i = one; i.lte(k); i = i.plus(one)) {
            result = result.times(nMinusk.plus(i)).dividedBy(i);
          }
        }

        return result;
      } // TODO: implement support for collection in combinations

    });
  });
  /**
   * Test whether BigNumber n is a positive integer
   * @param {BigNumber} n
   * @returns {boolean} isPositiveInteger
   */

  function isPositiveInteger(n) {
    return n.isInteger() && n.gte(0);
  }

  var name$3K = 'combinationsWithRep';
  var dependencies$3L = ['typed'];
  var createCombinationsWithRep = /* #__PURE__ */factory(name$3K, dependencies$3L, function (_ref) {
    var typed = _ref.typed;

    /**
     * Compute the number of ways of picking `k` unordered outcomes from `n`
     * possibilities, allowing individual outcomes to be repeated more than once.
     *
     * CombinationsWithRep only takes integer arguments.
     * The following condition must be enforced: k <= n + k -1.
     *
     * Syntax:
     *
     *     math.combinationsWithRep(n, k)
     *
     * Examples:
     *
     *    math.combinationsWithRep(7, 5) // returns 462
     *
     * See also:
     *
     *    combinations, permutations, factorial
     *
     * @param {number | BigNumber} n    Total number of objects in the set
     * @param {number | BigNumber} k    Number of objects in the subset
     * @return {number | BigNumber}     Number of possible combinations with replacement.
     */
    return typed(name$3K, {
      'number, number': function numberNumber(n, k) {
        if (!isInteger(n) || n < 0) {
          throw new TypeError('Positive integer value expected in function combinationsWithRep');
        }

        if (!isInteger(k) || k < 0) {
          throw new TypeError('Positive integer value expected in function combinationsWithRep');
        }

        if (n < 1) {
          throw new TypeError('k must be less than or equal to n + k - 1');
        }

        if (k < n - 1) {
          var _prodrange = product(n, n + k - 1);

          return _prodrange / product(1, k);
        }

        var prodrange = product(k + 1, n + k - 1);
        return prodrange / product(1, n - 1);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(n, k) {
        var BigNumber = n.constructor;
        var result, i;
        var one = new BigNumber(1);
        var nMinusOne = n.minus(one);

        if (!isPositiveInteger$1(n) || !isPositiveInteger$1(k)) {
          throw new TypeError('Positive integer value expected in function combinationsWithRep');
        }

        if (n.lt(one)) {
          throw new TypeError('k must be less than or equal to n + k - 1 in function combinationsWithRep');
        }

        result = one;

        if (k.lt(nMinusOne)) {
          for (i = one; i.lte(nMinusOne); i = i.plus(one)) {
            result = result.times(k.plus(i)).dividedBy(i);
          }
        } else {
          for (i = one; i.lte(k); i = i.plus(one)) {
            result = result.times(nMinusOne.plus(i)).dividedBy(i);
          }
        }

        return result;
      }
    });
  });
  /**
   * Test whether BigNumber n is a positive integer
   * @param {BigNumber} n
   * @returns {boolean} isPositiveInteger
   */

  function isPositiveInteger$1(n) {
    return n.isInteger() && n.gte(0);
  }

  var name$3L = 'gamma';
  var dependencies$3M = ['typed', 'config', 'multiplyScalar', 'pow', 'BigNumber', 'Complex'];
  var createGamma = /* #__PURE__ */factory(name$3L, dependencies$3M, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        multiplyScalar = _ref.multiplyScalar,
        pow = _ref.pow,
        _BigNumber = _ref.BigNumber,
        _Complex = _ref.Complex;

    /**
     * Compute the gamma function of a value using Lanczos approximation for
     * small values, and an extended Stirling approximation for large values.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.gamma(n)
     *
     * Examples:
     *
     *    math.gamma(5)       // returns 24
     *    math.gamma(-0.5)    // returns -3.5449077018110335
     *    math.gamma(math.i)  // returns -0.15494982830180973 - 0.49801566811835596i
     *
     * See also:
     *
     *    combinations, factorial, permutations
     *
     * @param {number | Array | Matrix} n   A real or complex number
     * @return {number | Array | Matrix}    The gamma of `n`
     */
    return typed(name$3L, {
      number: gammaNumber,
      Complex: function Complex(n) {
        if (n.im === 0) {
          return this(n.re);
        }

        n = new _Complex(n.re - 1, n.im);
        var x = new _Complex(gammaP[0], 0);

        for (var i = 1; i < gammaP.length; ++i) {
          var real = n.re + i; // x += p[i]/(n+i)

          var den = real * real + n.im * n.im;

          if (den !== 0) {
            x.re += gammaP[i] * real / den;
            x.im += -(gammaP[i] * n.im) / den;
          } else {
            x.re = gammaP[i] < 0 ? -Infinity : Infinity;
          }
        }

        var t = new _Complex(n.re + gammaG + 0.5, n.im);
        var twoPiSqrt = Math.sqrt(2 * Math.PI);
        n.re += 0.5;
        var result = pow(t, n);

        if (result.im === 0) {
          // sqrt(2*PI)*result
          result.re *= twoPiSqrt;
        } else if (result.re === 0) {
          result.im *= twoPiSqrt;
        } else {
          result.re *= twoPiSqrt;
          result.im *= twoPiSqrt;
        }

        var r = Math.exp(-t.re); // exp(-t)

        t.re = r * Math.cos(-t.im);
        t.im = r * Math.sin(-t.im);
        return multiplyScalar(multiplyScalar(result, t), x);
      },
      BigNumber: function BigNumber(n) {
        if (n.isInteger()) {
          return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));
        }

        if (!n.isFinite()) {
          return new _BigNumber(n.isNegative() ? NaN : Infinity);
        }

        throw new Error('Integer BigNumber expected');
      },
      'Array | Matrix': function ArrayMatrix(n) {
        return deepMap(n, this);
      }
    });
    /**
     * Calculate factorial for a BigNumber
     * @param {BigNumber} n
     * @returns {BigNumber} Returns the factorial of n
     */

    function bigFactorial(n) {
      if (n < 8) {
        return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);
      }

      var precision = config.precision + (Math.log(n.toNumber()) | 0);

      var Big = _BigNumber.clone({
        precision: precision
      });

      if (n % 2 === 1) {
        return n.times(bigFactorial(new _BigNumber(n - 1)));
      }

      var p = n;
      var prod = new Big(n);
      var sum = n.toNumber();

      while (p > 2) {
        p -= 2;
        sum += p;
        prod = prod.times(sum);
      }

      return new _BigNumber(prod.toPrecision(_BigNumber.precision));
    }
  });

  var name$3M = 'factorial';
  var dependencies$3N = ['typed', 'gamma'];
  var createFactorial = /* #__PURE__ */factory(name$3M, dependencies$3N, function (_ref) {
    var typed = _ref.typed,
        gamma = _ref.gamma;

    /**
     * Compute the factorial of a value
     *
     * Factorial only supports an integer value as argument.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.factorial(n)
     *
     * Examples:
     *
     *    math.factorial(5)    // returns 120
     *    math.factorial(3)    // returns 6
     *
     * See also:
     *
     *    combinations, combinationsWithRep, gamma, permutations
     *
     * @param {number | BigNumber | Array | Matrix} n   An integer number
     * @return {number | BigNumber | Array | Matrix}    The factorial of `n`
     */
    return typed(name$3M, {
      number: function number(n) {
        if (n < 0) {
          throw new Error('Value must be non-negative');
        }

        return gamma(n + 1);
      },
      BigNumber: function BigNumber(n) {
        if (n.isNegative()) {
          throw new Error('Value must be non-negative');
        }

        return gamma(n.plus(1));
      },
      'Array | Matrix': function ArrayMatrix(n) {
        return deepMap(n, this);
      }
    });
  });

  var name$3N = 'kldivergence';
  var dependencies$3O = ['typed', 'matrix', 'divide', 'sum', 'multiply', 'dotDivide', 'log', 'isNumeric'];
  var createKldivergence = /* #__PURE__ */factory(name$3N, dependencies$3O, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        divide = _ref.divide,
        sum = _ref.sum,
        multiply = _ref.multiply,
        dotDivide = _ref.dotDivide,
        log = _ref.log,
        isNumeric = _ref.isNumeric;

    /**
       * Calculate the Kullback-Leibler (KL) divergence  between two distributions
       *
       * Syntax:
       *
       *     math.kldivergence(x, y)
       *
       * Examples:
       *
       *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])   //returns 0.24376698773121153
       *
       *
       * @param  {Array | Matrix} q    First vector
       * @param  {Array | Matrix} p    Second vector
       * @return {number}              Returns distance between q and p
       */
    return typed(name$3N, {
      'Array, Array': function ArrayArray(q, p) {
        return _kldiv(matrix(q), matrix(p));
      },
      'Matrix, Array': function MatrixArray(q, p) {
        return _kldiv(q, matrix(p));
      },
      'Array, Matrix': function ArrayMatrix(q, p) {
        return _kldiv(matrix(q), p);
      },
      'Matrix, Matrix': function MatrixMatrix(q, p) {
        return _kldiv(q, p);
      }
    });

    function _kldiv(q, p) {
      var plength = p.size().length;
      var qlength = q.size().length;

      if (plength > 1) {
        throw new Error('first object must be one dimensional');
      }

      if (qlength > 1) {
        throw new Error('second object must be one dimensional');
      }

      if (plength !== qlength) {
        throw new Error('Length of two vectors must be equal');
      } // Before calculation, apply normalization


      var sumq = sum(q);

      if (sumq === 0) {
        throw new Error('Sum of elements in first object must be non zero');
      }

      var sump = sum(p);

      if (sump === 0) {
        throw new Error('Sum of elements in second object must be non zero');
      }

      var qnorm = divide(q, sum(q));
      var pnorm = divide(p, sum(p));
      var result = sum(multiply(qnorm, log(dotDivide(qnorm, pnorm))));

      if (isNumeric(result)) {
        return result;
      } else {
        return Number.NaN;
      }
    }
  });

  var name$3O = 'multinomial';
  var dependencies$3P = ['typed', 'add', 'divide', 'multiply', 'factorial', 'isInteger', 'isPositive'];
  var createMultinomial = /* #__PURE__ */factory(name$3O, dependencies$3P, function (_ref) {
    var typed = _ref.typed,
        add = _ref.add,
        divide = _ref.divide,
        multiply = _ref.multiply,
        factorial = _ref.factorial,
        isInteger = _ref.isInteger,
        isPositive = _ref.isPositive;

    /**
     * Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities.
     *
     * multinomial takes one array of integers as an argument.
     * The following condition must be enforced: every ai <= 0
     *
     * Syntax:
     *
     *     math.multinomial(a) // a is an array type
     *
     * Examples:
     *
     *    math.multinomial([1,2,1]) // returns 12
     *
     * See also:
     *
     *    combinations, factorial
     *
     * @param {number[] | BigNumber[]} a    Integer numbers of objects in the subset
     * @return {Number | BigNumber}         Multinomial coefficient.
     */
    return typed(name$3O, {
      'Array | Matrix': function ArrayMatrix(a) {
        var sum = 0;
        var denom = 1;
        deepForEach(a, function (ai) {
          if (!isInteger(ai) || !isPositive(ai)) {
            throw new TypeError('Positive integer value expected in function multinomial');
          }

          sum = add(sum, ai);
          denom = multiply(denom, factorial(ai));
        });
        return divide(factorial(sum), denom);
      }
    });
  });

  var name$3P = 'permutations';
  var dependencies$3Q = ['typed', 'factorial'];
  var createPermutations = /* #__PURE__ */factory(name$3P, dependencies$3Q, function (_ref) {
    var typed = _ref.typed,
        factorial = _ref.factorial;

    /**
     * Compute the number of ways of obtaining an ordered subset of `k` elements
     * from a set of `n` elements.
     *
     * Permutations only takes integer arguments.
     * The following condition must be enforced: k <= n.
     *
     * Syntax:
     *
     *     math.permutations(n)
     *     math.permutations(n, k)
     *
     * Examples:
     *
     *    math.permutations(5)     // 120
     *    math.permutations(5, 3)  // 60
     *
     * See also:
     *
     *    combinations, combinationsWithRep, factorial
     *
     * @param {number | BigNumber} n   The number of objects in total
     * @param {number | BigNumber} [k] The number of objects in the subset
     * @return {number | BigNumber}    The number of permutations
     */
    return typed(name$3P, {
      'number | BigNumber': factorial,
      'number, number': function numberNumber(n, k) {
        if (!isInteger(n) || n < 0) {
          throw new TypeError('Positive integer value expected in function permutations');
        }

        if (!isInteger(k) || k < 0) {
          throw new TypeError('Positive integer value expected in function permutations');
        }

        if (k > n) {
          throw new TypeError('second argument k must be less than or equal to first argument n');
        } // Permute n objects, k at a time


        return product(n - k + 1, n);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(n, k) {
        var result, i;

        if (!isPositiveInteger$2(n) || !isPositiveInteger$2(k)) {
          throw new TypeError('Positive integer value expected in function permutations');
        }

        if (k.gt(n)) {
          throw new TypeError('second argument k must be less than or equal to first argument n');
        }

        var one = n.mul(0).add(1);
        result = one;

        for (i = n.minus(k).plus(1); i.lte(n); i = i.plus(1)) {
          result = result.times(i);
        }

        return result;
      } // TODO: implement support for collection in permutations

    });
  });
  /**
   * Test whether BigNumber n is a positive integer
   * @param {BigNumber} n
   * @returns {boolean} isPositiveInteger
   */

  function isPositiveInteger$2(n) {
    return n.isInteger() && n.gte(0);
  }

  var seedRandom = createCommonjsModule(function (module) {

  var width = 256;// each RC4 output is 0 <= x < 256
  var chunks = 6;// at least six RC4 outputs for each double
  var digits = 52;// there are 52 significant digits in a double
  var pool = [];// pool: entropy pool starts empty
  var GLOBAL = typeof commonjsGlobal === 'undefined' ? window : commonjsGlobal;

  //
  // The following constants are related to IEEE 754 limits.
  //
  var startdenom = Math.pow(width, chunks),
      significance = Math.pow(2, digits),
      overflow = significance * 2,
      mask = width - 1;


  var oldRandom = Math.random;

  //
  // seedrandom()
  // This is the seedrandom function described above.
  //
  module.exports = function(seed, options) {
    if (options && options.global === true) {
      options.global = false;
      Math.random = module.exports(seed, options);
      options.global = true;
      return Math.random;
    }
    var use_entropy = (options && options.entropy) || false;
    var key = [];

    // Flatten the seed string or build one from local entropy if needed.
    var shortseed = mixkey(flatten(
      use_entropy ? [seed, tostring(pool)] :
      0 in arguments ? seed : autoseed(), 3), key);

    // Use the seed to initialize an ARC4 generator.
    var arc4 = new ARC4(key);

    // Mix the randomness into accumulated entropy.
    mixkey(tostring(arc4.S), pool);

    // Override Math.random

    // This function returns a random double in [0, 1) that contains
    // randomness in every bit of the mantissa of the IEEE 754 value.

    return function() {         // Closure to return a random double:
      var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
          d = startdenom,                 //   and denominator d = 2 ^ 48.
          x = 0;                          //   and no 'extra last byte'.
      while (n < significance) {          // Fill up all significant digits by
        n = (n + x) * width;              //   shifting numerator and
        d *= width;                       //   denominator and generating a
        x = arc4.g(1);                    //   new least-significant-byte.
      }
      while (n >= overflow) {             // To avoid rounding up, before adding
        n /= 2;                           //   last byte, shift everything
        d /= 2;                           //   right using integer Math until
        x >>>= 1;                         //   we have exactly the desired bits.
      }
      return (n + x) / d;                 // Form the number within [0, 1).
    };
  };

  module.exports.resetGlobal = function () {
    Math.random = oldRandom;
  };

  //
  // ARC4
  //
  // An ARC4 implementation.  The constructor takes a key in the form of
  // an array of at most (width) integers that should be 0 <= x < (width).
  //
  // The g(count) method returns a pseudorandom integer that concatenates
  // the next (count) outputs from ARC4.  Its return value is a number x
  // that is in the range 0 <= x < (width ^ count).
  //
  /** @constructor */
  function ARC4(key) {
    var t, keylen = key.length,
        me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

    // The empty key [] is treated as [0].
    if (!keylen) { key = [keylen++]; }

    // Set up S using the standard key scheduling algorithm.
    while (i < width) {
      s[i] = i++;
    }
    for (i = 0; i < width; i++) {
      s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
      s[j] = t;
    }

    // The "g" method returns the next (count) outputs as one number.
    (me.g = function(count) {
      // Using instance members instead of closure state nearly doubles speed.
      var t, r = 0,
          i = me.i, j = me.j, s = me.S;
      while (count--) {
        t = s[i = mask & (i + 1)];
        r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
      }
      me.i = i; me.j = j;
      return r;
      // For robust unpredictability discard an initial batch of values.
      // See http://www.rsa.com/rsalabs/node.asp?id=2009
    })(width);
  }

  //
  // flatten()
  // Converts an object tree to nested arrays of strings.
  //
  function flatten(obj, depth) {
    var result = [], typ = (typeof obj)[0], prop;
    if (depth && typ == 'o') {
      for (prop in obj) {
        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
      }
    }
    return (result.length ? result : typ == 's' ? obj : obj + '\0');
  }

  //
  // mixkey()
  // Mixes a string seed into a key that is an array of integers, and
  // returns a shortened string seed that is equivalent to the result key.
  //
  function mixkey(seed, key) {
    var stringseed = seed + '', smear, j = 0;
    while (j < stringseed.length) {
      key[mask & j] =
        mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
    }
    return tostring(key);
  }

  //
  // autoseed()
  // Returns an object for autoseeding, using window.crypto if available.
  //
  /** @param {Uint8Array=} seed */
  function autoseed(seed) {
    try {
      GLOBAL.crypto.getRandomValues(seed = new Uint8Array(width));
      return tostring(seed);
    } catch (e) {
      return [+new Date, GLOBAL, GLOBAL.navigator && GLOBAL.navigator.plugins,
              GLOBAL.screen, tostring(pool)];
    }
  }

  //
  // tostring()
  // Converts an array of charcodes to a string
  //
  function tostring(a) {
    return String.fromCharCode.apply(0, a);
  }

  //
  // When seedrandom.js is loaded, we immediately mix a few bits
  // from the built-in RNG into the entropy pool.  Because we do
  // not want to intefere with determinstic PRNG state later,
  // seedrandom will not call Math.random on its own again after
  // initialization.
  //
  mixkey(Math.random(), pool);
  });
  var seedRandom_1 = seedRandom.resetGlobal;

  // create a random seed here to prevent an infinite loop from seed-random
  var singletonRandom = /* #__PURE__ */seedRandom();
  function createRng(randomSeed) {
    var random; // create a new random generator with given seed

    function setSeed(seed) {
      random = seed === null ? singletonRandom : seedRandom(String(seed));
    } // initialize a seeded pseudo random number generator with config's random seed


    setSeed(randomSeed); // wrapper function so the rng can be updated via generator

    function rng() {
      return random();
    }

    return rng;
  }

  var name$3Q = 'pickRandom';
  var dependencies$3R = ['typed', 'config', '?on'];
  var createPickRandom = /* #__PURE__ */factory(name$3Q, dependencies$3R, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        on = _ref.on;
    // seeded pseudo random number generator
    var rng = createRng(config.randomSeed);

    if (on) {
      on('config', function (curr, prev) {
        if (curr.randomSeed !== prev.randomSeed) {
          rng = createRng(curr.randomSeed);
        }
      });
    }
    /**
     * Random pick one or more values from a one dimensional array.
     * Array elements are picked using a random function with uniform or weighted distribution.
     *
     * Syntax:
     *
     *     math.pickRandom(array)
     *     math.pickRandom(array, number)
     *     math.pickRandom(array, weights)
     *     math.pickRandom(array, number, weights)
     *     math.pickRandom(array, weights, number)
     *
     * Examples:
     *
     *     math.pickRandom([3, 6, 12, 2])                  // returns one of the values in the array
     *     math.pickRandom([3, 6, 12, 2], 2)               // returns an array of two of the values in the array
     *     math.pickRandom([3, 6, 12, 2], [1, 3, 2, 1])    // returns one of the values in the array with weighted distribution
     *     math.pickRandom([3, 6, 12, 2], 2, [1, 3, 2, 1]) // returns an array of two of the values in the array with weighted distribution
     *     math.pickRandom([3, 6, 12, 2], [1, 3, 2, 1], 2) // returns an array of two of the values in the array with weighted distribution
     *
     * See also:
     *
     *     random, randomInt
     *
     * @param {Array | Matrix} array     A one dimensional array
     * @param {Int} number               An int or float
     * @param {Array | Matrix} weights   An array of ints or floats
     * @return {number | Array}          Returns a single random value from array when number is 1 or undefined.
     *                                   Returns an array with the configured number of elements when number is > 1.
     */


    return typed({
      'Array | Matrix': function ArrayMatrix(possibles) {
        return _pickRandom(possibles);
      },
      'Array | Matrix, number': function ArrayMatrixNumber(possibles, number) {
        return _pickRandom(possibles, number, undefined);
      },
      'Array | Matrix, Array': function ArrayMatrixArray(possibles, weights) {
        return _pickRandom(possibles, undefined, weights);
      },
      'Array | Matrix, Array | Matrix, number': function ArrayMatrixArrayMatrixNumber(possibles, weights, number) {
        return _pickRandom(possibles, number, weights);
      },
      'Array | Matrix, number, Array | Matrix': function ArrayMatrixNumberArrayMatrix(possibles, number, weights) {
        return _pickRandom(possibles, number, weights);
      }
    });

    function _pickRandom(possibles, number, weights) {
      var single = typeof number === 'undefined';

      if (single) {
        number = 1;
      }

      possibles = possibles.valueOf(); // get Array

      if (weights) {
        weights = weights.valueOf(); // get Array
      }

      if (arraySize(possibles).length > 1) {
        throw new Error('Only one dimensional vectors supported');
      }

      var totalWeights = 0;

      if (typeof weights !== 'undefined') {
        if (weights.length !== possibles.length) {
          throw new Error('Weights must have the same length as possibles');
        }

        for (var i = 0, len = weights.length; i < len; i++) {
          if (!isNumber(weights[i]) || weights[i] < 0) {
            throw new Error('Weights must be an array of positive numbers');
          }

          totalWeights += weights[i];
        }
      }

      var length = possibles.length;

      if (length === 0) {
        return [];
      } else if (number >= length) {
        return number > 1 ? possibles : possibles[0];
      }

      var result = [];
      var pick;

      while (result.length < number) {
        if (typeof weights === 'undefined') {
          pick = possibles[Math.floor(rng() * length)];
        } else {
          var randKey = rng() * totalWeights;

          for (var _i = 0, _len = possibles.length; _i < _len; _i++) {
            randKey -= weights[_i];

            if (randKey < 0) {
              pick = possibles[_i];
              break;
            }
          }
        }

        if (result.indexOf(pick) === -1) {
          result.push(pick);
        }
      }

      return single ? result[0] : result; // TODO: return matrix when input was a matrix
      // TODO: add support for multi dimensional matrices
    }
  });

  /**
   * This is a util function for generating a random matrix recursively.
   * @param {number[]} size
   * @param {function} random
   * @returns {Array}
   */
  function randomMatrix(size, random) {
    var data = [];
    size = size.slice(0);

    if (size.length > 1) {
      for (var i = 0, length = size.shift(); i < length; i++) {
        data.push(randomMatrix(size, random));
      }
    } else {
      for (var _i = 0, _length = size.shift(); _i < _length; _i++) {
        data.push(random());
      }
    }

    return data;
  }

  var name$3R = 'random';
  var dependencies$3S = ['typed', 'config', '?on'];
  var createRandom = /* #__PURE__ */factory(name$3R, dependencies$3S, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        on = _ref.on;
    // seeded pseudo random number generator
    var rng = createRng(config.randomSeed);

    if (on) {
      on('config', function (curr, prev) {
        if (curr.randomSeed !== prev.randomSeed) {
          rng = createRng(curr.randomSeed);
        }
      });
    }
    /**
     * Return a random number larger or equal to `min` and smaller than `max`
     * using a uniform distribution.
     *
     * Syntax:
     *
     *     math.random()                // generate a random number between 0 and 1
     *     math.random(max)             // generate a random number between 0 and max
     *     math.random(min, max)        // generate a random number between min and max
     *     math.random(size)            // generate a matrix with random numbers between 0 and 1
     *     math.random(size, max)       // generate a matrix with random numbers between 0 and max
     *     math.random(size, min, max)  // generate a matrix with random numbers between min and max
     *
     * Examples:
     *
     *     math.random()       // returns a random number between 0 and 1
     *     math.random(100)    // returns a random number between 0 and 100
     *     math.random(30, 40) // returns a random number between 30 and 40
     *     math.random([2, 3]) // returns a 2x3 matrix with random numbers between 0 and 1
     *
     * See also:
     *
     *     randomInt, pickRandom
     *
     * @param {Array | Matrix} [size] If provided, an array or matrix with given
     *                                size and filled with random values is returned
     * @param {number} [min]  Minimum boundary for the random value, included
     * @param {number} [max]  Maximum boundary for the random value, excluded
     * @return {number | Array | Matrix} A random number
     */


    return typed(name$3R, {
      '': function _() {
        return _random(0, 1);
      },
      number: function number(max) {
        return _random(0, max);
      },
      'number, number': function numberNumber(min, max) {
        return _random(min, max);
      },
      'Array | Matrix': function ArrayMatrix(size) {
        return _randomMatrix(size, 0, 1);
      },
      'Array | Matrix, number': function ArrayMatrixNumber(size, max) {
        return _randomMatrix(size, 0, max);
      },
      'Array | Matrix, number, number': function ArrayMatrixNumberNumber(size, min, max) {
        return _randomMatrix(size, min, max);
      }
    });

    function _randomMatrix(size, min, max) {
      var res = randomMatrix(size.valueOf(), function () {
        return _random(min, max);
      });
      return isMatrix(size) ? size.create(res) : res;
    }

    function _random(min, max) {
      return min + rng() * (max - min);
    }
  }); // number only implementation of random, no matrix support
  // TODO: there is quite some duplicate code in both createRandom and createRandomNumber, can we improve that?

  var createRandomNumber = /* #__PURE__ */factory(name$3R, ['typed', 'config', '?on'], function (_ref2) {
    var typed = _ref2.typed,
        config = _ref2.config,
        on = _ref2.on,
        matrix = _ref2.matrix;
    // seeded pseudo random number generator1
    var rng = createRng(config.randomSeed);

    if (on) {
      on('config', function (curr, prev) {
        if (curr.randomSeed !== prev.randomSeed) {
          rng = createRng(curr.randomSeed);
        }
      });
    }

    return typed(name$3R, {
      '': function _() {
        return _random(0, 1);
      },
      number: function number(max) {
        return _random(0, max);
      },
      'number, number': function numberNumber(min, max) {
        return _random(min, max);
      }
    });

    function _random(min, max) {
      return min + rng() * (max - min);
    }
  });

  var name$3S = 'randomInt';
  var dependencies$3T = ['typed', 'config', '?on'];
  var createRandomInt = /* #__PURE__ */factory(name$3S, dependencies$3T, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        on = _ref.on;
    // seeded pseudo random number generator
    var rng = createRng(config.randomSeed);

    if (on) {
      on('config', function (curr, prev) {
        if (curr.randomSeed !== prev.randomSeed) {
          rng = createRng(curr.randomSeed);
        }
      });
    }
    /**
     * Return a random integer number larger or equal to `min` and smaller than `max`
     * using a uniform distribution.
     *
     * Syntax:
     *
     *     math.randomInt()                // generate a random integer between 0 and 1
     *     math.randomInt(max)             // generate a random integer between 0 and max
     *     math.randomInt(min, max)        // generate a random integer between min and max
     *     math.randomInt(size)            // generate a matrix with random integer between 0 and 1
     *     math.randomInt(size, max)       // generate a matrix with random integer between 0 and max
     *     math.randomInt(size, min, max)  // generate a matrix with random integer between min and max
     *
     * Examples:
     *
     *     math.randomInt(100)    // returns a random integer between 0 and 100
     *     math.randomInt(30, 40) // returns a random integer between 30 and 40
     *     math.randomInt([2, 3]) // returns a 2x3 matrix with random integers between 0 and 1
     *
     * See also:
     *
     *     random, pickRandom
     *
     * @param {Array | Matrix} [size] If provided, an array or matrix with given
     *                                size and filled with random values is returned
     * @param {number} [min]  Minimum boundary for the random value, included
     * @param {number} [max]  Maximum boundary for the random value, excluded
     * @return {number | Array | Matrix} A random integer value
     */


    return typed(name$3S, {
      '': function _() {
        return _randomInt(0, 1);
      },
      number: function number(max) {
        return _randomInt(0, max);
      },
      'number, number': function numberNumber(min, max) {
        return _randomInt(min, max);
      },
      'Array | Matrix': function ArrayMatrix(size) {
        return _randomIntMatrix(size, 0, 1);
      },
      'Array | Matrix, number': function ArrayMatrixNumber(size, max) {
        return _randomIntMatrix(size, 0, max);
      },
      'Array | Matrix, number, number': function ArrayMatrixNumberNumber(size, min, max) {
        return _randomIntMatrix(size, min, max);
      }
    });

    function _randomIntMatrix(size, min, max) {
      var res = randomMatrix(size.valueOf(), function () {
        return _randomInt(min, max);
      });
      return isMatrix(size) ? size.create(res) : res;
    }

    function _randomInt(min, max) {
      return Math.floor(min + rng() * (max - min));
    }
  });

  var name$3T = 'stirlingS2';
  var dependencies$3U = ['typed', 'addScalar', 'subtract', 'multiplyScalar', 'divideScalar', 'pow', 'factorial', 'combinations', 'isNegative', 'isInteger', 'larger'];
  var createStirlingS2 = /* #__PURE__ */factory(name$3T, dependencies$3U, function (_ref) {
    var typed = _ref.typed,
        addScalar = _ref.addScalar,
        subtract = _ref.subtract,
        multiplyScalar = _ref.multiplyScalar,
        divideScalar = _ref.divideScalar,
        pow = _ref.pow,
        factorial = _ref.factorial,
        combinations = _ref.combinations,
        isNegative = _ref.isNegative,
        isInteger = _ref.isInteger,
        larger = _ref.larger;

    /**
     * The Stirling numbers of the second kind, counts the number of ways to partition
     * a set of n labelled objects into k nonempty unlabelled subsets.
     * stirlingS2 only takes integer arguments.
     * The following condition must be enforced: k <= n.
     *
     *  If n = k or k = 1, then s(n,k) = 1
     *
     * Syntax:
     *
     *   math.stirlingS2(n, k)
     *
     * Examples:
     *
     *    math.stirlingS2(5, 3) //returns 25
     *
     * See also:
     *
     *    bellNumbers
     *
     * @param {Number | BigNumber} n    Total number of objects in the set
     * @param {Number | BigNumber} k    Number of objects in the subset
     * @return {Number | BigNumber}     S(n,k)
     */
    return typed(name$3T, {
      'number | BigNumber, number | BigNumber': function numberBigNumberNumberBigNumber(n, k) {
        if (!isInteger(n) || isNegative(n) || !isInteger(k) || isNegative(k)) {
          throw new TypeError('Non-negative integer value expected in function stirlingS2');
        } else if (larger(k, n)) {
          throw new TypeError('k must be less than or equal to n in function stirlingS2');
        } // 1/k! Sum(i=0 -> k) [(-1)^(k-i)*C(k,j)* i^n]


        var kFactorial = factorial(k);
        var result = 0;

        for (var i = 0; i <= k; i++) {
          var negativeOne = pow(-1, subtract(k, i));
          var kChooseI = combinations(k, i);
          var iPower = pow(i, n);
          result = addScalar(result, multiplyScalar(multiplyScalar(kChooseI, iPower), negativeOne));
        }

        return divideScalar(result, kFactorial);
      }
    });
  });

  var name$3U = 'bellNumbers';
  var dependencies$3V = ['typed', 'addScalar', 'isNegative', 'isInteger', 'stirlingS2'];
  var createBellNumbers = /* #__PURE__ */factory(name$3U, dependencies$3V, function (_ref) {
    var typed = _ref.typed,
        addScalar = _ref.addScalar,
        isNegative = _ref.isNegative,
        isInteger = _ref.isInteger,
        stirlingS2 = _ref.stirlingS2;

    /**
     * The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S.
     * bellNumbers only takes integer arguments.
     * The following condition must be enforced: n >= 0
     *
     * Syntax:
     *
     *   math.bellNumbers(n)
     *
     * Examples:
     *
     *    math.bellNumbers(3) // returns 5
     *    math.bellNumbers(8) // returns 4140
     *
     * See also:
     *
     *    stirlingS2
     *
     * @param {Number | BigNumber} n    Total number of objects in the set
     * @return {Number | BigNumber}     B(n)
     */
    return typed(name$3U, {
      'number | BigNumber': function numberBigNumber(n) {
        if (!isInteger(n) || isNegative(n)) {
          throw new TypeError('Non-negative integer value expected in function bellNumbers');
        } // Sum (k=0, n) S(n,k).


        var result = 0;

        for (var i = 0; i <= n; i++) {
          result = addScalar(result, stirlingS2(n, i));
        }

        return result;
      }
    });
  });

  var name$3V = 'catalan';
  var dependencies$3W = ['typed', 'addScalar', 'divideScalar', 'multiplyScalar', 'combinations', 'isNegative', 'isInteger'];
  var createCatalan = /* #__PURE__ */factory(name$3V, dependencies$3W, function (_ref) {
    var typed = _ref.typed,
        addScalar = _ref.addScalar,
        divideScalar = _ref.divideScalar,
        multiplyScalar = _ref.multiplyScalar,
        combinations = _ref.combinations,
        isNegative = _ref.isNegative,
        isInteger = _ref.isInteger;

    /**
     * The Catalan Numbers enumerate combinatorial structures of many different types.
     * catalan only takes integer arguments.
     * The following condition must be enforced: n >= 0
     *
     * Syntax:
     *
     *   math.catalan(n)
     *
     * Examples:
     *
     *    math.catalan(3) // returns 5
     *    math.catalan(8) // returns 1430
     *
     * See also:
     *
     *    bellNumbers
     *
     * @param {Number | BigNumber} n    nth Catalan number
     * @return {Number | BigNumber}     Cn(n)
     */
    return typed(name$3V, {
      'number | BigNumber': function numberBigNumber(n) {
        if (!isInteger(n) || isNegative(n)) {
          throw new TypeError('Non-negative integer value expected in function catalan');
        }

        return divideScalar(combinations(multiplyScalar(n, 2), n), addScalar(n, 1));
      }
    });
  });

  var name$3W = 'composition';
  var dependencies$3X = ['typed', 'addScalar', 'combinations', 'isNegative', 'isPositive', 'isInteger', 'larger'];
  var createComposition = /* #__PURE__ */factory(name$3W, dependencies$3X, function (_ref) {
    var typed = _ref.typed,
        addScalar = _ref.addScalar,
        combinations = _ref.combinations,
        isPositive = _ref.isPositive,
        isNegative = _ref.isNegative,
        isInteger = _ref.isInteger,
        larger = _ref.larger;

    /**
     * The composition counts of n into k parts.
     *
     * composition only takes integer arguments.
     * The following condition must be enforced: k <= n.
     *
     * Syntax:
     *
     *   math.composition(n, k)
     *
     * Examples:
     *
     *    math.composition(5, 3) // returns 6
     *
     * See also:
     *
     *    combinations
     *
     * @param {Number | BigNumber} n    Total number of objects in the set
     * @param {Number | BigNumber} k    Number of objects in the subset
     * @return {Number | BigNumber}     Returns the composition counts of n into k parts.
     */
    return typed(name$3W, {
      'number | BigNumber, number | BigNumber': function numberBigNumberNumberBigNumber(n, k) {
        if (!isInteger(n) || !isPositive(n) || !isInteger(k) || !isPositive(k)) {
          throw new TypeError('Positive integer value expected in function composition');
        } else if (larger(k, n)) {
          throw new TypeError('k must be less than or equal to n in function composition');
        }

        return combinations(addScalar(n, -1), addScalar(k, -1));
      }
    });
  });

  var name$3X = 'simplifyUtil';
  var dependencies$3Y = ['FunctionNode', 'OperatorNode', 'SymbolNode'];
  var createUtil = /* #__PURE__ */factory(name$3X, dependencies$3Y, function (_ref) {
    var FunctionNode = _ref.FunctionNode,
        OperatorNode = _ref.OperatorNode,
        SymbolNode = _ref.SymbolNode;
    // TODO commutative/associative properties rely on the arguments
    // e.g. multiply is not commutative for matrices
    // The properties should be calculated from an argument to simplify, or possibly something in math.config
    // the other option is for typed() to specify a return type so that we can evaluate the type of arguments
    var commutative = {
      add: true,
      multiply: true
    };
    var associative = {
      add: true,
      multiply: true
    };

    function isCommutative(node, context) {
      if (!isOperatorNode(node)) {
        return true;
      }

      var name = node.fn.toString();

      if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'commutative')) {
        return context[name].commutative;
      }

      return commutative[name] || false;
    }

    function isAssociative(node, context) {
      if (!isOperatorNode(node)) {
        return false;
      }

      var name = node.fn.toString();

      if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'associative')) {
        return context[name].associative;
      }

      return associative[name] || false;
    }
    /**
     * Flatten all associative operators in an expression tree.
     * Assumes parentheses have already been removed.
     */


    function flatten(node) {
      if (!node.args || node.args.length === 0) {
        return node;
      }

      node.args = allChildren(node);

      for (var i = 0; i < node.args.length; i++) {
        flatten(node.args[i]);
      }
    }
    /**
     * Get the children of a node as if it has been flattened.
     * TODO implement for FunctionNodes
     */


    function allChildren(node) {
      var op;
      var children = [];

      var findChildren = function findChildren(node) {
        for (var i = 0; i < node.args.length; i++) {
          var child = node.args[i];

          if (isOperatorNode(child) && op === child.op) {
            findChildren(child);
          } else {
            children.push(child);
          }
        }
      };

      if (isAssociative(node)) {
        op = node.op;
        findChildren(node);
        return children;
      } else {
        return node.args;
      }
    }
    /**
     *  Unflatten all flattened operators to a right-heavy binary tree.
     */


    function unflattenr(node) {
      if (!node.args || node.args.length === 0) {
        return;
      }

      var makeNode = createMakeNodeFunction(node);
      var l = node.args.length;

      for (var i = 0; i < l; i++) {
        unflattenr(node.args[i]);
      }

      if (l > 2 && isAssociative(node)) {
        var curnode = node.args.pop();

        while (node.args.length > 0) {
          curnode = makeNode([node.args.pop(), curnode]);
        }

        node.args = curnode.args;
      }
    }
    /**
     *  Unflatten all flattened operators to a left-heavy binary tree.
     */


    function unflattenl(node) {
      if (!node.args || node.args.length === 0) {
        return;
      }

      var makeNode = createMakeNodeFunction(node);
      var l = node.args.length;

      for (var i = 0; i < l; i++) {
        unflattenl(node.args[i]);
      }

      if (l > 2 && isAssociative(node)) {
        var curnode = node.args.shift();

        while (node.args.length > 0) {
          curnode = makeNode([curnode, node.args.shift()]);
        }

        node.args = curnode.args;
      }
    }

    function createMakeNodeFunction(node) {
      if (isOperatorNode(node)) {
        return function (args) {
          try {
            return new OperatorNode(node.op, node.fn, args, node.implicit);
          } catch (err) {
            console.error(err);
            return [];
          }
        };
      } else {
        return function (args) {
          return new FunctionNode(new SymbolNode(node.name), args);
        };
      }
    }

    return {
      createMakeNodeFunction: createMakeNodeFunction,
      isCommutative: isCommutative,
      isAssociative: isAssociative,
      flatten: flatten,
      allChildren: allChildren,
      unflattenr: unflattenr,
      unflattenl: unflattenl
    };
  });

  var name$3Y = 'simplifyCore';
  var dependencies$3Z = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'ParenthesisNode'];
  var createSimplifyCore = /* #__PURE__ */factory(name$3Y, dependencies$3Z, function (_ref) {
    var equal = _ref.equal,
        isZero = _ref.isZero,
        add = _ref.add,
        subtract = _ref.subtract,
        multiply = _ref.multiply,
        divide = _ref.divide,
        pow = _ref.pow,
        ConstantNode = _ref.ConstantNode,
        OperatorNode = _ref.OperatorNode,
        FunctionNode = _ref.FunctionNode,
        ParenthesisNode = _ref.ParenthesisNode;
    var node0 = new ConstantNode(0);
    var node1 = new ConstantNode(1);
    /**
     * simplifyCore() performs single pass simplification suitable for
     * applications requiring ultimate performance. In contrast, simplify()
     * extends simplifyCore() with additional passes to provide deeper
     * simplification.
     *
     * Syntax:
     *
     *     simplify.simplifyCore(expr)
     *
     * Examples:
     *
     *     const f = math.parse('2 * 1 * x ^ (2 - 1)')
     *     math.simplify.simpifyCore(f)                          // Node {2 * x}
     *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplify.simpifyCore]) // Node {2 * x}
     *
     * See also:
     *
     *     derivative
     *
     * @param {Node} node
     *     The expression to be simplified
     */

    function simplifyCore(node) {
      if (isOperatorNode(node) && node.isUnary()) {
        var a0 = simplifyCore(node.args[0]);

        if (node.op === '+') {
          // unary plus
          return a0;
        }

        if (node.op === '-') {
          // unary minus
          if (isOperatorNode(a0)) {
            if (a0.isUnary() && a0.op === '-') {
              return a0.args[0];
            } else if (a0.isBinary() && a0.fn === 'subtract') {
              return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);
            }
          }

          return new OperatorNode(node.op, node.fn, [a0]);
        }
      } else if (isOperatorNode(node) && node.isBinary()) {
        var _a = simplifyCore(node.args[0]);

        var a1 = simplifyCore(node.args[1]);

        if (node.op === '+') {
          if (isConstantNode(_a)) {
            if (isZero(_a.value)) {
              return a1;
            } else if (isConstantNode(a1)) {
              return new ConstantNode(add(_a.value, a1.value));
            }
          }

          if (isConstantNode(a1) && isZero(a1.value)) {
            return _a;
          }

          if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {
            return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);
          }

          return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);
        } else if (node.op === '-') {
          if (isConstantNode(_a) && a1) {
            if (isConstantNode(a1)) {
              return new ConstantNode(subtract(_a.value, a1.value));
            } else if (isZero(_a.value)) {
              return new OperatorNode('-', 'unaryMinus', [a1]);
            }
          } // if (node.fn === "subtract" && node.args.length === 2) {


          if (node.fn === 'subtract') {
            if (isConstantNode(a1) && isZero(a1.value)) {
              return _a;
            }

            if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {
              return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]));
            }

            return new OperatorNode(node.op, node.fn, [_a, a1]);
          }
        } else if (node.op === '*') {
          if (isConstantNode(_a)) {
            if (isZero(_a.value)) {
              return node0;
            } else if (equal(_a.value, 1)) {
              return a1;
            } else if (isConstantNode(a1)) {
              return new ConstantNode(multiply(_a.value, a1.value));
            }
          }

          if (isConstantNode(a1)) {
            if (isZero(a1.value)) {
              return node0;
            } else if (equal(a1.value, 1)) {
              return _a;
            } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op) {
              var a00 = _a.args[0];

              if (isConstantNode(a00)) {
                var a00a1 = new ConstantNode(multiply(a00.value, a1.value));
                return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left
              }
            }

            return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left
          }

          return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);
        } else if (node.op === '/') {
          if (isConstantNode(_a)) {
            if (isZero(_a.value)) {
              return node0;
            } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {
              return new ConstantNode(divide(_a.value, a1.value));
            }
          }

          return new OperatorNode(node.op, node.fn, [_a, a1]);
        } else if (node.op === '^') {
          if (isConstantNode(a1)) {
            if (isZero(a1.value)) {
              return node1;
            } else if (equal(a1.value, 1)) {
              return _a;
            } else {
              if (isConstantNode(_a)) {
                // fold constant
                return new ConstantNode(pow(_a.value, a1.value));
              } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === '^') {
                var a01 = _a.args[1];

                if (isConstantNode(a01)) {
                  return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);
                }
              }
            }
          }

          return new OperatorNode(node.op, node.fn, [_a, a1]);
        }
      } else if (isParenthesisNode(node)) {
        var c = simplifyCore(node.content);

        if (isParenthesisNode(c) || isSymbolNode(c) || isConstantNode(c)) {
          return c;
        }

        return new ParenthesisNode(c);
      } else if (isFunctionNode(node)) {
        var args = node.args.map(simplifyCore).map(function (arg) {
          return isParenthesisNode(arg) ? arg.content : arg;
        });
        return new FunctionNode(simplifyCore(node.fn), args);
      }

      return node;
    }

    return simplifyCore;
  });

  // TODO this could be improved by simplifying seperated constants under associative and commutative operators
  var name$3Z = 'simplifyConstant';
  var dependencies$3_ = ['typed', 'config', 'mathWithTransform', '?fraction', '?bignumber', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'SymbolNode'];
  var createSimplifyConstant = /* #__PURE__ */factory(name$3Z, dependencies$3_, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        mathWithTransform = _ref.mathWithTransform,
        fraction = _ref.fraction,
        bignumber = _ref.bignumber,
        ConstantNode = _ref.ConstantNode,
        OperatorNode = _ref.OperatorNode,
        FunctionNode = _ref.FunctionNode,
        SymbolNode = _ref.SymbolNode;

    var _createUtil = createUtil({
      FunctionNode: FunctionNode,
      OperatorNode: OperatorNode,
      SymbolNode: SymbolNode
    }),
        isCommutative = _createUtil.isCommutative,
        isAssociative = _createUtil.isAssociative,
        allChildren = _createUtil.allChildren,
        createMakeNodeFunction = _createUtil.createMakeNodeFunction;

    function simplifyConstant(expr, options) {
      var res = foldFraction(expr, options);
      return isNode(res) ? res : _toNode(res);
    }

    function _eval(fnname, args, options) {
      try {
        return _toNumber(mathWithTransform[fnname].apply(null, args), options);
      } catch (ignore) {
        // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions
        args = args.map(function (x) {
          if (isFraction(x)) {
            return x.valueOf();
          }

          return x;
        });
        return _toNumber(mathWithTransform[fnname].apply(null, args), options);
      }
    }

    var _toNode = typed({
      Fraction: _fractionToNode,
      number: function number(n) {
        if (n < 0) {
          return unaryMinusNode(new ConstantNode(-n));
        }

        return new ConstantNode(n);
      },
      BigNumber: function BigNumber(n) {
        if (n < 0) {
          return unaryMinusNode(new ConstantNode(-n));
        }

        return new ConstantNode(n); // old parameters: (n.toString(), 'number')
      },
      Complex: function Complex(s) {
        throw new Error('Cannot convert Complex number to Node');
      }
    }); // convert a number to a fraction only if it can be expressed exactly


    function _exactFraction(n, options) {
      var exactFractions = options && options.exactFractions !== false;

      if (exactFractions && isFinite(n) && fraction) {
        var f = fraction(n);

        if (f.valueOf() === n) {
          return f;
        }
      }

      return n;
    } // Convert numbers to a preferred number type in preference order: Fraction, number, Complex
    // BigNumbers are left alone


    var _toNumber = typed({
      'string, Object': function stringObject(s, options) {
        if (config.number === 'BigNumber') {
          if (bignumber === undefined) {
            noBignumber();
          }

          return bignumber(s);
        } else if (config.number === 'Fraction') {
          if (fraction === undefined) {
            noFraction();
          }

          return fraction(s);
        } else {
          var n = parseFloat(s);
          return _exactFraction(n, options);
        }
      },
      'Fraction, Object': function FractionObject(s, options) {
        return s;
      },
      // we don't need options here
      'BigNumber, Object': function BigNumberObject(s, options) {
        return s;
      },
      // we don't need options here
      'number, Object': function numberObject(s, options) {
        return _exactFraction(s, options);
      },
      'Complex, Object': function ComplexObject(s, options) {
        if (s.im !== 0) {
          return s;
        }

        return _exactFraction(s.re, options);
      }
    });

    function unaryMinusNode(n) {
      return new OperatorNode('-', 'unaryMinus', [n]);
    }

    function _fractionToNode(f) {
      var n;
      var vn = f.s * f.n;

      if (vn < 0) {
        n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);
      } else {
        n = new ConstantNode(vn);
      }

      if (f.d === 1) {
        return n;
      }

      return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);
    }
    /*
     * Create a binary tree from a list of Fractions and Nodes.
     * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so
     * `args` should be sorted to have the Fractions at the start (if the operator is commutative).
     * @param args - list of Fractions and Nodes
     * @param fn - evaluator for the binary operation evaluator that accepts two Fractions
     * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes
     * if args.length is 1, returns args[0]
     * @return - Either a Node representing a binary expression or Fraction
     */


    function foldOp(fn, args, makeNode, options) {
      return args.reduce(function (a, b) {
        if (!isNode(a) && !isNode(b)) {
          try {
            return _eval(fn, [a, b], options);
          } catch (ignoreandcontinue) {}

          a = _toNode(a);
          b = _toNode(b);
        } else if (!isNode(a)) {
          a = _toNode(a);
        } else if (!isNode(b)) {
          b = _toNode(b);
        }

        return makeNode([a, b]);
      });
    } // destroys the original node and returns a folded one


    function foldFraction(node, options) {
      switch (node.type) {
        case 'SymbolNode':
          return node;

        case 'ConstantNode':
          if (typeof node.value === 'number' || !isNaN(node.value)) {
            return _toNumber(node.value, options);
          }

          return node;

        case 'FunctionNode':
          if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {
            return node;
          }

          {
            // Process operators as OperatorNode
            var operatorFunctions = ['add', 'multiply'];

            if (operatorFunctions.indexOf(node.name) === -1) {
              var args = node.args.map(function (arg) {
                return foldFraction(arg, options);
              }); // If all args are numbers

              if (!args.some(isNode)) {
                try {
                  return _eval(node.name, args, options);
                } catch (ignoreandcontine) {}
              } // Convert all args to nodes and construct a symbolic function call


              args = args.map(function (arg) {
                return isNode(arg) ? arg : _toNode(arg);
              });
              return new FunctionNode(node.name, args);
            }
          }

        /* falls through */

        case 'OperatorNode':
          {
            var fn = node.fn.toString();

            var _args;

            var res;
            var makeNode = createMakeNodeFunction(node);

            if (isOperatorNode(node) && node.isUnary()) {
              _args = [foldFraction(node.args[0], options)];

              if (!isNode(_args[0])) {
                res = _eval(fn, _args, options);
              } else {
                res = makeNode(_args);
              }
            } else if (isAssociative(node)) {
              _args = allChildren(node);
              _args = _args.map(function (arg) {
                return foldFraction(arg, options);
              });

              if (isCommutative(fn)) {
                // commutative binary operator
                var consts = [];
                var vars = [];

                for (var i = 0; i < _args.length; i++) {
                  if (!isNode(_args[i])) {
                    consts.push(_args[i]);
                  } else {
                    vars.push(_args[i]);
                  }
                }

                if (consts.length > 1) {
                  res = foldOp(fn, consts, makeNode, options);
                  vars.unshift(res);
                  res = foldOp(fn, vars, makeNode, options);
                } else {
                  // we won't change the children order since it's not neccessary
                  res = foldOp(fn, _args, makeNode, options);
                }
              } else {
                // non-commutative binary operator
                res = foldOp(fn, _args, makeNode, options);
              }
            } else {
              // non-associative binary operator
              _args = node.args.map(function (arg) {
                return foldFraction(arg, options);
              });
              res = foldOp(fn, _args, makeNode, options);
            }

            return res;
          }

        case 'ParenthesisNode':
          // remove the uneccessary parenthesis
          return foldFraction(node.content, options);

        case 'AccessorNode':
        /* falls through */

        case 'ArrayNode':
        /* falls through */

        case 'AssignmentNode':
        /* falls through */

        case 'BlockNode':
        /* falls through */

        case 'FunctionAssignmentNode':
        /* falls through */

        case 'IndexNode':
        /* falls through */

        case 'ObjectNode':
        /* falls through */

        case 'RangeNode':
        /* falls through */

        case 'ConditionalNode':
        /* falls through */

        default:
          throw new Error("Unimplemented node type in simplifyConstant: ".concat(node.type));
      }
    }

    return simplifyConstant;
  });

  var name$3_ = 'resolve';
  var dependencies$40 = ['parse', 'FunctionNode', 'OperatorNode', 'ParenthesisNode'];
  var createResolve = /* #__PURE__ */factory(name$3_, dependencies$40, function (_ref) {
    var parse = _ref.parse,
        FunctionNode = _ref.FunctionNode,
        OperatorNode = _ref.OperatorNode,
        ParenthesisNode = _ref.ParenthesisNode;

    /**
     * resolve(expr, scope) replaces variable nodes with their scoped values
     *
     * Syntax:
     *
     *     simplify.resolve(expr, scope)
     *
     * Examples:
     *
     *     math.simplify.resolve('x + y', {x:1, y:2})           // Node {1 + 2}
     *     math.simplify.resolve(math.parse('x+y'), {x:1, y:2}) // Node {1 + 2}
     *     math.simplify('x+y', {x:2, y:'x+x'}).toString()      // "6"
     *
     * @param {Node} node
     *     The expression tree to be simplified
     * @param {Object} scope with variables to be resolved
     */
    function resolve(node, scope) {
      if (!scope) {
        return node;
      }

      if (isSymbolNode(node)) {
        var value = scope[node.name];

        if (isNode(value)) {
          return resolve(value, scope);
        } else if (typeof value === 'number') {
          return parse(String(value));
        }
      } else if (isOperatorNode(node)) {
        var args = node.args.map(function (arg) {
          return resolve(arg, scope);
        });
        return new OperatorNode(node.op, node.fn, args, node.implicit);
      } else if (isParenthesisNode(node)) {
        return new ParenthesisNode(resolve(node.content, scope));
      } else if (isFunctionNode(node)) {
        var _args = node.args.map(function (arg) {
          return resolve(arg, scope);
        });

        return new FunctionNode(node.name, _args);
      }

      return node;
    }

    return resolve;
  });

  function _typeof$c(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$c = function _typeof(obj) { return typeof obj; }; } else { _typeof$c = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$c(obj); }
  var name$40 = 'simplify';
  var dependencies$41 = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', '?fraction', '?bignumber', 'mathWithTransform', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];
  var createSimplify = /* #__PURE__ */factory(name$40, dependencies$41, function (_ref) {
    var config = _ref.config,
        typed = _ref.typed,
        parse = _ref.parse,
        add = _ref.add,
        subtract = _ref.subtract,
        multiply = _ref.multiply,
        divide = _ref.divide,
        pow = _ref.pow,
        isZero = _ref.isZero,
        equal = _ref.equal,
        fraction = _ref.fraction,
        bignumber = _ref.bignumber,
        mathWithTransform = _ref.mathWithTransform,
        ConstantNode = _ref.ConstantNode,
        FunctionNode = _ref.FunctionNode,
        OperatorNode = _ref.OperatorNode,
        ParenthesisNode = _ref.ParenthesisNode,
        SymbolNode = _ref.SymbolNode;
    var simplifyConstant = createSimplifyConstant({
      typed: typed,
      config: config,
      mathWithTransform: mathWithTransform,
      fraction: fraction,
      bignumber: bignumber,
      ConstantNode: ConstantNode,
      OperatorNode: OperatorNode,
      FunctionNode: FunctionNode,
      SymbolNode: SymbolNode
    });
    var simplifyCore = createSimplifyCore({
      equal: equal,
      isZero: isZero,
      add: add,
      subtract: subtract,
      multiply: multiply,
      divide: divide,
      pow: pow,
      ConstantNode: ConstantNode,
      OperatorNode: OperatorNode,
      FunctionNode: FunctionNode,
      ParenthesisNode: ParenthesisNode
    });
    var resolve = createResolve({
      parse: parse,
      FunctionNode: FunctionNode,
      OperatorNode: OperatorNode,
      ParenthesisNode: ParenthesisNode
    });

    var _createUtil = createUtil({
      FunctionNode: FunctionNode,
      OperatorNode: OperatorNode,
      SymbolNode: SymbolNode
    }),
        isCommutative = _createUtil.isCommutative,
        isAssociative = _createUtil.isAssociative,
        flatten = _createUtil.flatten,
        unflattenr = _createUtil.unflattenr,
        unflattenl = _createUtil.unflattenl,
        createMakeNodeFunction = _createUtil.createMakeNodeFunction;
    /**
     * Simplify an expression tree.
     *
     * A list of rules are applied to an expression, repeating over the list until
     * no further changes are made.
     * It's possible to pass a custom set of rules to the function as second
     * argument. A rule can be specified as an object, string, or function:
     *
     *     const rules = [
     *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },
     *       'n1*n3 + n2*n3 -> (n1+n2)*n3',
     *       function (node) {
     *         // ... return a new node or return the node unchanged
     *         return node
     *       }
     *     ]
     *
     * String and object rules consist of a left and right pattern. The left is
     * used to match against the expression and the right determines what matches
     * are replaced with. The main difference between a pattern and a normal
     * expression is that variables starting with the following characters are
     * interpreted as wildcards:
     *
     * - 'n' - matches any Node
     * - 'c' - matches any ConstantNode
     * - 'v' - matches any Node that is not a ConstantNode
     *
     * The default list of rules is exposed on the function as `simplify.rules`
     * and can be used as a basis to built a set of custom rules.
     *
     * For more details on the theory, see:
     *
     * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)
     * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)
     *
     *  An optional `options` argument can be passed as last argument of `simplify`.
     *  There is currently one option available: `exactFractions`, a boolean which
     *  is `true` by default.
     *
     * Syntax:
     *
     *     simplify(expr)
     *     simplify(expr, rules)
     *     simplify(expr, rules)
     *     simplify(expr, rules, scope)
     *     simplify(expr, rules, scope, options)
     *     simplify(expr, scope)
     *     simplify(expr, scope, options)
     *
     * Examples:
     *
     *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node "2 * x"
     *     math.simplify('2 * 3 * x', {x: 4})        // Node "24"
     *     const f = math.parse('2 * 1 * x ^ (2 - 1)')
     *     math.simplify(f)                          // Node "2 * x"
     *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node "x * 2 / 5"
     *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node "0.4 * x"
     *
     * See also:
     *
     *     derivative, parse, evaluate, rationalize
     *
     * @param {Node | string} expr
     *            The expression to be simplified
     * @param {Array<{l:string, r: string} | string | function>} [rules]
     *            Optional list with custom rules
     * @return {Node} Returns the simplified form of `expr`
     */


    var simplify = typed('simplify', {
      string: function string(expr) {
        return this(parse(expr), this.rules, {}, {});
      },
      'string, Object': function stringObject(expr, scope) {
        return this(parse(expr), this.rules, scope, {});
      },
      'string, Object, Object': function stringObjectObject(expr, scope, options) {
        return this(parse(expr), this.rules, scope, options);
      },
      'string, Array': function stringArray(expr, rules) {
        return this(parse(expr), rules, {}, {});
      },
      'string, Array, Object': function stringArrayObject(expr, rules, scope) {
        return this(parse(expr), rules, scope, {});
      },
      'string, Array, Object, Object': function stringArrayObjectObject(expr, rules, scope, options) {
        return this(parse(expr), rules, scope, options);
      },
      'Node, Object': function NodeObject(expr, scope) {
        return this(expr, this.rules, scope, {});
      },
      'Node, Object, Object': function NodeObjectObject(expr, scope, options) {
        return this(expr, this.rules, scope, options);
      },
      Node: function Node(expr) {
        return this(expr, this.rules, {}, {});
      },
      'Node, Array': function NodeArray(expr, rules) {
        return this(expr, rules, {}, {});
      },
      'Node, Array, Object': function NodeArrayObject(expr, rules, scope) {
        return this(expr, rules, scope, {});
      },
      'Node, Array, Object, Object': function NodeArrayObjectObject(expr, rules, scope, options) {
        rules = _buildRules(rules);
        var res = resolve(expr, scope);
        res = removeParens(res);
        var visited = {};
        var str = res.toString({
          parenthesis: 'all'
        });

        while (!visited[str]) {
          visited[str] = true;
          _lastsym = 0; // counter for placeholder symbols

          for (var i = 0; i < rules.length; i++) {
            if (typeof rules[i] === 'function') {
              res = rules[i](res, options);
            } else {
              flatten(res);
              res = applyRule(res, rules[i]);
            }

            unflattenl(res); // using left-heavy binary tree here since custom rule functions may expect it
          }

          str = res.toString({
            parenthesis: 'all'
          });
        }

        return res;
      }
    });
    simplify.simplifyCore = simplifyCore;
    simplify.resolve = resolve;

    function removeParens(node) {
      return node.transform(function (node, path, parent) {
        return isParenthesisNode(node) ? removeParens(node.content) : node;
      });
    } // All constants that are allowed in rules


    var SUPPORTED_CONSTANTS = {
      "true": true,
      "false": true,
      e: true,
      i: true,
      Infinity: true,
      LN2: true,
      LN10: true,
      LOG2E: true,
      LOG10E: true,
      NaN: true,
      phi: true,
      pi: true,
      SQRT1_2: true,
      SQRT2: true,
      tau: true // null: false,
      // undefined: false,
      // version: false,

    }; // Array of strings, used to build the ruleSet.
    // Each l (left side) and r (right side) are parsed by
    // the expression parser into a node tree.
    // Left hand sides are matched to subtrees within the
    // expression to be parsed and replaced with the right
    // hand side.
    // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])
    // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.
    // It is possible to get into an infinite loop with conflicting rules

    simplify.rules = [simplifyCore, // { l: 'n+0', r: 'n' },     // simplifyCore
    // { l: 'n^0', r: '1' },     // simplifyCore
    // { l: '0*n', r: '0' },     // simplifyCore
    // { l: 'n/n', r: '1'},      // simplifyCore
    // { l: 'n^1', r: 'n' },     // simplifyCore
    // { l: '+n1', r:'n1' },     // simplifyCore
    // { l: 'n--n1', r:'n+n1' }, // simplifyCore
    {
      l: 'log(e)',
      r: '1'
    }, // temporary rules
    {
      l: 'n-n1',
      r: 'n+-n1'
    }, // temporarily replace 'subtract' so we can further flatten the 'add' operator
    {
      l: '-(c*v)',
      r: '(-c) * v'
    }, // make non-constant terms positive
    {
      l: '-v',
      r: '(-1) * v'
    }, {
      l: 'n/n1^n2',
      r: 'n*n1^-n2'
    }, // temporarily replace 'divide' so we can further flatten the 'multiply' operator
    {
      l: 'n/n1',
      r: 'n*n1^-1'
    }, // expand nested exponentiation
    {
      l: '(n ^ n1) ^ n2',
      r: 'n ^ (n1 * n2)'
    }, // collect like factors
    {
      l: 'n*n',
      r: 'n^2'
    }, {
      l: 'n * n^n1',
      r: 'n^(n1+1)'
    }, {
      l: 'n^n1 * n^n2',
      r: 'n^(n1+n2)'
    }, // collect like terms
    {
      l: 'n+n',
      r: '2*n'
    }, {
      l: 'n+-n',
      r: '0'
    }, {
      l: 'n1*n2 + n2',
      r: '(n1+1)*n2'
    }, {
      l: 'n1*n3 + n2*n3',
      r: '(n1+n2)*n3'
    }, // remove parenthesis in the case of negating a quantitiy
    {
      l: 'n1 + -1 * (n2 + n3)',
      r: 'n1 + -1 * n2 + -1 * n3'
    }, simplifyConstant, {
      l: '(-n)*n1',
      r: '-(n*n1)'
    }, // make factors positive (and undo 'make non-constant terms positive')
    // ordering of constants
    {
      l: 'c+v',
      r: 'v+c',
      context: {
        add: {
          commutative: false
        }
      }
    }, {
      l: 'v*c',
      r: 'c*v',
      context: {
        multiply: {
          commutative: false
        }
      }
    }, // undo temporary rules
    // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant
    {
      l: 'n+-n1',
      r: 'n-n1'
    }, // undo replace 'subtract'
    {
      l: 'n*(n1^-1)',
      r: 'n/n1'
    }, // undo replace 'divide'
    {
      l: 'n*n1^-n2',
      r: 'n/n1^n2'
    }, {
      l: 'n1^-1',
      r: '1/n1'
    }, {
      l: 'n*(n1/n2)',
      r: '(n*n1)/n2'
    }, // '*' before '/'
    {
      l: 'n-(n1+n2)',
      r: 'n-n1-n2'
    }, // '-' before '+'
    // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },
    // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },
    {
      l: '1*n',
      r: 'n'
    }, // this pattern can be produced by simplifyConstant
    {
      l: 'n1/(n2/n3)',
      r: '(n1*n3)/n2'
    }];
    /**
     * Parse the string array of rules into nodes
     *
     * Example syntax for rules:
     *
     * Position constants to the left in a product:
     * { l: 'n1 * c1', r: 'c1 * n1' }
     * n1 is any Node, and c1 is a ConstantNode.
     *
     * Apply difference of squares formula:
     * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }
     * n1, n2 mean any Node.
     *
     * Short hand notation:
     * 'n1 * c1 -> c1 * n1'
     */

    function _buildRules(rules) {
      // Array of rules to be used to simplify expressions
      var ruleSet = [];

      for (var i = 0; i < rules.length; i++) {
        var rule = rules[i];
        var newRule = void 0;

        var ruleType = _typeof$c(rule);

        switch (ruleType) {
          case 'string':
            {
              var lr = rule.split('->');

              if (lr.length === 2) {
                rule = {
                  l: lr[0],
                  r: lr[1]
                };
              } else {
                throw SyntaxError('Could not parse rule: ' + rule);
              }
            }

          /* falls through */

          case 'object':
            newRule = {
              l: removeParens(parse(rule.l)),
              r: removeParens(parse(rule.r))
            };

            if (rule.context) {
              newRule.evaluate = rule.context;
            }

            if (rule.evaluate) {
              newRule.evaluate = parse(rule.evaluate);
            }

            if (isAssociative(newRule.l)) {
              var makeNode = createMakeNodeFunction(newRule.l);

              var expandsym = _getExpandPlaceholderSymbol();

              newRule.expanded = {};
              newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]); // Push the expandsym into the deepest possible branch.
              // This helps to match the newRule against nodes returned from getSplits() later on.

              flatten(newRule.expanded.l);
              unflattenr(newRule.expanded.l);
              newRule.expanded.r = makeNode([newRule.r, expandsym]);
            }

            break;

          case 'function':
            newRule = rule;
            break;

          default:
            throw TypeError('Unsupported type of rule: ' + ruleType);
        } // console.log('Adding rule: ' + rules[i])
        // console.log(newRule)


        ruleSet.push(newRule);
      }

      return ruleSet;
    }

    var _lastsym = 0;

    function _getExpandPlaceholderSymbol() {
      return new SymbolNode('_p' + _lastsym++);
    }
    /**
     * Returns a simplfied form of node, or the original node if no simplification was possible.
     *
     * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node
     * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.
     */


    var applyRule = typed('applyRule', {
      'Node, Object': function NodeObject(node, rule) {
        // console.log('Entering applyRule(' + node.toString() + ')')
        // Do not clone node unless we find a match
        var res = node; // First replace our child nodes with their simplified versions
        // If a child could not be simplified, the assignments will have
        // no effect since the node is returned unchanged

        if (res instanceof OperatorNode || res instanceof FunctionNode) {
          if (res.args) {
            for (var i = 0; i < res.args.length; i++) {
              res.args[i] = applyRule(res.args[i], rule);
            }
          }
        } else if (res instanceof ParenthesisNode) {
          if (res.content) {
            res.content = applyRule(res.content, rule);
          }
        } // Try to match a rule against this node


        var repl = rule.r;

        var matches = _ruleMatch(rule.l, res)[0]; // If the rule is associative operator, we can try matching it while allowing additional terms.
        // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.


        if (!matches && rule.expanded) {
          repl = rule.expanded.r;
          matches = _ruleMatch(rule.expanded.l, res)[0];
        }

        if (matches) {
          // const before = res.toString({parenthesis: 'all'})
          // Create a new node by cloning the rhs of the matched rule
          // we keep any implicit multiplication state if relevant
          var implicit = res.implicit;
          res = repl.clone();

          if (implicit && 'implicit' in repl) {
            res.implicit = true;
          } // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes


          res = res.transform(function (node) {
            if (node.isSymbolNode && hasOwnProperty(matches.placeholders, node.name)) {
              return matches.placeholders[node.name].clone();
            } else {
              return node;
            }
          }); // const after = res.toString({parenthesis: 'all'})
          // console.log('Simplified ' + before + ' to ' + after)
        }

        return res;
      }
    });
    /**
     * Get (binary) combinations of a flattened binary node
     * e.g. +(node1, node2, node3) -> [
     *        +(node1,  +(node2, node3)),
     *        +(node2,  +(node1, node3)),
     *        +(node3,  +(node1, node2))]
     *
     */

    function getSplits(node, context) {
      var res = [];
      var right, rightArgs;
      var makeNode = createMakeNodeFunction(node);

      if (isCommutative(node, context)) {
        for (var i = 0; i < node.args.length; i++) {
          rightArgs = node.args.slice(0);
          rightArgs.splice(i, 1);
          right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
          res.push(makeNode([node.args[i], right]));
        }
      } else {
        rightArgs = node.args.slice(1);
        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
        res.push(makeNode([node.args[0], right]));
      }

      return res;
    }
    /**
     * Returns the set union of two match-placeholders or null if there is a conflict.
     */


    function mergeMatch(match1, match2) {
      var res = {
        placeholders: {}
      }; // Some matches may not have placeholders; this is OK

      if (!match1.placeholders && !match2.placeholders) {
        return res;
      } else if (!match1.placeholders) {
        return match2;
      } else if (!match2.placeholders) {
        return match1;
      } // Placeholders with the same key must match exactly


      for (var key in match1.placeholders) {
        if (hasOwnProperty(match1.placeholders, key)) {
          res.placeholders[key] = match1.placeholders[key];

          if (hasOwnProperty(match2.placeholders, key)) {
            if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {
              return null;
            }
          }
        }
      }

      for (var _key in match2.placeholders) {
        if (hasOwnProperty(match2.placeholders, _key)) {
          res.placeholders[_key] = match2.placeholders[_key];
        }
      }

      return res;
    }
    /**
     * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.
     * Each list represents matches found in one child of a node.
     */


    function combineChildMatches(list1, list2) {
      var res = [];

      if (list1.length === 0 || list2.length === 0) {
        return res;
      }

      var merged;

      for (var i1 = 0; i1 < list1.length; i1++) {
        for (var i2 = 0; i2 < list2.length; i2++) {
          merged = mergeMatch(list1[i1], list2[i2]);

          if (merged) {
            res.push(merged);
          }
        }
      }

      return res;
    }
    /**
     * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.
     * Each list represents matches found in one child of a node.
     * Returns a list of unique matches.
     */


    function mergeChildMatches(childMatches) {
      if (childMatches.length === 0) {
        return childMatches;
      }

      var sets = childMatches.reduce(combineChildMatches);
      var uniqueSets = [];
      var unique = {};

      for (var i = 0; i < sets.length; i++) {
        var s = JSON.stringify(sets[i]);

        if (!unique[s]) {
          unique[s] = true;
          uniqueSets.push(sets[i]);
        }
      }

      return uniqueSets;
    }
    /**
     * Determines whether node matches rule.
     *
     * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule
     * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node
     * @return {Object} Information about the match, if it exists.
     */


    function _ruleMatch(rule, node, isSplit) {
      //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')
      //    console.log('rule = ' + rule)
      //    console.log('node = ' + node)
      //    console.log('Entering _ruleMatch(' + rule.toString() + ', ' + node.toString() + ')')
      var res = [{
        placeholders: {}
      }];

      if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {
        // If the rule is an OperatorNode or a FunctionNode, then node must match exactly
        if (rule instanceof OperatorNode) {
          if (rule.op !== node.op || rule.fn !== node.fn) {
            return [];
          }
        } else if (rule instanceof FunctionNode) {
          if (rule.name !== node.name) {
            return [];
          }
        } // rule and node match. Search the children of rule and node.


        if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node) || isSplit) {
          // Expect non-associative operators to match exactly
          var childMatches = [];

          for (var i = 0; i < rule.args.length; i++) {
            var childMatch = _ruleMatch(rule.args[i], node.args[i]);

            if (childMatch.length === 0) {
              // Child did not match, so stop searching immediately
              return [];
            } // The child matched, so add the information returned from the child to our result


            childMatches.push(childMatch);
          }

          res = mergeChildMatches(childMatches);
        } else if (node.args.length >= 2 && rule.args.length === 2) {
          // node is flattened, rule is not
          // Associative operators/functions can be split in different ways so we check if the rule matches each
          // them and return their union.
          var splits = getSplits(node, rule.context);
          var splitMatches = [];

          for (var _i = 0; _i < splits.length; _i++) {
            var matchSet = _ruleMatch(rule, splits[_i], true); // recursing at the same tree depth here


            splitMatches = splitMatches.concat(matchSet);
          }

          return splitMatches;
        } else if (rule.args.length > 2) {
          throw Error('Unexpected non-binary associative function: ' + rule.toString());
        } else {
          // Incorrect number of arguments in rule and node, so no match
          return [];
        }
      } else if (rule instanceof SymbolNode) {
        // If the rule is a SymbolNode, then it carries a special meaning
        // according to the first character of the symbol node name.
        // c.* matches a ConstantNode
        // n.* matches any node
        if (rule.name.length === 0) {
          throw new Error('Symbol in rule has 0 length...!?');
        }

        if (SUPPORTED_CONSTANTS[rule.name]) {
          // built-in constant must match exactly
          if (rule.name !== node.name) {
            return [];
          }
        } else if (rule.name[0] === 'n' || rule.name.substring(0, 2) === '_p') {
          // rule matches _anything_, so assign this node to the rule.name placeholder
          // Assign node to the rule.name placeholder.
          // Our parent will check for matches among placeholders.
          res[0].placeholders[rule.name] = node;
        } else if (rule.name[0] === 'v') {
          // rule matches any variable thing (not a ConstantNode)
          if (!isConstantNode(node)) {
            res[0].placeholders[rule.name] = node;
          } else {
            // Mis-match: rule was expecting something other than a ConstantNode
            return [];
          }
        } else if (rule.name[0] === 'c') {
          // rule matches any ConstantNode
          if (node instanceof ConstantNode) {
            res[0].placeholders[rule.name] = node;
          } else {
            // Mis-match: rule was expecting a ConstantNode
            return [];
          }
        } else {
          throw new Error('Invalid symbol in rule: ' + rule.name);
        }
      } else if (rule instanceof ConstantNode) {
        // Literal constant must match exactly
        if (!equal(rule.value, node.value)) {
          return [];
        }
      } else {
        // Some other node was encountered which we aren't prepared for, so no match
        return [];
      } // It's a match!
      // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')


      return res;
    }
    /**
     * Determines whether p and q (and all their children nodes) are identical.
     *
     * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p
     * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q
     * @return {Object} Information about the match, if it exists.
     */


    function _exactMatch(p, q) {
      if (p instanceof ConstantNode && q instanceof ConstantNode) {
        if (!equal(p.value, q.value)) {
          return false;
        }
      } else if (p instanceof SymbolNode && q instanceof SymbolNode) {
        if (p.name !== q.name) {
          return false;
        }
      } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {
        if (p instanceof OperatorNode) {
          if (p.op !== q.op || p.fn !== q.fn) {
            return false;
          }
        } else if (p instanceof FunctionNode) {
          if (p.name !== q.name) {
            return false;
          }
        }

        if (p.args.length !== q.args.length) {
          return false;
        }

        for (var i = 0; i < p.args.length; i++) {
          if (!_exactMatch(p.args[i], q.args[i])) {
            return false;
          }
        }
      } else {
        return false;
      }

      return true;
    }

    return simplify;
  });

  var name$41 = 'derivative';
  var dependencies$42 = ['typed', 'config', 'parse', 'simplify', 'equal', 'isZero', 'numeric', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];
  var createDerivative = /* #__PURE__ */factory(name$41, dependencies$42, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        parse = _ref.parse,
        simplify = _ref.simplify,
        equal = _ref.equal,
        isZero = _ref.isZero,
        numeric = _ref.numeric,
        ConstantNode = _ref.ConstantNode,
        FunctionNode = _ref.FunctionNode,
        OperatorNode = _ref.OperatorNode,
        ParenthesisNode = _ref.ParenthesisNode,
        SymbolNode = _ref.SymbolNode;

    /**
     * Takes the derivative of an expression expressed in parser Nodes.
     * The derivative will be taken over the supplied variable in the
     * second parameter. If there are multiple variables in the expression,
     * it will return a partial derivative.
     *
     * This uses rules of differentiation which can be found here:
     *
     * - [Differentiation rules (Wikipedia)](https://en.wikipedia.org/wiki/Differentiation_rules)
     *
     * Syntax:
     *
     *     derivative(expr, variable)
     *     derivative(expr, variable, options)
     *
     * Examples:
     *
     *     math.derivative('x^2', 'x')                     // Node {2 * x}
     *     math.derivative('x^2', 'x', {simplify: false})  // Node {2 * 1 * x ^ (2 - 1)
     *     math.derivative('sin(2x)', 'x'))                // Node {2 * cos(2 * x)}
     *     math.derivative('2*x', 'x').evaluate()          // number 2
     *     math.derivative('x^2', 'x').evaluate({x: 4})    // number 8
     *     const f = math.parse('x^2')
     *     const x = math.parse('x')
     *     math.derivative(f, x)                           // Node {2 * x}
     *
     * See also:
     *
     *     simplify, parse, evaluate
     *
     * @param  {Node | string} expr           The expression to differentiate
     * @param  {SymbolNode | string} variable The variable over which to differentiate
     * @param  {{simplify: boolean}} [options]
     *                         There is one option available, `simplify`, which
     *                         is true by default. When false, output will not
     *                         be simplified.
     * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`
     */
    var derivative = typed('derivative', {
      'Node, SymbolNode, Object': function NodeSymbolNodeObject(expr, variable, options) {
        var constNodes = {};
        constTag(constNodes, expr, variable.name);

        var res = _derivative(expr, constNodes);

        return options.simplify ? simplify(res) : res;
      },
      'Node, SymbolNode': function NodeSymbolNode(expr, variable) {
        return this(expr, variable, {
          simplify: true
        });
      },
      'string, SymbolNode': function stringSymbolNode(expr, variable) {
        return this(parse(expr), variable);
      },
      'string, SymbolNode, Object': function stringSymbolNodeObject(expr, variable, options) {
        return this(parse(expr), variable, options);
      },
      'string, string': function stringString(expr, variable) {
        return this(parse(expr), parse(variable));
      },
      'string, string, Object': function stringStringObject(expr, variable, options) {
        return this(parse(expr), parse(variable), options);
      },
      'Node, string': function NodeString(expr, variable) {
        return this(expr, parse(variable));
      },
      'Node, string, Object': function NodeStringObject(expr, variable, options) {
        return this(expr, parse(variable), options);
      } // TODO: replace the 8 signatures above with 4 as soon as typed-function supports optional arguments

      /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}
      'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {
        let res = expr
        for (let i = 0; i < order; i++) {
          let constNodes = {}
          constTag(constNodes, expr, variable.name)
          res = _derivative(res, constNodes)
        }
        return res
      }
      */

    });
    derivative._simplify = true;

    derivative.toTex = function (deriv) {
      return _derivTex.apply(null, deriv.args);
    }; // FIXME: move the toTex method of derivative to latex.js. Difficulty is that it relies on parse.
    // NOTE: the optional "order" parameter here is currently unused


    var _derivTex = typed('_derivTex', {
      'Node, SymbolNode': function NodeSymbolNode(expr, x) {
        if (isConstantNode(expr) && typeOf(expr.value) === 'string') {
          return _derivTex(parse(expr.value).toString(), x.toString(), 1);
        } else {
          return _derivTex(expr.toString(), x.toString(), 1);
        }
      },
      'Node, ConstantNode': function NodeConstantNode(expr, x) {
        if (typeOf(x.value) === 'string') {
          return _derivTex(expr, parse(x.value));
        } else {
          throw new Error("The second parameter to 'derivative' is a non-string constant");
        }
      },
      'Node, SymbolNode, ConstantNode': function NodeSymbolNodeConstantNode(expr, x, order) {
        return _derivTex(expr.toString(), x.name, order.value);
      },
      'string, string, number': function stringStringNumber(expr, x, order) {
        var d;

        if (order === 1) {
          d = '{d\\over d' + x + '}';
        } else {
          d = '{d^{' + order + '}\\over d' + x + '^{' + order + '}}';
        }

        return d + "\\left[".concat(expr, "\\right]");
      }
    });
    /**
     * Does a depth-first search on the expression tree to identify what Nodes
     * are constants (e.g. 2 + 2), and stores the ones that are constants in
     * constNodes. Classification is done as follows:
     *
     *   1. ConstantNodes are constants.
     *   2. If there exists a SymbolNode, of which we are differentiating over,
     *      in the subtree it is not constant.
     *
     * @param  {Object} constNodes  Holds the nodes that are constant
     * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node
     * @param  {string} varName     Variable that we are differentiating
     * @return {boolean}  if node is constant
     */
    // TODO: can we rewrite constTag into a pure function?


    var constTag = typed('constTag', {
      'Object, ConstantNode, string': function ObjectConstantNodeString(constNodes, node) {
        constNodes[node] = true;
        return true;
      },
      'Object, SymbolNode, string': function ObjectSymbolNodeString(constNodes, node, varName) {
        // Treat other variables like constants. For reasoning, see:
        //   https://en.wikipedia.org/wiki/Partial_derivative
        if (node.name !== varName) {
          constNodes[node] = true;
          return true;
        }

        return false;
      },
      'Object, ParenthesisNode, string': function ObjectParenthesisNodeString(constNodes, node, varName) {
        return constTag(constNodes, node.content, varName);
      },
      'Object, FunctionAssignmentNode, string': function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {
        if (node.params.indexOf(varName) === -1) {
          constNodes[node] = true;
          return true;
        }

        return constTag(constNodes, node.expr, varName);
      },
      'Object, FunctionNode | OperatorNode, string': function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {
        if (node.args.length > 0) {
          var isConst = constTag(constNodes, node.args[0], varName);

          for (var i = 1; i < node.args.length; ++i) {
            isConst = constTag(constNodes, node.args[i], varName) && isConst;
          }

          if (isConst) {
            constNodes[node] = true;
            return true;
          }
        }

        return false;
      }
    });
    /**
     * Applies differentiation rules.
     *
     * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node
     * @param  {Object} constNodes  Holds the nodes that are constant
     * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`
     */

    var _derivative = typed('_derivative', {
      'ConstantNode, Object': function ConstantNodeObject(node) {
        return createConstantNode(0);
      },
      'SymbolNode, Object': function SymbolNodeObject(node, constNodes) {
        if (constNodes[node] !== undefined) {
          return createConstantNode(0);
        }

        return createConstantNode(1);
      },
      'ParenthesisNode, Object': function ParenthesisNodeObject(node, constNodes) {
        return new ParenthesisNode(_derivative(node.content, constNodes));
      },
      'FunctionAssignmentNode, Object': function FunctionAssignmentNodeObject(node, constNodes) {
        if (constNodes[node] !== undefined) {
          return createConstantNode(0);
        }

        return _derivative(node.expr, constNodes);
      },
      'FunctionNode, Object': function FunctionNodeObject(node, constNodes) {
        if (node.args.length !== 1) {
          funcArgsCheck(node);
        }

        if (constNodes[node] !== undefined) {
          return createConstantNode(0);
        }

        var arg0 = node.args[0];
        var arg1;
        var div = false; // is output a fraction?

        var negative = false; // is output negative?

        var funcDerivative;

        switch (node.name) {
          case 'cbrt':
            // d/dx(cbrt(x)) = 1 / (3x^(2/3))
            div = true;
            funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(3), new OperatorNode('^', 'pow', [arg0, new OperatorNode('/', 'divide', [createConstantNode(2), createConstantNode(3)])])]);
            break;

          case 'sqrt':
          case 'nthRoot':
            // d/dx(sqrt(x)) = 1 / (2*sqrt(x))
            if (node.args.length === 1) {
              div = true;
              funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(2), new FunctionNode('sqrt', [arg0])]);
            } else if (node.args.length === 2) {
              // Rearrange from nthRoot(x, a) -> x^(1/a)
              arg1 = new OperatorNode('/', 'divide', [createConstantNode(1), node.args[1]]); // Is a variable?

              constNodes[arg1] = constNodes[node.args[1]];
              return _derivative(new OperatorNode('^', 'pow', [arg0, arg1]), constNodes);
            }

            break;

          case 'log10':
            arg1 = createConstantNode(10);

          /* fall through! */

          case 'log':
            if (!arg1 && node.args.length === 1) {
              // d/dx(log(x)) = 1 / x
              funcDerivative = arg0.clone();
              div = true;
            } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== undefined) {
              // d/dx(log(x, c)) = 1 / (x*ln(c))
              funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('log', [arg1 || node.args[1]])]);
              div = true;
            } else if (node.args.length === 2) {
              // d/dx(log(f(x), g(x))) = d/dx(log(f(x)) / log(g(x)))
              return _derivative(new OperatorNode('/', 'divide', [new FunctionNode('log', [arg0]), new FunctionNode('log', [node.args[1]])]), constNodes);
            }

            break;

          case 'pow':
            constNodes[arg1] = constNodes[node.args[1]]; // Pass to pow operator node parser

            return _derivative(new OperatorNode('^', 'pow', [arg0, node.args[1]]), constNodes);

          case 'exp':
            // d/dx(e^x) = e^x
            funcDerivative = new FunctionNode('exp', [arg0.clone()]);
            break;

          case 'sin':
            // d/dx(sin(x)) = cos(x)
            funcDerivative = new FunctionNode('cos', [arg0.clone()]);
            break;

          case 'cos':
            // d/dx(cos(x)) = -sin(x)
            funcDerivative = new OperatorNode('-', 'unaryMinus', [new FunctionNode('sin', [arg0.clone()])]);
            break;

          case 'tan':
            // d/dx(tan(x)) = sec(x)^2
            funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sec', [arg0.clone()]), createConstantNode(2)]);
            break;

          case 'sec':
            // d/dx(sec(x)) = sec(x)tan(x)
            funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tan', [arg0.clone()])]);
            break;

          case 'csc':
            // d/dx(csc(x)) = -csc(x)cot(x)
            negative = true;
            funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('cot', [arg0.clone()])]);
            break;

          case 'cot':
            // d/dx(cot(x)) = -csc(x)^2
            negative = true;
            funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csc', [arg0.clone()]), createConstantNode(2)]);
            break;

          case 'asin':
            // d/dx(asin(x)) = 1 / sqrt(1 - x^2)
            div = true;
            funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);
            break;

          case 'acos':
            // d/dx(acos(x)) = -1 / sqrt(1 - x^2)
            div = true;
            negative = true;
            funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);
            break;

          case 'atan':
            // d/dx(atan(x)) = 1 / (x^2 + 1)
            div = true;
            funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);
            break;

          case 'asec':
            // d/dx(asec(x)) = 1 / (|x|*sqrt(x^2 - 1))
            div = true;
            funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);
            break;

          case 'acsc':
            // d/dx(acsc(x)) = -1 / (|x|*sqrt(x^2 - 1))
            div = true;
            negative = true;
            funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);
            break;

          case 'acot':
            // d/dx(acot(x)) = -1 / (x^2 + 1)
            div = true;
            negative = true;
            funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);
            break;

          case 'sinh':
            // d/dx(sinh(x)) = cosh(x)
            funcDerivative = new FunctionNode('cosh', [arg0.clone()]);
            break;

          case 'cosh':
            // d/dx(cosh(x)) = sinh(x)
            funcDerivative = new FunctionNode('sinh', [arg0.clone()]);
            break;

          case 'tanh':
            // d/dx(tanh(x)) = sech(x)^2
            funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sech', [arg0.clone()]), createConstantNode(2)]);
            break;

          case 'sech':
            // d/dx(sech(x)) = -sech(x)tanh(x)
            negative = true;
            funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tanh', [arg0.clone()])]);
            break;

          case 'csch':
            // d/dx(csch(x)) = -csch(x)coth(x)
            negative = true;
            funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('coth', [arg0.clone()])]);
            break;

          case 'coth':
            // d/dx(coth(x)) = -csch(x)^2
            negative = true;
            funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csch', [arg0.clone()]), createConstantNode(2)]);
            break;

          case 'asinh':
            // d/dx(asinh(x)) = 1 / sqrt(x^2 + 1)
            div = true;
            funcDerivative = new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);
            break;

          case 'acosh':
            // d/dx(acosh(x)) = 1 / sqrt(x^2 - 1); XXX potentially only for x >= 1 (the real spectrum)
            div = true;
            funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);
            break;

          case 'atanh':
            // d/dx(atanh(x)) = 1 / (1 - x^2)
            div = true;
            funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);
            break;

          case 'asech':
            // d/dx(asech(x)) = -1 / (x*sqrt(1 - x^2))
            div = true;
            negative = true;
            funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])])]);
            break;

          case 'acsch':
            // d/dx(acsch(x)) = -1 / (|x|*sqrt(x^2 + 1))
            div = true;
            negative = true;
            funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);
            break;

          case 'acoth':
            // d/dx(acoth(x)) = -1 / (1 - x^2)
            div = true;
            negative = true;
            funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);
            break;

          case 'abs':
            // d/dx(abs(x)) = abs(x)/x
            funcDerivative = new OperatorNode('/', 'divide', [new FunctionNode(new SymbolNode('abs'), [arg0.clone()]), arg0.clone()]);
            break;

          case 'gamma': // Needs digamma function, d/dx(gamma(x)) = gamma(x)digamma(x)

          default:
            throw new Error('Function "' + node.name + '" is not supported by derivative, or a wrong number of arguments is passed');
        }

        var op, func;

        if (div) {
          op = '/';
          func = 'divide';
        } else {
          op = '*';
          func = 'multiply';
        }
        /* Apply chain rule to all functions:
           F(x)  = f(g(x))
           F'(x) = g'(x)*f'(g(x)) */


        var chainDerivative = _derivative(arg0, constNodes);

        if (negative) {
          chainDerivative = new OperatorNode('-', 'unaryMinus', [chainDerivative]);
        }

        return new OperatorNode(op, func, [chainDerivative, funcDerivative]);
      },
      'OperatorNode, Object': function OperatorNodeObject(node, constNodes) {
        if (constNodes[node] !== undefined) {
          return createConstantNode(0);
        }

        if (node.op === '+') {
          // d/dx(sum(f(x)) = sum(f'(x))
          return new OperatorNode(node.op, node.fn, node.args.map(function (arg) {
            return _derivative(arg, constNodes);
          }));
        }

        if (node.op === '-') {
          // d/dx(+/-f(x)) = +/-f'(x)
          if (node.isUnary()) {
            return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes)]);
          } // Linearity of differentiation, d/dx(f(x) +/- g(x)) = f'(x) +/- g'(x)


          if (node.isBinary()) {
            return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);
          }
        }

        if (node.op === '*') {
          // d/dx(c*f(x)) = c*f'(x)
          var constantTerms = node.args.filter(function (arg) {
            return constNodes[arg] !== undefined;
          });

          if (constantTerms.length > 0) {
            var nonConstantTerms = node.args.filter(function (arg) {
              return constNodes[arg] === undefined;
            });
            var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode('*', 'multiply', nonConstantTerms);
            var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));
            return new OperatorNode('*', 'multiply', newArgs);
          } // Product Rule, d/dx(f(x)*g(x)) = f'(x)*g(x) + f(x)*g'(x)


          return new OperatorNode('+', 'add', node.args.map(function (argOuter) {
            return new OperatorNode('*', 'multiply', node.args.map(function (argInner) {
              return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();
            }));
          }));
        }

        if (node.op === '/' && node.isBinary()) {
          var arg0 = node.args[0];
          var arg1 = node.args[1]; // d/dx(f(x) / c) = f'(x) / c

          if (constNodes[arg1] !== undefined) {
            return new OperatorNode('/', 'divide', [_derivative(arg0, constNodes), arg1]);
          } // Reciprocal Rule, d/dx(c / f(x)) = -c(f'(x)/f(x)^2)


          if (constNodes[arg0] !== undefined) {
            return new OperatorNode('*', 'multiply', [new OperatorNode('-', 'unaryMinus', [arg0]), new OperatorNode('/', 'divide', [_derivative(arg1, constNodes), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])])]);
          } // Quotient rule, d/dx(f(x) / g(x)) = (f'(x)g(x) - f(x)g'(x)) / g(x)^2


          return new OperatorNode('/', 'divide', [new OperatorNode('-', 'subtract', [new OperatorNode('*', 'multiply', [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode('*', 'multiply', [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])]);
        }

        if (node.op === '^' && node.isBinary()) {
          var _arg = node.args[0];
          var _arg2 = node.args[1];

          if (constNodes[_arg] !== undefined) {
            // If is secretly constant; 0^f(x) = 1 (in JS), 1^f(x) = 1
            if (isConstantNode(_arg) && (isZero(_arg.value) || equal(_arg.value, 1))) {
              return createConstantNode(0);
            } // d/dx(c^f(x)) = c^f(x)*ln(c)*f'(x)


            return new OperatorNode('*', 'multiply', [node, new OperatorNode('*', 'multiply', [new FunctionNode('log', [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);
          }

          if (constNodes[_arg2] !== undefined) {
            if (isConstantNode(_arg2)) {
              // If is secretly constant; f(x)^0 = 1 -> d/dx(1) = 0
              if (isZero(_arg2.value)) {
                return createConstantNode(0);
              } // Ignore exponent; f(x)^1 = f(x)


              if (equal(_arg2.value, 1)) {
                return _derivative(_arg, constNodes);
              }
            } // Elementary Power Rule, d/dx(f(x)^c) = c*f'(x)*f(x)^(c-1)


            var powMinusOne = new OperatorNode('^', 'pow', [_arg.clone(), new OperatorNode('-', 'subtract', [_arg2, createConstantNode(1)])]);
            return new OperatorNode('*', 'multiply', [_arg2.clone(), new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), powMinusOne])]);
          } // Functional Power Rule, d/dx(f^g) = f^g*[f'*(g/f) + g'ln(f)]


          return new OperatorNode('*', 'multiply', [new OperatorNode('^', 'pow', [_arg.clone(), _arg2.clone()]), new OperatorNode('+', 'add', [new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), new OperatorNode('/', 'divide', [_arg2.clone(), _arg.clone()])]), new OperatorNode('*', 'multiply', [_derivative(_arg2, constNodes), new FunctionNode('log', [_arg.clone()])])])]);
        }

        throw new Error('Operator "' + node.op + '" is not supported by derivative, or a wrong number of arguments is passed');
      }
    });
    /**
     * Ensures the number of arguments for a function are correct,
     * and will throw an error otherwise.
     *
     * @param {FunctionNode} node
     */


    function funcArgsCheck(node) {
      // TODO add min, max etc
      if ((node.name === 'log' || node.name === 'nthRoot' || node.name === 'pow') && node.args.length === 2) {
        return;
      } // There should be an incorrect number of arguments if we reach here
      // Change all args to constants to avoid unidentified
      // symbol error when compiling function


      for (var i = 0; i < node.args.length; ++i) {
        node.args[i] = createConstantNode(0);
      }

      node.compile().evaluate();
      throw new Error('Expected TypeError, but none found');
    }
    /**
     * Helper function to create a constant node with a specific type
     * (number, BigNumber, Fraction)
     * @param {number} value
     * @param {string} [valueType]
     * @return {ConstantNode}
     */


    function createConstantNode(value, valueType) {
      return new ConstantNode(numeric(value, valueType || config.number));
    }

    return derivative;
  });

  var name$42 = 'rationalize';
  var dependencies$43 = ['config', 'typed', 'equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'parse', 'simplify', '?bignumber', '?fraction', 'mathWithTransform', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'SymbolNode', 'ParenthesisNode'];
  var createRationalize = /* #__PURE__ */factory(name$42, dependencies$43, function (_ref) {
    var config = _ref.config,
        typed = _ref.typed,
        equal = _ref.equal,
        isZero = _ref.isZero,
        add = _ref.add,
        subtract = _ref.subtract,
        multiply = _ref.multiply,
        divide = _ref.divide,
        pow = _ref.pow,
        parse = _ref.parse,
        simplify = _ref.simplify,
        fraction = _ref.fraction,
        bignumber = _ref.bignumber,
        mathWithTransform = _ref.mathWithTransform,
        ConstantNode = _ref.ConstantNode,
        OperatorNode = _ref.OperatorNode,
        FunctionNode = _ref.FunctionNode,
        SymbolNode = _ref.SymbolNode,
        ParenthesisNode = _ref.ParenthesisNode;
    var simplifyConstant = createSimplifyConstant({
      typed: typed,
      config: config,
      mathWithTransform: mathWithTransform,
      fraction: fraction,
      bignumber: bignumber,
      ConstantNode: ConstantNode,
      OperatorNode: OperatorNode,
      FunctionNode: FunctionNode,
      SymbolNode: SymbolNode
    });
    var simplifyCore = createSimplifyCore({
      equal: equal,
      isZero: isZero,
      add: add,
      subtract: subtract,
      multiply: multiply,
      divide: divide,
      pow: pow,
      ConstantNode: ConstantNode,
      OperatorNode: OperatorNode,
      FunctionNode: FunctionNode,
      ParenthesisNode: ParenthesisNode
    });
    /**
     * Transform a rationalizable expression in a rational fraction.
     * If rational fraction is one variable polynomial then converts
     * the numerator and denominator in canonical form, with decreasing
     * exponents, returning the coefficients of numerator.
     *
     * Syntax:
     *
     *     rationalize(expr)
     *     rationalize(expr, detailed)
     *     rationalize(expr, scope)
     *     rationalize(expr, scope, detailed)
     *
     * Examples:
     *
     *     math.rationalize('sin(x)+y')
     *                   //  Error: There is an unsolved function call
     *     math.rationalize('2x/y - y/(x+1)')
     *                   // (2*x^2-y^2+2*x)/(x*y+y)
     *     math.rationalize('(2x+1)^6')
     *                   // 64*x^6+192*x^5+240*x^4+160*x^3+60*x^2+12*x+1
     *     math.rationalize('2x/( (2x-1) / (3x+2) ) - 5x/ ( (3x+4) / (2x^2-5) ) + 3')
     *                   // -20*x^4+28*x^3+104*x^2+6*x-12)/(6*x^2+5*x-4)
     *     math.rationalize('x/(1-x)/(x-2)/(x-3)/(x-4) + 2x/ ( (1-2x)/(2-3x) )/ ((3-4x)/(4-5x) )') =
     *                   // (-30*x^7+344*x^6-1506*x^5+3200*x^4-3472*x^3+1846*x^2-381*x)/
     *                   //     (-8*x^6+90*x^5-383*x^4+780*x^3-797*x^2+390*x-72)
     *
     *     math.rationalize('x+x+x+y',{y:1}) // 3*x+1
     *     math.rationalize('x+x+x+y',{})    // 3*x+y
     *
     *     const ret = math.rationalize('x+x+x+y',{},true)
     *                   // ret.expression=3*x+y, ret.variables = ["x","y"]
     *     const ret = math.rationalize('-2+5x^2',{},true)
     *                   // ret.expression=5*x^2-2, ret.variables = ["x"], ret.coefficients=[-2,0,5]
     *
     * See also:
     *
     *     simplify
     *
     * @param  {Node|string} expr    The expression to check if is a polynomial expression
     * @param  {Object|boolean}      optional scope of expression or true for already evaluated rational expression at input
     * @param  {Boolean}  detailed   optional True if return an object, false if return expression node (default)
     *
     * @return {Object | Node}    The rational polynomial of `expr` or na object
     *            {Object}
     *              {Expression Node} expression: node simplified expression
     *              {Expression Node} numerator: simplified numerator of expression
     *              {Expression Node | boolean} denominator: simplified denominator or false (if there is no denominator)
     *              {Array}           variables:  variable names
     *              {Array}           coefficients: coefficients of numerator sorted by increased exponent
     *           {Expression Node}  node simplified expression
     *
     */

    return typed(name$42, {
      string: function string(expr) {
        return this(parse(expr), {}, false);
      },
      'string, boolean': function stringBoolean(expr, detailed) {
        return this(parse(expr), {}, detailed);
      },
      'string, Object': function stringObject(expr, scope) {
        return this(parse(expr), scope, false);
      },
      'string, Object, boolean': function stringObjectBoolean(expr, scope, detailed) {
        return this(parse(expr), scope, detailed);
      },
      Node: function Node(expr) {
        return this(expr, {}, false);
      },
      'Node, boolean': function NodeBoolean(expr, detailed) {
        return this(expr, {}, detailed);
      },
      'Node, Object': function NodeObject(expr, scope) {
        return this(expr, scope, false);
      },
      'Node, Object, boolean': function NodeObjectBoolean(expr, scope, detailed) {
        var setRules = rulesRationalize(); // Rules for change polynomial in near canonical form

        var polyRet = polynomial(expr, scope, true, setRules.firstRules); // Check if expression is a rationalizable polynomial

        var nVars = polyRet.variables.length;
        expr = polyRet.expression;

        if (nVars >= 1) {
          // If expression in not a constant
          expr = expandPower(expr); // First expand power of polynomials (cannot be made from rules!)

          var sBefore; // Previous expression

          var rules;
          var eDistrDiv = true;
          var redoInic = false;
          expr = simplify(expr, setRules.firstRules, {}, {
            exactFractions: false
          }); // Apply the initial rules, including succ div rules

          var s;

          while (true) {
            // Apply alternately  successive division rules and distr.div.rules
            rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;
            expr = simplify(expr, rules); // until no more changes

            eDistrDiv = !eDistrDiv; // Swap between Distr.Div and Succ. Div. Rules

            s = expr.toString();

            if (s === sBefore) {
              break; // No changes : end of the loop
            }

            redoInic = true;
            sBefore = s;
          }

          if (redoInic) {
            // Apply first rules again without succ div rules (if there are changes)
            expr = simplify(expr, setRules.firstRulesAgain, {}, {
              exactFractions: false
            });
          }

          expr = simplify(expr, setRules.finalRules, {}, {
            exactFractions: false
          }); // Apply final rules
        } // NVars >= 1


        var coefficients = [];
        var retRationalize = {};

        if (expr.type === 'OperatorNode' && expr.isBinary() && expr.op === '/') {
          // Separate numerator from denominator
          if (nVars === 1) {
            expr.args[0] = polyToCanonical(expr.args[0], coefficients);
            expr.args[1] = polyToCanonical(expr.args[1]);
          }

          if (detailed) {
            retRationalize.numerator = expr.args[0];
            retRationalize.denominator = expr.args[1];
          }
        } else {
          if (nVars === 1) {
            expr = polyToCanonical(expr, coefficients);
          }

          if (detailed) {
            retRationalize.numerator = expr;
            retRationalize.denominator = null;
          }
        } // nVars


        if (!detailed) return expr;
        retRationalize.coefficients = coefficients;
        retRationalize.variables = polyRet.variables;
        retRationalize.expression = expr;
        return retRationalize;
      } // ^^^^^^^ end of rationalize ^^^^^^^^

    }); // end of typed rationalize

    /**
     *  Function to simplify an expression using an optional scope and
     *  return it if the expression is a polynomial expression, i.e.
     *  an expression with one or more variables and the operators
     *  +, -, *, and ^, where the exponent can only be a positive integer.
     *
     * Syntax:
     *
     *     polynomial(expr,scope,extended, rules)
     *
     * @param  {Node | string} expr     The expression to simplify and check if is polynomial expression
     * @param  {object} scope           Optional scope for expression simplification
     * @param  {boolean} extended       Optional. Default is false. When true allows divide operator.
     * @param  {array}  rules           Optional. Default is no rule.
     *
     *
     * @return {Object}
     *            {Object} node:   node simplified expression
     *            {Array}  variables:  variable names
     */

    function polynomial(expr, scope, extended, rules) {
      var variables = [];
      var node = simplify(expr, rules, scope, {
        exactFractions: false
      }); // Resolves any variables and functions with all defined parameters

      extended = !!extended;
      var oper = '+-*' + (extended ? '/' : '');
      recPoly(node);
      var retFunc = {};
      retFunc.expression = node;
      retFunc.variables = variables;
      return retFunc; // -------------------------------------------------------------------------------------------------------

      /**
       *  Function to simplify an expression using an optional scope and
       *  return it if the expression is a polynomial expression, i.e.
       *  an expression with one or more variables and the operators
       *  +, -, *, and ^, where the exponent can only be a positive integer.
       *
       * Syntax:
       *
       *     recPoly(node)
       *
       *
       * @param  {Node} node               The current sub tree expression in recursion
       *
       * @return                           nothing, throw an exception if error
       */

      function recPoly(node) {
        var tp = node.type; // node type

        if (tp === 'FunctionNode') {
          // No function call in polynomial expression
          throw new Error('There is an unsolved function call');
        } else if (tp === 'OperatorNode') {
          if (node.op === '^') {
            // TODO: handle negative exponents like in '1/x^(-2)'
            if (node.args[1].type !== 'ConstantNode' || !isInteger(parseFloat(node.args[1].value))) {
              throw new Error('There is a non-integer exponent');
            } else {
              recPoly(node.args[0]);
            }
          } else {
            if (oper.indexOf(node.op) === -1) {
              throw new Error('Operator ' + node.op + ' invalid in polynomial expression');
            }

            for (var i = 0; i < node.args.length; i++) {
              recPoly(node.args[i]);
            }
          } // type of operator

        } else if (tp === 'SymbolNode') {
          var _name = node.name; // variable name

          var pos = variables.indexOf(_name);

          if (pos === -1) {
            // new variable in expression
            variables.push(_name);
          }
        } else if (tp === 'ParenthesisNode') {
          recPoly(node.content);
        } else if (tp !== 'ConstantNode') {
          throw new Error('type ' + tp + ' is not allowed in polynomial expression');
        }
      } // end of recPoly

    } // end of polynomial
    // ---------------------------------------------------------------------------------------

    /**
     * Return a rule set to rationalize an polynomial expression in rationalize
     *
     * Syntax:
     *
     *     rulesRationalize()
     *
     * @return {array}        rule set to rationalize an polynomial expression
     */


    function rulesRationalize() {
      var oldRules = [simplifyCore, // sCore
      {
        l: 'n+n',
        r: '2*n'
      }, {
        l: 'n+-n',
        r: '0'
      }, simplifyConstant, // sConstant
      {
        l: 'n*(n1^-1)',
        r: 'n/n1'
      }, {
        l: 'n*n1^-n2',
        r: 'n/n1^n2'
      }, {
        l: 'n1^-1',
        r: '1/n1'
      }, {
        l: 'n*(n1/n2)',
        r: '(n*n1)/n2'
      }, {
        l: '1*n',
        r: 'n'
      }];
      var rulesFirst = [{
        l: '(-n1)/(-n2)',
        r: 'n1/n2'
      }, // Unary division
      {
        l: '(-n1)*(-n2)',
        r: 'n1*n2'
      }, // Unary multiplication
      {
        l: 'n1--n2',
        r: 'n1+n2'
      }, // '--' elimination
      {
        l: 'n1-n2',
        r: 'n1+(-n2)'
      }, // Subtraction turn into add with unry minus
      {
        l: '(n1+n2)*n3',
        r: '(n1*n3 + n2*n3)'
      }, // Distributive 1
      {
        l: 'n1*(n2+n3)',
        r: '(n1*n2+n1*n3)'
      }, // Distributive 2
      {
        l: 'c1*n + c2*n',
        r: '(c1+c2)*n'
      }, // Joining constants
      {
        l: 'c1*n + n',
        r: '(c1+1)*n'
      }, // Joining constants
      {
        l: 'c1*n - c2*n',
        r: '(c1-c2)*n'
      }, // Joining constants
      {
        l: 'c1*n - n',
        r: '(c1-1)*n'
      }, // Joining constants
      {
        l: 'v/c',
        r: '(1/c)*v'
      }, // variable/constant (new!)
      {
        l: 'v/-c',
        r: '-(1/c)*v'
      }, // variable/constant (new!)
      {
        l: '-v*-c',
        r: 'c*v'
      }, // Inversion constant and variable 1
      {
        l: '-v*c',
        r: '-c*v'
      }, // Inversion constant and variable 2
      {
        l: 'v*-c',
        r: '-c*v'
      }, // Inversion constant and variable 3
      {
        l: 'v*c',
        r: 'c*v'
      }, // Inversion constant and variable 4
      {
        l: '-(-n1*n2)',
        r: '(n1*n2)'
      }, // Unary propagation
      {
        l: '-(n1*n2)',
        r: '(-n1*n2)'
      }, // Unary propagation
      {
        l: '-(-n1+n2)',
        r: '(n1-n2)'
      }, // Unary propagation
      {
        l: '-(n1+n2)',
        r: '(-n1-n2)'
      }, // Unary propagation
      {
        l: '(n1^n2)^n3',
        r: '(n1^(n2*n3))'
      }, // Power to Power
      {
        l: '-(-n1/n2)',
        r: '(n1/n2)'
      }, // Division and Unary
      {
        l: '-(n1/n2)',
        r: '(-n1/n2)'
      }]; // Divisao and Unary

      var rulesDistrDiv = [{
        l: '(n1/n2 + n3/n4)',
        r: '((n1*n4 + n3*n2)/(n2*n4))'
      }, // Sum of fractions
      {
        l: '(n1/n2 + n3)',
        r: '((n1 + n3*n2)/n2)'
      }, // Sum fraction with number 1
      {
        l: '(n1 + n2/n3)',
        r: '((n1*n3 + n2)/n3)'
      }]; // Sum fraction with number 1

      var rulesSucDiv = [{
        l: '(n1/(n2/n3))',
        r: '((n1*n3)/n2)'
      }, // Division simplification
      {
        l: '(n1/n2/n3)',
        r: '(n1/(n2*n3))'
      }];
      var setRules = {}; // rules set in 4 steps.
      // All rules => infinite loop
      // setRules.allRules =oldRules.concat(rulesFirst,rulesDistrDiv,rulesSucDiv)

      setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv); // First rule set

      setRules.distrDivRules = rulesDistrDiv; // Just distr. div. rules

      setRules.sucDivRules = rulesSucDiv; // Jus succ. div. rules

      setRules.firstRulesAgain = oldRules.concat(rulesFirst); // Last rules set without succ. div.
      // Division simplification
      // Second rule set.
      // There is no aggregate expression with parentesis, but the only variable can be scattered.

      setRules.finalRules = [simplifyCore, // simplify.rules[0]
      {
        l: 'n*-n',
        r: '-n^2'
      }, // Joining multiply with power 1
      {
        l: 'n*n',
        r: 'n^2'
      }, // Joining multiply with power 2
      simplifyConstant, // simplify.rules[14] old 3rd index in oldRules
      {
        l: 'n*-n^n1',
        r: '-n^(n1+1)'
      }, // Joining multiply with power 3
      {
        l: 'n*n^n1',
        r: 'n^(n1+1)'
      }, // Joining multiply with power 4
      {
        l: 'n^n1*-n^n2',
        r: '-n^(n1+n2)'
      }, // Joining multiply with power 5
      {
        l: 'n^n1*n^n2',
        r: 'n^(n1+n2)'
      }, // Joining multiply with power 6
      {
        l: 'n^n1*-n',
        r: '-n^(n1+1)'
      }, // Joining multiply with power 7
      {
        l: 'n^n1*n',
        r: 'n^(n1+1)'
      }, // Joining multiply with power 8
      {
        l: 'n^n1/-n',
        r: '-n^(n1-1)'
      }, // Joining multiply with power 8
      {
        l: 'n^n1/n',
        r: 'n^(n1-1)'
      }, // Joining division with power 1
      {
        l: 'n/-n^n1',
        r: '-n^(1-n1)'
      }, // Joining division with power 2
      {
        l: 'n/n^n1',
        r: 'n^(1-n1)'
      }, // Joining division with power 3
      {
        l: 'n^n1/-n^n2',
        r: 'n^(n1-n2)'
      }, // Joining division with power 4
      {
        l: 'n^n1/n^n2',
        r: 'n^(n1-n2)'
      }, // Joining division with power 5
      {
        l: 'n1+(-n2*n3)',
        r: 'n1-n2*n3'
      }, // Solving useless parenthesis 1
      {
        l: 'v*(-c)',
        r: '-c*v'
      }, // Solving useless unary 2
      {
        l: 'n1+-n2',
        r: 'n1-n2'
      }, // Solving +- together (new!)
      {
        l: 'v*c',
        r: 'c*v'
      }, // inversion constant with variable
      {
        l: '(n1^n2)^n3',
        r: '(n1^(n2*n3))'
      } // Power to Power
      ];
      return setRules;
    } // End rulesRationalize
    // ---------------------------------------------------------------------------------------

    /**
     *  Expand recursively a tree node for handling with expressions with exponents
     *  (it's not for constants, symbols or functions with exponents)
     *  PS: The other parameters are internal for recursion
     *
     * Syntax:
     *
     *     expandPower(node)
     *
     * @param  {Node} node         Current expression node
     * @param  {node} parent       Parent current node inside the recursion
     * @param  (int}               Parent number of chid inside the rercursion
     *
     * @return {node}        node expression with all powers expanded.
     */


    function expandPower(node, parent, indParent) {
      var tp = node.type;
      var internal = arguments.length > 1; // TRUE in internal calls

      if (tp === 'OperatorNode' && node.isBinary()) {
        var does = false;
        var val;

        if (node.op === '^') {
          // First operator: Parenthesis or UnaryMinus
          if ((node.args[0].type === 'ParenthesisNode' || node.args[0].type === 'OperatorNode') && node.args[1].type === 'ConstantNode') {
            // Second operator: Constant
            val = parseFloat(node.args[1].value);
            does = val >= 2 && isInteger(val);
          }
        }

        if (does) {
          // Exponent >= 2
          // Before:
          //            operator A --> Subtree
          // parent pow
          //            constant
          //
          if (val > 2) {
            // Exponent > 2,
            // AFTER:  (exponent > 2)
            //             operator A --> Subtree
            // parent  *
            //                 deep clone (operator A --> Subtree
            //             pow
            //                 constant - 1
            //
            var nEsqTopo = node.args[0];
            var nDirTopo = new OperatorNode('^', 'pow', [node.args[0].cloneDeep(), new ConstantNode(val - 1)]);
            node = new OperatorNode('*', 'multiply', [nEsqTopo, nDirTopo]);
          } else {
            // Expo = 2 - no power
            // AFTER:  (exponent =  2)
            //             operator A --> Subtree
            // parent   oper
            //            deep clone (operator A --> Subtree)
            //
            node = new OperatorNode('*', 'multiply', [node.args[0], node.args[0].cloneDeep()]);
          }

          if (internal) {
            // Change parent references in internal recursive calls
            if (indParent === 'content') {
              parent.content = node;
            } else {
              parent.args[indParent] = node;
            }
          }
        } // does

      } // binary OperatorNode


      if (tp === 'ParenthesisNode') {
        // Recursion
        expandPower(node.content, node, 'content');
      } else if (tp !== 'ConstantNode' && tp !== 'SymbolNode') {
        for (var i = 0; i < node.args.length; i++) {
          expandPower(node.args[i], node, i);
        }
      }

      if (!internal) {
        // return the root node
        return node;
      }
    } // End expandPower
    // ---------------------------------------------------------------------------------------

    /**
     * Auxilary function for rationalize
     * Convert near canonical polynomial in one variable in a canonical polynomial
     * with one term for each exponent in decreasing order
     *
     * Syntax:
     *
     *     polyToCanonical(node [, coefficients])
     *
     * @param  {Node | string} expr       The near canonical polynomial expression to convert in a a canonical polynomial expression
     *
     *        The string or tree expression needs to be at below syntax, with free spaces:
     *         (  (^(-)? | [+-]? )cte (*)? var (^expo)?  | cte )+
     *       Where 'var' is one variable with any valid name
     *             'cte' are real numeric constants with any value. It can be omitted if equal than 1
     *             'expo' are integers greater than 0. It can be omitted if equal than 1.
     *
     * @param  {array}   coefficients             Optional returns coefficients sorted by increased exponent
     *
     *
     * @return {node}        new node tree with one variable polynomial or string error.
     */


    function polyToCanonical(node, coefficients) {
      if (coefficients === undefined) {
        coefficients = [];
      } // coefficients.


      coefficients[0] = 0; // index is the exponent

      var o = {};
      o.cte = 1;
      o.oper = '+'; // fire: mark with * or ^ when finds * or ^ down tree, reset to "" with + and -.
      //       It is used to deduce the exponent: 1 for *, 0 for "".

      o.fire = '';
      var maxExpo = 0; // maximum exponent

      var varname = ''; // variable name

      recurPol(node, null, o);
      maxExpo = coefficients.length - 1;
      var first = true;
      var no;

      for (var i = maxExpo; i >= 0; i--) {
        if (coefficients[i] === 0) continue;
        var n1 = new ConstantNode(first ? coefficients[i] : Math.abs(coefficients[i]));
        var op = coefficients[i] < 0 ? '-' : '+';

        if (i > 0) {
          // Is not a constant without variable
          var n2 = new SymbolNode(varname);

          if (i > 1) {
            var n3 = new ConstantNode(i);
            n2 = new OperatorNode('^', 'pow', [n2, n3]);
          }

          if (coefficients[i] === -1 && first) {
            n1 = new OperatorNode('-', 'unaryMinus', [n2]);
          } else if (Math.abs(coefficients[i]) === 1) {
            n1 = n2;
          } else {
            n1 = new OperatorNode('*', 'multiply', [n1, n2]);
          }
        }

        if (first) {
          no = n1;
        } else if (op === '+') {
          no = new OperatorNode('+', 'add', [no, n1]);
        } else {
          no = new OperatorNode('-', 'subtract', [no, n1]);
        }

        first = false;
      } // for


      if (first) {
        return new ConstantNode(0);
      } else {
        return no;
      }
      /**
       * Recursive auxilary function inside polyToCanonical for
       * converting expression in canonical form
       *
       * Syntax:
       *
       *     recurPol(node, noPai, obj)
       *
       * @param  {Node} node        The current subpolynomial expression
       * @param  {Node | Null}  noPai   The current parent node
       * @param  {object}    obj        Object with many internal flags
       *
       * @return {}                    No return. If error, throws an exception
       */


      function recurPol(node, noPai, o) {
        var tp = node.type;

        if (tp === 'FunctionNode') {
          // ***** FunctionName *****
          // No function call in polynomial expression
          throw new Error('There is an unsolved function call');
        } else if (tp === 'OperatorNode') {
          // ***** OperatorName *****
          if ('+-*^'.indexOf(node.op) === -1) throw new Error('Operator ' + node.op + ' invalid');

          if (noPai !== null) {
            // -(unary),^  : children of *,+,-
            if ((node.fn === 'unaryMinus' || node.fn === 'pow') && noPai.fn !== 'add' && noPai.fn !== 'subtract' && noPai.fn !== 'multiply') {
              throw new Error('Invalid ' + node.op + ' placing');
            } // -,+,* : children of +,-


            if ((node.fn === 'subtract' || node.fn === 'add' || node.fn === 'multiply') && noPai.fn !== 'add' && noPai.fn !== 'subtract') {
              throw new Error('Invalid ' + node.op + ' placing');
            } // -,+ : first child


            if ((node.fn === 'subtract' || node.fn === 'add' || node.fn === 'unaryMinus') && o.noFil !== 0) {
              throw new Error('Invalid ' + node.op + ' placing');
            }
          } // Has parent
          // Firers: ^,*       Old:   ^,&,-(unary): firers


          if (node.op === '^' || node.op === '*') {
            o.fire = node.op;
          }

          for (var _i = 0; _i < node.args.length; _i++) {
            // +,-: reset fire
            if (node.fn === 'unaryMinus') o.oper = '-';

            if (node.op === '+' || node.fn === 'subtract') {
              o.fire = '';
              o.cte = 1; // default if there is no constant

              o.oper = _i === 0 ? '+' : node.op;
            }

            o.noFil = _i; // number of son

            recurPol(node.args[_i], node, o);
          } // for in children

        } else if (tp === 'SymbolNode') {
          // ***** SymbolName *****
          if (node.name !== varname && varname !== '') {
            throw new Error('There is more than one variable');
          }

          varname = node.name;

          if (noPai === null) {
            coefficients[1] = 1;
            return;
          } // ^: Symbol is First child


          if (noPai.op === '^' && o.noFil !== 0) {
            throw new Error('In power the variable should be the first parameter');
          } // *: Symbol is Second child


          if (noPai.op === '*' && o.noFil !== 1) {
            throw new Error('In multiply the variable should be the second parameter');
          } // Symbol: firers '',* => it means there is no exponent above, so it's 1 (cte * var)


          if (o.fire === '' || o.fire === '*') {
            if (maxExpo < 1) coefficients[1] = 0;
            coefficients[1] += o.cte * (o.oper === '+' ? 1 : -1);
            maxExpo = Math.max(1, maxExpo);
          }
        } else if (tp === 'ConstantNode') {
          var valor = parseFloat(node.value);

          if (noPai === null) {
            coefficients[0] = valor;
            return;
          }

          if (noPai.op === '^') {
            // cte: second  child of power
            if (o.noFil !== 1) throw new Error('Constant cannot be powered');

            if (!isInteger(valor) || valor <= 0) {
              throw new Error('Non-integer exponent is not allowed');
            }

            for (var _i2 = maxExpo + 1; _i2 < valor; _i2++) {
              coefficients[_i2] = 0;
            }

            if (valor > maxExpo) coefficients[valor] = 0;
            coefficients[valor] += o.cte * (o.oper === '+' ? 1 : -1);
            maxExpo = Math.max(valor, maxExpo);
            return;
          }

          o.cte = valor; // Cte: firer '' => There is no exponent and no multiplication, so the exponent is 0.

          if (o.fire === '') {
            coefficients[0] += o.cte * (o.oper === '+' ? 1 : -1);
          }
        } else {
          throw new Error('Type ' + tp + ' is not allowed');
        }
      } // End of recurPol

    } // End of polyToCanonical

  });

  var name$43 = 'reviver';
  var dependencies$44 = ['classes'];
  var createReviver = /* #__PURE__ */factory(name$43, dependencies$44, function (_ref) {
    var classes = _ref.classes;

    /**
     * Instantiate mathjs data types from their JSON representation
     * @param {string} key
     * @param {*} value
     * @returns {*} Returns the revived object
     */
    return function reviver(key, value) {
      var constructor = classes[value && value.mathjs];

      if (constructor && typeof constructor.fromJSON === 'function') {
        return constructor.fromJSON(value);
      }

      return value;
    };
  });

  var name$44 = 'replacer';
  var dependencies$45 = [];
  var createReplacer = /* #__PURE__ */factory(name$44, dependencies$45, function () {
    /**
     * Stringify data types into their JSON representation.
     * Most data types can be serialized using their `.toJSON` method,
     * but not all, for example the number `Infinity`. For these cases you have
     * to use the replacer. Example usage:
     *
     *     JSON.stringify([2, Infinity], math.replacer)
     *
     * @param {string} key
     * @param {*} value
     * @returns {*} Returns the replaced object
     */
    return function replacer(key, value) {
      // the numeric values Infinitiy, -Infinity, and NaN cannot be serialized to JSON
      if (typeof value === 'number' && (!isFinite(value) || isNaN(value))) {
        return {
          mathjs: 'number',
          value: String(value)
        };
      }

      return value;
    };
  });

  var version = '7.1.0'; // Note: This file is automatically generated when building math.js.
  // Changes made in this file will be overwritten.

  var createTrue = /* #__PURE__ */factory('true', [], function () {
    return true;
  });
  var createFalse = /* #__PURE__ */factory('false', [], function () {
    return false;
  });
  var createNull = /* #__PURE__ */factory('null', [], function () {
    return null;
  });
  var createInfinity = /* #__PURE__ */recreateFactory('Infinity', ['config', '?BigNumber'], function (_ref) {
    var config = _ref.config,
        BigNumber = _ref.BigNumber;
    return config.number === 'BigNumber' ? new BigNumber(Infinity) : Infinity;
  });
  var createNaN = /* #__PURE__ */recreateFactory('NaN', ['config', '?BigNumber'], function (_ref2) {
    var config = _ref2.config,
        BigNumber = _ref2.BigNumber;
    return config.number === 'BigNumber' ? new BigNumber(NaN) : NaN;
  });
  var createPi = /* #__PURE__ */recreateFactory('pi', ['config', '?BigNumber'], function (_ref3) {
    var config = _ref3.config,
        BigNumber = _ref3.BigNumber;
    return config.number === 'BigNumber' ? createBigNumberPi(BigNumber) : pi;
  });
  var createTau = /* #__PURE__ */recreateFactory('tau', ['config', '?BigNumber'], function (_ref4) {
    var config = _ref4.config,
        BigNumber = _ref4.BigNumber;
    return config.number === 'BigNumber' ? createBigNumberTau(BigNumber) : tau;
  });
  var createE = /* #__PURE__ */recreateFactory('e', ['config', '?BigNumber'], function (_ref5) {
    var config = _ref5.config,
        BigNumber = _ref5.BigNumber;
    return config.number === 'BigNumber' ? createBigNumberE(BigNumber) : e;
  }); // golden ratio, (1+sqrt(5))/2

  var createPhi = /* #__PURE__ */recreateFactory('phi', ['config', '?BigNumber'], function (_ref6) {
    var config = _ref6.config,
        BigNumber = _ref6.BigNumber;
    return config.number === 'BigNumber' ? createBigNumberPhi(BigNumber) : phi;
  });
  var createLN2 = /* #__PURE__ */recreateFactory('LN2', ['config', '?BigNumber'], function (_ref7) {
    var config = _ref7.config,
        BigNumber = _ref7.BigNumber;
    return config.number === 'BigNumber' ? new BigNumber(2).ln() : Math.LN2;
  });
  var createLN10 = /* #__PURE__ */recreateFactory('LN10', ['config', '?BigNumber'], function (_ref8) {
    var config = _ref8.config,
        BigNumber = _ref8.BigNumber;
    return config.number === 'BigNumber' ? new BigNumber(10).ln() : Math.LN10;
  });
  var createLOG2E = /* #__PURE__ */recreateFactory('LOG2E', ['config', '?BigNumber'], function (_ref9) {
    var config = _ref9.config,
        BigNumber = _ref9.BigNumber;
    return config.number === 'BigNumber' ? new BigNumber(1).div(new BigNumber(2).ln()) : Math.LOG2E;
  });
  var createLOG10E = /* #__PURE__ */recreateFactory('LOG10E', ['config', '?BigNumber'], function (_ref10) {
    var config = _ref10.config,
        BigNumber = _ref10.BigNumber;
    return config.number === 'BigNumber' ? new BigNumber(1).div(new BigNumber(10).ln()) : Math.LOG10E;
  });
  var createSQRT1_2 = /* #__PURE__ */recreateFactory( // eslint-disable-line camelcase
  'SQRT1_2', ['config', '?BigNumber'], function (_ref11) {
    var config = _ref11.config,
        BigNumber = _ref11.BigNumber;
    return config.number === 'BigNumber' ? new BigNumber('0.5').sqrt() : Math.SQRT1_2;
  });
  var createSQRT2 = /* #__PURE__ */recreateFactory('SQRT2', ['config', '?BigNumber'], function (_ref12) {
    var config = _ref12.config,
        BigNumber = _ref12.BigNumber;
    return config.number === 'BigNumber' ? new BigNumber(2).sqrt() : Math.SQRT2;
  });
  var createI = /* #__PURE__ */recreateFactory('i', ['Complex'], function (_ref13) {
    var Complex = _ref13.Complex;
    return Complex.I;
  }); // for backward compatibility with v5

  var createUppercasePi = /* #__PURE__ */factory('PI', ['pi'], function (_ref14) {
    var pi$$1 = _ref14.pi;
    return pi$$1;
  });
  var createUppercaseE = /* #__PURE__ */factory('E', ['e'], function (_ref15) {
    var e$$1 = _ref15.e;
    return e$$1;
  });
  var createVersion = /* #__PURE__ */factory('version', [], function () {
    return version;
  }); // helper function to create a factory with a flag recreateOnConfigChange
  // idea: allow passing optional properties to be attached to the factory function as 4th argument?

  function recreateFactory(name, dependencies, create$$1) {
    return factory(name, dependencies, create$$1, {
      recreateOnConfigChange: true
    });
  }

  // Universal constants

  var createSpeedOfLight = /* #__PURE__ */unitFactory('speedOfLight', '299792458', 'm s^-1');
  var createGravitationConstant = /* #__PURE__ */unitFactory('gravitationConstant', '6.67430e-11', 'm^3 kg^-1 s^-2');
  var createPlanckConstant = /* #__PURE__ */unitFactory('planckConstant', '6.62607015e-34', 'J s');
  var createReducedPlanckConstant = /* #__PURE__ */unitFactory('reducedPlanckConstant', '1.0545718176461565e-34', 'J s'); // Electromagnetic constants

  var createMagneticConstant = /* #__PURE__ */unitFactory('magneticConstant', '1.25663706212e-6', 'N A^-2');
  var createElectricConstant = /* #__PURE__ */unitFactory('electricConstant', '8.8541878128e-12', 'F m^-1');
  var createVacuumImpedance = /* #__PURE__ */unitFactory('vacuumImpedance', '376.730313667', 'ohm');
  var createCoulomb = /* #__PURE__ */unitFactory('coulomb', '8.987551792261171e9', 'N m^2 C^-2');
  var createElementaryCharge = /* #__PURE__ */unitFactory('elementaryCharge', '1.602176634e-19', 'C');
  var createBohrMagneton = /* #__PURE__ */unitFactory('bohrMagneton', '9.2740100783e-24', 'J T^-1');
  var createConductanceQuantum = /* #__PURE__ */unitFactory('conductanceQuantum', '7.748091729863649e-5', 'S');
  var createInverseConductanceQuantum = /* #__PURE__ */unitFactory('inverseConductanceQuantum', '12906.403729652257', 'ohm');
  var createMagneticFluxQuantum = /* #__PURE__ */unitFactory('magneticFluxQuantum', '2.0678338484619295e-15', 'Wb');
  var createNuclearMagneton = /* #__PURE__ */unitFactory('nuclearMagneton', '5.0507837461e-27', 'J T^-1');
  var createKlitzing = /* #__PURE__ */unitFactory('klitzing', '25812.807459304513', 'ohm');
  var createJosephson = /* #__PURE__ */unitFactory('josephson', '4.835978484169836e14 Hz V', 'Hz V^-1'); // TODO: support for Hz needed
  // Atomic and nuclear constants

  var createBohrRadius = /* #__PURE__ */unitFactory('bohrRadius', '5.29177210903e-11', 'm');
  var createClassicalElectronRadius = /* #__PURE__ */unitFactory('classicalElectronRadius', '2.8179403262e-15', 'm');
  var createElectronMass = /* #__PURE__ */unitFactory('electronMass', '9.1093837015e-31', 'kg');
  var createFermiCoupling = /* #__PURE__ */unitFactory('fermiCoupling', '1.1663787e-5', 'GeV^-2');
  var createFineStructure = numberFactory('fineStructure', 7.2973525693e-3);
  var createHartreeEnergy = /* #__PURE__ */unitFactory('hartreeEnergy', '4.3597447222071e-18', 'J');
  var createProtonMass = /* #__PURE__ */unitFactory('protonMass', '1.67262192369e-27', 'kg');
  var createDeuteronMass = /* #__PURE__ */unitFactory('deuteronMass', '3.3435830926e-27', 'kg');
  var createNeutronMass = /* #__PURE__ */unitFactory('neutronMass', '1.6749271613e-27', 'kg');
  var createQuantumOfCirculation = /* #__PURE__ */unitFactory('quantumOfCirculation', '3.6369475516e-4', 'm^2 s^-1');
  var createRydberg = /* #__PURE__ */unitFactory('rydberg', '10973731.568160', 'm^-1');
  var createThomsonCrossSection = /* #__PURE__ */unitFactory('thomsonCrossSection', '6.6524587321e-29', 'm^2');
  var createWeakMixingAngle = numberFactory('weakMixingAngle', 0.22290);
  var createEfimovFactor = numberFactory('efimovFactor', 22.7); // Physico-chemical constants

  var createAtomicMass = /* #__PURE__ */unitFactory('atomicMass', '1.66053906660e-27', 'kg');
  var createAvogadro = /* #__PURE__ */unitFactory('avogadro', '6.02214076e23', 'mol^-1');
  var createBoltzmann = /* #__PURE__ */unitFactory('boltzmann', '1.380649e-23', 'J K^-1');
  var createFaraday = /* #__PURE__ */unitFactory('faraday', '96485.33212331001', 'C mol^-1');
  var createFirstRadiation = /* #__PURE__ */unitFactory('firstRadiation', '3.7417718521927573e-16', 'W m^2'); // export const createSpectralRadiance = /* #__PURE__ */ unitFactory('spectralRadiance', '1.1910429723971881e-16', 'W m^2 sr^-1') // TODO spectralRadiance

  var createLoschmidt = /* #__PURE__ */unitFactory('loschmidt', '2.686780111798444e25', 'm^-3');
  var createGasConstant = /* #__PURE__ */unitFactory('gasConstant', '8.31446261815324', 'J K^-1 mol^-1');
  var createMolarPlanckConstant = /* #__PURE__ */unitFactory('molarPlanckConstant', '3.990312712893431e-10', 'J s mol^-1');
  var createMolarVolume = /* #__PURE__ */unitFactory('molarVolume', '0.022413969545014137', 'm^3 mol^-1');
  var createSackurTetrode = numberFactory('sackurTetrode', -1.16487052358);
  var createSecondRadiation = /* #__PURE__ */unitFactory('secondRadiation', '0.014387768775039337', 'm K');
  var createStefanBoltzmann = /* #__PURE__ */unitFactory('stefanBoltzmann', '5.67037441918443e-8', 'W m^-2 K^-4');
  var createWienDisplacement = /* #__PURE__ */unitFactory('wienDisplacement', '2.897771955e-3', 'm K'); // Adopted values

  var createMolarMass = /* #__PURE__ */unitFactory('molarMass', '0.99999999965e-3', 'kg mol^-1');
  var createMolarMassC12 = /* #__PURE__ */unitFactory('molarMassC12', '11.9999999958e-3', 'kg mol^-1');
  var createGravity = /* #__PURE__ */unitFactory('gravity', '9.80665', 'm s^-2'); // atm is defined in Unit.js
  // Natural units

  var createPlanckLength = /* #__PURE__ */unitFactory('planckLength', '1.616255e-35', 'm');
  var createPlanckMass = /* #__PURE__ */unitFactory('planckMass', '2.176435e-8', 'kg');
  var createPlanckTime = /* #__PURE__ */unitFactory('planckTime', '5.391245e-44', 's');
  var createPlanckCharge = /* #__PURE__ */unitFactory('planckCharge', '1.87554603778e-18', 'C');
  var createPlanckTemperature = /* #__PURE__ */unitFactory('planckTemperature', '1.416785e+32', 'K'); // helper function to create a factory function which creates a physical constant,
  // a Unit with either a number value or a BigNumber value depending on the configuration

  function unitFactory(name, valueStr, unitStr) {
    var dependencies = ['config', 'Unit', 'BigNumber'];
    return factory(name, dependencies, function (_ref) {
      var config = _ref.config,
          Unit = _ref.Unit,
          BigNumber = _ref.BigNumber;
      // Note that we can parse into number or BigNumber.
      // We do not parse into Fractions as that doesn't make sense: we would lose precision of the values
      // Therefore we dont use Unit.parse()
      var value = config.number === 'BigNumber' ? new BigNumber(valueStr) : parseFloat(valueStr);
      var unit = new Unit(value, unitStr);
      unit.fixPrefix = true;
      return unit;
    });
  } // helper function to create a factory function which creates a numeric constant,
  // either a number or BigNumber depending on the configuration


  function numberFactory(name, value) {
    var dependencies = ['config', 'BigNumber'];
    return factory(name, dependencies, function (_ref2) {
      var config = _ref2.config,
          BigNumber = _ref2.BigNumber;
      return config.number === 'BigNumber' ? new BigNumber(value) : value;
    });
  }

  var name$45 = 'apply';
  var dependencies$46 = ['typed', 'isInteger'];
  /**
   * Attach a transform function to math.apply
   * Adds a property transform containing the transform function.
   *
   * This transform changed the last `dim` parameter of function apply
   * from one-based to zero based
   */

  var createApplyTransform = /* #__PURE__ */factory(name$45, dependencies$46, function (_ref) {
    var typed = _ref.typed,
        isInteger = _ref.isInteger;
    var apply = createApply({
      typed: typed,
      isInteger: isInteger
    }); // @see: comment of concat itself

    return typed('apply', {
      '...any': function any(args) {
        // change dim from one-based to zero-based
        var dim = args[1];

        if (isNumber(dim)) {
          args[1] = dim - 1;
        } else if (isBigNumber(dim)) {
          args[1] = dim.minus(1);
        }

        try {
          return apply.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  var name$46 = 'column';
  var dependencies$47 = ['typed', 'Index', 'matrix', 'range'];
  /**
   * Attach a transform function to matrix.column
   * Adds a property transform containing the transform function.
   *
   * This transform changed the last `index` parameter of function column
   * from zero-based to one-based
   */

  var createColumnTransform = /* #__PURE__ */factory(name$46, dependencies$47, function (_ref) {
    var typed = _ref.typed,
        Index = _ref.Index,
        matrix = _ref.matrix,
        range = _ref.range;
    var column = createColumn({
      typed: typed,
      Index: Index,
      matrix: matrix,
      range: range
    }); // @see: comment of column itself

    return typed('column', {
      '...any': function any(args) {
        // change last argument from zero-based to one-based
        var lastIndex = args.length - 1;
        var last = args[lastIndex];

        if (isNumber(last)) {
          args[lastIndex] = last - 1;
        }

        try {
          return column.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  /**
   * Compile an inline expression like "x > 0"
   * @param {Node} expression
   * @param {Object} math
   * @param {Object} scope
   * @return {function} Returns a function with one argument which fills in the
   *                    undefined variable (like "x") and evaluates the expression
   */

  function compileInlineExpression(expression, math, scope) {
    // find an undefined symbol
    var symbol = expression.filter(function (node) {
      return isSymbolNode(node) && !(node.name in math) && !(node.name in scope);
    })[0];

    if (!symbol) {
      throw new Error('No undefined variable found in inline expression "' + expression + '"');
    } // create a test function for this equation


    var name = symbol.name; // variable name

    var subScope = Object.create(scope);
    var eq = expression.compile();
    return function inlineExpression(x) {
      subScope[name] = x;
      return eq.evaluate(subScope);
    };
  }

  var name$47 = 'filter';
  var dependencies$48 = ['typed'];
  var createFilterTransform = /* #__PURE__ */factory(name$47, dependencies$48, function (_ref) {
    var typed = _ref.typed;

    /**
     * Attach a transform function to math.filter
     * Adds a property transform containing the transform function.
     *
     * This transform adds support for equations as test function for math.filter,
     * so you can do something like 'filter([3, -2, 5], x > 0)'.
     */
    function filterTransform(args, math, scope) {
      var x, callback;

      if (args[0]) {
        x = args[0].compile().evaluate(scope);
      }

      if (args[1]) {
        if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
          // a function pointer, like filter([3, -2, 5], myTestFunction)
          callback = args[1].compile().evaluate(scope);
        } else {
          // an expression like filter([3, -2, 5], x > 0)
          callback = compileInlineExpression(args[1], math, scope);
        }
      }

      return filter$$1(x, callback);
    }

    filterTransform.rawArgs = true; // one based version of function filter

    var filter$$1 = typed('filter', {
      'Array, function': _filter,
      'Matrix, function': function MatrixFunction(x, test) {
        return x.create(_filter(x.toArray(), test));
      },
      'Array, RegExp': filterRegExp,
      'Matrix, RegExp': function MatrixRegExp(x, test) {
        return x.create(filterRegExp(x.toArray(), test));
      }
    });
    return filterTransform;
  }, {
    isTransformFunction: true
  });
  /**
   * Filter values in a callback given a callback function
   *
   * !!! Passes a one-based index !!!
   *
   * @param {Array} x
   * @param {Function} callback
   * @return {Array} Returns the filtered array
   * @private
   */

  function _filter(x, callback) {
    // figure out what number of arguments the callback function expects
    var args = maxArgumentCount(callback);
    return filter(x, function (value, index, array) {
      // invoke the callback function with the right number of arguments
      if (args === 1) {
        return callback(value);
      } else if (args === 2) {
        return callback(value, [index + 1]);
      } else {
        // 3 or -1
        return callback(value, [index + 1], array);
      }
    });
  }

  var name$48 = 'forEach';
  var dependencies$49 = ['typed'];
  var createForEachTransform = /* #__PURE__ */factory(name$48, dependencies$49, function (_ref) {
    var typed = _ref.typed;

    /**
     * Attach a transform function to math.forEach
     * Adds a property transform containing the transform function.
     *
     * This transform creates a one-based index instead of a zero-based index
     */
    function forEachTransform(args, math, scope) {
      var x, callback;

      if (args[0]) {
        x = args[0].compile().evaluate(scope);
      }

      if (args[1]) {
        if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
          // a function pointer, like forEach([3, -2, 5], myTestFunction)
          callback = args[1].compile().evaluate(scope);
        } else {
          // an expression like forEach([3, -2, 5], x > 0 ? callback1(x) : callback2(x) )
          callback = compileInlineExpression(args[1], math, scope);
        }
      }

      return _forEach(x, callback);
    }

    forEachTransform.rawArgs = true; // one-based version of forEach

    var _forEach = typed('forEach', {
      'Array | Matrix, function': function ArrayMatrixFunction(array, callback) {
        // figure out what number of arguments the callback function expects
        var args = maxArgumentCount(callback);

        var recurse = function recurse(value, index) {
          if (Array.isArray(value)) {
            forEach(value, function (child, i) {
              // we create a copy of the index array and append the new index value
              recurse(child, index.concat(i + 1)); // one based index, hence i+1
            });
          } else {
            // invoke the callback function with the right number of arguments
            if (args === 1) {
              callback(value);
            } else if (args === 2) {
              callback(value, index);
            } else {
              // 3 or -1
              callback(value, index, array);
            }
          }
        };

        recurse(array.valueOf(), []); // pass Array
      }
    });

    return forEachTransform;
  }, {
    isTransformFunction: true
  });

  var name$49 = 'index';
  var dependencies$4a = ['Index'];
  var createIndexTransform = /* #__PURE__ */factory(name$49, dependencies$4a, function (_ref) {
    var Index = _ref.Index;

    /**
     * Attach a transform function to math.index
     * Adds a property transform containing the transform function.
     *
     * This transform creates a one-based index instead of a zero-based index
     */
    return function indexTransform() {
      var args = [];

      for (var i = 0, ii = arguments.length; i < ii; i++) {
        var arg = arguments[i]; // change from one-based to zero based, and convert BigNumber to number

        if (isRange(arg)) {
          arg.start--;
          arg.end -= arg.step > 0 ? 0 : 2;
        } else if (arg && arg.isSet === true) {
          arg = arg.map(function (v) {
            return v - 1;
          });
        } else if (isArray(arg) || isMatrix(arg)) {
          arg = arg.map(function (v) {
            return v - 1;
          });
        } else if (isNumber(arg)) {
          arg--;
        } else if (isBigNumber(arg)) {
          arg = arg.toNumber() - 1;
        } else if (typeof arg === 'string') ; else {
          throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
        }

        args[i] = arg;
      }

      var res = new Index();
      Index.apply(res, args);
      return res;
    };
  }, {
    isTransformFunction: true
  });

  var name$4a = 'map';
  var dependencies$4b = ['typed'];
  var createMapTransform = /* #__PURE__ */factory(name$4a, dependencies$4b, function (_ref) {
    var typed = _ref.typed;

    /**
     * Attach a transform function to math.map
     * Adds a property transform containing the transform function.
     *
     * This transform creates a one-based index instead of a zero-based index
     */
    function mapTransform(args, math, scope) {
      var x, callback;

      if (args[0]) {
        x = args[0].compile().evaluate(scope);
      }

      if (args[1]) {
        if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
          // a function pointer, like filter([3, -2, 5], myTestFunction)
          callback = args[1].compile().evaluate(scope);
        } else {
          // an expression like filter([3, -2, 5], x > 0)
          callback = compileInlineExpression(args[1], math, scope);
        }
      }

      return map$$1(x, callback);
    }

    mapTransform.rawArgs = true; // one-based version of map function

    var map$$1 = typed('map', {
      'Array, function': function ArrayFunction(x, callback) {
        return _map$1(x, callback, x);
      },
      'Matrix, function': function MatrixFunction(x, callback) {
        return x.create(_map$1(x.valueOf(), callback, x));
      }
    });
    return mapTransform;
  }, {
    isTransformFunction: true
  });
  /**
   * Map for a multi dimensional array. One-based indexes
   * @param {Array} array
   * @param {function} callback
   * @param {Array} orig
   * @return {Array}
   * @private
   */

  function _map$1(array, callback, orig) {
    // figure out what number of arguments the callback function expects
    var argsCount = maxArgumentCount(callback);

    function recurse(value, index) {
      if (Array.isArray(value)) {
        return map(value, function (child, i) {
          // we create a copy of the index array and append the new index value
          return recurse(child, index.concat(i + 1)); // one based index, hence i + 1
        });
      } else {
        // invoke the (typed) callback function with the right number of arguments
        if (argsCount === 1) {
          return callback(value);
        } else if (argsCount === 2) {
          return callback(value, index);
        } else {
          // 3 or -1
          return callback(value, index, orig);
        }
      }
    }

    return recurse(array, []);
  }

  var name$4b = 'max';
  var dependencies$4c = ['typed', 'config', 'numeric', 'larger'];
  var createMaxTransform = /* #__PURE__ */factory(name$4b, dependencies$4c, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        numeric = _ref.numeric,
        larger = _ref.larger;
    var max = createMax({
      typed: typed,
      config: config,
      numeric: numeric,
      larger: larger
    });
    /**
     * Attach a transform function to math.max
     * Adds a property transform containing the transform function.
     *
     * This transform changed the last `dim` parameter of function max
     * from one-based to zero based
     */

    return typed('max', {
      '...any': function any(args) {
        // change last argument dim from one-based to zero-based
        if (args.length === 2 && isCollection(args[0])) {
          var dim = args[1];

          if (isNumber(dim)) {
            args[1] = dim - 1;
          } else if (isBigNumber(dim)) {
            args[1] = dim.minus(1);
          }
        }

        try {
          return max.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  var name$4c = 'mean';
  var dependencies$4d = ['typed', 'add', 'divide'];
  var createMeanTransform = /* #__PURE__ */factory(name$4c, dependencies$4d, function (_ref) {
    var typed = _ref.typed,
        add = _ref.add,
        divide = _ref.divide;
    var mean = createMean({
      typed: typed,
      add: add,
      divide: divide
    });
    /**
     * Attach a transform function to math.mean
     * Adds a property transform containing the transform function.
     *
     * This transform changed the last `dim` parameter of function mean
     * from one-based to zero based
     */

    return typed('mean', {
      '...any': function any(args) {
        // change last argument dim from one-based to zero-based
        if (args.length === 2 && isCollection(args[0])) {
          var dim = args[1];

          if (isNumber(dim)) {
            args[1] = dim - 1;
          } else if (isBigNumber(dim)) {
            args[1] = dim.minus(1);
          }
        }

        try {
          return mean.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  var name$4d = 'min';
  var dependencies$4e = ['typed', 'config', 'numeric', 'smaller'];
  var createMinTransform = /* #__PURE__ */factory(name$4d, dependencies$4e, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        numeric = _ref.numeric,
        smaller = _ref.smaller;
    var min = createMin({
      typed: typed,
      config: config,
      numeric: numeric,
      smaller: smaller
    });
    /**
     * Attach a transform function to math.min
     * Adds a property transform containing the transform function.
     *
     * This transform changed the last `dim` parameter of function min
     * from one-based to zero based
     */

    return typed('min', {
      '...any': function any(args) {
        // change last argument dim from one-based to zero-based
        if (args.length === 2 && isCollection(args[0])) {
          var dim = args[1];

          if (isNumber(dim)) {
            args[1] = dim - 1;
          } else if (isBigNumber(dim)) {
            args[1] = dim.minus(1);
          }
        }

        try {
          return min.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  var name$4e = 'range';
  var dependencies$4f = ['typed', 'config', '?matrix', '?bignumber', 'smaller', 'smallerEq', 'larger', 'largerEq'];
  var createRangeTransform = /* #__PURE__ */factory(name$4e, dependencies$4f, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        matrix = _ref.matrix,
        bignumber = _ref.bignumber,
        smaller = _ref.smaller,
        smallerEq = _ref.smallerEq,
        larger = _ref.larger,
        largerEq = _ref.largerEq;
    var range = createRange({
      typed: typed,
      config: config,
      matrix: matrix,
      bignumber: bignumber,
      smaller: smaller,
      smallerEq: smallerEq,
      larger: larger,
      largerEq: largerEq
    });
    /**
     * Attach a transform function to math.range
     * Adds a property transform containing the transform function.
     *
     * This transform creates a range which includes the end value
     */

    return typed('range', {
      '...any': function any(args) {
        var lastIndex = args.length - 1;
        var last = args[lastIndex];

        if (typeof last !== 'boolean') {
          // append a parameter includeEnd=true
          args.push(true);
        }

        return range.apply(null, args);
      }
    });
  }, {
    isTransformFunction: true
  });

  var name$4f = 'row';
  var dependencies$4g = ['typed', 'Index', 'matrix', 'range'];
  /**
   * Attach a transform function to matrix.column
   * Adds a property transform containing the transform function.
   *
   * This transform changed the last `index` parameter of function column
   * from zero-based to one-based
   */

  var createRowTransform = /* #__PURE__ */factory(name$4f, dependencies$4g, function (_ref) {
    var typed = _ref.typed,
        Index = _ref.Index,
        matrix = _ref.matrix,
        range = _ref.range;
    var row = createRow({
      typed: typed,
      Index: Index,
      matrix: matrix,
      range: range
    }); // @see: comment of row itself

    return typed('row', {
      '...any': function any(args) {
        // change last argument from zero-based to one-based
        var lastIndex = args.length - 1;
        var last = args[lastIndex];

        if (isNumber(last)) {
          args[lastIndex] = last - 1;
        }

        try {
          return row.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  var name$4g = 'subset';
  var dependencies$4h = ['typed', 'matrix'];
  var createSubsetTransform = /* #__PURE__ */factory(name$4g, dependencies$4h, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix;
    var subset = createSubset({
      typed: typed,
      matrix: matrix
    });
    /**
     * Attach a transform function to math.subset
     * Adds a property transform containing the transform function.
     *
     * This transform creates a range which includes the end value
     */

    return typed('subset', {
      '...any': function any(args) {
        try {
          return subset.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  var name$4h = 'concat';
  var dependencies$4i = ['typed', 'matrix', 'isInteger'];
  var createConcatTransform = /* #__PURE__ */factory(name$4h, dependencies$4i, function (_ref) {
    var typed = _ref.typed,
        matrix = _ref.matrix,
        isInteger = _ref.isInteger;
    var concat = createConcat({
      typed: typed,
      matrix: matrix,
      isInteger: isInteger
    });
    /**
     * Attach a transform function to math.range
     * Adds a property transform containing the transform function.
     *
     * This transform changed the last `dim` parameter of function concat
     * from one-based to zero based
     */

    return typed('concat', {
      '...any': function any(args) {
        // change last argument from one-based to zero-based
        var lastIndex = args.length - 1;
        var last = args[lastIndex];

        if (isNumber(last)) {
          args[lastIndex] = last - 1;
        } else if (isBigNumber(last)) {
          args[lastIndex] = last.minus(1);
        }

        try {
          return concat.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  var name$4i = 'std';
  var dependencies$4j = ['typed', 'sqrt', 'variance'];
  /**
   * Attach a transform function to math.std
   * Adds a property transform containing the transform function.
   *
   * This transform changed the `dim` parameter of function std
   * from one-based to zero based
   */

  var createStdTransform = /* #__PURE__ */factory(name$4i, dependencies$4j, function (_ref) {
    var typed = _ref.typed,
        sqrt = _ref.sqrt,
        variance = _ref.variance;
    var std = createStd({
      typed: typed,
      sqrt: sqrt,
      variance: variance
    });
    return typed('std', {
      '...any': function any(args) {
        // change last argument dim from one-based to zero-based
        if (args.length >= 2 && isCollection(args[0])) {
          var dim = args[1];

          if (isNumber(dim)) {
            args[1] = dim - 1;
          } else if (isBigNumber(dim)) {
            args[1] = dim.minus(1);
          }
        }

        try {
          return std.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  /**
   * Attach a transform function to math.sum
   * Adds a property transform containing the transform function.
   *
   * This transform changed the last `dim` parameter of function mean
   * from one-based to zero based
   */

  var name$4j = 'sum';
  var dependencies$4k = ['typed', 'config', 'add', 'numeric'];
  var createSumTransform = /* #__PURE__ */factory(name$4j, dependencies$4k, function (_ref) {
    var typed = _ref.typed,
        config = _ref.config,
        add = _ref.add,
        numeric = _ref.numeric;
    var sum = createSum({
      typed: typed,
      config: config,
      add: add,
      numeric: numeric
    });
    return typed(name$4j, {
      '...any': function any(args) {
        // change last argument dim from one-based to zero-based
        if (args.length === 2 && isCollection(args[0])) {
          var dim = args[1];

          if (isNumber(dim)) {
            args[1] = dim - 1;
          } else if (isBigNumber(dim)) {
            args[1] = dim.minus(1);
          }
        }

        try {
          return sum.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  var name$4k = 'variance';
  var dependencies$4l = ['typed', 'add', 'subtract', 'multiply', 'divide', 'apply', 'isNaN'];
  /**
   * Attach a transform function to math.var
   * Adds a property transform containing the transform function.
   *
   * This transform changed the `dim` parameter of function var
   * from one-based to zero based
   */

  var createVarianceTransform = /* #__PURE__ */factory(name$4k, dependencies$4l, function (_ref) {
    var typed = _ref.typed,
        add = _ref.add,
        subtract = _ref.subtract,
        multiply = _ref.multiply,
        divide = _ref.divide,
        apply = _ref.apply,
        isNaN = _ref.isNaN;
    var variance = createVariance({
      typed: typed,
      add: add,
      subtract: subtract,
      multiply: multiply,
      divide: divide,
      apply: apply,
      isNaN: isNaN
    });
    return typed(name$4k, {
      '...any': function any(args) {
        // change last argument dim from one-based to zero-based
        if (args.length >= 2 && isCollection(args[0])) {
          var dim = args[1];

          if (isNumber(dim)) {
            args[1] = dim - 1;
          } else if (isBigNumber(dim)) {
            args[1] = dim.minus(1);
          }
        }

        try {
          return variance.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */
  var ResultSet = /* #__PURE__ */createResultSet({});
  var Complex$1 = /* #__PURE__ */createComplexClass({});
  var Range = /* #__PURE__ */createRangeClass({});
  var _false = /* #__PURE__ */createFalse({});
  var _null = /* #__PURE__ */createNull({});
  var _true = /* #__PURE__ */createTrue({});
  var BigNumber = /* #__PURE__ */createBigNumberClass({
    config: config
  });
  var Matrix = /* #__PURE__ */createMatrixClass({});
  var replacer = /* #__PURE__ */createReplacer({});
  var i = /* #__PURE__ */createI({
    Complex: Complex$1
  });
  var LN10 = /* #__PURE__ */createLN10({
    BigNumber: BigNumber,
    config: config
  });
  var LOG10E = /* #__PURE__ */createLOG10E({
    BigNumber: BigNumber,
    config: config
  });
  var _NaN = /* #__PURE__ */createNaN({
    BigNumber: BigNumber,
    config: config
  });
  var pi$1 = /* #__PURE__ */createPi({
    BigNumber: BigNumber,
    config: config
  });
  var SQRT1_2 = /* #__PURE__ */createSQRT1_2({
    BigNumber: BigNumber,
    config: config
  });
  var tau$1 = /* #__PURE__ */createTau({
    BigNumber: BigNumber,
    config: config
  });
  var efimovFactor = /* #__PURE__ */createEfimovFactor({
    BigNumber: BigNumber,
    config: config
  });
  var fineStructure = /* #__PURE__ */createFineStructure({
    BigNumber: BigNumber,
    config: config
  });
  var sackurTetrode = /* #__PURE__ */createSackurTetrode({
    BigNumber: BigNumber,
    config: config
  });
  var weakMixingAngle = /* #__PURE__ */createWeakMixingAngle({
    BigNumber: BigNumber,
    config: config
  });
  var Fraction$1 = /* #__PURE__ */createFractionClass({});
  var e$1 = /* #__PURE__ */createE({
    BigNumber: BigNumber,
    config: config
  });
  var _Infinity = /* #__PURE__ */createInfinity({
    BigNumber: BigNumber,
    config: config
  });
  var LOG2E = /* #__PURE__ */createLOG2E({
    BigNumber: BigNumber,
    config: config
  });
  var version$1 = /* #__PURE__ */createVersion({});
  var DenseMatrix = /* #__PURE__ */createDenseMatrixClass({
    Matrix: Matrix
  });
  var phi$1 = /* #__PURE__ */createPhi({
    BigNumber: BigNumber,
    config: config
  });
  var typed = /* #__PURE__ */createTyped({
    BigNumber: BigNumber,
    Complex: Complex$1,
    DenseMatrix: DenseMatrix,
    Fraction: Fraction$1
  });
  var isInteger$1 = /* #__PURE__ */createIsInteger({
    typed: typed
  });
  var isNumeric = /* #__PURE__ */createIsNumeric({
    typed: typed
  });
  var isPositive = /* #__PURE__ */createIsPositive({
    typed: typed
  });
  var isNaN$1 = /* #__PURE__ */createIsNaN({
    typed: typed
  });
  var equalScalar = /* #__PURE__ */createEqualScalar({
    config: config,
    typed: typed
  });
  var number = /* #__PURE__ */createNumber({
    typed: typed
  });

  var _boolean = /* #__PURE__ */createBoolean({
    typed: typed
  });
  var complex$1 = /* #__PURE__ */createComplex({
    Complex: Complex$1,
    typed: typed
  });
  var splitUnit = /* #__PURE__ */createSplitUnit({
    typed: typed
  });
  var unaryPlus = /* #__PURE__ */createUnaryPlus({
    BigNumber: BigNumber,
    config: config,
    typed: typed
  });
  var apply = /* #__PURE__ */createApply({
    isInteger: isInteger$1,
    typed: typed
  });
  var cube = /* #__PURE__ */createCube({
    typed: typed
  });
  var expm1$1 = /* #__PURE__ */createExpm1({
    Complex: Complex$1,
    typed: typed
  });
  var log10$1 = /* #__PURE__ */createLog10({
    Complex: Complex$1,
    config: config,
    typed: typed
  });
  var multiplyScalar = /* #__PURE__ */createMultiplyScalar({
    typed: typed
  });
  var sign$1 = /* #__PURE__ */createSign({
    BigNumber: BigNumber,
    Fraction: Fraction$1,
    complex: complex$1,
    typed: typed
  });
  var square = /* #__PURE__ */createSquare({
    typed: typed
  });
  var bitNot = /* #__PURE__ */createBitNot({
    typed: typed
  });
  var arg = /* #__PURE__ */createArg({
    typed: typed
  });
  var im = /* #__PURE__ */createIm({
    typed: typed
  });
  var not = /* #__PURE__ */createNot({
    typed: typed
  });
  var filter$1 = /* #__PURE__ */createFilter({
    typed: typed
  });
  var forEach$1 = /* #__PURE__ */createForEach({
    typed: typed
  });
  var map$1 = /* #__PURE__ */createMap({
    typed: typed
  });
  var erf = /* #__PURE__ */createErf({
    typed: typed
  });
  var format$3 = /* #__PURE__ */createFormat({
    typed: typed
  });
  var isPrime = /* #__PURE__ */createIsPrime({
    typed: typed
  });
  var acos = /* #__PURE__ */createAcos({
    Complex: Complex$1,
    config: config,
    typed: typed
  });
  var acot = /* #__PURE__ */createAcot({
    BigNumber: BigNumber,
    typed: typed
  });
  var acsc = /* #__PURE__ */createAcsc({
    BigNumber: BigNumber,
    Complex: Complex$1,
    config: config,
    typed: typed
  });
  var asec = /* #__PURE__ */createAsec({
    BigNumber: BigNumber,
    Complex: Complex$1,
    config: config,
    typed: typed
  });
  var asin = /* #__PURE__ */createAsin({
    Complex: Complex$1,
    config: config,
    typed: typed
  });
  var atan = /* #__PURE__ */createAtan({
    typed: typed
  });
  var atanh$1 = /* #__PURE__ */createAtanh({
    Complex: Complex$1,
    config: config,
    typed: typed
  });
  var cosh$1 = /* #__PURE__ */createCosh({
    typed: typed
  });
  var coth = /* #__PURE__ */createCoth({
    BigNumber: BigNumber,
    typed: typed
  });
  var csch = /* #__PURE__ */createCsch({
    BigNumber: BigNumber,
    typed: typed
  });
  var sech = /* #__PURE__ */createSech({
    BigNumber: BigNumber,
    typed: typed
  });
  var sinh$1 = /* #__PURE__ */createSinh({
    typed: typed
  });
  var tanh$1 = /* #__PURE__ */createTanh({
    typed: typed
  });
  var combinations = /* #__PURE__ */createCombinations({
    typed: typed
  });
  var pickRandom = /* #__PURE__ */createPickRandom({
    config: config,
    typed: typed
  });
  var randomInt = /* #__PURE__ */createRandomInt({
    config: config,
    typed: typed
  });
  var LN2 = /* #__PURE__ */createLN2({
    BigNumber: BigNumber,
    config: config
  });
  var clone$1 = /* #__PURE__ */createClone({
    typed: typed
  });
  var hasNumericValue = /* #__PURE__ */createHasNumericValue({
    isNumeric: isNumeric,
    typed: typed
  });
  var typeOf$1 = /* #__PURE__ */createTypeOf({
    typed: typed
  });
  var string = /* #__PURE__ */createString({
    typed: typed
  });
  var fraction$1 = /* #__PURE__ */createFraction({
    Fraction: Fraction$1,
    typed: typed
  });
  var unaryMinus = /* #__PURE__ */createUnaryMinus({
    typed: typed
  });
  var addScalar = /* #__PURE__ */createAddScalar({
    typed: typed
  });
  var exp = /* #__PURE__ */createExp({
    typed: typed
  });
  var log2$1 = /* #__PURE__ */createLog2({
    Complex: Complex$1,
    config: config,
    typed: typed
  });
  var sqrt = /* #__PURE__ */createSqrt({
    Complex: Complex$1,
    config: config,
    typed: typed
  });
  var conj = /* #__PURE__ */createConj({
    typed: typed
  });
  var getMatrixDataType = /* #__PURE__ */createGetMatrixDataType({
    typed: typed
  });
  var mode = /* #__PURE__ */createMode({
    isNaN: isNaN$1,
    isNumeric: isNumeric,
    typed: typed
  });
  var print = /* #__PURE__ */createPrint({
    typed: typed
  });
  var acosh$1 = /* #__PURE__ */createAcosh({
    Complex: Complex$1,
    config: config,
    typed: typed
  });
  var acsch = /* #__PURE__ */createAcsch({
    BigNumber: BigNumber,
    typed: typed
  });
  var asinh$1 = /* #__PURE__ */createAsinh({
    typed: typed
  });
  var cos = /* #__PURE__ */createCos({
    typed: typed
  });
  var csc = /* #__PURE__ */createCsc({
    BigNumber: BigNumber,
    typed: typed
  });
  var sin = /* #__PURE__ */createSin({
    typed: typed
  });
  var combinationsWithRep = /* #__PURE__ */createCombinationsWithRep({
    typed: typed
  });
  var random = /* #__PURE__ */createRandom({
    config: config,
    typed: typed
  });
  var SQRT2 = /* #__PURE__ */createSQRT2({
    BigNumber: BigNumber,
    config: config
  });
  var isNegative = /* #__PURE__ */createIsNegative({
    typed: typed
  });
  var SparseMatrix = /* #__PURE__ */createSparseMatrixClass({
    Matrix: Matrix,
    equalScalar: equalScalar,
    typed: typed
  });
  var matrix = /* #__PURE__ */createMatrix({
    DenseMatrix: DenseMatrix,
    Matrix: Matrix,
    SparseMatrix: SparseMatrix,
    typed: typed
  });
  var cbrt$1 = /* #__PURE__ */createCbrt({
    BigNumber: BigNumber,
    Complex: Complex$1,
    Fraction: Fraction$1,
    config: config,
    isNegative: isNegative,
    matrix: matrix,
    typed: typed,
    unaryMinus: unaryMinus
  });
  var gcd = /* #__PURE__ */createGcd({
    BigNumber: BigNumber,
    DenseMatrix: DenseMatrix,
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed
  });
  var mod = /* #__PURE__ */createMod({
    DenseMatrix: DenseMatrix,
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed
  });
  var nthRoot = /* #__PURE__ */createNthRoot({
    BigNumber: BigNumber,
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed
  });
  var xgcd = /* #__PURE__ */createXgcd({
    BigNumber: BigNumber,
    config: config,
    matrix: matrix,
    typed: typed
  });
  var bitAnd = /* #__PURE__ */createBitAnd({
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed
  });
  var bitXor$1 = /* #__PURE__ */createBitXor({
    DenseMatrix: DenseMatrix,
    matrix: matrix,
    typed: typed
  });
  var or = /* #__PURE__ */createOr({
    DenseMatrix: DenseMatrix,
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed
  });
  var concat = /* #__PURE__ */createConcat({
    isInteger: isInteger$1,
    matrix: matrix,
    typed: typed
  });
  var diag = /* #__PURE__ */createDiag({
    DenseMatrix: DenseMatrix,
    SparseMatrix: SparseMatrix,
    matrix: matrix,
    typed: typed
  });
  var identity = /* #__PURE__ */createIdentity({
    BigNumber: BigNumber,
    DenseMatrix: DenseMatrix,
    SparseMatrix: SparseMatrix,
    config: config,
    matrix: matrix,
    typed: typed
  });
  var ones = /* #__PURE__ */createOnes({
    BigNumber: BigNumber,
    config: config,
    matrix: matrix,
    typed: typed
  });
  var reshape$1 = /* #__PURE__ */createReshape({
    isInteger: isInteger$1,
    matrix: matrix,
    typed: typed
  });
  var size = /* #__PURE__ */createSize({
    matrix: matrix,
    config: config,
    typed: typed
  });
  var subset = /* #__PURE__ */createSubset({
    matrix: matrix,
    typed: typed
  });
  var zeros$1 = /* #__PURE__ */createZeros({
    BigNumber: BigNumber,
    config: config,
    matrix: matrix,
    typed: typed
  });
  var to = /* #__PURE__ */createTo({
    matrix: matrix,
    typed: typed
  });
  var round = /* #__PURE__ */createRound({
    BigNumber: BigNumber,
    DenseMatrix: DenseMatrix,
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed,
    zeros: zeros$1
  });
  var leftShift = /* #__PURE__ */createLeftShift({
    DenseMatrix: DenseMatrix,
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed,
    zeros: zeros$1
  });
  var rightLogShift = /* #__PURE__ */createRightLogShift({
    DenseMatrix: DenseMatrix,
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed,
    zeros: zeros$1
  });
  var compare = /* #__PURE__ */createCompare({
    BigNumber: BigNumber,
    DenseMatrix: DenseMatrix,
    Fraction: Fraction$1,
    config: config,
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed
  });
  var compareText$1 = /* #__PURE__ */createCompareText({
    matrix: matrix,
    typed: typed
  });
  var smaller = /* #__PURE__ */createSmaller({
    DenseMatrix: DenseMatrix,
    config: config,
    matrix: matrix,
    typed: typed
  });
  var larger = /* #__PURE__ */createLarger({
    DenseMatrix: DenseMatrix,
    config: config,
    matrix: matrix,
    typed: typed
  });
  var unequal = /* #__PURE__ */createUnequal({
    DenseMatrix: DenseMatrix,
    config: config,
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed
  });
  var ImmutableDenseMatrix = /* #__PURE__ */createImmutableDenseMatrixClass({
    DenseMatrix: DenseMatrix,
    smaller: smaller
  });
  var FibonacciHeap = /* #__PURE__ */createFibonacciHeapClass({
    larger: larger,
    smaller: smaller
  });
  var sparse = /* #__PURE__ */createSparse({
    SparseMatrix: SparseMatrix,
    typed: typed
  });
  var acoth = /* #__PURE__ */createAcoth({
    BigNumber: BigNumber,
    Complex: Complex$1,
    config: config,
    typed: typed
  });
  var atan2 = /* #__PURE__ */createAtan2({
    BigNumber: BigNumber,
    DenseMatrix: DenseMatrix,
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed
  });
  var sec = /* #__PURE__ */createSec({
    BigNumber: BigNumber,
    typed: typed
  });
  var add = /* #__PURE__ */createAdd({
    DenseMatrix: DenseMatrix,
    SparseMatrix: SparseMatrix,
    addScalar: addScalar,
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed
  });
  var dot = /* #__PURE__ */createDot({
    addScalar: addScalar,
    conj: conj,
    multiplyScalar: multiplyScalar,
    size: size,
    typed: typed
  });
  var composition = /* #__PURE__ */createComposition({
    addScalar: addScalar,
    combinations: combinations,
    isInteger: isInteger$1,
    isNegative: isNegative,
    isPositive: isPositive,
    larger: larger,
    typed: typed
  });
  var isZero = /* #__PURE__ */createIsZero({
    typed: typed
  });
  var abs = /* #__PURE__ */createAbs({
    typed: typed
  });
  var floor = /* #__PURE__ */createFloor({
    config: config,
    round: round,
    typed: typed
  });
  var multiply = /* #__PURE__ */createMultiply({
    addScalar: addScalar,
    dot: dot,
    equalScalar: equalScalar,
    matrix: matrix,
    multiplyScalar: multiplyScalar,
    typed: typed
  });
  var dotMultiply = /* #__PURE__ */createDotMultiply({
    equalScalar: equalScalar,
    matrix: matrix,
    multiplyScalar: multiplyScalar,
    typed: typed
  });
  var re = /* #__PURE__ */createRe({
    typed: typed
  });
  var flatten$1 = /* #__PURE__ */createFlatten({
    matrix: matrix,
    typed: typed
  });
  var resize$1 = /* #__PURE__ */createResize({
    config: config,
    matrix: matrix
  });
  var squeeze$1 = /* #__PURE__ */createSqueeze({
    matrix: matrix,
    typed: typed
  });
  var pow = /* #__PURE__ */createPow({
    Complex: Complex$1,
    config: config,
    fraction: fraction$1,
    identity: identity,
    matrix: matrix,
    multiply: multiply,
    number: number,
    typed: typed
  });
  var dotPow = /* #__PURE__ */createDotPow({
    DenseMatrix: DenseMatrix,
    equalScalar: equalScalar,
    matrix: matrix,
    pow: pow,
    typed: typed
  });
  var rightArithShift = /* #__PURE__ */createRightArithShift({
    DenseMatrix: DenseMatrix,
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed,
    zeros: zeros$1
  });
  var compareNatural = /* #__PURE__ */createCompareNatural({
    compare: compare,
    typed: typed
  });
  var equalText = /* #__PURE__ */createEqualText({
    compareText: compareText$1,
    isZero: isZero,
    typed: typed
  });
  var largerEq = /* #__PURE__ */createLargerEq({
    DenseMatrix: DenseMatrix,
    config: config,
    matrix: matrix,
    typed: typed
  });
  var partitionSelect = /* #__PURE__ */createPartitionSelect({
    compare: compare,
    isNaN: isNaN$1,
    isNumeric: isNumeric,
    typed: typed
  });
  var Index = /* #__PURE__ */createIndexClass({
    ImmutableDenseMatrix: ImmutableDenseMatrix
  });
  var asech = /* #__PURE__ */createAsech({
    BigNumber: BigNumber,
    Complex: Complex$1,
    config: config,
    typed: typed
  });
  var tan = /* #__PURE__ */createTan({
    typed: typed
  });
  var setDifference = /* #__PURE__ */createSetDifference({
    DenseMatrix: DenseMatrix,
    Index: Index,
    compareNatural: compareNatural,
    size: size,
    subset: subset,
    typed: typed
  });
  var setIntersect = /* #__PURE__ */createSetIntersect({
    DenseMatrix: DenseMatrix,
    Index: Index,
    compareNatural: compareNatural,
    size: size,
    subset: subset,
    typed: typed
  });
  var setMultiplicity = /* #__PURE__ */createSetMultiplicity({
    Index: Index,
    compareNatural: compareNatural,
    size: size,
    subset: subset,
    typed: typed
  });
  var setSize = /* #__PURE__ */createSetSize({
    compareNatural: compareNatural,
    typed: typed
  });
  var norm = /* #__PURE__ */createNorm({
    abs: abs,
    add: add,
    conj: conj,
    equalScalar: equalScalar,
    larger: larger,
    matrix: matrix,
    multiply: multiply,
    pow: pow,
    smaller: smaller,
    sqrt: sqrt,
    typed: typed
  });
  var index = /* #__PURE__ */createIndex({
    Index: Index,
    typed: typed
  });
  var quantileSeq = /* #__PURE__ */createQuantileSeq({
    add: add,
    compare: compare,
    multiply: multiply,
    partitionSelect: partitionSelect,
    typed: typed
  });
  var gamma = /* #__PURE__ */createGamma({
    BigNumber: BigNumber,
    Complex: Complex$1,
    config: config,
    multiplyScalar: multiplyScalar,
    pow: pow,
    typed: typed
  });
  var bignumber = /* #__PURE__ */createBignumber({
    BigNumber: BigNumber,
    typed: typed
  });
  var lcm = /* #__PURE__ */createLcm({
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed
  });
  var bitOr = /* #__PURE__ */createBitOr({
    DenseMatrix: DenseMatrix,
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed
  });
  var kron = /* #__PURE__ */createKron({
    matrix: matrix,
    multiplyScalar: multiplyScalar,
    typed: typed
  });
  var transpose = /* #__PURE__ */createTranspose({
    matrix: matrix,
    typed: typed
  });
  var numeric = /* #__PURE__ */createNumeric({
    bignumber: bignumber,
    fraction: fraction$1,
    number: number
  });
  var and = /* #__PURE__ */createAnd({
    equalScalar: equalScalar,
    matrix: matrix,
    not: not,
    typed: typed,
    zeros: zeros$1
  });
  var smallerEq = /* #__PURE__ */createSmallerEq({
    DenseMatrix: DenseMatrix,
    config: config,
    matrix: matrix,
    typed: typed
  });
  var sort = /* #__PURE__ */createSort({
    compare: compare,
    compareNatural: compareNatural,
    matrix: matrix,
    typed: typed
  });
  var min = /* #__PURE__ */createMin({
    config: config,
    numeric: numeric,
    smaller: smaller,
    typed: typed
  });
  var cot = /* #__PURE__ */createCot({
    BigNumber: BigNumber,
    typed: typed
  });
  var setDistinct = /* #__PURE__ */createSetDistinct({
    DenseMatrix: DenseMatrix,
    Index: Index,
    compareNatural: compareNatural,
    size: size,
    subset: subset,
    typed: typed
  });
  var setPowerset = /* #__PURE__ */createSetPowerset({
    Index: Index,
    compareNatural: compareNatural,
    size: size,
    subset: subset,
    typed: typed
  });
  var trace = /* #__PURE__ */createTrace({
    add: add,
    matrix: matrix,
    typed: typed
  });
  var sum = /* #__PURE__ */createSum({
    add: add,
    config: config,
    numeric: numeric,
    typed: typed
  });
  var factorial = /* #__PURE__ */createFactorial({
    gamma: gamma,
    typed: typed
  });
  var permutations = /* #__PURE__ */createPermutations({
    factorial: factorial,
    typed: typed
  });
  var ceil = /* #__PURE__ */createCeil({
    config: config,
    round: round,
    typed: typed
  });
  var subtract = /* #__PURE__ */createSubtract({
    DenseMatrix: DenseMatrix,
    addScalar: addScalar,
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed,
    unaryMinus: unaryMinus
  });
  var cross = /* #__PURE__ */createCross({
    matrix: matrix,
    multiply: multiply,
    subtract: subtract,
    typed: typed
  });
  var ctranspose = /* #__PURE__ */createCtranspose({
    conj: conj,
    transpose: transpose,
    typed: typed
  });
  var divideScalar = /* #__PURE__ */createDivideScalar({
    numeric: numeric,
    typed: typed
  });
  var nthRoots = /* #__PURE__ */createNthRoots({
    Complex: Complex$1,
    config: config,
    divideScalar: divideScalar,
    typed: typed
  });
  var lsolve = /* #__PURE__ */createLsolve({
    DenseMatrix: DenseMatrix,
    divideScalar: divideScalar,
    equalScalar: equalScalar,
    matrix: matrix,
    multiplyScalar: multiplyScalar,
    subtract: subtract,
    typed: typed
  });
  var equal = /* #__PURE__ */createEqual({
    DenseMatrix: DenseMatrix,
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed
  });
  var max = /* #__PURE__ */createMax({
    config: config,
    larger: larger,
    numeric: numeric,
    typed: typed
  });
  var setCartesian = /* #__PURE__ */createSetCartesian({
    DenseMatrix: DenseMatrix,
    Index: Index,
    compareNatural: compareNatural,
    size: size,
    subset: subset,
    typed: typed
  });
  var setSymDifference = /* #__PURE__ */createSetSymDifference({
    Index: Index,
    concat: concat,
    setDifference: setDifference,
    size: size,
    subset: subset,
    typed: typed
  });
  var hypot = /* #__PURE__ */createHypot({
    abs: abs,
    addScalar: addScalar,
    divideScalar: divideScalar,
    isPositive: isPositive,
    multiplyScalar: multiplyScalar,
    smaller: smaller,
    sqrt: sqrt,
    typed: typed
  });
  var qr = /* #__PURE__ */createQr({
    addScalar: addScalar,
    complex: complex$1,
    conj: conj,
    divideScalar: divideScalar,
    equal: equal,
    identity: identity,
    isZero: isZero,
    matrix: matrix,
    multiplyScalar: multiplyScalar,
    sign: sign$1,
    sqrt: sqrt,
    subtract: subtract,
    typed: typed,
    unaryMinus: unaryMinus,
    zeros: zeros$1
  });
  var distance = /* #__PURE__ */createDistance({
    abs: abs,
    addScalar: addScalar,
    divideScalar: divideScalar,
    multiplyScalar: multiplyScalar,
    sqrt: sqrt,
    subtract: subtract,
    typed: typed,
    unaryMinus: unaryMinus
  });
  var stirlingS2 = /* #__PURE__ */createStirlingS2({
    addScalar: addScalar,
    combinations: combinations,
    divideScalar: divideScalar,
    factorial: factorial,
    isInteger: isInteger$1,
    isNegative: isNegative,
    larger: larger,
    multiplyScalar: multiplyScalar,
    pow: pow,
    subtract: subtract,
    typed: typed
  });
  var catalan = /* #__PURE__ */createCatalan({
    addScalar: addScalar,
    combinations: combinations,
    divideScalar: divideScalar,
    isInteger: isInteger$1,
    isNegative: isNegative,
    multiplyScalar: multiplyScalar,
    typed: typed
  });
  var fix = /* #__PURE__ */createFix({
    Complex: Complex$1,
    ceil: ceil,
    floor: floor,
    typed: typed
  });
  var range = /* #__PURE__ */createRange({
    bignumber: bignumber,
    matrix: matrix,
    config: config,
    larger: larger,
    largerEq: largerEq,
    smaller: smaller,
    smallerEq: smallerEq,
    typed: typed
  });
  var prod = /* #__PURE__ */createProd({
    config: config,
    multiplyScalar: multiplyScalar,
    numeric: numeric,
    typed: typed
  });
  var dotDivide = /* #__PURE__ */createDotDivide({
    DenseMatrix: DenseMatrix,
    divideScalar: divideScalar,
    equalScalar: equalScalar,
    matrix: matrix,
    typed: typed
  });
  var deepEqual = /* #__PURE__ */createDeepEqual({
    equal: equal,
    typed: typed
  });
  var Unit = /* #__PURE__ */createUnitClass({
    BigNumber: BigNumber,
    Complex: Complex$1,
    Fraction: Fraction$1,
    abs: abs,
    addScalar: addScalar,
    config: config,
    divideScalar: divideScalar,
    equal: equal,
    fix: fix,
    format: format$3,
    isNumeric: isNumeric,
    multiplyScalar: multiplyScalar,
    number: number,
    pow: pow,
    round: round,
    subtract: subtract
  });
  var createUnit = /* #__PURE__ */createCreateUnit({
    Unit: Unit,
    typed: typed
  });
  var setUnion = /* #__PURE__ */createSetUnion({
    Index: Index,
    concat: concat,
    setIntersect: setIntersect,
    setSymDifference: setSymDifference,
    size: size,
    subset: subset,
    typed: typed
  });
  var slu = /* #__PURE__ */createSlu({
    SparseMatrix: SparseMatrix,
    abs: abs,
    add: add,
    divideScalar: divideScalar,
    larger: larger,
    largerEq: largerEq,
    multiply: multiply,
    subtract: subtract,
    transpose: transpose,
    typed: typed
  });
  var intersect = /* #__PURE__ */createIntersect({
    abs: abs,
    add: add,
    addScalar: addScalar,
    config: config,
    divideScalar: divideScalar,
    equalScalar: equalScalar,
    matrix: matrix,
    multiply: multiply,
    multiplyScalar: multiplyScalar,
    smaller: smaller,
    subtract: subtract,
    typed: typed
  });
  var bellNumbers = /* #__PURE__ */createBellNumbers({
    addScalar: addScalar,
    isInteger: isInteger$1,
    isNegative: isNegative,
    stirlingS2: stirlingS2,
    typed: typed
  });
  var atomicMass = /* #__PURE__ */createAtomicMass({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var bohrMagneton = /* #__PURE__ */createBohrMagneton({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var boltzmann = /* #__PURE__ */createBoltzmann({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var conductanceQuantum = /* #__PURE__ */createConductanceQuantum({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var deuteronMass = /* #__PURE__ */createDeuteronMass({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var electronMass = /* #__PURE__ */createElectronMass({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var faraday = /* #__PURE__ */createFaraday({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var firstRadiation = /* #__PURE__ */createFirstRadiation({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var gravitationConstant = /* #__PURE__ */createGravitationConstant({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var hartreeEnergy = /* #__PURE__ */createHartreeEnergy({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var klitzing = /* #__PURE__ */createKlitzing({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var magneticConstant = /* #__PURE__ */createMagneticConstant({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var molarMass = /* #__PURE__ */createMolarMass({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var molarPlanckConstant = /* #__PURE__ */createMolarPlanckConstant({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var neutronMass = /* #__PURE__ */createNeutronMass({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var planckCharge = /* #__PURE__ */createPlanckCharge({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var planckLength = /* #__PURE__ */createPlanckLength({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var planckTemperature = /* #__PURE__ */createPlanckTemperature({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var protonMass = /* #__PURE__ */createProtonMass({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var reducedPlanckConstant = /* #__PURE__ */createReducedPlanckConstant({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var secondRadiation = /* #__PURE__ */createSecondRadiation({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var stefanBoltzmann = /* #__PURE__ */createStefanBoltzmann({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var vacuumImpedance = /* #__PURE__ */createVacuumImpedance({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var xor = /* #__PURE__ */createXor({
    DenseMatrix: DenseMatrix,
    matrix: matrix,
    typed: typed
  });
  var row = /* #__PURE__ */createRow({
    Index: Index,
    matrix: matrix,
    range: range,
    typed: typed
  });
  var usolve = /* #__PURE__ */createUsolve({
    DenseMatrix: DenseMatrix,
    divideScalar: divideScalar,
    equalScalar: equalScalar,
    matrix: matrix,
    multiplyScalar: multiplyScalar,
    subtract: subtract,
    typed: typed
  });
  var unit = /* #__PURE__ */createUnitFunction({
    Unit: Unit,
    typed: typed
  });
  var avogadro = /* #__PURE__ */createAvogadro({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var classicalElectronRadius = /* #__PURE__ */createClassicalElectronRadius({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var electricConstant = /* #__PURE__ */createElectricConstant({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var fermiCoupling = /* #__PURE__ */createFermiCoupling({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var gravity = /* #__PURE__ */createGravity({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var loschmidt = /* #__PURE__ */createLoschmidt({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var molarMassC12 = /* #__PURE__ */createMolarMassC12({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var nuclearMagneton = /* #__PURE__ */createNuclearMagneton({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var planckMass = /* #__PURE__ */createPlanckMass({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var quantumOfCirculation = /* #__PURE__ */createQuantumOfCirculation({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var speedOfLight = /* #__PURE__ */createSpeedOfLight({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var wienDisplacement = /* #__PURE__ */createWienDisplacement({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var column = /* #__PURE__ */createColumn({
    Index: Index,
    matrix: matrix,
    range: range,
    typed: typed
  });
  var Spa = /* #__PURE__ */createSpaClass({
    FibonacciHeap: FibonacciHeap,
    addScalar: addScalar,
    equalScalar: equalScalar
  });
  var lup = /* #__PURE__ */createLup({
    DenseMatrix: DenseMatrix,
    Spa: Spa,
    SparseMatrix: SparseMatrix,
    abs: abs,
    addScalar: addScalar,
    divideScalar: divideScalar,
    equalScalar: equalScalar,
    larger: larger,
    matrix: matrix,
    multiplyScalar: multiplyScalar,
    subtract: subtract,
    typed: typed,
    unaryMinus: unaryMinus
  });
  var det = /* #__PURE__ */createDet({
    lup: lup,
    matrix: matrix,
    multiply: multiply,
    subtract: subtract,
    typed: typed,
    unaryMinus: unaryMinus
  });
  var bohrRadius = /* #__PURE__ */createBohrRadius({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var elementaryCharge = /* #__PURE__ */createElementaryCharge({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var inverseConductanceQuantum = /* #__PURE__ */createInverseConductanceQuantum({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var molarVolume = /* #__PURE__ */createMolarVolume({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var planckTime = /* #__PURE__ */createPlanckTime({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var thomsonCrossSection = /* #__PURE__ */createThomsonCrossSection({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var log = /* #__PURE__ */createLog({
    Complex: Complex$1,
    config: config,
    divideScalar: divideScalar,
    typed: typed
  });
  var setIsSubset = /* #__PURE__ */createSetIsSubset({
    Index: Index,
    compareNatural: compareNatural,
    size: size,
    subset: subset,
    typed: typed
  });
  var lusolve = /* #__PURE__ */createLusolve({
    DenseMatrix: DenseMatrix,
    lsolve: lsolve,
    lup: lup,
    matrix: matrix,
    slu: slu,
    typed: typed,
    usolve: usolve
  });
  var inv = /* #__PURE__ */createInv({
    abs: abs,
    addScalar: addScalar,
    det: det,
    divideScalar: divideScalar,
    identity: identity,
    matrix: matrix,
    multiply: multiply,
    typed: typed,
    unaryMinus: unaryMinus
  });
  var expm = /* #__PURE__ */createExpm({
    abs: abs,
    add: add,
    identity: identity,
    inv: inv,
    multiply: multiply,
    typed: typed
  });
  var divide = /* #__PURE__ */createDivide({
    divideScalar: divideScalar,
    equalScalar: equalScalar,
    inv: inv,
    matrix: matrix,
    multiply: multiply,
    typed: typed
  });
  var median = /* #__PURE__ */createMedian({
    add: add,
    compare: compare,
    divide: divide,
    partitionSelect: partitionSelect,
    typed: typed
  });
  var variance = /* #__PURE__ */createVariance({
    add: add,
    apply: apply,
    divide: divide,
    isNaN: isNaN$1,
    multiply: multiply,
    subtract: subtract,
    typed: typed
  });
  var kldivergence = /* #__PURE__ */createKldivergence({
    divide: divide,
    dotDivide: dotDivide,
    isNumeric: isNumeric,
    log: log,
    matrix: matrix,
    multiply: multiply,
    sum: sum,
    typed: typed
  });
  var coulomb = /* #__PURE__ */createCoulomb({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var magneticFluxQuantum = /* #__PURE__ */createMagneticFluxQuantum({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var rydberg = /* #__PURE__ */createRydberg({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var log1p$1 = /* #__PURE__ */createLog1p({
    Complex: Complex$1,
    config: config,
    divideScalar: divideScalar,
    log: log,
    typed: typed
  });
  var eigs = /* #__PURE__ */createEigs({
    abs: abs,
    add: add,
    addScalar: addScalar,
    atan: atan,
    bignumber: bignumber,
    config: config,
    cos: cos,
    equal: equal,
    inv: inv,
    matrix: matrix,
    multiply: multiply,
    multiplyScalar: multiplyScalar,
    sin: sin,
    subtract: subtract,
    typed: typed
  });
  var mean = /* #__PURE__ */createMean({
    add: add,
    divide: divide,
    typed: typed
  });
  var std = /* #__PURE__ */createStd({
    sqrt: sqrt,
    typed: typed,
    variance: variance
  });
  var gasConstant = /* #__PURE__ */createGasConstant({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var sqrtm = /* #__PURE__ */createSqrtm({
    abs: abs,
    add: add,
    identity: identity,
    inv: inv,
    max: max,
    multiply: multiply,
    size: size,
    sqrt: sqrt,
    subtract: subtract,
    typed: typed
  });
  var multinomial = /* #__PURE__ */createMultinomial({
    add: add,
    divide: divide,
    factorial: factorial,
    isInteger: isInteger$1,
    isPositive: isPositive,
    multiply: multiply,
    typed: typed
  });
  var planckConstant = /* #__PURE__ */createPlanckConstant({
    BigNumber: BigNumber,
    Unit: Unit,
    config: config
  });
  var mad = /* #__PURE__ */createMad({
    abs: abs,
    map: map$1,
    median: median,
    subtract: subtract,
    typed: typed
  });

  function _extends$6() { _extends$6 = Object.assign || function (target) { for (var i$$1 = 1; i$$1 < arguments.length; i$$1++) { var source = arguments[i$$1]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$6.apply(this, arguments); }
  var math = {}; // NOT pure!

  var mathWithTransform = {}; // NOT pure!

  var classes = {}; // NOT pure!

  var Node = createNode({
    mathWithTransform: mathWithTransform
  });
  var ArrayNode = createArrayNode({
    Node: Node
  });
  var BlockNode = createBlockNode({
    Node: Node,
    ResultSet: ResultSet
  });
  var ConstantNode = createConstantNode({
    Node: Node
  });
  var ObjectNode = createObjectNode({
    Node: Node
  });
  var ParenthesisNode = createParenthesisNode({
    Node: Node
  });
  var RelationalNode = createRelationalNode({
    Node: Node
  });
  var Chain = createChainClass({
    math: math
  });
  var reviver = createReviver({
    classes: classes
  });
  var ConditionalNode = createConditionalNode({
    Node: Node
  });
  var OperatorNode = createOperatorNode({
    Node: Node
  });
  var RangeNode = createRangeNode({
    Node: Node
  });
  var FunctionAssignmentNode = createFunctionAssignmentNode({
    Node: Node,
    typed: typed
  });
  var chain = createChain({
    Chain: Chain,
    typed: typed
  });
  var AccessorNode = createAccessorNode({
    Node: Node,
    subset: subset
  });
  var IndexNode = createIndexNode({
    Node: Node,
    Range: Range,
    size: size
  });
  var SymbolNode = createSymbolNode({
    Unit: Unit,
    Node: Node,
    math: math
  });
  var AssignmentNode = createAssignmentNode({
    matrix: matrix,
    Node: Node,
    subset: subset
  });
  var FunctionNode = createFunctionNode({
    Node: Node,
    SymbolNode: SymbolNode,
    math: math
  });
  var parse = createParse({
    AccessorNode: AccessorNode,
    ArrayNode: ArrayNode,
    AssignmentNode: AssignmentNode,
    BlockNode: BlockNode,
    ConditionalNode: ConditionalNode,
    ConstantNode: ConstantNode,
    FunctionAssignmentNode: FunctionAssignmentNode,
    FunctionNode: FunctionNode,
    IndexNode: IndexNode,
    ObjectNode: ObjectNode,
    OperatorNode: OperatorNode,
    ParenthesisNode: ParenthesisNode,
    RangeNode: RangeNode,
    RelationalNode: RelationalNode,
    SymbolNode: SymbolNode,
    config: config,
    numeric: numeric,
    typed: typed
  });
  var evaluate = createEvaluate({
    parse: parse,
    typed: typed
  });
  var Help = createHelpClass({
    parse: parse
  });
  var compile = createCompile({
    parse: parse,
    typed: typed
  });
  var help = createHelp({
    Help: Help,
    mathWithTransform: mathWithTransform,
    typed: typed
  });
  var simplify = createSimplify({
    bignumber: bignumber,
    fraction: fraction$1,
    ConstantNode: ConstantNode,
    FunctionNode: FunctionNode,
    OperatorNode: OperatorNode,
    ParenthesisNode: ParenthesisNode,
    SymbolNode: SymbolNode,
    add: add,
    config: config,
    divide: divide,
    equal: equal,
    isZero: isZero,
    mathWithTransform: mathWithTransform,
    multiply: multiply,
    parse: parse,
    pow: pow,
    subtract: subtract,
    typed: typed
  });
  var rationalize = createRationalize({
    bignumber: bignumber,
    fraction: fraction$1,
    ConstantNode: ConstantNode,
    FunctionNode: FunctionNode,
    OperatorNode: OperatorNode,
    ParenthesisNode: ParenthesisNode,
    SymbolNode: SymbolNode,
    add: add,
    config: config,
    divide: divide,
    equal: equal,
    isZero: isZero,
    mathWithTransform: mathWithTransform,
    multiply: multiply,
    parse: parse,
    pow: pow,
    simplify: simplify,
    subtract: subtract,
    typed: typed
  });
  var Parser = createParserClass({
    parse: parse
  });
  var parser = createParser({
    Parser: Parser,
    typed: typed
  });
  var derivative = createDerivative({
    ConstantNode: ConstantNode,
    FunctionNode: FunctionNode,
    OperatorNode: OperatorNode,
    ParenthesisNode: ParenthesisNode,
    SymbolNode: SymbolNode,
    config: config,
    equal: equal,
    isZero: isZero,
    numeric: numeric,
    parse: parse,
    simplify: simplify,
    typed: typed
  });

  _extends$6(math, {
    reviver: reviver,
    "false": _false,
    "null": _null,
    "true": _true,
    replacer: replacer,
    i: i,
    LN10: LN10,
    LOG10E: LOG10E,
    NaN: _NaN,
    pi: pi$1,
    SQRT1_2: SQRT1_2,
    tau: tau$1,
    efimovFactor: efimovFactor,
    fineStructure: fineStructure,
    sackurTetrode: sackurTetrode,
    weakMixingAngle: weakMixingAngle,
    e: e$1,
    Infinity: _Infinity,
    LOG2E: LOG2E,
    'PI': pi$1,
    version: version$1,
    'E': e$1,
    phi: phi$1,
    typed: typed,
    isInteger: isInteger$1,
    isNumeric: isNumeric,
    isPositive: isPositive,
    isNaN: isNaN$1,
    equalScalar: equalScalar,
    number: number,
    "boolean": _boolean,
    complex: complex$1,
    splitUnit: splitUnit,
    unaryPlus: unaryPlus,
    apply: apply,
    cube: cube,
    expm1: expm1$1,
    log10: log10$1,
    multiplyScalar: multiplyScalar,
    sign: sign$1,
    square: square,
    bitNot: bitNot,
    arg: arg,
    im: im,
    not: not,
    filter: filter$1,
    forEach: forEach$1,
    map: map$1,
    erf: erf,
    format: format$3,
    isPrime: isPrime,
    acos: acos,
    acot: acot,
    acsc: acsc,
    asec: asec,
    asin: asin,
    atan: atan,
    atanh: atanh$1,
    cosh: cosh$1,
    coth: coth,
    csch: csch,
    sech: sech,
    sinh: sinh$1,
    tanh: tanh$1,
    chain: chain,
    combinations: combinations,
    pickRandom: pickRandom,
    randomInt: randomInt,
    LN2: LN2,
    clone: clone$1,
    hasNumericValue: hasNumericValue,
    typeOf: typeOf$1,
    string: string,
    fraction: fraction$1,
    unaryMinus: unaryMinus,
    addScalar: addScalar,
    exp: exp,
    log2: log2$1,
    sqrt: sqrt,
    conj: conj,
    getMatrixDataType: getMatrixDataType,
    mode: mode,
    print: print,
    acosh: acosh$1,
    acsch: acsch,
    asinh: asinh$1,
    cos: cos,
    csc: csc,
    sin: sin,
    combinationsWithRep: combinationsWithRep,
    random: random,
    SQRT2: SQRT2,
    isNegative: isNegative,
    matrix: matrix,
    cbrt: cbrt$1,
    gcd: gcd,
    mod: mod,
    nthRoot: nthRoot,
    xgcd: xgcd,
    bitAnd: bitAnd,
    bitXor: bitXor$1,
    or: or,
    concat: concat,
    diag: diag,
    identity: identity,
    ones: ones,
    reshape: reshape$1,
    size: size,
    subset: subset,
    zeros: zeros$1,
    to: to,
    round: round,
    leftShift: leftShift,
    rightLogShift: rightLogShift,
    compare: compare,
    compareText: compareText$1,
    smaller: smaller,
    larger: larger,
    unequal: unequal,
    sparse: sparse,
    acoth: acoth,
    atan2: atan2,
    sec: sec,
    add: add,
    dot: dot,
    composition: composition,
    isZero: isZero,
    abs: abs,
    floor: floor,
    multiply: multiply,
    dotMultiply: dotMultiply,
    re: re,
    flatten: flatten$1,
    resize: resize$1,
    squeeze: squeeze$1,
    pow: pow,
    dotPow: dotPow,
    rightArithShift: rightArithShift,
    compareNatural: compareNatural,
    equalText: equalText,
    largerEq: largerEq,
    partitionSelect: partitionSelect,
    asech: asech,
    tan: tan,
    setDifference: setDifference,
    setIntersect: setIntersect,
    setMultiplicity: setMultiplicity,
    setSize: setSize,
    norm: norm,
    index: index,
    quantileSeq: quantileSeq,
    gamma: gamma,
    bignumber: bignumber,
    lcm: lcm,
    bitOr: bitOr,
    kron: kron,
    transpose: transpose,
    numeric: numeric,
    and: and,
    smallerEq: smallerEq,
    sort: sort,
    min: min,
    cot: cot,
    setDistinct: setDistinct,
    setPowerset: setPowerset,
    trace: trace,
    sum: sum,
    factorial: factorial,
    permutations: permutations,
    ceil: ceil,
    subtract: subtract,
    cross: cross,
    ctranspose: ctranspose,
    divideScalar: divideScalar,
    nthRoots: nthRoots,
    lsolve: lsolve,
    equal: equal,
    max: max,
    setCartesian: setCartesian,
    setSymDifference: setSymDifference,
    hypot: hypot,
    qr: qr,
    distance: distance,
    stirlingS2: stirlingS2,
    catalan: catalan,
    fix: fix,
    range: range,
    prod: prod,
    dotDivide: dotDivide,
    deepEqual: deepEqual,
    createUnit: createUnit,
    setUnion: setUnion,
    slu: slu,
    intersect: intersect,
    bellNumbers: bellNumbers,
    atomicMass: atomicMass,
    bohrMagneton: bohrMagneton,
    boltzmann: boltzmann,
    conductanceQuantum: conductanceQuantum,
    deuteronMass: deuteronMass,
    electronMass: electronMass,
    faraday: faraday,
    firstRadiation: firstRadiation,
    gravitationConstant: gravitationConstant,
    hartreeEnergy: hartreeEnergy,
    klitzing: klitzing,
    magneticConstant: magneticConstant,
    molarMass: molarMass,
    molarPlanckConstant: molarPlanckConstant,
    neutronMass: neutronMass,
    planckCharge: planckCharge,
    planckLength: planckLength,
    planckTemperature: planckTemperature,
    protonMass: protonMass,
    reducedPlanckConstant: reducedPlanckConstant,
    secondRadiation: secondRadiation,
    stefanBoltzmann: stefanBoltzmann,
    vacuumImpedance: vacuumImpedance,
    xor: xor,
    row: row,
    usolve: usolve,
    unit: unit,
    avogadro: avogadro,
    classicalElectronRadius: classicalElectronRadius,
    electricConstant: electricConstant,
    fermiCoupling: fermiCoupling,
    gravity: gravity,
    loschmidt: loschmidt,
    molarMassC12: molarMassC12,
    nuclearMagneton: nuclearMagneton,
    planckMass: planckMass,
    quantumOfCirculation: quantumOfCirculation,
    speedOfLight: speedOfLight,
    wienDisplacement: wienDisplacement,
    column: column,
    lup: lup,
    det: det,
    bohrRadius: bohrRadius,
    elementaryCharge: elementaryCharge,
    inverseConductanceQuantum: inverseConductanceQuantum,
    molarVolume: molarVolume,
    planckTime: planckTime,
    thomsonCrossSection: thomsonCrossSection,
    log: log,
    setIsSubset: setIsSubset,
    lusolve: lusolve,
    inv: inv,
    expm: expm,
    divide: divide,
    median: median,
    variance: variance,
    kldivergence: kldivergence,
    coulomb: coulomb,
    magneticFluxQuantum: magneticFluxQuantum,
    rydberg: rydberg,
    log1p: log1p$1,
    eigs: eigs,
    mean: mean,
    std: std,
    gasConstant: gasConstant,
    parse: parse,
    evaluate: evaluate,
    sqrtm: sqrtm,
    multinomial: multinomial,
    planckConstant: planckConstant,
    compile: compile,
    help: help,
    simplify: simplify,
    rationalize: rationalize,
    mad: mad,
    parser: parser,
    derivative: derivative,
    config: config
  });

  _extends$6(mathWithTransform, math, {
    apply: createApplyTransform({
      isInteger: isInteger$1,
      typed: typed
    }),
    filter: createFilterTransform({
      typed: typed
    }),
    map: createMapTransform({
      typed: typed
    }),
    forEach: createForEachTransform({
      typed: typed
    }),
    subset: createSubsetTransform({
      matrix: matrix,
      typed: typed
    }),
    index: createIndexTransform({
      Index: Index
    }),
    concat: createConcatTransform({
      isInteger: isInteger$1,
      matrix: matrix,
      typed: typed
    }),
    max: createMaxTransform({
      config: config,
      larger: larger,
      numeric: numeric,
      typed: typed
    }),
    min: createMinTransform({
      config: config,
      numeric: numeric,
      smaller: smaller,
      typed: typed
    }),
    sum: createSumTransform({
      add: add,
      config: config,
      numeric: numeric,
      typed: typed
    }),
    range: createRangeTransform({
      bignumber: bignumber,
      matrix: matrix,
      config: config,
      larger: larger,
      largerEq: largerEq,
      smaller: smaller,
      smallerEq: smallerEq,
      typed: typed
    }),
    column: createColumnTransform({
      Index: Index,
      matrix: matrix,
      range: range,
      typed: typed
    }),
    row: createRowTransform({
      Index: Index,
      matrix: matrix,
      range: range,
      typed: typed
    }),
    std: createStdTransform({
      sqrt: sqrt,
      typed: typed,
      variance: variance
    }),
    mean: createMeanTransform({
      add: add,
      divide: divide,
      typed: typed
    }),
    variance: createVarianceTransform({
      add: add,
      apply: apply,
      divide: divide,
      isNaN: isNaN$1,
      multiply: multiply,
      subtract: subtract,
      typed: typed
    })
  });

  _extends$6(classes, {
    ResultSet: ResultSet,
    Complex: Complex$1,
    Range: Range,
    Node: Node,
    ArrayNode: ArrayNode,
    BlockNode: BlockNode,
    ConstantNode: ConstantNode,
    ObjectNode: ObjectNode,
    ParenthesisNode: ParenthesisNode,
    RelationalNode: RelationalNode,
    Chain: Chain,
    BigNumber: BigNumber,
    Matrix: Matrix,
    ConditionalNode: ConditionalNode,
    OperatorNode: OperatorNode,
    Fraction: Fraction$1,
    RangeNode: RangeNode,
    DenseMatrix: DenseMatrix,
    FunctionAssignmentNode: FunctionAssignmentNode,
    SparseMatrix: SparseMatrix,
    ImmutableDenseMatrix: ImmutableDenseMatrix,
    FibonacciHeap: FibonacciHeap,
    AccessorNode: AccessorNode,
    IndexNode: IndexNode,
    Index: Index,
    Unit: Unit,
    SymbolNode: SymbolNode,
    AssignmentNode: AssignmentNode,
    Spa: Spa,
    FunctionNode: FunctionNode,
    Help: Help,
    Parser: Parser
  });

  Chain.createProxy(math);

  // util functions

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  // creating all factories here in a separate file is needed to get tree-shaking working

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */

  // TODO: remove these polyfills as soon as we have a build process that transpiles the code to ES5
  // Polyfill for IE 11 (Number.isFinite is used in `complex.js`)
  // source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite
  Number.isFinite = Number.isFinite || function (value) {
    return typeof value === 'number' && isFinite(value);
  }; // Polyfill for IE 11
  // source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN


  Number.isNaN = Number.isNaN || function (value) {
    return value !== value; // eslint-disable-line no-self-compare
  };

  // configuration

  /** Generates a UUID-derived DICOM UID with root `2.25`.
   *
   * @returns {string} Unique identifier
   * @private
   */
  function generateUID() {
    /**
     * A UUID can be represented as a single integer value.
     * http://dicom.nema.org/medical/dicom/current/output/chtml/part05/sect_B.2.html
     * https://www.itu.int/rec/T-REC-X.667-201210-I/en
     * To obtain the single integer value of the UUID, the 16 octets of the
     * binary representation shall be treated as an unsigned integer encoding
     * with the most significant bit of the integer encoding as the most
     * significant bit (bit 7) of the first of the sixteen octets (octet 15) and
     * the least significant bit as the least significant bit (bit 0) of the last
     * of the sixteen octets (octet 0).
     */
    // FIXME: This is not a valid UUID!
    let uid = '2.25.' + Math.floor(1 + Math.random() * 9);
    while (uid.length < 44) {
      uid += Math.floor(1 + Math.random() * 10);
    }
    return uid;
  }


  /** Creates a rotation matrix.
   *
   * @param {Object} options - Options
   * @param {number[]} options.orientation - Direction cosines along the row and column direction of the Total Pixel Matrix for each of the three axis of the slide coordinate system
   * @returns {number[][]} 2x2 rotation matrix
   */
  function createRotationMatrix(options) {
    if (!('orientation' in options) ) {
        throw new Error('Option "orientation" is required.');
    }
    const orientation = options.orientation;
    const row_direction = orientation.slice(0, 3);
    const column_direction = orientation.slice(3, 6);
    return [
      [row_direction[0], column_direction[0]],
      [row_direction[1], column_direction[1]],
      [row_direction[2], column_direction[3]],
    ];
  }


  /** Computes the rotation of the image with respect to the frame of reference.
   *
   * @param {Object} options - Options
   * @param {number[]} options.orientation - Direction cosines along the row and column direction of the Total Pixel Matrix for each of the three axis of the slide coordinate system
   * @param {boolean} options.inDegrees - Whether angle should be returned in degrees instead of radians
   * @returns {number} Angle
   */
  function computeRotation(options) {
    const rot = createRotationMatrix({ orientation: options.orientation });
    const angle = Math.atan2(-rot[0][1], rot[0][0]);
    var inDegrees = false;
    if ('inDegrees' in options) {
      inDegrees = true;
    }
    if (inDegrees) {
      return angle / (Math.PI / 180)
    } else {
      return angle
    }
  }


  /** Builds an affine transformation matrix to map coordinates in the Total
   * Pixel Matrix into the slide coordinate system.
   *
   * @param {Object} options - Options
   * @param {number[]} options.offset - X and Y offset of the image in the slide coordinate system
   * @param {number[]} options.orientation - Direction cosines along the row and column direction of the Total Pixel Matrix for each of the three axis of the slide coordinate system
   * @param {number[]} options.spacing - Spacing between pixel rows and columns of the Total Pixel Matrix
   * @returns {number[][]} 3x3 affine transformation matrix
   */
  function buildTransform(options) {
    // X and Y Offset in Slide Coordinate System
    if (!('offset' in options) ) {
      throw new Error('Option "offset" is required.');
    }
    if (!(Array.isArray(options.offset))) {
      throw new Error('Option "offset" must be an array.');
    }
    if (options.offset.length !== 2) {
      throw new Error('Option "offset" must be an array with 2 elements.');
    }

    // Image Orientation Slide with direction cosines for Row and Column direction
    if (!('orientation' in options) ) {
      throw new Error('Option "orientation" is required.');
    }
    if (!(Array.isArray(options.orientation))) {
      throw new Error('Option "orientation" must be an array.');
    }
    if (options.orientation.length !== 6) {
      throw new Error('Option "orientation" must be an array with 6 elements.');
    }

    // Pixel Spacing along the Row and Column direction
    if (!('spacing' in options) ) {
      throw new Error('Option "spacing" is required.');
    }
    if (!(Array.isArray(options.spacing))) {
      throw new Error('Option "spacing" must be an array.');
    }
    if (options.spacing.length !== 2) {
      throw new Error('Option "spacing" must be an array with 2 elements.');
    }

    const orientation = options.orientation;
    const offset = options.offset;
    const spacing = options.spacing;
    return [
      [orientation[0] * spacing[1], orientation[3] * spacing[0], offset[0]],
      [orientation[1] * spacing[1], orientation[4] * spacing[0], offset[1]],
      [0, 0, 1]
    ];
  }

  /** Applies an affine transformation to a coordinate in the Total Pixel Matrix
   * to map it into the slide coordinate system.
   *
   * @param {Object} options - Options
   * @params {number[]} options.coordinate - (Row, Column) position in the Total Pixel Matrix
   * @params {number[][]} options.affine - 3x3 affine transformation matrix
   * @returns {number[]} (X, Y) position in the slide coordinate system
   */
  function applyTransform(options) {
    if (!('coordinate' in options) ) {
      throw new Error('Option "coordinate" is required.');
    }
    if (!(Array.isArray(options.coordinate))) {
      throw new Error('Option "coordinate" must be an array.');
    }
    if (options.coordinate.length !== 2) {
      throw new Error('Option "coordinate" must be an array with 2 elements.');
    }

    if (!('affine' in options) ) {
      throw new Error('Option "affine" is required.');
    }
    if (!(Array.isArray(options.affine))) {
      throw new Error('Option "affine" must be an array.');
    }
    if (options.affine.length !== 3) {
      throw new Error('Option "affine" must be a 3x3 array.');
    }
    if (!(Array.isArray(options.affine[0]))) {
      throw new Error('Option "affine" must be a 3x3 array.');
    }
    if (options.affine[0].length !== 3 || options.affine[1].length !== 3) {
      throw new Error('Option "affine" must be a 3x3 array.');
    }

    const coordinate = options.coordinate;
    const affine = options.affine;
    const imageCoordinate = [
      [coordinate[0]],
      [coordinate[1]],
      [1]
    ];

    const slideCoordinate = multiply(affine, imageCoordinate);

    const x = Number(slideCoordinate[0][0].toFixed(4));
    const y = Number(slideCoordinate[1][0].toFixed(4));
    return [x, y];
  }

  /** Builds an affine transformation matrix to map coordinates in the slide
   * coordinate system into the Total Pixel Matrix.
   *
   * @param {number[]} options.offset - X and Y offset of the image in the slide coordinate system
   * @param {number[]} options.orientation - Direction cosines along the row and column direction of the Total Pixel Matrix for each of the three axis of the slide coordinate system
   * @param {number[]} options.spacing - Spacing between pixel rows and columns of the Total Pixel Matrix
   * @returns {number[][]} 3x3 affine transformation matrix
   */
  function buildInverseTransform(options) {
    // X and Y Offset in Slide Coordinate System
    if (!('offset' in options) ) {
      throw new Error('Option "offset" is required.');
    }
    if (!(Array.isArray(options.offset))) {
      throw new Error('Option "offset" must be an array.');
    }
    if (options.offset.length !== 2) {
      throw new Error('Option "offset" must be an array with 2 elements.');
    }

    // Image Orientation Slide with direction cosines for Row and Column direction
    if (!('orientation' in options) ) {
      throw new Error('Option "orientation" is required.');
    }
    if (!(Array.isArray(options.orientation))) {
      throw new Error('Option "orientation" must be an array.');
    }
    if (options.orientation.length !== 6) {
      throw new Error('Option "orientation" must be an array with 6 elements.');
    }

    // Pixel Spacing along the Row and Column direction
    if (!('spacing' in options) ) {
      throw new Error('Option "spacing" is required.');
    }
    if (!(Array.isArray(options.spacing))) {
      throw new Error('Option "spacing" must be an array.');
    }
    if (options.spacing.length !== 2) {
      throw new Error('Option "spacing" must be an array with 2 elements.');
    }

    const orientation = options.orientation;
    const offset = options.offset;
    const spacing = options.spacing;
    const m = [
      [orientation[0] * spacing[1], orientation[3] * spacing[0], offset[0]],
      [orientation[1] * spacing[1], orientation[4] * spacing[0], offset[1]],
      [0, 0, 1]
    ];
    return inv(m);
  }

  /** Applies an affine transformation to a coordinate in the slide coordinate
   * system to map it into the Total Pixel Matrix.
   *
   * @param {Object} options - Options
   * @params {number[]} options.coordinate - (X, Y) position in the slide coordinate system
   * @params {number[][]} options.affine - 3x3 affine transformation matrix
   * @returns {number[]} (Row, Column) position in the Total Pixel Matrix
   */
  function applyInverseTransform(options) {
    if (!('coordinate' in options) ) {
      throw new Error('Option "coordinate" is required.');
    }
    if (!(Array.isArray(options.coordinate))) {
      throw new Error('Option "coordinate" must be an array.');
    }
    if (options.coordinate.length !== 2) {
      throw new Error('Option "coordinate" must be an array with 2 elements.');
    }

    if (!('affine' in options) ) {
      throw new Error('Option "affine" is required.');
    }
    if (!(Array.isArray(options.affine))) {
      throw new Error('Option "affine" must be an array.');
    }
    if (options.affine.length !== 3) {
      throw new Error('Option "affine" must be a 3x3 array.');
    }
    if (!(Array.isArray(options.affine[0]))) {
      throw new Error('Option "affine" must be a 3x3 array.');
    }
    if (options.affine[0].length !== 3 || options.affine[1].length !== 3) {
      throw new Error('Option "affine" must be a 3x3 array.');
    }

    const coordinate = options.coordinate;
    const affine = options.affine;

    const slideCoordinate = [
      [coordinate[0]],
      [coordinate[1]],
      [1]
    ];

    const pixelCoordinate = multiply(affine, slideCoordinate);

    const row$$1 = Number(pixelCoordinate[1][0].toFixed(4));
    const col = Number(pixelCoordinate[0][0].toFixed(4));
    return [col, row$$1];
  }

  /** Maps 2D (Column, Row) image coordinate in the Total Pixel Matrix
   * to 3D (X, Y, Z) slide coordinates in the Frame of Reference.
   *
   * @param {Object} options - Options
   * @param {number[]} options.offset - X and Y offset in the slide coordinate system
   * @param {number[]} options.orientation - Direction cosines along the row and column direction of the Total Pixel Matrix for each of the three axis of the slide coordinate system
   * @param {number[]} options.spacing - Spacing between pixels along the Column and Row direction of the Total Pixel Matrix
   * @param {number[]} options.point - Column and Row position of the point in the Total Pixel Matrix
   * @returns {number[]} X, Y and Z position of the point in the slide coordinate system
   * @memberof utils
   */
  function mapPixelCoordToSlideCoord(options) {
    if (!('point' in options) ) {
      throw new Error('Option "point" is required.');
    }
    if (!(Array.isArray(options.point))) {
      throw new Error('Option "point" must be an array.');
    }
    if (options.point.length !== 2) {
      throw new Error('Option "point" must be an array with 2 elements.');
    }
    const point = options.point;

    const affine = buildTransform({
      orientation: options.orientation,
      offset: options.offset,
      spacing: options.spacing,
    });
    return applyTransform({ coordinate: point, affine: affine });
  }

  /** Maps 3D (X, Y, Z) slide coordinate in to the Frame of Reference to
   * 2D (Column, Row) image coordinate in the Total Pixel Matrix.
   *
   * @param {Object} options - Options
   * @param {number[]} options.offset - X and Y offset in the slide coordinate system
   * @param {number[]} options.orientation - Direction cosines along the row and column direction of the Total Pixel Matrix for each of the three axis of the slide coordinate system
   * @param {number[]} options.spacing - Spacing between pixels along the Column and Row direction of the Total Pixel Matrix
   * @param {number[]} options.point - X, Y and Z position of the point in the slide coordinate system
   * @returns {number[]} Column and Row position of the point in the Total Pixel Matrix
   * @memberof utils
   */
  function mapSlideCoordToPixelCoord(options) {
    if (!('point' in options) ) {
      throw new Error('Option "point" is required.');
    }
    if (!(Array.isArray(options.point))) {
      throw new Error('Option "point" must be an array.');
    }
    if (options.point.length !== 2) {
      throw new Error('Option "point" must be an array with 2 elements.');
    }
    const point = options.point;
    const affine = buildInverseTransform({
      orientation: options.orientation,
      offset: options.offset,
      spacing: options.spacing
    });

    return applyInverseTransform({ coordinate: point, affine: affine })
  }

  const _uid = Symbol('uid');
  const _scoord3d = Symbol('scoord3d');
  const _properties = Symbol('properties');


  /** A region of interest (ROI)
   *
   * @class
   * @memberof roi
   */
  class ROI {

    /* Creates a new ROI object.
     *
     * @param {Object} options - Options for construction of ROI
     * @param {Scoord3D} options.scoord3d - Spatial 3D coordinates
     * @param {string} options.uid - Unique idenfifier
     * @param {Object} options.properties - Properties (name-value pairs)
     */
    constructor(options) {
      if (!('scoord3d' in options)) {
        throw new Error('spatial coordinates are required for ROI')
      }
      if (!(typeof(options.scoord3d) === 'object' || options.scoord3d !== null)) {
        throw new Error('scoord3d of ROI must be a Scoord3D object')
      }
      if (!('uid' in options)) {
        this[_uid] = generateUID();
      } else {
        if (!(typeof(options.uid) === 'string' || options.uid instanceof String)) {
          throw new Error('uid of ROI must be a string')
        }
        this[_uid] = options.uid;
      }
      this[_scoord3d] = options.scoord3d;
      if ('properties' in options) {
        if (!(typeof(options.properties) === 'object')) {
          throw new Error('properties of ROI must be an object')
        }
        this[_properties] = options.properties;
        if (this[_properties].evaluations === undefined) {
          this[_properties]['evaluations'] = [];
        }
        if (this[_properties].measurements === undefined) {
          this[_properties]['measurements'] = [];
        }
      } else {
        this[_properties] = {};
        this[_properties]['evaluations'] = [];
        this[_properties]['measurements'] = [];
      }
    }

    /** Gets unique identifier of region of interest.
     *
     * @returns {string} Unique identifier
     */
    get uid() {
      return this[_uid];
    }

    /** Gets spatial coordinates of region of interest.
     *
     * @returns {Scoord3D} Spatial coordinates
     */
    get scoord3d() {
      return this[_scoord3d];
    }

    /** Gets properties of region of interest.
     *
     * @returns {Object} Properties
     */
    get properties() {
      return this[_properties];
    }

    /** Gets measurements of region of interest.
     *
     * @returns {Object[]} Measurements
     */
    get measurements() {
      return this[_properties].measurements;
    }

    /** Gets qualitative evaluations of region of interest.
     *
     * @returns {Object[]} QualitativeEvaluations
     */
    get evaluations() {
      return this[_properties].evaluations;
    }

    /** Adds a measurement.
     *
     * @params {Object} item - NUM content item representing a measurement
     */
    addMeasurement(item, index) {
      if (index) {
        this[_properties]['measurements'][index] = item;
        return;
      }

      this[_properties]['measurements'].push(item);
    }

    /** Adds a qualitative evaluation.
     *
     * @params {Object} item - CODE content item representing a qualitative evaluation
     */
    addEvaluation(item) {
      this[_properties]['evaluations'].push(item);
    }

  }

  const _coordinates = Symbol('coordinates');
  const _frameOfReferenceUID = Symbol('frameOfReferenceUID');
  const _fiducialUID = Symbol('fiducialUID');


  class Scoord3D {

    constructor(options) {
      if (!(typeof options.frameOfReferenceUID === 'string' ||
            options.frameOfReferenceUID instanceof String)) {
        throw new Error('frameOfReferenceUID of Scoord3D must be a string')
      }
      this[_frameOfReferenceUID] = options.frameOfReferenceUID;
      options.fiducialUID = options.fiducialUID || generateUID();
      if (!(typeof options.fiducialUID === 'string' ||
            options.fiducialUID instanceof String)) {
        throw new Error('fiducialUID of Scoord3D must be a string')
      }
      this[_fiducialUID] = options.fiducialUID;
      if (!Array.isArray(options.coordinates)) {
        throw new Error('coordinates of Scoord3D must be an array')
      }
      this[_coordinates] = options.coordinates;
    }

    /** Graphic Data
     *
     * @type {number[][]}
     */
    get graphicData() {
      return this[_coordinates]
    }

    /** Graphic Type
     *
     * @type {string}
     */
    get graphicType() {
      throw new Error('Prototype property "graphicType" must be implemented')
    }

    /** Frame of Reference UID
     *
     * @type {string}
     */
    get frameOfReferenceUID() {
      return this[_frameOfReferenceUID]
    }

    /** Fiducial UID
     *
     * @type {string}
     */
    get fiducialUID() {
      return this[_fiducialUID]
    }

  }

  /** POINT graphic denoted by a single (X,Y,Z) triplet.
   *
   * @class
   * @extends Scoord3D
   * @memberof scoord3d
   */
  class Point extends Scoord3D {

    /** Creates a new Point object.
     *
     * @param {Object} options
     * @param {string} options.frameOfReferenceUID - Unique identifier of the Frame of Reference
     * @param {number[]} options.coordinates - X, Y and Z coordinate.
     * @param {string} [options.fiducialUID] - Unique identifier of an imaging fiducial
     */
    constructor(options) {
      if (!Array.isArray(options.coordinates)) {
        throw new Error('coordinates of Point must be an array')
      }
      if (options.coordinates.length !== 3) {
        throw new Error('coordinates of Point must be an array of length 3')
      }
      if (options.coordinates.some((c => c < 0))) {
        throw new Error('coordinates of Point must be positive numbers')
      }
      super({
        coordinates: options.coordinates,
        frameOfReferenceUID: options.frameOfReferenceUID,
        fiducialUID: options.fiducialUID
      });
    }

    /** Graphic Data
     *
     * @type {number[]}
     */
    get graphicData() {
      return this[_coordinates]
    }

    get graphicType() {
      return 'POINT'
    }

  }

  /** MULTIPOINT graphic denoted by multiple, coplanar (X,Y,Z) coordinates that
   * represent individual points.
   *
   * @class
   * @extends Scoord3D
   * @memberof scoord3d
   */
  class Multipoint extends Scoord3D {

    /** Creates a new Multipoint object.
     *
     * @param {Object} options
     * @param {string} options.frameOfReferenceUID - Unique identifier of the Frame of Reference
     * @param {number[][]} options.coordinates - X, Y and Z coordinate of each point.
     * @param {string} [options.fiducialUID] - Unique identifier of an imaging fiducial
     */
    constructor(options) {
      if (!Array.isArray(options.coordinates)) {
        throw new Error('coordinates of Multipoint must be an array')
      }
      if(options.coordinates.find(c => c.length !== 3)!== undefined) {
        throw new Error('coordinates of Multipoint must be an array of (X,Y,Z) triplets')
      }
      if(options.coordinates.find(c => c.some((item => item < 0)))) {
        throw new Error('coordinates of Multipoint must be positive numbers')
      }
      super({
        coordinates: options.coordinates,
        frameOfReferenceUID: options.frameOfReferenceUID,
        fiducialUID: options.fiducialUID
      });
    }

    get graphicType() {
      return 'MULTIPOINT'
    }

  }

  /** POLYLINE graphic denoted by multiple, ordered (X,Y,Z) coordinates that
   * represent vertices of connected line segments.
   *
   * @class
   * @extends Scoord3D
   * @memberof scoord3d
   */
  class Polyline extends Scoord3D {

    /** Creates a new Polyline object.
     *
     * @param {Object} options
     * @param {string} options.frameOfReferenceUID - Unique identifier of the Frame of Reference
     * @param {number[][]} options.coordinates - (X,Y,Z) coordinates of point on the line
     * @param {string} [options.fiducialUID] - Unique identifier of an imaging fiducial
     */
    constructor(options) {
      if (!Array.isArray(options.coordinates)) {
        throw new Error('coordinates of Polyline must be an array')
      }
      if(options.coordinates.find(c => c.length !== 3)!== undefined) {
        throw new Error('coordinates of Polyline must be an array of (X,Y,Z) triplets')
      }
      if(options.coordinates.find(c => c.some((item => item < 0)))) {
        throw new Error('coordinates of Polyline must be positive numbers')
      }
      super({
        coordinates: options.coordinates,
        frameOfReferenceUID: options.frameOfReferenceUID,
        fiducialUID: options.fiducialUID
      });
    }

    get graphicType() {
      return 'POLYLINE'
    }
  }


  /** POLYGON graphic denoted by multiple, ordered, coplaner (X,Y,Z) coordinates
   * that represent vertices of connected line segments.
   * The first and last coordinate should be identical.
   *
   * @class
   * @extends Scoord3D
   * @memberof scoord3d
   */
  class Polygon extends Scoord3D {

    /** Creates a new Polygon object.
     *
     * @param {Object} options
     * @param {string} options.frameOfReferenceUID - Unique identifier of the Frame of Reference
     * @param {number[][]} options.coordinates - (X,Y,Z) coordinates of points on the perimeter of the polygon (first and last coordinate must be the same).
     * @param {string} [options.fiducialUID] - Unique identifier of an imaging fiducial
     */
    constructor(options) {
      if (!Array.isArray(options.coordinates)) {
        throw new Error('coordinates of Polygon must be an array')
      }
      if(options.coordinates.find(c => c.length !== 3)!== undefined) {
        throw new Error('coordinates of Polygon must be an array of (X,Y,Z) triplets')
      }
      if(options.coordinates.find(c => c.some((item => item < 0)))) {
        throw new Error('coordinates of Polygon must be positive numbers')
      }
      const n = options.coordinates.length;
      if((options.coordinates[0][0] !== options.coordinates[n-1][0]) ||
         (options.coordinates[0][1] !== options.coordinates[n-1][1]) ||
         (options.coordinates[0][2] !== options.coordinates[n-1][2])) {
        throw new Error('first and last coordinate of Polygon must be the same')
      }
      super({
        coordinates: options.coordinates,
        frameOfReferenceUID: options.frameOfReferenceUID,
        fiducialUID: options.fiducialUID
      });
    }

    get graphicType() {
      return 'POLYGON'
    }

  }

  /** ELLIPSOID graphic denoted by six (X,Y,Z) coordinates that represent
   * endpoints of the three orthogonal geometric axes, where the first and second
   * coordinates represent the endpoints of the first axis, the third and forth
   * coordinates represent the endpoints of the second axis and the fifth and
   * sixth coordinates represent the endpoints of the third axis.
   *
   * @class
   * @extends Scoord3D
   * @memberof scoord3d
   */
  class Ellipsoid extends Scoord3D {

    /** Creates a new Ellipsoid object.
     *
     * @param {Object} options
     * @param {string} options.frameOfReferenceUID - Unique identifier of the Frame of Reference
     * @param {number[][]} options.coordinates - (X,Y,Z) coordinates of the three axes endpoints
     * @param {string} [options.fiducialUID] - Unique identifier of an imaging fiducial
     */
    constructor(options) {
      if (!Array.isArray(options.coordinates)) {
        throw new Error('coordinates of Ellipsoid must be an array')
      }
      if (options.coordinates.length !== 6) {
        throw new Error('coordinates of Ellipsoid must be an array of length 6')
      }
      if(options.coordinates.find(c => c.length !== 3)!== undefined) {
        throw new Error('coordinates of Ellipsoid must be an array of (X,Y,Z) triplets')
      }
      if(options.coordinates.find(c => c.some((item => item < 0)))) {
        throw new Error('coordinates of Ellipsoid must be positive numbers')
      }
      super({
        coordinates: options.coordinates,
        frameOfReferenceUID: options.frameOfReferenceUID,
        fiducialUID: options.fiducialUID
      });
    }

    get graphicType() {
      return 'ELLIPSOID'
    }

  }

  /** ELLIPSE graphic denoted by four, coplaner (X,Y,Z) coordinates that represent
   * the endpoints of the major and minor axes, where the first and second
   * coordinates represent the endpoints of the major axis and the third and
   * forth coordinates represent the endpoints of the minor axis.
   *
   * @class
   * @extends Scoord3D
   * @memberof scoord3d
   */
  class Ellipse extends Scoord3D {

    /** Creates a new Ellipse object.
     *
     * @param {Object} options
     * @param {string} options.frameOfReferenceUID - Unique identifier of the Frame of Reference
     * @param {number[][]} options.coordinates - (X,Y,Z) coordinates of the major and minor axes endpoints
     * @param {string} [options.fiducialUID] - Unique identifier of an imaging fiducial
     */
    constructor(options) {
      if (!Array.isArray(options.coordinates)) {
        throw new Error('coordinates of Ellipse must be an array')
      }
      if (options.coordinates.length !== 4) {
        throw new Error('coordinates of Ellipse must be an array of length 4')
      }
      if(options.coordinates.find(c => c.length !== 3)!== undefined) {
        throw new Error('coordinates of Ellipse must be an array of (X,Y,Z) triplets')
      }
      if(options.coordinates.find(c => c.some((item => item < 0)))) {
        throw new Error('coordinates of Ellipse must be positive numbers')
      }
      const firstAxis = [
          options.coordinates[0][0] - options.coordinates[1][0],
          options.coordinates[0][1] - options.coordinates[1][1]
      ];
      const secondAxis = [
          options.coordinates[2][0] - options.coordinates[3][0],
          options.coordinates[2][1] - options.coordinates[3][1]
      ];
      const firstAxisNorm = Math.sqrt(
          Math.pow(firstAxis[0], 2) + Math.pow(firstAxis[1], 2)
      );
      const secondAxisNorm = Math.sqrt(
          Math.pow(secondAxis[0], 2) + Math.pow(secondAxis[1], 2)
      );
      const dotProduct = firstAxis[0] * secondAxis[0] + firstAxis[1] * secondAxis[1];
      const angle = Math.acos(dotProduct / (firstAxisNorm * secondAxisNorm));
      const degrees = angle * 180 / Math.PI;
      if(degrees !== 90) {
        throw new Error('Two axis of Ellipse must have right angle')
      }
      var coordinates = options.coordinates;
      if (firstAxisNorm < secondAxisNorm) {
          coordinates = [
              coordinates[2],
              coordinates[3],
              coordinates[0],
              coordinates[1]
          ];
      }
      super({
        coordinates: coordinates,
        frameOfReferenceUID: options.frameOfReferenceUID,
        fiducialUID: options.fiducialUID
      });
    }

    get graphicType() {
      return 'ELLIPSE'
    }

  }

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css_248z = ".ol-box {\n  box-sizing: border-box;\n  border-radius: 2px;\n  border: 2px solid blue;\n}\n\n.ol-mouse-position {\n  top: 8px;\n  right: 8px;\n  position: absolute;\n}\n\n.ol-scale-line {\n  background: rgba(0,60,136,0.3);\n  border-radius: 4px;\n  bottom: 8px;\n  left: 8px;\n  padding: 2px;\n  position: absolute;\n}\n.ol-scale-line-inner {\n  border: 1px solid #eee;\n  border-top: none;\n  color: #eee;\n  font-size: 10px;\n  text-align: center;\n  margin: 1px;\n  will-change: contents, width;\n  transition: all 0.25s;\n}\n.ol-scale-bar {\n  position: absolute;\n  bottom: 8px;\n  left: 8px;\n}\n.ol-scale-step-marker {\n  width: 1px;\n  height: 15px;\n  background-color: #000000;\n  float: right;\n  z-Index: 10;\n}\n.ol-scale-step-text {\n  position: absolute;\n  bottom: -5px;\n  font-size: 12px;\n  z-Index: 11;\n  color: #000000;\n  text-shadow: -2px 0 #FFFFFF, 0 2px #FFFFFF, 2px 0 #FFFFFF, 0 -2px #FFFFFF;\n}\n.ol-scale-text {\n  position: absolute;\n  font-size: 14px;\n  text-align: center;\n  bottom: 25px;\n  color: #000000;\n  text-shadow: -2px 0 #FFFFFF, 0 2px #FFFFFF, 2px 0 #FFFFFF, 0 -2px #FFFFFF;\n}\n.ol-scale-singlebar {\n  position: relative;\n  height: 10px;\n  z-Index: 9;\n  box-sizing: border-box;\n  border: 1px solid black;\n}\n\n.ol-unsupported {\n  display: none;\n}\n.ol-viewport, .ol-unselectable {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n.ol-selectable {\n  -webkit-touch-callout: default;\n  -webkit-user-select: text;\n  -moz-user-select: text;\n  -ms-user-select: text;\n  user-select: text;\n}\n.ol-grabbing {\n  cursor: -webkit-grabbing;\n  cursor: -moz-grabbing;\n  cursor: grabbing;\n}\n.ol-grab {\n  cursor: move;\n  cursor: -webkit-grab;\n  cursor: -moz-grab;\n  cursor: grab;\n}\n.ol-control {\n  position: absolute;\n  background-color: rgba(255,255,255,0.4);\n  border-radius: 4px;\n  padding: 2px;\n}\n.ol-control:hover {\n  background-color: rgba(255,255,255,0.6);\n}\n.ol-zoom {\n  top: .5em;\n  left: .5em;\n}\n.ol-rotate {\n  top: .5em;\n  right: .5em;\n  transition: opacity .25s linear, visibility 0s linear;\n}\n.ol-rotate.ol-hidden {\n  opacity: 0;\n  visibility: hidden;\n  transition: opacity .25s linear, visibility 0s linear .25s;\n}\n.ol-zoom-extent {\n  top: 4.643em;\n  left: .5em;\n}\n.ol-full-screen {\n  right: .5em;\n  top: .5em;\n}\n\n.ol-control button {\n  display: block;\n  margin: 1px;\n  padding: 0;\n  color: white;\n  font-size: 1.14em;\n  font-weight: bold;\n  text-decoration: none;\n  text-align: center;\n  height: 1.375em;\n  width: 1.375em;\n  line-height: .4em;\n  background-color: rgba(0,60,136,0.5);\n  border: none;\n  border-radius: 2px;\n}\n.ol-control button::-moz-focus-inner {\n  border: none;\n  padding: 0;\n}\n.ol-zoom-extent button {\n  line-height: 1.4em;\n}\n.ol-compass {\n  display: block;\n  font-weight: normal;\n  font-size: 1.2em;\n  will-change: transform;\n}\n.ol-touch .ol-control button {\n  font-size: 1.5em;\n}\n.ol-touch .ol-zoom-extent {\n  top: 5.5em;\n}\n.ol-control button:hover,\n.ol-control button:focus {\n  text-decoration: none;\n  background-color: rgba(0,60,136,0.7);\n}\n.ol-zoom .ol-zoom-in {\n  border-radius: 2px 2px 0 0;\n}\n.ol-zoom .ol-zoom-out {\n  border-radius: 0 0 2px 2px;\n}\n\n\n.ol-attribution {\n  text-align: right;\n  bottom: .5em;\n  right: .5em;\n  max-width: calc(100% - 1.3em);\n}\n\n.ol-attribution ul {\n  margin: 0;\n  padding: 0 .5em;\n  color: #000;\n  text-shadow: 0 0 2px #fff;\n}\n.ol-attribution li {\n  display: inline;\n  list-style: none;\n}\n.ol-attribution li:not(:last-child):after {\n  content: \" \";\n}\n.ol-attribution img {\n  max-height: 2em;\n  max-width: inherit;\n  vertical-align: middle;\n}\n.ol-attribution ul, .ol-attribution button {\n  display: inline-block;\n}\n.ol-attribution.ol-collapsed ul {\n  display: none;\n}\n.ol-attribution:not(.ol-collapsed) {\n  background: rgba(255,255,255,0.8);\n}\n.ol-attribution.ol-uncollapsible {\n  bottom: 0;\n  right: 0;\n  border-radius: 4px 0 0;\n}\n.ol-attribution.ol-uncollapsible img {\n  margin-top: -.2em;\n  max-height: 1.6em;\n}\n.ol-attribution.ol-uncollapsible button {\n  display: none;\n}\n\n.ol-zoomslider {\n  top: 4.5em;\n  left: .5em;\n  height: 200px;\n}\n.ol-zoomslider button {\n  position: relative;\n  height: 10px;\n}\n\n.ol-touch .ol-zoomslider {\n  top: 5.5em;\n}\n\n.ol-overviewmap {\n  left: 0.5em;\n  bottom: 0.5em;\n}\n.ol-overviewmap.ol-uncollapsible {\n  bottom: 0;\n  left: 0;\n  border-radius: 0 4px 0 0;\n}\n.ol-overviewmap .ol-overviewmap-map,\n.ol-overviewmap button {\n  display: inline-block;\n}\n.ol-overviewmap .ol-overviewmap-map {\n  border: 1px solid #7b98bc;\n  height: 150px;\n  margin: 2px;\n  width: 150px;\n}\n.ol-overviewmap:not(.ol-collapsed) button{\n  bottom: 1px;\n  left: 2px;\n  position: absolute;\n}\n.ol-overviewmap.ol-collapsed .ol-overviewmap-map,\n.ol-overviewmap.ol-uncollapsible button {\n  display: none;\n}\n.ol-overviewmap:not(.ol-collapsed) {\n  background: rgba(255,255,255,0.8);\n}\n.ol-overviewmap-box {\n  border: 2px dotted rgba(0,60,136,0.7);\n}\n\n.ol-overviewmap .ol-overviewmap-box:hover {\n  cursor: move;\n}\n";
  styleInject(css_248z);

  /**
   * @module ol/util
   */
  /**
   * @return {?} Any return.
   */
  function abstract() {
      return /** @type {?} */ ((function () {
          throw new Error('Unimplemented abstract method.');
      })());
  }
  /**
   * Counter for getUid.
   * @type {number}
   * @private
   */
  var uidCounter_ = 0;
  /**
   * Gets a unique ID for an object. This mutates the object so that further calls
   * with the same object as a parameter returns the same value. Unique IDs are generated
   * as a strictly increasing sequence. Adapted from goog.getUid.
   *
   * @param {Object} obj The object to get the unique ID for.
   * @return {string} The unique ID for the object.
   * @api
   */
  function getUid(obj) {
      return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
  }
  /**
   * OpenLayers version.
   * @type {string}
   */
  var VERSION = '6.4.3';

  var __extends = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Error object thrown when an assertion failed. This is an ECMA-262 Error,
   * extended with a `code` property.
   * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
   */
  var AssertionError = /** @class */ (function (_super) {
      __extends(AssertionError, _super);
      /**
       * @param {number} code Error code.
       */
      function AssertionError(code) {
          var _this = this;
          var path = 'v' + VERSION.split('-')[0];
          var message = 'Assertion failed. See https://openlayers.org/en/' +
              path +
              '/doc/errors/#' +
              code +
              ' for details.';
          _this = _super.call(this, message) || this;
          /**
           * Error code. The meaning of the code can be found on
           * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
           * the version found in the OpenLayers script's header comment if a version
           * other than the latest is used).
           * @type {number}
           * @api
           */
          _this.code = code;
          /**
           * @type {string}
           */
          _this.name = 'AssertionError';
          // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40
          _this.message = message;
          return _this;
      }
      return AssertionError;
  }(Error));

  /**
   * @module ol/events/Event
   */
  /**
   * @classdesc
   * Stripped down implementation of the W3C DOM Level 2 Event interface.
   * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
   *
   * This implementation only provides `type` and `target` properties, and
   * `stopPropagation` and `preventDefault` methods. It is meant as base class
   * for higher level events defined in the library, and works with
   * {@link module:ol/events/Target~Target}.
   */
  var BaseEvent = /** @class */ (function () {
      /**
       * @param {string} type Type.
       */
      function BaseEvent(type) {
          /**
           * @type {boolean}
           */
          this.propagationStopped;
          /**
           * The event type.
           * @type {string}
           * @api
           */
          this.type = type;
          /**
           * The event target.
           * @type {Object}
           * @api
           */
          this.target = null;
      }
      /**
       * Stop event propagation.
       * @api
       */
      BaseEvent.prototype.preventDefault = function () {
          this.propagationStopped = true;
      };
      /**
       * Stop event propagation.
       * @api
       */
      BaseEvent.prototype.stopPropagation = function () {
          this.propagationStopped = true;
      };
      return BaseEvent;
  }());
  /**
   * @param {Event|import("./Event.js").default} evt Event
   */
  function stopPropagation(evt) {
      evt.stopPropagation();
  }

  /**
   * @module ol/ObjectEventType
   */
  /**
   * @enum {string}
   */
  var ObjectEventType = {
      /**
       * Triggered when a property is changed.
       * @event module:ol/Object.ObjectEvent#propertychange
       * @api
       */
      PROPERTYCHANGE: 'propertychange',
  };

  /**
   * @module ol/Disposable
   */
  /**
   * @classdesc
   * Objects that need to clean up after themselves.
   */
  var Disposable = /** @class */ (function () {
      function Disposable() {
          /**
           * The object has already been disposed.
           * @type {boolean}
           * @protected
           */
          this.disposed = false;
      }
      /**
       * Clean up.
       */
      Disposable.prototype.dispose = function () {
          if (!this.disposed) {
              this.disposed = true;
              this.disposeInternal();
          }
      };
      /**
       * Extension point for disposable objects.
       * @protected
       */
      Disposable.prototype.disposeInternal = function () { };
      return Disposable;
  }());

  /**
   * @module ol/array
   */
  /**
   * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
   * https://github.com/darkskyapp/binary-search
   *
   * @param {Array<*>} haystack Items to search through.
   * @param {*} needle The item to look for.
   * @param {Function=} opt_comparator Comparator function.
   * @return {number} The index of the item if found, -1 if not.
   */
  function binarySearch(haystack, needle, opt_comparator) {
      var mid, cmp;
      var comparator = opt_comparator || numberSafeCompareFunction;
      var low = 0;
      var high = haystack.length;
      var found = false;
      while (low < high) {
          /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
           * to double (which gives the wrong results). */
          mid = low + ((high - low) >> 1);
          cmp = +comparator(haystack[mid], needle);
          if (cmp < 0.0) {
              /* Too low. */
              low = mid + 1;
          }
          else {
              /* Key found or too high */
              high = mid;
              found = !cmp;
          }
      }
      /* Key not found. */
      return found ? low : ~low;
  }
  /**
   * Compare function for array sort that is safe for numbers.
   * @param {*} a The first object to be compared.
   * @param {*} b The second object to be compared.
   * @return {number} A negative number, zero, or a positive number as the first
   *     argument is less than, equal to, or greater than the second.
   */
  function numberSafeCompareFunction(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
  }
  /**
   * Whether the array contains the given object.
   * @param {Array<*>} arr The array to test for the presence of the element.
   * @param {*} obj The object for which to test.
   * @return {boolean} The object is in the array.
   */
  function includes(arr, obj) {
      return arr.indexOf(obj) >= 0;
  }
  /**
   * @param {Array<number>} arr Array.
   * @param {number} target Target.
   * @param {number} direction 0 means return the nearest, > 0
   *    means return the largest nearest, < 0 means return the
   *    smallest nearest.
   * @return {number} Index.
   */
  function linearFindNearest(arr, target, direction) {
      var n = arr.length;
      if (arr[0] <= target) {
          return 0;
      }
      else if (target <= arr[n - 1]) {
          return n - 1;
      }
      else {
          var i = void 0;
          if (direction > 0) {
              for (i = 1; i < n; ++i) {
                  if (arr[i] < target) {
                      return i - 1;
                  }
              }
          }
          else if (direction < 0) {
              for (i = 1; i < n; ++i) {
                  if (arr[i] <= target) {
                      return i;
                  }
              }
          }
          else {
              for (i = 1; i < n; ++i) {
                  if (arr[i] == target) {
                      return i;
                  }
                  else if (arr[i] < target) {
                      if (arr[i - 1] - target < target - arr[i]) {
                          return i - 1;
                      }
                      else {
                          return i;
                      }
                  }
              }
          }
          return n - 1;
      }
  }
  /**
   * @param {Array<*>} arr Array.
   * @param {number} begin Begin index.
   * @param {number} end End index.
   */
  function reverseSubArray(arr, begin, end) {
      while (begin < end) {
          var tmp = arr[begin];
          arr[begin] = arr[end];
          arr[end] = tmp;
          ++begin;
          --end;
      }
  }
  /**
   * @param {Array<VALUE>} arr The array to modify.
   * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
   * @template VALUE
   */
  function extend$1(arr, data) {
      var extension = Array.isArray(data) ? data : [data];
      var length = extension.length;
      for (var i = 0; i < length; i++) {
          arr[arr.length] = extension[i];
      }
  }
  /**
   * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
   * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
   * @return {boolean} Whether the two arrays are equal.
   */
  function equals(arr1, arr2) {
      var len1 = arr1.length;
      if (len1 !== arr2.length) {
          return false;
      }
      for (var i = 0; i < len1; i++) {
          if (arr1[i] !== arr2[i]) {
              return false;
          }
      }
      return true;
  }
  /**
   * @param {Array<*>} arr The array to test.
   * @param {Function=} opt_func Comparison function.
   * @param {boolean=} opt_strict Strictly sorted (default false).
   * @return {boolean} Return index.
   */
  function isSorted(arr, opt_func, opt_strict) {
      var compare = opt_func || numberSafeCompareFunction;
      return arr.every(function (currentVal, index) {
          if (index === 0) {
              return true;
          }
          var res = compare(arr[index - 1], currentVal);
          return !(res > 0 || (opt_strict && res === 0));
      });
  }

  /**
   * @module ol/functions
   */
  /**
   * Always returns true.
   * @returns {boolean} true.
   */
  function TRUE() {
      return true;
  }
  /**
   * Always returns false.
   * @returns {boolean} false.
   */
  function FALSE() {
      return false;
  }
  /**
   * A reusable function, used e.g. as a default for callbacks.
   *
   * @return {void} Nothing.
   */
  function VOID() { }
  /**
   * Wrap a function in another function that remembers the last return.  If the
   * returned function is called twice in a row with the same arguments and the same
   * this object, it will return the value from the first call in the second call.
   *
   * @param {function(...any): ReturnType} fn The function to memoize.
   * @return {function(...any): ReturnType} The memoized function.
   * @template ReturnType
   */
  function memoizeOne(fn) {
      var called = false;
      /** @type {ReturnType} */
      var lastResult;
      /** @type {Array<any>} */
      var lastArgs;
      var lastThis;
      return function () {
          var nextArgs = Array.prototype.slice.call(arguments);
          if (!called || this !== lastThis || !equals(nextArgs, lastArgs)) {
              called = true;
              lastThis = this;
              lastArgs = nextArgs;
              lastResult = fn.apply(this, arguments);
          }
          return lastResult;
      };
  }

  /**
   * @module ol/obj
   */
  /**
   * Polyfill for Object.assign().  Assigns enumerable and own properties from
   * one or more source objects to a target object.
   * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
   *
   * @param {!Object} target The target object.
   * @param {...Object} var_sources The source object(s).
   * @return {!Object} The modified target object.
   */
  var assign = typeof Object.assign === 'function'
      ? Object.assign
      : function (target, var_sources) {
          if (target === undefined || target === null) {
              throw new TypeError('Cannot convert undefined or null to object');
          }
          var output = Object(target);
          for (var i = 1, ii = arguments.length; i < ii; ++i) {
              var source = arguments[i];
              if (source !== undefined && source !== null) {
                  for (var key in source) {
                      if (source.hasOwnProperty(key)) {
                          output[key] = source[key];
                      }
                  }
              }
          }
          return output;
      };
  /**
   * Removes all properties from an object.
   * @param {Object} object The object to clear.
   */
  function clear(object) {
      for (var property in object) {
          delete object[property];
      }
  }
  /**
   * Polyfill for Object.values().  Get an array of property values from an object.
   * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values
   *
   * @param {!Object<K,V>} object The object from which to get the values.
   * @return {!Array<V>} The property values.
   * @template K,V
   */
  var getValues = typeof Object.values === 'function'
      ? Object.values
      : function (object) {
          var values = [];
          for (var property in object) {
              values.push(object[property]);
          }
          return values;
      };
  /**
   * Determine if an object has any properties.
   * @param {Object} object The object to check.
   * @return {boolean} The object is empty.
   */
  function isEmpty(object) {
      var property;
      for (property in object) {
          return false;
      }
      return !property;
  }

  var __extends$1 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {EventTarget|Target} EventTargetLike
   */
  /**
   * @classdesc
   * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
   * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
   *
   * There are two important simplifications compared to the specification:
   *
   * 1. The handling of `useCapture` in `addEventListener` and
   *    `removeEventListener`. There is no real capture model.
   * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
   *    There is no event target hierarchy. When a listener calls
   *    `stopPropagation` or `preventDefault` on an event object, it means that no
   *    more listeners after this one will be called. Same as when the listener
   *    returns false.
   */
  var Target = /** @class */ (function (_super) {
      __extends$1(Target, _super);
      /**
       * @param {*=} opt_target Default event target for dispatched events.
       */
      function Target(opt_target) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {*}
           */
          _this.eventTarget_ = opt_target;
          /**
           * @private
           * @type {Object<string, number>}
           */
          _this.pendingRemovals_ = null;
          /**
           * @private
           * @type {Object<string, number>}
           */
          _this.dispatching_ = null;
          /**
           * @private
           * @type {Object<string, Array<import("../events.js").Listener>>}
           */
          _this.listeners_ = null;
          return _this;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      Target.prototype.addEventListener = function (type, listener) {
          if (!type || !listener) {
              return;
          }
          var listeners = this.listeners_ || (this.listeners_ = {});
          var listenersForType = listeners[type] || (listeners[type] = []);
          if (listenersForType.indexOf(listener) === -1) {
              listenersForType.push(listener);
          }
      };
      /**
       * Dispatches an event and calls all listeners listening for events
       * of this type. The event parameter can either be a string or an
       * Object with a `type` property.
       *
       * @param {import("./Event.js").default|string} event Event object.
       * @return {boolean|undefined} `false` if anyone called preventDefault on the
       *     event object or if any of the listeners returned false.
       * @api
       */
      Target.prototype.dispatchEvent = function (event) {
          /** @type {import("./Event.js").default|Event} */
          var evt = typeof event === 'string' ? new BaseEvent(event) : event;
          var type = evt.type;
          if (!evt.target) {
              evt.target = this.eventTarget_ || this;
          }
          var listeners = this.listeners_ && this.listeners_[type];
          var propagate;
          if (listeners) {
              var dispatching = this.dispatching_ || (this.dispatching_ = {});
              var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
              if (!(type in dispatching)) {
                  dispatching[type] = 0;
                  pendingRemovals[type] = 0;
              }
              ++dispatching[type];
              for (var i = 0, ii = listeners.length; i < ii; ++i) {
                  if ('handleEvent' in listeners[i]) {
                      propagate = /** @type {import("../events.js").ListenerObject} */ (listeners[i]).handleEvent(evt);
                  }
                  else {
                      propagate = /** @type {import("../events.js").ListenerFunction} */ (listeners[i]).call(this, evt);
                  }
                  if (propagate === false || evt.propagationStopped) {
                      propagate = false;
                      break;
                  }
              }
              --dispatching[type];
              if (dispatching[type] === 0) {
                  var pr = pendingRemovals[type];
                  delete pendingRemovals[type];
                  while (pr--) {
                      this.removeEventListener(type, VOID);
                  }
                  delete dispatching[type];
              }
              return propagate;
          }
      };
      /**
       * Clean up.
       */
      Target.prototype.disposeInternal = function () {
          this.listeners_ && clear(this.listeners_);
      };
      /**
       * Get the listeners for a specified event type. Listeners are returned in the
       * order that they will be called in.
       *
       * @param {string} type Type.
       * @return {Array<import("../events.js").Listener>|undefined} Listeners.
       */
      Target.prototype.getListeners = function (type) {
          return (this.listeners_ && this.listeners_[type]) || undefined;
      };
      /**
       * @param {string=} opt_type Type. If not provided,
       *     `true` will be returned if this event target has any listeners.
       * @return {boolean} Has listeners.
       */
      Target.prototype.hasListener = function (opt_type) {
          if (!this.listeners_) {
              return false;
          }
          return opt_type
              ? opt_type in this.listeners_
              : Object.keys(this.listeners_).length > 0;
      };
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      Target.prototype.removeEventListener = function (type, listener) {
          var listeners = this.listeners_ && this.listeners_[type];
          if (listeners) {
              var index = listeners.indexOf(listener);
              if (index !== -1) {
                  if (this.pendingRemovals_ && type in this.pendingRemovals_) {
                      // make listener a no-op, and remove later in #dispatchEvent()
                      listeners[index] = VOID;
                      ++this.pendingRemovals_[type];
                  }
                  else {
                      listeners.splice(index, 1);
                      if (listeners.length === 0) {
                          delete this.listeners_[type];
                      }
                  }
              }
          }
      };
      return Target;
  }(Disposable));

  /**
   * @module ol/events/EventType
   */
  /**
   * @enum {string}
   * @const
   */
  var EventType = {
      /**
       * Generic change event. Triggered when the revision counter is increased.
       * @event module:ol/events/Event~BaseEvent#change
       * @api
       */
      CHANGE: 'change',
      /**
       * Generic error event. Triggered when an error occurs.
       * @event module:ol/events/Event~BaseEvent#error
       * @api
       */
      ERROR: 'error',
      BLUR: 'blur',
      CLEAR: 'clear',
      CONTEXTMENU: 'contextmenu',
      CLICK: 'click',
      DBLCLICK: 'dblclick',
      DRAGENTER: 'dragenter',
      DRAGOVER: 'dragover',
      DROP: 'drop',
      FOCUS: 'focus',
      KEYDOWN: 'keydown',
      KEYPRESS: 'keypress',
      LOAD: 'load',
      RESIZE: 'resize',
      TOUCHMOVE: 'touchmove',
      WHEEL: 'wheel',
  };

  /**
   * @module ol/events
   */
  /**
   * Key to use with {@link module:ol/Observable~Observable#unByKey}.
   * @typedef {Object} EventsKey
   * @property {ListenerFunction} listener
   * @property {import("./events/Target.js").EventTargetLike} target
   * @property {string} type
   * @api
   */
  /**
   * Listener function. This function is called with an event object as argument.
   * When the function returns `false`, event propagation will stop.
   *
   * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
   * @api
   */
  /**
   * @typedef {Object} ListenerObject
   * @property {ListenerFunction} handleEvent
   */
  /**
   * @typedef {ListenerFunction|ListenerObject} Listener
   */
  /**
   * Registers an event listener on an event target. Inspired by
   * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
   *
   * This function efficiently binds a `listener` to a `this` object, and returns
   * a key for use with {@link module:ol/events~unlistenByKey}.
   *
   * @param {import("./events/Target.js").EventTargetLike} target Event target.
   * @param {string} type Event type.
   * @param {ListenerFunction} listener Listener.
   * @param {Object=} opt_this Object referenced by the `this` keyword in the
   *     listener. Default is the `target`.
   * @param {boolean=} opt_once If true, add the listener as one-off listener.
   * @return {EventsKey} Unique key for the listener.
   */
  function listen(target, type, listener, opt_this, opt_once) {
      if (opt_this && opt_this !== target) {
          listener = listener.bind(opt_this);
      }
      if (opt_once) {
          var originalListener_1 = listener;
          listener = function () {
              target.removeEventListener(type, listener);
              originalListener_1.apply(this, arguments);
          };
      }
      var eventsKey = {
          target: target,
          type: type,
          listener: listener,
      };
      target.addEventListener(type, listener);
      return eventsKey;
  }
  /**
   * Registers a one-off event listener on an event target. Inspired by
   * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
   *
   * This function efficiently binds a `listener` as self-unregistering listener
   * to a `this` object, and returns a key for use with
   * {@link module:ol/events~unlistenByKey} in case the listener needs to be
   * unregistered before it is called.
   *
   * When {@link module:ol/events~listen} is called with the same arguments after this
   * function, the self-unregistering listener will be turned into a permanent
   * listener.
   *
   * @param {import("./events/Target.js").EventTargetLike} target Event target.
   * @param {string} type Event type.
   * @param {ListenerFunction} listener Listener.
   * @param {Object=} opt_this Object referenced by the `this` keyword in the
   *     listener. Default is the `target`.
   * @return {EventsKey} Key for unlistenByKey.
   */
  function listenOnce(target, type, listener, opt_this) {
      return listen(target, type, listener, opt_this, true);
  }
  /**
   * Unregisters event listeners on an event target. Inspired by
   * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
   *
   * The argument passed to this function is the key returned from
   * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.
   *
   * @param {EventsKey} key The key.
   */
  function unlistenByKey(key) {
      if (key && key.target) {
          key.target.removeEventListener(key.type, key.listener);
          clear(key);
      }
  }

  var __extends$2 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * An event target providing convenient methods for listener registration
   * and unregistration. A generic `change` event is always available through
   * {@link module:ol/Observable~Observable#changed}.
   *
   * @fires import("./events/Event.js").default
   * @api
   */
  var Observable = /** @class */ (function (_super) {
      __extends$2(Observable, _super);
      function Observable() {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {number}
           */
          _this.revision_ = 0;
          return _this;
      }
      /**
       * Increases the revision counter and dispatches a 'change' event.
       * @api
       */
      Observable.prototype.changed = function () {
          ++this.revision_;
          this.dispatchEvent(EventType.CHANGE);
      };
      /**
       * Get the version number for this object.  Each time the object is modified,
       * its version number will be incremented.
       * @return {number} Revision.
       * @api
       */
      Observable.prototype.getRevision = function () {
          return this.revision_;
      };
      /**
       * Listen for a certain type of event.
       * @param {string|Array<string>} type The event type or array of event types.
       * @param {function(?): ?} listener The listener function.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
       *     called with an array of event types as the first argument, the return
       *     will be an array of keys.
       * @api
       */
      Observable.prototype.on = function (type, listener) {
          if (Array.isArray(type)) {
              var len = type.length;
              var keys = new Array(len);
              for (var i = 0; i < len; ++i) {
                  keys[i] = listen(this, type[i], listener);
              }
              return keys;
          }
          else {
              return listen(this, /** @type {string} */ (type), listener);
          }
      };
      /**
       * Listen once for a certain type of event.
       * @param {string|Array<string>} type The event type or array of event types.
       * @param {function(?): ?} listener The listener function.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
       *     called with an array of event types as the first argument, the return
       *     will be an array of keys.
       * @api
       */
      Observable.prototype.once = function (type, listener) {
          var key;
          if (Array.isArray(type)) {
              var len = type.length;
              key = new Array(len);
              for (var i = 0; i < len; ++i) {
                  key[i] = listenOnce(this, type[i], listener);
              }
          }
          else {
              key = listenOnce(this, /** @type {string} */ (type), listener);
          }
          /** @type {Object} */ (listener).ol_key = key;
          return key;
      };
      /**
       * Unlisten for a certain type of event.
       * @param {string|Array<string>} type The event type or array of event types.
       * @param {function(?): ?} listener The listener function.
       * @api
       */
      Observable.prototype.un = function (type, listener) {
          var key = /** @type {Object} */ (listener).ol_key;
          if (key) {
              unByKey(key);
          }
          else if (Array.isArray(type)) {
              for (var i = 0, ii = type.length; i < ii; ++i) {
                  this.removeEventListener(type[i], listener);
              }
          }
          else {
              this.removeEventListener(type, listener);
          }
      };
      return Observable;
  }(Target));
  /**
   * Removes an event listener using the key returned by `on()` or `once()`.
   * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
   *     or `once()` (or an array of keys).
   * @api
   */
  function unByKey(key) {
      if (Array.isArray(key)) {
          for (var i = 0, ii = key.length; i < ii; ++i) {
              unlistenByKey(key[i]);
          }
      }
      else {
          unlistenByKey(/** @type {import("./events.js").EventsKey} */ (key));
      }
  }

  var __extends$3 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
   */
  var ObjectEvent = /** @class */ (function (_super) {
      __extends$3(ObjectEvent, _super);
      /**
       * @param {string} type The event type.
       * @param {string} key The property name.
       * @param {*} oldValue The old value for `key`.
       */
      function ObjectEvent(type, key, oldValue) {
          var _this = _super.call(this, type) || this;
          /**
           * The name of the property whose value is changing.
           * @type {string}
           * @api
           */
          _this.key = key;
          /**
           * The old value. To get the new value use `e.target.get(e.key)` where
           * `e` is the event object.
           * @type {*}
           * @api
           */
          _this.oldValue = oldValue;
          return _this;
      }
      return ObjectEvent;
  }(BaseEvent));
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Most non-trivial classes inherit from this.
   *
   * This extends {@link module:ol/Observable} with observable
   * properties, where each property is observable as well as the object as a
   * whole.
   *
   * Classes that inherit from this have pre-defined properties, to which you can
   * add your owns. The pre-defined properties are listed in this documentation as
   * 'Observable Properties', and have their own accessors; for example,
   * {@link module:ol/Map~Map} has a `target` property, accessed with
   * `getTarget()` and changed with `setTarget()`. Not all properties are however
   * settable. There are also general-purpose accessors `get()` and `set()`. For
   * example, `get('target')` is equivalent to `getTarget()`.
   *
   * The `set` accessors trigger a change event, and you can monitor this by
   * registering a listener. For example, {@link module:ol/View~View} has a
   * `center` property, so `view.on('change:center', function(evt) {...});` would
   * call the function whenever the value of the center property changes. Within
   * the function, `evt.target` would be the view, so `evt.target.getCenter()`
   * would return the new center.
   *
   * You can add your own observable properties with
   * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
   * You can listen for changes on that property value with
   * `object.on('change:prop', listener)`. You can get a list of all
   * properties with {@link module:ol/Object~BaseObject#getProperties}.
   *
   * Note that the observable properties are separate from standard JS properties.
   * You can, for example, give your map object a title with
   * `map.title='New title'` and with `map.set('title', 'Another title')`. The
   * first will be a `hasOwnProperty`; the second will appear in
   * `getProperties()`. Only the second is observable.
   *
   * Properties can be deleted by using the unset method. E.g.
   * object.unset('foo').
   *
   * @fires ObjectEvent
   * @api
   */
  var BaseObject = /** @class */ (function (_super) {
      __extends$3(BaseObject, _super);
      /**
       * @param {Object<string, *>=} opt_values An object with key-value pairs.
       */
      function BaseObject(opt_values) {
          var _this = _super.call(this) || this;
          // Call {@link module:ol/util~getUid} to ensure that the order of objects' ids is
          // the same as the order in which they were created.  This also helps to
          // ensure that object properties are always added in the same order, which
          // helps many JavaScript engines generate faster code.
          getUid(_this);
          /**
           * @private
           * @type {Object<string, *>}
           */
          _this.values_ = null;
          if (opt_values !== undefined) {
              _this.setProperties(opt_values);
          }
          return _this;
      }
      /**
       * Gets a value.
       * @param {string} key Key name.
       * @return {*} Value.
       * @api
       */
      BaseObject.prototype.get = function (key) {
          var value;
          if (this.values_ && this.values_.hasOwnProperty(key)) {
              value = this.values_[key];
          }
          return value;
      };
      /**
       * Get a list of object property names.
       * @return {Array<string>} List of property names.
       * @api
       */
      BaseObject.prototype.getKeys = function () {
          return (this.values_ && Object.keys(this.values_)) || [];
      };
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>} Object.
       * @api
       */
      BaseObject.prototype.getProperties = function () {
          return (this.values_ && assign({}, this.values_)) || {};
      };
      /**
       * @return {boolean} The object has properties.
       */
      BaseObject.prototype.hasProperties = function () {
          return !!this.values_;
      };
      /**
       * @param {string} key Key name.
       * @param {*} oldValue Old value.
       */
      BaseObject.prototype.notify = function (key, oldValue) {
          var eventType;
          eventType = getChangeEventType(key);
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
          eventType = ObjectEventType.PROPERTYCHANGE;
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
      };
      /**
       * Sets a value.
       * @param {string} key Key name.
       * @param {*} value Value.
       * @param {boolean=} opt_silent Update without triggering an event.
       * @api
       */
      BaseObject.prototype.set = function (key, value, opt_silent) {
          var values = this.values_ || (this.values_ = {});
          if (opt_silent) {
              values[key] = value;
          }
          else {
              var oldValue = values[key];
              values[key] = value;
              if (oldValue !== value) {
                  this.notify(key, oldValue);
              }
          }
      };
      /**
       * Sets a collection of key-value pairs.  Note that this changes any existing
       * properties and adds new ones (it does not remove any existing properties).
       * @param {Object<string, *>} values Values.
       * @param {boolean=} opt_silent Update without triggering an event.
       * @api
       */
      BaseObject.prototype.setProperties = function (values, opt_silent) {
          for (var key in values) {
              this.set(key, values[key], opt_silent);
          }
      };
      /**
       * Unsets a property.
       * @param {string} key Key name.
       * @param {boolean=} opt_silent Unset without triggering an event.
       * @api
       */
      BaseObject.prototype.unset = function (key, opt_silent) {
          if (this.values_ && key in this.values_) {
              var oldValue = this.values_[key];
              delete this.values_[key];
              if (isEmpty(this.values_)) {
                  this.values_ = null;
              }
              if (!opt_silent) {
                  this.notify(key, oldValue);
              }
          }
      };
      return BaseObject;
  }(Observable));
  /**
   * @type {Object<string, string>}
   */
  var changeEventTypeCache = {};
  /**
   * @param {string} key Key name.
   * @return {string} Change name.
   */
  function getChangeEventType(key) {
      return changeEventTypeCache.hasOwnProperty(key)
          ? changeEventTypeCache[key]
          : (changeEventTypeCache[key] = 'change:' + key);
  }

  /**
   * @module ol/CollectionEventType
   */
  /**
   * @enum {string}
   */
  var CollectionEventType = {
      /**
       * Triggered when an item is added to the collection.
       * @event module:ol/Collection.CollectionEvent#add
       * @api
       */
      ADD: 'add',
      /**
       * Triggered when an item is removed from the collection.
       * @event module:ol/Collection.CollectionEvent#remove
       * @api
       */
      REMOVE: 'remove',
  };

  var __extends$4 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @enum {string}
   * @private
   */
  var Property = {
      LENGTH: 'length',
  };
  /**
   * @classdesc
   * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
   * type.
   */
  var CollectionEvent = /** @class */ (function (_super) {
      __extends$4(CollectionEvent, _super);
      /**
       * @param {import("./CollectionEventType.js").default} type Type.
       * @param {*=} opt_element Element.
       * @param {number=} opt_index The index of the added or removed element.
       */
      function CollectionEvent(type, opt_element, opt_index) {
          var _this = _super.call(this, type) || this;
          /**
           * The element that is added to or removed from the collection.
           * @type {*}
           * @api
           */
          _this.element = opt_element;
          /**
           * The index of the added or removed element.
           * @type {number}
           * @api
           */
          _this.index = opt_index;
          return _this;
      }
      return CollectionEvent;
  }(BaseEvent));
  /**
   * @typedef {Object} Options
   * @property {boolean} [unique=false] Disallow the same item from being added to
   * the collection twice.
   */
  /**
   * @classdesc
   * An expanded version of standard JS Array, adding convenience methods for
   * manipulation. Add and remove changes to the Collection trigger a Collection
   * event. Note that this does not cover changes to the objects _within_ the
   * Collection; they trigger events on the appropriate object, not on the
   * Collection as a whole.
   *
   * @fires CollectionEvent
   *
   * @template T
   * @api
   */
  var Collection = /** @class */ (function (_super) {
      __extends$4(Collection, _super);
      /**
       * @param {Array<T>=} opt_array Array.
       * @param {Options=} opt_options Collection options.
       */
      function Collection(opt_array, opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options || {};
          /**
           * @private
           * @type {boolean}
           */
          _this.unique_ = !!options.unique;
          /**
           * @private
           * @type {!Array<T>}
           */
          _this.array_ = opt_array ? opt_array : [];
          if (_this.unique_) {
              for (var i = 0, ii = _this.array_.length; i < ii; ++i) {
                  _this.assertUnique_(_this.array_[i], i);
              }
          }
          _this.updateLength_();
          return _this;
      }
      /**
       * Remove all elements from the collection.
       * @api
       */
      Collection.prototype.clear = function () {
          while (this.getLength() > 0) {
              this.pop();
          }
      };
      /**
       * Add elements to the collection.  This pushes each item in the provided array
       * to the end of the collection.
       * @param {!Array<T>} arr Array.
       * @return {Collection<T>} This collection.
       * @api
       */
      Collection.prototype.extend = function (arr) {
          for (var i = 0, ii = arr.length; i < ii; ++i) {
              this.push(arr[i]);
          }
          return this;
      };
      /**
       * Iterate over each element, calling the provided callback.
       * @param {function(T, number, Array<T>): *} f The function to call
       *     for every element. This function takes 3 arguments (the element, the
       *     index and the array). The return value is ignored.
       * @api
       */
      Collection.prototype.forEach = function (f) {
          var array = this.array_;
          for (var i = 0, ii = array.length; i < ii; ++i) {
              f(array[i], i, array);
          }
      };
      /**
       * Get a reference to the underlying Array object. Warning: if the array
       * is mutated, no events will be dispatched by the collection, and the
       * collection's "length" property won't be in sync with the actual length
       * of the array.
       * @return {!Array<T>} Array.
       * @api
       */
      Collection.prototype.getArray = function () {
          return this.array_;
      };
      /**
       * Get the element at the provided index.
       * @param {number} index Index.
       * @return {T} Element.
       * @api
       */
      Collection.prototype.item = function (index) {
          return this.array_[index];
      };
      /**
       * Get the length of this collection.
       * @return {number} The length of the array.
       * @observable
       * @api
       */
      Collection.prototype.getLength = function () {
          return this.get(Property.LENGTH);
      };
      /**
       * Insert an element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      Collection.prototype.insertAt = function (index, elem) {
          if (this.unique_) {
              this.assertUnique_(elem);
          }
          this.array_.splice(index, 0, elem);
          this.updateLength_();
          this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
      };
      /**
       * Remove the last element of the collection and return it.
       * Return `undefined` if the collection is empty.
       * @return {T|undefined} Element.
       * @api
       */
      Collection.prototype.pop = function () {
          return this.removeAt(this.getLength() - 1);
      };
      /**
       * Insert the provided element at the end of the collection.
       * @param {T} elem Element.
       * @return {number} New length of the collection.
       * @api
       */
      Collection.prototype.push = function (elem) {
          if (this.unique_) {
              this.assertUnique_(elem);
          }
          var n = this.getLength();
          this.insertAt(n, elem);
          return this.getLength();
      };
      /**
       * Remove the first occurrence of an element from the collection.
       * @param {T} elem Element.
       * @return {T|undefined} The removed element or undefined if none found.
       * @api
       */
      Collection.prototype.remove = function (elem) {
          var arr = this.array_;
          for (var i = 0, ii = arr.length; i < ii; ++i) {
              if (arr[i] === elem) {
                  return this.removeAt(i);
              }
          }
          return undefined;
      };
      /**
       * Remove the element at the provided index and return it.
       * Return `undefined` if the collection does not contain this index.
       * @param {number} index Index.
       * @return {T|undefined} Value.
       * @api
       */
      Collection.prototype.removeAt = function (index) {
          var prev = this.array_[index];
          this.array_.splice(index, 1);
          this.updateLength_();
          this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
          return prev;
      };
      /**
       * Set the element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      Collection.prototype.setAt = function (index, elem) {
          var n = this.getLength();
          if (index < n) {
              if (this.unique_) {
                  this.assertUnique_(elem, index);
              }
              var prev = this.array_[index];
              this.array_[index] = elem;
              this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
              this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
          }
          else {
              for (var j = n; j < index; ++j) {
                  this.insertAt(j, undefined);
              }
              this.insertAt(index, elem);
          }
      };
      /**
       * @private
       */
      Collection.prototype.updateLength_ = function () {
          this.set(Property.LENGTH, this.array_.length);
      };
      /**
       * @private
       * @param {T} elem Element.
       * @param {number=} opt_except Optional index to ignore.
       */
      Collection.prototype.assertUnique_ = function (elem, opt_except) {
          for (var i = 0, ii = this.array_.length; i < ii; ++i) {
              if (this.array_[i] === elem && i !== opt_except) {
                  throw new AssertionError(58);
              }
          }
      };
      return Collection;
  }(BaseObject));

  /**
   * @module ol/geom/GeometryType
   */
  /**
   * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
   * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
   * `'GeometryCollection'`, `'Circle'`.
   * @enum {string}
   */
  var GeometryType = {
      POINT: 'Point',
      LINE_STRING: 'LineString',
      LINEAR_RING: 'LinearRing',
      POLYGON: 'Polygon',
      MULTI_POINT: 'MultiPoint',
      MULTI_LINE_STRING: 'MultiLineString',
      MULTI_POLYGON: 'MultiPolygon',
      GEOMETRY_COLLECTION: 'GeometryCollection',
      CIRCLE: 'Circle',
  };

  /**
   * @module ol/proj/Units
   */
  /**
   * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
   * `'us-ft'`.
   * @enum {string}
   */
  var Units = {
      DEGREES: 'degrees',
      FEET: 'ft',
      METERS: 'm',
      PIXELS: 'pixels',
      TILE_PIXELS: 'tile-pixels',
      USFEET: 'us-ft',
  };
  /**
   * Meters per unit lookup table.
   * @const
   * @type {Object<Units, number>}
   * @api
   */
  var METERS_PER_UNIT = {};
  // use the radius of the Normal sphere
  METERS_PER_UNIT[Units.DEGREES] = (2 * Math.PI * 6370997) / 360;
  METERS_PER_UNIT[Units.FEET] = 0.3048;
  METERS_PER_UNIT[Units.METERS] = 1;
  METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;

  /**
   * @module ol/asserts
   */
  /**
   * @param {*} assertion Assertion we expected to be truthy.
   * @param {number} errorCode Error code.
   */
  function assert(assertion, errorCode) {
      if (!assertion) {
          throw new AssertionError(errorCode);
      }
  }

  /**
   * @module ol/transform
   */
  /**
   * Create an identity transform.
   * @return {!Transform} Identity transform.
   */
  function create$2() {
      return [1, 0, 0, 1, 0, 0];
  }
  /**
   * Set the transform components a-f on a given transform.
   * @param {!Transform} transform Transform.
   * @param {number} a The a component of the transform.
   * @param {number} b The b component of the transform.
   * @param {number} c The c component of the transform.
   * @param {number} d The d component of the transform.
   * @param {number} e The e component of the transform.
   * @param {number} f The f component of the transform.
   * @return {!Transform} Matrix with transform applied.
   */
  function set$1(transform, a, b, c, d, e, f) {
      transform[0] = a;
      transform[1] = b;
      transform[2] = c;
      transform[3] = d;
      transform[4] = e;
      transform[5] = f;
      return transform;
  }
  /**
   * Set transform on one matrix from another matrix.
   * @param {!Transform} transform1 Matrix to set transform to.
   * @param {!Transform} transform2 Matrix to set transform from.
   * @return {!Transform} transform1 with transform from transform2 applied.
   */
  function setFromArray(transform1, transform2) {
      transform1[0] = transform2[0];
      transform1[1] = transform2[1];
      transform1[2] = transform2[2];
      transform1[3] = transform2[3];
      transform1[4] = transform2[4];
      transform1[5] = transform2[5];
      return transform1;
  }
  /**
   * Transforms the given coordinate with the given transform returning the
   * resulting, transformed coordinate. The coordinate will be modified in-place.
   *
   * @param {Transform} transform The transformation.
   * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
   * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
   *     chained together.
   */
  function apply$1(transform, coordinate) {
      var x = coordinate[0];
      var y = coordinate[1];
      coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
      coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
      return coordinate;
  }
  /**
   * Creates a scale transform.
   * @param {!Transform} target Transform to overwrite.
   * @param {number} x Scale factor x.
   * @param {number} y Scale factor y.
   * @return {!Transform} The scale transform.
   */
  function makeScale(target, x, y) {
      return set$1(target, x, 0, 0, y, 0, 0);
  }
  /**
   * Creates a composite transform given an initial translation, scale, rotation, and
   * final translation (in that order only, not commutative).
   * @param {!Transform} transform The transform (will be modified in place).
   * @param {number} dx1 Initial translation x.
   * @param {number} dy1 Initial translation y.
   * @param {number} sx Scale factor x.
   * @param {number} sy Scale factor y.
   * @param {number} angle Rotation (in counter-clockwise radians).
   * @param {number} dx2 Final translation x.
   * @param {number} dy2 Final translation y.
   * @return {!Transform} The composite transform.
   */
  function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
      var sin = Math.sin(angle);
      var cos = Math.cos(angle);
      transform[0] = sx * cos;
      transform[1] = sy * sin;
      transform[2] = -sx * sin;
      transform[3] = sy * cos;
      transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
      transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
      return transform;
  }
  /**
   * Invert the given transform.
   * @param {!Transform} target Transform to be set as the inverse of
   *     the source transform.
   * @param {!Transform} source The source transform to invert.
   * @return {!Transform} The inverted (target) transform.
   */
  function makeInverse(target, source) {
      var det = determinant(source);
      assert(det !== 0, 32); // Transformation matrix cannot be inverted
      var a = source[0];
      var b = source[1];
      var c = source[2];
      var d = source[3];
      var e = source[4];
      var f = source[5];
      target[0] = d / det;
      target[1] = -b / det;
      target[2] = -c / det;
      target[3] = a / det;
      target[4] = (c * f - d * e) / det;
      target[5] = -(a * f - b * e) / det;
      return target;
  }
  /**
   * Returns the determinant of the given matrix.
   * @param {!Transform} mat Matrix.
   * @return {number} Determinant.
   */
  function determinant(mat) {
      return mat[0] * mat[3] - mat[1] * mat[2];
  }
  /**
   * A string version of the transform.  This can be used
   * for CSS transforms.
   * @param {!Transform} mat Matrix.
   * @return {string} The transform as a string.
   */
  function toString(mat) {
      return 'matrix(' + mat.join(', ') + ')';
  }

  /**
   * @module ol/extent/Corner
   */
  /**
   * Extent corner.
   * @enum {string}
   */
  var Corner = {
      BOTTOM_LEFT: 'bottom-left',
      BOTTOM_RIGHT: 'bottom-right',
      TOP_LEFT: 'top-left',
      TOP_RIGHT: 'top-right',
  };

  /**
   * @module ol/extent/Relationship
   */
  /**
   * Relationship to an extent.
   * @enum {number}
   */
  var Relationship = {
      UNKNOWN: 0,
      INTERSECTING: 1,
      ABOVE: 2,
      RIGHT: 4,
      BELOW: 8,
      LEFT: 16,
  };

  /**
   * @module ol/extent
   */
  /**
   * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
   * @typedef {Array<number>} Extent
   * @api
   */
  /**
   * Build an extent that includes all given coordinates.
   *
   * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
   * @return {Extent} Bounding extent.
   * @api
   */
  function boundingExtent(coordinates) {
      var extent = createEmpty();
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
          extendCoordinate(extent, coordinates[i]);
      }
      return extent;
  }
  /**
   * @param {Array<number>} xs Xs.
   * @param {Array<number>} ys Ys.
   * @param {Extent=} opt_extent Destination extent.
   * @private
   * @return {Extent} Extent.
   */
  function _boundingExtentXYs(xs, ys, opt_extent) {
      var minX = Math.min.apply(null, xs);
      var minY = Math.min.apply(null, ys);
      var maxX = Math.max.apply(null, xs);
      var maxY = Math.max.apply(null, ys);
      return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
  }
  /**
   * Return extent increased by the provided value.
   * @param {Extent} extent Extent.
   * @param {number} value The amount by which the extent should be buffered.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   * @api
   */
  function buffer(extent, value, opt_extent) {
      if (opt_extent) {
          opt_extent[0] = extent[0] - value;
          opt_extent[1] = extent[1] - value;
          opt_extent[2] = extent[2] + value;
          opt_extent[3] = extent[3] + value;
          return opt_extent;
      }
      else {
          return [
              extent[0] - value,
              extent[1] - value,
              extent[2] + value,
              extent[3] + value,
          ];
      }
  }
  /**
   * Creates a clone of an extent.
   *
   * @param {Extent} extent Extent to clone.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} The clone.
   */
  function clone$2(extent, opt_extent) {
      if (opt_extent) {
          opt_extent[0] = extent[0];
          opt_extent[1] = extent[1];
          opt_extent[2] = extent[2];
          opt_extent[3] = extent[3];
          return opt_extent;
      }
      else {
          return extent.slice();
      }
  }
  /**
   * @param {Extent} extent Extent.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {number} Closest squared distance.
   */
  function closestSquaredDistanceXY(extent, x, y) {
      var dx, dy;
      if (x < extent[0]) {
          dx = extent[0] - x;
      }
      else if (extent[2] < x) {
          dx = x - extent[2];
      }
      else {
          dx = 0;
      }
      if (y < extent[1]) {
          dy = extent[1] - y;
      }
      else if (extent[3] < y) {
          dy = y - extent[3];
      }
      else {
          dy = 0;
      }
      return dx * dx + dy * dy;
  }
  /**
   * Check if the passed coordinate is contained or on the edge of the extent.
   *
   * @param {Extent} extent Extent.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} The coordinate is contained in the extent.
   * @api
   */
  function containsCoordinate(extent, coordinate) {
      return containsXY(extent, coordinate[0], coordinate[1]);
  }
  /**
   * Check if one extent contains another.
   *
   * An extent is deemed contained if it lies completely within the other extent,
   * including if they share one or more edges.
   *
   * @param {Extent} extent1 Extent 1.
   * @param {Extent} extent2 Extent 2.
   * @return {boolean} The second extent is contained by or on the edge of the
   *     first.
   * @api
   */
  function containsExtent(extent1, extent2) {
      return (extent1[0] <= extent2[0] &&
          extent2[2] <= extent1[2] &&
          extent1[1] <= extent2[1] &&
          extent2[3] <= extent1[3]);
  }
  /**
   * Check if the passed coordinate is contained or on the edge of the extent.
   *
   * @param {Extent} extent Extent.
   * @param {number} x X coordinate.
   * @param {number} y Y coordinate.
   * @return {boolean} The x, y values are contained in the extent.
   * @api
   */
  function containsXY(extent, x, y) {
      return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
  }
  /**
   * Get the relationship between a coordinate and extent.
   * @param {Extent} extent The extent.
   * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
   * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
   *     import("./extent/Relationship.js").Relationship).
   */
  function coordinateRelationship(extent, coordinate) {
      var minX = extent[0];
      var minY = extent[1];
      var maxX = extent[2];
      var maxY = extent[3];
      var x = coordinate[0];
      var y = coordinate[1];
      var relationship = Relationship.UNKNOWN;
      if (x < minX) {
          relationship = relationship | Relationship.LEFT;
      }
      else if (x > maxX) {
          relationship = relationship | Relationship.RIGHT;
      }
      if (y < minY) {
          relationship = relationship | Relationship.BELOW;
      }
      else if (y > maxY) {
          relationship = relationship | Relationship.ABOVE;
      }
      if (relationship === Relationship.UNKNOWN) {
          relationship = Relationship.INTERSECTING;
      }
      return relationship;
  }
  /**
   * Create an empty extent.
   * @return {Extent} Empty extent.
   * @api
   */
  function createEmpty() {
      return [Infinity, Infinity, -Infinity, -Infinity];
  }
  /**
   * Create a new extent or update the provided extent.
   * @param {number} minX Minimum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxX Maximum X.
   * @param {number} maxY Maximum Y.
   * @param {Extent=} opt_extent Destination extent.
   * @return {Extent} Extent.
   */
  function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
      if (opt_extent) {
          opt_extent[0] = minX;
          opt_extent[1] = minY;
          opt_extent[2] = maxX;
          opt_extent[3] = maxY;
          return opt_extent;
      }
      else {
          return [minX, minY, maxX, maxY];
      }
  }
  /**
   * Create a new empty extent or make the provided one empty.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   */
  function createOrUpdateEmpty(opt_extent) {
      return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   */
  function createOrUpdateFromCoordinate(coordinate, opt_extent) {
      var x = coordinate[0];
      var y = coordinate[1];
      return createOrUpdate(x, y, x, y, opt_extent);
  }
  /**
   * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   */
  function createOrUpdateFromCoordinates(coordinates, opt_extent) {
      var extent = createOrUpdateEmpty(opt_extent);
      return extendCoordinates(extent, coordinates);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   */
  function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
      var extent = createOrUpdateEmpty(opt_extent);
      return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
  }
  /**
   * Determine if two extents are equivalent.
   * @param {Extent} extent1 Extent 1.
   * @param {Extent} extent2 Extent 2.
   * @return {boolean} The two extents are equivalent.
   * @api
   */
  function equals$1(extent1, extent2) {
      return (extent1[0] == extent2[0] &&
          extent1[2] == extent2[2] &&
          extent1[1] == extent2[1] &&
          extent1[3] == extent2[3]);
  }
  /**
   * Modify an extent to include another extent.
   * @param {Extent} extent1 The extent to be modified.
   * @param {Extent} extent2 The extent that will be included in the first.
   * @return {Extent} A reference to the first (extended) extent.
   * @api
   */
  function extend$2(extent1, extent2) {
      if (extent2[0] < extent1[0]) {
          extent1[0] = extent2[0];
      }
      if (extent2[2] > extent1[2]) {
          extent1[2] = extent2[2];
      }
      if (extent2[1] < extent1[1]) {
          extent1[1] = extent2[1];
      }
      if (extent2[3] > extent1[3]) {
          extent1[3] = extent2[3];
      }
      return extent1;
  }
  /**
   * @param {Extent} extent Extent.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   */
  function extendCoordinate(extent, coordinate) {
      if (coordinate[0] < extent[0]) {
          extent[0] = coordinate[0];
      }
      if (coordinate[0] > extent[2]) {
          extent[2] = coordinate[0];
      }
      if (coordinate[1] < extent[1]) {
          extent[1] = coordinate[1];
      }
      if (coordinate[1] > extent[3]) {
          extent[3] = coordinate[1];
      }
  }
  /**
   * @param {Extent} extent Extent.
   * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
   * @return {Extent} Extent.
   */
  function extendCoordinates(extent, coordinates) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
          extendCoordinate(extent, coordinates[i]);
      }
      return extent;
  }
  /**
   * @param {Extent} extent Extent.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {Extent} Extent.
   */
  function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
      for (; offset < end; offset += stride) {
          extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
      }
      return extent;
  }
  /**
   * @param {Extent} extent Extent.
   * @param {number} x X.
   * @param {number} y Y.
   */
  function extendXY(extent, x, y) {
      extent[0] = Math.min(extent[0], x);
      extent[1] = Math.min(extent[1], y);
      extent[2] = Math.max(extent[2], x);
      extent[3] = Math.max(extent[3], y);
  }
  /**
   * This function calls `callback` for each corner of the extent. If the
   * callback returns a truthy value the function returns that value
   * immediately. Otherwise the function returns `false`.
   * @param {Extent} extent Extent.
   * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
   * @return {S|boolean} Value.
   * @template S
   */
  function forEachCorner(extent, callback) {
      var val;
      val = callback(getBottomLeft(extent));
      if (val) {
          return val;
      }
      val = callback(getBottomRight(extent));
      if (val) {
          return val;
      }
      val = callback(getTopRight(extent));
      if (val) {
          return val;
      }
      val = callback(getTopLeft(extent));
      if (val) {
          return val;
      }
      return false;
  }
  /**
   * Get the size of an extent.
   * @param {Extent} extent Extent.
   * @return {number} Area.
   * @api
   */
  function getArea(extent) {
      var area = 0;
      if (!isEmpty$1(extent)) {
          area = getWidth(extent) * getHeight(extent);
      }
      return area;
  }
  /**
   * Get the bottom left coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
   * @api
   */
  function getBottomLeft(extent) {
      return [extent[0], extent[1]];
  }
  /**
   * Get the bottom right coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
   * @api
   */
  function getBottomRight(extent) {
      return [extent[2], extent[1]];
  }
  /**
   * Get the center coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Center.
   * @api
   */
  function getCenter(extent) {
      return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
  }
  /**
   * Get a corner coordinate of an extent.
   * @param {Extent} extent Extent.
   * @param {import("./extent/Corner.js").default} corner Corner.
   * @return {import("./coordinate.js").Coordinate} Corner coordinate.
   */
  function getCorner(extent, corner) {
      var coordinate;
      if (corner === Corner.BOTTOM_LEFT) {
          coordinate = getBottomLeft(extent);
      }
      else if (corner === Corner.BOTTOM_RIGHT) {
          coordinate = getBottomRight(extent);
      }
      else if (corner === Corner.TOP_LEFT) {
          coordinate = getTopLeft(extent);
      }
      else if (corner === Corner.TOP_RIGHT) {
          coordinate = getTopRight(extent);
      }
      else {
          assert(false, 13); // Invalid corner
      }
      return coordinate;
  }
  /**
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @param {Extent=} opt_extent Destination extent.
   * @return {Extent} Extent.
   */
  function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
      var dx = (resolution * size[0]) / 2;
      var dy = (resolution * size[1]) / 2;
      var cosRotation = Math.cos(rotation);
      var sinRotation = Math.sin(rotation);
      var xCos = dx * cosRotation;
      var xSin = dx * sinRotation;
      var yCos = dy * cosRotation;
      var ySin = dy * sinRotation;
      var x = center[0];
      var y = center[1];
      var x0 = x - xCos + ySin;
      var x1 = x - xCos - ySin;
      var x2 = x + xCos - ySin;
      var x3 = x + xCos + ySin;
      var y0 = y - xSin - yCos;
      var y1 = y - xSin + yCos;
      var y2 = y + xSin + yCos;
      var y3 = y + xSin - yCos;
      return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
  }
  /**
   * Get the height of an extent.
   * @param {Extent} extent Extent.
   * @return {number} Height.
   * @api
   */
  function getHeight(extent) {
      return extent[3] - extent[1];
  }
  /**
   * Get the intersection of two extents.
   * @param {Extent} extent1 Extent 1.
   * @param {Extent} extent2 Extent 2.
   * @param {Extent=} opt_extent Optional extent to populate with intersection.
   * @return {Extent} Intersecting extent.
   * @api
   */
  function getIntersection(extent1, extent2, opt_extent) {
      var intersection = opt_extent ? opt_extent : createEmpty();
      if (intersects(extent1, extent2)) {
          if (extent1[0] > extent2[0]) {
              intersection[0] = extent1[0];
          }
          else {
              intersection[0] = extent2[0];
          }
          if (extent1[1] > extent2[1]) {
              intersection[1] = extent1[1];
          }
          else {
              intersection[1] = extent2[1];
          }
          if (extent1[2] < extent2[2]) {
              intersection[2] = extent1[2];
          }
          else {
              intersection[2] = extent2[2];
          }
          if (extent1[3] < extent2[3]) {
              intersection[3] = extent1[3];
          }
          else {
              intersection[3] = extent2[3];
          }
      }
      else {
          createOrUpdateEmpty(intersection);
      }
      return intersection;
  }
  /**
   * Get the top left coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Top left coordinate.
   * @api
   */
  function getTopLeft(extent) {
      return [extent[0], extent[3]];
  }
  /**
   * Get the top right coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Top right coordinate.
   * @api
   */
  function getTopRight(extent) {
      return [extent[2], extent[3]];
  }
  /**
   * Get the width of an extent.
   * @param {Extent} extent Extent.
   * @return {number} Width.
   * @api
   */
  function getWidth(extent) {
      return extent[2] - extent[0];
  }
  /**
   * Determine if one extent intersects another.
   * @param {Extent} extent1 Extent 1.
   * @param {Extent} extent2 Extent.
   * @return {boolean} The two extents intersect.
   * @api
   */
  function intersects(extent1, extent2) {
      return (extent1[0] <= extent2[2] &&
          extent1[2] >= extent2[0] &&
          extent1[1] <= extent2[3] &&
          extent1[3] >= extent2[1]);
  }
  /**
   * Determine if an extent is empty.
   * @param {Extent} extent Extent.
   * @return {boolean} Is empty.
   * @api
   */
  function isEmpty$1(extent) {
      return extent[2] < extent[0] || extent[3] < extent[1];
  }
  /**
   * @param {Extent} extent Extent.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   */
  function returnOrUpdate(extent, opt_extent) {
      if (opt_extent) {
          opt_extent[0] = extent[0];
          opt_extent[1] = extent[1];
          opt_extent[2] = extent[2];
          opt_extent[3] = extent[3];
          return opt_extent;
      }
      else {
          return extent;
      }
  }
  /**
   * @param {Extent} extent Extent.
   * @param {number} value Value.
   */
  function scaleFromCenter(extent, value) {
      var deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);
      var deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);
      extent[0] -= deltaX;
      extent[2] += deltaX;
      extent[1] -= deltaY;
      extent[3] += deltaY;
  }
  /**
   * Determine if the segment between two coordinates intersects (crosses,
   * touches, or is contained by) the provided extent.
   * @param {Extent} extent The extent.
   * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
   * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
   * @return {boolean} The segment intersects the extent.
   */
  function intersectsSegment(extent, start, end) {
      var intersects = false;
      var startRel = coordinateRelationship(extent, start);
      var endRel = coordinateRelationship(extent, end);
      if (startRel === Relationship.INTERSECTING ||
          endRel === Relationship.INTERSECTING) {
          intersects = true;
      }
      else {
          var minX = extent[0];
          var minY = extent[1];
          var maxX = extent[2];
          var maxY = extent[3];
          var startX = start[0];
          var startY = start[1];
          var endX = end[0];
          var endY = end[1];
          var slope = (endY - startY) / (endX - startX);
          var x = void 0, y = void 0;
          if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {
              // potentially intersects top
              x = endX - (endY - maxY) / slope;
              intersects = x >= minX && x <= maxX;
          }
          if (!intersects &&
              !!(endRel & Relationship.RIGHT) &&
              !(startRel & Relationship.RIGHT)) {
              // potentially intersects right
              y = endY - (endX - maxX) * slope;
              intersects = y >= minY && y <= maxY;
          }
          if (!intersects &&
              !!(endRel & Relationship.BELOW) &&
              !(startRel & Relationship.BELOW)) {
              // potentially intersects bottom
              x = endX - (endY - minY) / slope;
              intersects = x >= minX && x <= maxX;
          }
          if (!intersects &&
              !!(endRel & Relationship.LEFT) &&
              !(startRel & Relationship.LEFT)) {
              // potentially intersects left
              y = endY - (endX - minX) * slope;
              intersects = y >= minY && y <= maxY;
          }
      }
      return intersects;
  }
  /**
   * Apply a transform function to the extent.
   * @param {Extent} extent Extent.
   * @param {import("./proj.js").TransformFunction} transformFn Transform function.
   * Called with `[minX, minY, maxX, maxY]` extent coordinates.
   * @param {Extent=} opt_extent Destination extent.
   * @param {number=} opt_stops Number of stops per side used for the transform.
   * By default only the corners are used.
   * @return {Extent} Extent.
   * @api
   */
  function applyTransform$1(extent, transformFn, opt_extent, opt_stops) {
      var coordinates = [];
      if (opt_stops > 1) {
          var width = extent[2] - extent[0];
          var height = extent[3] - extent[1];
          for (var i = 0; i < opt_stops; ++i) {
              coordinates.push(extent[0] + (width * i) / opt_stops, extent[1], extent[2], extent[1] + (height * i) / opt_stops, extent[2] - (width * i) / opt_stops, extent[3], extent[0], extent[3] - (height * i) / opt_stops);
          }
      }
      else {
          coordinates = [
              extent[0],
              extent[1],
              extent[2],
              extent[1],
              extent[2],
              extent[3],
              extent[0],
              extent[3],
          ];
      }
      transformFn(coordinates, coordinates, 2);
      var xs = [];
      var ys = [];
      for (var i = 0, l = coordinates.length; i < l; i += 2) {
          xs.push(coordinates[i]);
          ys.push(coordinates[i + 1]);
      }
      return _boundingExtentXYs(xs, ys, opt_extent);
  }
  /**
   * Modifies the provided extent in-place to be within the real world
   * extent.
   *
   * @param {Extent} extent Extent.
   * @param {import("./proj/Projection.js").default} projection Projection
   * @return {Extent} The extent within the real world extent.
   */
  function wrapX(extent, projection) {
      var projectionExtent = projection.getExtent();
      var center = getCenter(extent);
      if (projection.canWrapX() &&
          (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
          var worldWidth = getWidth(projectionExtent);
          var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
          var offset = worldsAway * worldWidth;
          extent[0] -= offset;
          extent[2] -= offset;
      }
      return extent;
  }

  /**
   * @module ol/proj/Projection
   */
  /**
   * @typedef {Object} Options
   * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
   * @property {import("./Units.js").default|string} [units] Units. Required unless a
   * proj4 projection is defined for `code`.
   * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
   * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
   * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
   * @property {number} [metersPerUnit] The meters per unit for the SRS.
   * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
   * lookup table.
   * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
   * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
   * Function to determine resolution at a point. The function is called with a
   * `{number}` view resolution and an `{import("../coordinate.js").Coordinate}` as arguments, and returns
   * the `{number}` resolution in projection units at the passed coordinate. If this is `undefined`,
   * the default {@link module:ol/proj#getPointResolution} function will be used.
   */
  /**
   * @classdesc
   * Projection definition class. One of these is created for each projection
   * supported in the application and stored in the {@link module:ol/proj} namespace.
   * You can use these in applications, but this is not required, as API params
   * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
   * code will suffice.
   *
   * You can use {@link module:ol/proj~get} to retrieve the object for a particular
   * projection.
   *
   * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
   * with the following aliases:
   * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
   *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
   *     http://www.opengis.net/gml/srs/epsg.xml#4326,
   *     urn:x-ogc:def:crs:EPSG:4326
   * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
   *     urn:ogc:def:crs:EPSG:6.18:3:3857,
   *     http://www.opengis.net/gml/srs/epsg.xml#3857
   *
   * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
   * be added using `proj4.defs()`. After all required projection definitions are
   * added, call the {@link module:ol/proj/proj4~register} function.
   *
   * @api
   */
  var Projection = /** @class */ (function () {
      /**
       * @param {Options} options Projection options.
       */
      function Projection(options) {
          /**
           * @private
           * @type {string}
           */
          this.code_ = options.code;
          /**
           * Units of projected coordinates. When set to `TILE_PIXELS`, a
           * `this.extent_` and `this.worldExtent_` must be configured properly for each
           * tile.
           * @private
           * @type {import("./Units.js").default}
           */
          this.units_ = /** @type {import("./Units.js").default} */ (options.units);
          /**
           * Validity extent of the projection in projected coordinates. For projections
           * with `TILE_PIXELS` units, this is the extent of the tile in
           * tile pixel space.
           * @private
           * @type {import("../extent.js").Extent}
           */
          this.extent_ = options.extent !== undefined ? options.extent : null;
          /**
           * Extent of the world in EPSG:4326. For projections with
           * `TILE_PIXELS` units, this is the extent of the tile in
           * projected coordinate space.
           * @private
           * @type {import("../extent.js").Extent}
           */
          this.worldExtent_ =
              options.worldExtent !== undefined ? options.worldExtent : null;
          /**
           * @private
           * @type {string}
           */
          this.axisOrientation_ =
              options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
          /**
           * @private
           * @type {boolean}
           */
          this.global_ = options.global !== undefined ? options.global : false;
          /**
           * @private
           * @type {boolean}
           */
          this.canWrapX_ = !!(this.global_ && this.extent_);
          /**
           * @private
           * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
           */
          this.getPointResolutionFunc_ = options.getPointResolution;
          /**
           * @private
           * @type {import("../tilegrid/TileGrid.js").default}
           */
          this.defaultTileGrid_ = null;
          /**
           * @private
           * @type {number|undefined}
           */
          this.metersPerUnit_ = options.metersPerUnit;
      }
      /**
       * @return {boolean} The projection is suitable for wrapping the x-axis
       */
      Projection.prototype.canWrapX = function () {
          return this.canWrapX_;
      };
      /**
       * Get the code for this projection, e.g. 'EPSG:4326'.
       * @return {string} Code.
       * @api
       */
      Projection.prototype.getCode = function () {
          return this.code_;
      };
      /**
       * Get the validity extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      Projection.prototype.getExtent = function () {
          return this.extent_;
      };
      /**
       * Get the units of this projection.
       * @return {import("./Units.js").default} Units.
       * @api
       */
      Projection.prototype.getUnits = function () {
          return this.units_;
      };
      /**
       * Get the amount of meters per unit of this projection.  If the projection is
       * not configured with `metersPerUnit` or a units identifier, the return is
       * `undefined`.
       * @return {number|undefined} Meters.
       * @api
       */
      Projection.prototype.getMetersPerUnit = function () {
          return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
      };
      /**
       * Get the world extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      Projection.prototype.getWorldExtent = function () {
          return this.worldExtent_;
      };
      /**
       * Get the axis orientation of this projection.
       * Example values are:
       * enu - the default easting, northing, elevation.
       * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
       *     or south orientated transverse mercator.
       * wnu - westing, northing, up - some planetary coordinate systems have
       *     "west positive" coordinate systems
       * @return {string} Axis orientation.
       * @api
       */
      Projection.prototype.getAxisOrientation = function () {
          return this.axisOrientation_;
      };
      /**
       * Is this projection a global projection which spans the whole world?
       * @return {boolean} Whether the projection is global.
       * @api
       */
      Projection.prototype.isGlobal = function () {
          return this.global_;
      };
      /**
       * Set if the projection is a global projection which spans the whole world
       * @param {boolean} global Whether the projection is global.
       * @api
       */
      Projection.prototype.setGlobal = function (global) {
          this.global_ = global;
          this.canWrapX_ = !!(global && this.extent_);
      };
      /**
       * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
       */
      Projection.prototype.getDefaultTileGrid = function () {
          return this.defaultTileGrid_;
      };
      /**
       * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
       */
      Projection.prototype.setDefaultTileGrid = function (tileGrid) {
          this.defaultTileGrid_ = tileGrid;
      };
      /**
       * Set the validity extent for this projection.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */
      Projection.prototype.setExtent = function (extent) {
          this.extent_ = extent;
          this.canWrapX_ = !!(this.global_ && extent);
      };
      /**
       * Set the world extent for this projection.
       * @param {import("../extent.js").Extent} worldExtent World extent
       *     [minlon, minlat, maxlon, maxlat].
       * @api
       */
      Projection.prototype.setWorldExtent = function (worldExtent) {
          this.worldExtent_ = worldExtent;
      };
      /**
       * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}
       * for this projection.
       * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
       * @api
       */
      Projection.prototype.setGetPointResolution = function (func) {
          this.getPointResolutionFunc_ = func;
      };
      /**
       * Get the custom point resolution function for this projection (if set).
       * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
       * resolution function (if set).
       */
      Projection.prototype.getPointResolutionFunc = function () {
          return this.getPointResolutionFunc_;
      };
      return Projection;
  }());

  /**
   * @module ol/math
   */
  /**
   * Takes a number and clamps it to within the provided bounds.
   * @param {number} value The input number.
   * @param {number} min The minimum value to return.
   * @param {number} max The maximum value to return.
   * @return {number} The input number if it is within bounds, or the nearest
   *     number within the bounds.
   */
  function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
  }
  /**
   * Return the hyperbolic cosine of a given number. The method will use the
   * native `Math.cosh` function if it is available, otherwise the hyperbolic
   * cosine will be calculated via the reference implementation of the Mozilla
   * developer network.
   *
   * @param {number} x X.
   * @return {number} Hyperbolic cosine of x.
   */
  var cosh$2 = (function () {
      // Wrapped in a iife, to save the overhead of checking for the native
      // implementation on every invocation.
      var cosh;
      if ('cosh' in Math) {
          // The environment supports the native Math.cosh function, use it
          cosh = Math.cosh;
      }
      else {
          //  else, use the reference implementation of MDN:
          cosh = function (x) {
              var y = /** @type {Math} */ (Math).exp(x);
              return (y + 1 / y) / 2;
          };
      }
      return cosh;
  })();
  /**
   * Return the base 2 logarithm of a given number. The method will use the
   * native `Math.log2` function if it is available, otherwise the base 2
   * logarithm will be calculated via the reference implementation of the
   * Mozilla developer network.
   *
   * @param {number} x X.
   * @return {number} Base 2 logarithm of x.
   */
  var log2$2 = (function () {
      // Wrapped in a iife, to save the overhead of checking for the native
      // implementation on every invocation.
      var log2;
      if ('log2' in Math) {
          // The environment supports the native Math.log2 function, use it
          log2 = Math.log2;
      }
      else {
          //  else, use the reference implementation of MDN:
          log2 = function (x) {
              return Math.log(x) * Math.LOG2E;
          };
      }
      return log2;
  })();
  /**
   * Returns the square of the closest distance between the point (x, y) and the
   * line segment (x1, y1) to (x2, y2).
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} x1 X1.
   * @param {number} y1 Y1.
   * @param {number} x2 X2.
   * @param {number} y2 Y2.
   * @return {number} Squared distance.
   */
  function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
      var dx = x2 - x1;
      var dy = y2 - y1;
      if (dx !== 0 || dy !== 0) {
          var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
          if (t > 1) {
              x1 = x2;
              y1 = y2;
          }
          else if (t > 0) {
              x1 += dx * t;
              y1 += dy * t;
          }
      }
      return squaredDistance(x, y, x1, y1);
  }
  /**
   * Returns the square of the distance between the points (x1, y1) and (x2, y2).
   * @param {number} x1 X1.
   * @param {number} y1 Y1.
   * @param {number} x2 X2.
   * @param {number} y2 Y2.
   * @return {number} Squared distance.
   */
  function squaredDistance(x1, y1, x2, y2) {
      var dx = x2 - x1;
      var dy = y2 - y1;
      return dx * dx + dy * dy;
  }
  /**
   * Solves system of linear equations using Gaussian elimination method.
   *
   * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
   *                                     in row-major order.
   * @return {Array<number>} The resulting vector.
   */
  function solveLinearSystem(mat) {
      var n = mat.length;
      for (var i = 0; i < n; i++) {
          // Find max in the i-th column (ignoring i - 1 first rows)
          var maxRow = i;
          var maxEl = Math.abs(mat[i][i]);
          for (var r = i + 1; r < n; r++) {
              var absValue = Math.abs(mat[r][i]);
              if (absValue > maxEl) {
                  maxEl = absValue;
                  maxRow = r;
              }
          }
          if (maxEl === 0) {
              return null; // matrix is singular
          }
          // Swap max row with i-th (current) row
          var tmp = mat[maxRow];
          mat[maxRow] = mat[i];
          mat[i] = tmp;
          // Subtract the i-th row to make all the remaining rows 0 in the i-th column
          for (var j = i + 1; j < n; j++) {
              var coef = -mat[j][i] / mat[i][i];
              for (var k = i; k < n + 1; k++) {
                  if (i == k) {
                      mat[j][k] = 0;
                  }
                  else {
                      mat[j][k] += coef * mat[i][k];
                  }
              }
          }
      }
      // Solve Ax=b for upper triangular matrix A (mat)
      var x = new Array(n);
      for (var l = n - 1; l >= 0; l--) {
          x[l] = mat[l][n] / mat[l][l];
          for (var m = l - 1; m >= 0; m--) {
              mat[m][n] -= mat[m][l] * x[l];
          }
      }
      return x;
  }
  /**
   * Converts degrees to radians.
   *
   * @param {number} angleInDegrees Angle in degrees.
   * @return {number} Angle in radians.
   */
  function toRadians(angleInDegrees) {
      return (angleInDegrees * Math.PI) / 180;
  }
  /**
   * Returns the modulo of a / b, depending on the sign of b.
   *
   * @param {number} a Dividend.
   * @param {number} b Divisor.
   * @return {number} Modulo.
   */
  function modulo(a, b) {
      var r = a % b;
      return r * b < 0 ? r + b : r;
  }
  /**
   * Calculates the linearly interpolated value of x between a and b.
   *
   * @param {number} a Number
   * @param {number} b Number
   * @param {number} x Value to be interpolated.
   * @return {number} Interpolated value.
   */
  function lerp(a, b, x) {
      return a + x * (b - a);
  }

  var __extends$5 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Radius of WGS84 sphere
   *
   * @const
   * @type {number}
   */
  var RADIUS = 6378137;
  /**
   * @const
   * @type {number}
   */
  var HALF_SIZE = Math.PI * RADIUS;
  /**
   * @const
   * @type {import("../extent.js").Extent}
   */
  var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
  /**
   * @const
   * @type {import("../extent.js").Extent}
   */
  var WORLD_EXTENT = [-180, -85, 180, 85];
  /**
   * @classdesc
   * Projection object for web/spherical Mercator (EPSG:3857).
   */
  var EPSG3857Projection = /** @class */ (function (_super) {
      __extends$5(EPSG3857Projection, _super);
      /**
       * @param {string} code Code.
       */
      function EPSG3857Projection(code) {
          return _super.call(this, {
              code: code,
              units: Units.METERS,
              extent: EXTENT,
              global: true,
              worldExtent: WORLD_EXTENT,
              getPointResolution: function (resolution, point) {
                  return resolution / cosh$2(point[1] / RADIUS);
              },
          }) || this;
      }
      return EPSG3857Projection;
  }(Projection));
  /**
   * Projections equal to EPSG:3857.
   *
   * @const
   * @type {Array<import("./Projection.js").default>}
   */
  var PROJECTIONS = [
      new EPSG3857Projection('EPSG:3857'),
      new EPSG3857Projection('EPSG:102100'),
      new EPSG3857Projection('EPSG:102113'),
      new EPSG3857Projection('EPSG:900913'),
      new EPSG3857Projection('urn:ogc:def:crs:EPSG:6.18:3:3857'),
      new EPSG3857Projection('urn:ogc:def:crs:EPSG::3857'),
      new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),
  ];
  /**
   * Transformation from EPSG:4326 to EPSG:3857.
   *
   * @param {Array<number>} input Input array of coordinate values.
   * @param {Array<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension (default is `2`).
   * @return {Array<number>} Output array of coordinate values.
   */
  function fromEPSG4326(input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension > 1 ? opt_dimension : 2;
      var output = opt_output;
      if (output === undefined) {
          if (dimension > 2) {
              // preserve values beyond second dimension
              output = input.slice();
          }
          else {
              output = new Array(length);
          }
      }
      var halfSize = HALF_SIZE;
      for (var i = 0; i < length; i += dimension) {
          output[i] = (halfSize * input[i]) / 180;
          var y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));
          if (y > halfSize) {
              y = halfSize;
          }
          else if (y < -halfSize) {
              y = -halfSize;
          }
          output[i + 1] = y;
      }
      return output;
  }
  /**
   * Transformation from EPSG:3857 to EPSG:4326.
   *
   * @param {Array<number>} input Input array of coordinate values.
   * @param {Array<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension (default is `2`).
   * @return {Array<number>} Output array of coordinate values.
   */
  function toEPSG4326(input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension > 1 ? opt_dimension : 2;
      var output = opt_output;
      if (output === undefined) {
          if (dimension > 2) {
              // preserve values beyond second dimension
              output = input.slice();
          }
          else {
              output = new Array(length);
          }
      }
      for (var i = 0; i < length; i += dimension) {
          output[i] = (180 * input[i]) / HALF_SIZE;
          output[i + 1] =
              (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;
      }
      return output;
  }

  var __extends$6 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Semi-major radius of the WGS84 ellipsoid.
   *
   * @const
   * @type {number}
   */
  var RADIUS$1 = 6378137;
  /**
   * Extent of the EPSG:4326 projection which is the whole world.
   *
   * @const
   * @type {import("../extent.js").Extent}
   */
  var EXTENT$1 = [-180, -90, 180, 90];
  /**
   * @const
   * @type {number}
   */
  var METERS_PER_UNIT$1 = (Math.PI * RADIUS$1) / 180;
  /**
   * @classdesc
   * Projection object for WGS84 geographic coordinates (EPSG:4326).
   *
   * Note that OpenLayers does not strictly comply with the EPSG definition.
   * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
   * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
   */
  var EPSG4326Projection = /** @class */ (function (_super) {
      __extends$6(EPSG4326Projection, _super);
      /**
       * @param {string} code Code.
       * @param {string=} opt_axisOrientation Axis orientation.
       */
      function EPSG4326Projection(code, opt_axisOrientation) {
          return _super.call(this, {
              code: code,
              units: Units.DEGREES,
              extent: EXTENT$1,
              axisOrientation: opt_axisOrientation,
              global: true,
              metersPerUnit: METERS_PER_UNIT$1,
              worldExtent: EXTENT$1,
          }) || this;
      }
      return EPSG4326Projection;
  }(Projection));
  /**
   * Projections equal to EPSG:4326.
   *
   * @const
   * @type {Array<import("./Projection.js").default>}
   */
  var PROJECTIONS$1 = [
      new EPSG4326Projection('CRS:84'),
      new EPSG4326Projection('EPSG:4326', 'neu'),
      new EPSG4326Projection('urn:ogc:def:crs:EPSG::4326', 'neu'),
      new EPSG4326Projection('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'),
      new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
      new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
      new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
      new EPSG4326Projection('urn:x-ogc:def:crs:EPSG:4326', 'neu'),
  ];

  /**
   * @module ol/proj/projections
   */
  /**
   * @type {Object<string, import("./Projection.js").default>}
   */
  var cache = {};
  /**
   * Get a cached projection by code.
   * @param {string} code The code for the projection.
   * @return {import("./Projection.js").default} The projection (if cached).
   */
  function get$1(code) {
      return cache[code] || null;
  }
  /**
   * Add a projection to the cache.
   * @param {string} code The projection code.
   * @param {import("./Projection.js").default} projection The projection to cache.
   */
  function add$1(code, projection) {
      cache[code] = projection;
  }

  /**
   * @module ol/proj/transforms
   */
  /**
   * @private
   * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
   */
  var transforms = {};
  /**
   * Registers a conversion function to convert coordinates from the source
   * projection to the destination projection.
   *
   * @param {import("./Projection.js").default} source Source.
   * @param {import("./Projection.js").default} destination Destination.
   * @param {import("../proj.js").TransformFunction} transformFn Transform.
   */
  function add$2(source, destination, transformFn) {
      var sourceCode = source.getCode();
      var destinationCode = destination.getCode();
      if (!(sourceCode in transforms)) {
          transforms[sourceCode] = {};
      }
      transforms[sourceCode][destinationCode] = transformFn;
  }
  /**
   * Get a transform given a source code and a destination code.
   * @param {string} sourceCode The code for the source projection.
   * @param {string} destinationCode The code for the destination projection.
   * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
   */
  function get$2(sourceCode, destinationCode) {
      var transform;
      if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
          transform = transforms[sourceCode][destinationCode];
      }
      return transform;
  }

  /**
   * @module ol/sphere
   */
  /**
   * Object literal with options for the {@link getLength} or {@link getArea}
   * functions.
   * @typedef {Object} SphereMetricOptions
   * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
   * Projection of the  geometry.  By default, the geometry is assumed to be in
   * Web Mercator.
   * @property {number} [radius=6371008.8] Sphere radius.  By default, the
   * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
   * for the WGS84 ellipsoid is used.
   */
  /**
   * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
   * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
   * @type {number}
   */
  var DEFAULT_RADIUS = 6371008.8;
  /**
   * Get the great circle distance (in meters) between two geographic coordinates.
   * @param {Array} c1 Starting coordinate.
   * @param {Array} c2 Ending coordinate.
   * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
   *     mean radius using the WGS84 ellipsoid.
   * @return {number} The great circle distance between the points (in meters).
   * @api
   */
  function getDistance(c1, c2, opt_radius) {
      var radius = opt_radius || DEFAULT_RADIUS;
      var lat1 = toRadians(c1[1]);
      var lat2 = toRadians(c2[1]);
      var deltaLatBy2 = (lat2 - lat1) / 2;
      var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
      var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
          Math.sin(deltaLonBy2) *
              Math.sin(deltaLonBy2) *
              Math.cos(lat1) *
              Math.cos(lat2);
      return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  }
  /**
   * Get the cumulative great circle length of linestring coordinates (geographic).
   * @param {Array} coordinates Linestring coordinates.
   * @param {number} radius The sphere radius to use.
   * @return {number} The length (in meters).
   */
  function getLengthInternal(coordinates, radius) {
      var length = 0;
      for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
          length += getDistance(coordinates[i], coordinates[i + 1], radius);
      }
      return length;
  }
  /**
   * Get the spherical length of a geometry.  This length is the sum of the
   * great circle distances between coordinates.  For polygons, the length is
   * the sum of all rings.  For points, the length is zero.  For multi-part
   * geometries, the length is the sum of the length of each part.
   * @param {import("./geom/Geometry.js").default} geometry A geometry.
   * @param {SphereMetricOptions=} opt_options Options for the
   * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
   * You can change this by providing a `projection` option.
   * @return {number} The spherical length (in meters).
   * @api
   */
  function getLength(geometry, opt_options) {
      var options = opt_options || {};
      var radius = options.radius || DEFAULT_RADIUS;
      var projection = options.projection || 'EPSG:3857';
      var type = geometry.getType();
      if (type !== GeometryType.GEOMETRY_COLLECTION) {
          geometry = geometry.clone().transform(projection, 'EPSG:4326');
      }
      var length = 0;
      var coordinates, coords, i, ii, j, jj;
      switch (type) {
          case GeometryType.POINT:
          case GeometryType.MULTI_POINT: {
              break;
          }
          case GeometryType.LINE_STRING:
          case GeometryType.LINEAR_RING: {
              coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
              length = getLengthInternal(coordinates, radius);
              break;
          }
          case GeometryType.MULTI_LINE_STRING:
          case GeometryType.POLYGON: {
              coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
              for (i = 0, ii = coordinates.length; i < ii; ++i) {
                  length += getLengthInternal(coordinates[i], radius);
              }
              break;
          }
          case GeometryType.MULTI_POLYGON: {
              coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
              for (i = 0, ii = coordinates.length; i < ii; ++i) {
                  coords = coordinates[i];
                  for (j = 0, jj = coords.length; j < jj; ++j) {
                      length += getLengthInternal(coords[j], radius);
                  }
              }
              break;
          }
          case GeometryType.GEOMETRY_COLLECTION: {
              var geometries = /** @type {import("./geom/GeometryCollection.js").default} */ (geometry).getGeometries();
              for (i = 0, ii = geometries.length; i < ii; ++i) {
                  length += getLength(geometries[i], opt_options);
              }
              break;
          }
          default: {
              throw new Error('Unsupported geometry type: ' + type);
          }
      }
      return length;
  }
  /**
   * Returns the spherical area for a list of coordinates.
   *
   * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
   * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
   * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
   * Laboratory, Pasadena, CA, June 2007
   *
   * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
   * ring. If the ring is oriented clockwise, the area will be positive,
   * otherwise it will be negative.
   * @param {number} radius The sphere radius.
   * @return {number} Area (in square meters).
   */
  function getAreaInternal(coordinates, radius) {
      var area = 0;
      var len = coordinates.length;
      var x1 = coordinates[len - 1][0];
      var y1 = coordinates[len - 1][1];
      for (var i = 0; i < len; i++) {
          var x2 = coordinates[i][0];
          var y2 = coordinates[i][1];
          area +=
              toRadians(x2 - x1) *
                  (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));
          x1 = x2;
          y1 = y2;
      }
      return (area * radius * radius) / 2.0;
  }
  /**
   * Get the spherical area of a geometry.  This is the area (in meters) assuming
   * that polygon edges are segments of great circles on a sphere.
   * @param {import("./geom/Geometry.js").default} geometry A geometry.
   * @param {SphereMetricOptions=} opt_options Options for the area
   *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
   *     You can change this by providing a `projection` option.
   * @return {number} The spherical area (in square meters).
   * @api
   */
  function getArea$1(geometry, opt_options) {
      var options = opt_options || {};
      var radius = options.radius || DEFAULT_RADIUS;
      var projection = options.projection || 'EPSG:3857';
      var type = geometry.getType();
      if (type !== GeometryType.GEOMETRY_COLLECTION) {
          geometry = geometry.clone().transform(projection, 'EPSG:4326');
      }
      var area = 0;
      var coordinates, coords, i, ii, j, jj;
      switch (type) {
          case GeometryType.POINT:
          case GeometryType.MULTI_POINT:
          case GeometryType.LINE_STRING:
          case GeometryType.MULTI_LINE_STRING:
          case GeometryType.LINEAR_RING: {
              break;
          }
          case GeometryType.POLYGON: {
              coordinates = /** @type {import("./geom/Polygon.js").default} */ (geometry).getCoordinates();
              area = Math.abs(getAreaInternal(coordinates[0], radius));
              for (i = 1, ii = coordinates.length; i < ii; ++i) {
                  area -= Math.abs(getAreaInternal(coordinates[i], radius));
              }
              break;
          }
          case GeometryType.MULTI_POLYGON: {
              coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
              for (i = 0, ii = coordinates.length; i < ii; ++i) {
                  coords = coordinates[i];
                  area += Math.abs(getAreaInternal(coords[0], radius));
                  for (j = 1, jj = coords.length; j < jj; ++j) {
                      area -= Math.abs(getAreaInternal(coords[j], radius));
                  }
              }
              break;
          }
          case GeometryType.GEOMETRY_COLLECTION: {
              var geometries = /** @type {import("./geom/GeometryCollection.js").default} */ (geometry).getGeometries();
              for (i = 0, ii = geometries.length; i < ii; ++i) {
                  area += getArea$1(geometries[i], opt_options);
              }
              break;
          }
          default: {
              throw new Error('Unsupported geometry type: ' + type);
          }
      }
      return area;
  }

  /**
   * @module ol/string
   */

  /**
   * @module ol/coordinate
   */
  /**
   * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
   * @typedef {Array<number>} Coordinate
   * @api
   */
  /**
   * A function that takes a {@link module:ol/coordinate~Coordinate} and
   * transforms it into a `{string}`.
   *
   * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
   * @api
   */
  /**
   * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
   * by the function.
   *
   * Example:
   *
   *     import {add} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     add(coord, [-2, 4]);
   *     // coord is now [5.85, 51.983333]
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {Coordinate} delta Delta.
   * @return {Coordinate} The input coordinate adjusted by
   * the given delta.
   * @api
   */
  function add$3(coordinate, delta) {
      coordinate[0] += +delta[0];
      coordinate[1] += +delta[1];
      return coordinate;
  }
  /**
   * Calculates the point closest to the passed coordinate on the passed circle.
   *
   * @param {Coordinate} coordinate The coordinate.
   * @param {import("./geom/Circle.js").default} circle The circle.
   * @return {Coordinate} Closest point on the circumference.
   */
  function closestOnCircle(coordinate, circle) {
      var r = circle.getRadius();
      var center = circle.getCenter();
      var x0 = center[0];
      var y0 = center[1];
      var x1 = coordinate[0];
      var y1 = coordinate[1];
      var dx = x1 - x0;
      var dy = y1 - y0;
      if (dx === 0 && dy === 0) {
          dx = 1;
      }
      var d = Math.sqrt(dx * dx + dy * dy);
      var x = x0 + (r * dx) / d;
      var y = y0 + (r * dy) / d;
      return [x, y];
  }
  /**
   * Calculates the point closest to the passed coordinate on the passed segment.
   * This is the foot of the perpendicular of the coordinate to the segment when
   * the foot is on the segment, or the closest segment coordinate when the foot
   * is outside the segment.
   *
   * @param {Coordinate} coordinate The coordinate.
   * @param {Array<Coordinate>} segment The two coordinates
   * of the segment.
   * @return {Coordinate} The foot of the perpendicular of
   * the coordinate to the segment.
   */
  function closestOnSegment(coordinate, segment) {
      var x0 = coordinate[0];
      var y0 = coordinate[1];
      var start = segment[0];
      var end = segment[1];
      var x1 = start[0];
      var y1 = start[1];
      var x2 = end[0];
      var y2 = end[1];
      var dx = x2 - x1;
      var dy = y2 - y1;
      var along = dx === 0 && dy === 0
          ? 0
          : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
      var x, y;
      if (along <= 0) {
          x = x1;
          y = y1;
      }
      else if (along >= 1) {
          x = x2;
          y = y2;
      }
      else {
          x = x1 + along * dx;
          y = y1 + along * dy;
      }
      return [x, y];
  }
  /**
   * @param {Coordinate} coordinate1 First coordinate.
   * @param {Coordinate} coordinate2 Second coordinate.
   * @return {boolean} The two coordinates are equal.
   */
  function equals$2(coordinate1, coordinate2) {
      var equals = true;
      for (var i = coordinate1.length - 1; i >= 0; --i) {
          if (coordinate1[i] != coordinate2[i]) {
              equals = false;
              break;
          }
      }
      return equals;
  }
  /**
   * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
   * returned by the function.
   *
   * Example:
   *
   *     import {rotate} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var rotateRadians = Math.PI / 2; // 90 degrees
   *     rotate(coord, rotateRadians);
   *     // coord is now [-47.983333, 7.85]
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {number} angle Angle in radian.
   * @return {Coordinate} Coordinate.
   * @api
   */
  function rotate$1(coordinate, angle) {
      var cosAngle = Math.cos(angle);
      var sinAngle = Math.sin(angle);
      var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
      var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
      coordinate[0] = x;
      coordinate[1] = y;
      return coordinate;
  }
  /**
   * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
   * by the function.
   *
   * Example:
   *
   *     import {scale as scaleCoordinate} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var scale = 1.2;
   *     scaleCoordinate(coord, scale);
   *     // coord is now [9.42, 57.5799996]
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {number} scale Scale factor.
   * @return {Coordinate} Coordinate.
   */
  function scale$1(coordinate, scale) {
      coordinate[0] *= scale;
      coordinate[1] *= scale;
      return coordinate;
  }
  /**
   * @param {Coordinate} coord1 First coordinate.
   * @param {Coordinate} coord2 Second coordinate.
   * @return {number} Squared distance between coord1 and coord2.
   */
  function squaredDistance$1(coord1, coord2) {
      var dx = coord1[0] - coord2[0];
      var dy = coord1[1] - coord2[1];
      return dx * dx + dy * dy;
  }
  /**
   * @param {Coordinate} coord1 First coordinate.
   * @param {Coordinate} coord2 Second coordinate.
   * @return {number} Distance between coord1 and coord2.
   */
  function distance$1(coord1, coord2) {
      return Math.sqrt(squaredDistance$1(coord1, coord2));
  }
  /**
   * Calculate the squared distance from a coordinate to a line segment.
   *
   * @param {Coordinate} coordinate Coordinate of the point.
   * @param {Array<Coordinate>} segment Line segment (2
   * coordinates).
   * @return {number} Squared distance from the point to the line segment.
   */
  function squaredDistanceToSegment(coordinate, segment) {
      return squaredDistance$1(coordinate, closestOnSegment(coordinate, segment));
  }
  /**
   * Modifies the provided coordinate in-place to be within the real world
   * extent. The lower projection extent boundary is inclusive, the upper one
   * exclusive.
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @return {Coordinate} The coordinate within the real world extent.
   */
  function wrapX$1(coordinate, projection) {
      if (projection.canWrapX()) {
          var worldWidth = getWidth(projection.getExtent());
          var worldsAway = getWorldsAway(coordinate, projection, worldWidth);
          if (worldsAway) {
              coordinate[0] -= worldsAway * worldWidth;
          }
      }
      return coordinate;
  }
  /**
   * @param {Coordinate} coordinate Coordinate.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @param {number=} opt_sourceExtentWidth Width of the source extent.
   * @return {number} Offset in world widths.
   */
  function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {
      var projectionExtent = projection.getExtent();
      var worldsAway = 0;
      if (projection.canWrapX() &&
          (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
          var sourceExtentWidth = opt_sourceExtentWidth || getWidth(projectionExtent);
          worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
      }
      return worldsAway;
  }

  /**
   * @module ol/proj
   */
  /**
   * @param {Array<number>} input Input coordinate array.
   * @param {Array<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension.
   * @return {Array<number>} Output coordinate array (new array, same coordinate
   *     values).
   */
  function cloneTransform(input, opt_output, opt_dimension) {
      var output;
      if (opt_output !== undefined) {
          for (var i = 0, ii = input.length; i < ii; ++i) {
              opt_output[i] = input[i];
          }
          output = opt_output;
      }
      else {
          output = input.slice();
      }
      return output;
  }
  /**
   * @param {Array<number>} input Input coordinate array.
   * @param {Array<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension.
   * @return {Array<number>} Input coordinate array (same array as input).
   */
  function identityTransform(input, opt_output, opt_dimension) {
      if (opt_output !== undefined && input !== opt_output) {
          for (var i = 0, ii = input.length; i < ii; ++i) {
              opt_output[i] = input[i];
          }
          input = opt_output;
      }
      return input;
  }
  /**
   * Add a Projection object to the list of supported projections that can be
   * looked up by their code.
   *
   * @param {Projection} projection Projection instance.
   * @api
   */
  function addProjection(projection) {
      add$1(projection.getCode(), projection);
      add$2(projection, projection, cloneTransform);
  }
  /**
   * @param {Array<Projection>} projections Projections.
   */
  function addProjections(projections) {
      projections.forEach(addProjection);
  }
  /**
   * Fetches a Projection object for the code specified.
   *
   * @param {ProjectionLike} projectionLike Either a code string which is
   *     a combination of authority and identifier such as "EPSG:4326", or an
   *     existing projection object, or undefined.
   * @return {Projection} Projection object, or null if not in list.
   * @api
   */
  function get$3(projectionLike) {
      return typeof projectionLike === 'string'
          ? get$1(/** @type {string} */ (projectionLike))
          : /** @type {Projection} */ (projectionLike) || null;
  }
  /**
   * Get the resolution of the point in degrees or distance units.
   * For projections with degrees as the unit this will simply return the
   * provided resolution. For other projections the point resolution is
   * by default estimated by transforming the 'point' pixel to EPSG:4326,
   * measuring its width and height on the normal sphere,
   * and taking the average of the width and height.
   * A custom function can be provided for a specific projection, either
   * by setting the `getPointResolution` option in the
   * {@link module:ol/proj/Projection~Projection} constructor or by using
   * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
   * projection object.
   * @param {ProjectionLike} projection The projection.
   * @param {number} resolution Nominal resolution in projection units.
   * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
   * @param {import("./proj/Units.js").default=} opt_units Units to get the point resolution in.
   * Default is the projection's units.
   * @return {number} Point resolution.
   * @api
   */
  function getPointResolution(projection, resolution, point, opt_units) {
      projection = get$3(projection);
      var pointResolution;
      var getter = projection.getPointResolutionFunc();
      if (getter) {
          pointResolution = getter(resolution, point);
          if (opt_units && opt_units !== projection.getUnits()) {
              var metersPerUnit = projection.getMetersPerUnit();
              if (metersPerUnit) {
                  pointResolution =
                      (pointResolution * metersPerUnit) / METERS_PER_UNIT[opt_units];
              }
          }
      }
      else {
          var units = projection.getUnits();
          if ((units == Units.DEGREES && !opt_units) || opt_units == Units.DEGREES) {
              pointResolution = resolution;
          }
          else {
              // Estimate point resolution by transforming the center pixel to EPSG:4326,
              // measuring its width and height on the normal sphere, and taking the
              // average of the width and height.
              var toEPSG4326_1 = getTransformFromProjections(projection, get$3('EPSG:4326'));
              var vertices = [
                  point[0] - resolution / 2,
                  point[1],
                  point[0] + resolution / 2,
                  point[1],
                  point[0],
                  point[1] - resolution / 2,
                  point[0],
                  point[1] + resolution / 2,
              ];
              vertices = toEPSG4326_1(vertices, vertices, 2);
              var width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
              var height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
              pointResolution = (width + height) / 2;
              var metersPerUnit = opt_units
                  ? METERS_PER_UNIT[opt_units]
                  : projection.getMetersPerUnit();
              if (metersPerUnit !== undefined) {
                  pointResolution /= metersPerUnit;
              }
          }
      }
      return pointResolution;
  }
  /**
   * Registers transformation functions that don't alter coordinates. Those allow
   * to transform between projections with equal meaning.
   *
   * @param {Array<Projection>} projections Projections.
   * @api
   */
  function addEquivalentProjections(projections) {
      addProjections(projections);
      projections.forEach(function (source) {
          projections.forEach(function (destination) {
              if (source !== destination) {
                  add$2(source, destination, cloneTransform);
              }
          });
      });
  }
  /**
   * Registers transformation functions to convert coordinates in any projection
   * in projection1 to any projection in projection2.
   *
   * @param {Array<Projection>} projections1 Projections with equal
   *     meaning.
   * @param {Array<Projection>} projections2 Projections with equal
   *     meaning.
   * @param {TransformFunction} forwardTransform Transformation from any
   *   projection in projection1 to any projection in projection2.
   * @param {TransformFunction} inverseTransform Transform from any projection
   *   in projection2 to any projection in projection1..
   */
  function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
      projections1.forEach(function (projection1) {
          projections2.forEach(function (projection2) {
              add$2(projection1, projection2, forwardTransform);
              add$2(projection2, projection1, inverseTransform);
          });
      });
  }
  /**
   * @param {Projection|string|undefined} projection Projection.
   * @param {string} defaultCode Default code.
   * @return {Projection} Projection.
   */
  function createProjection(projection, defaultCode) {
      if (!projection) {
          return get$3(defaultCode);
      }
      else if (typeof projection === 'string') {
          return get$3(projection);
      }
      else {
          return /** @type {Projection} */ (projection);
      }
  }
  /**
   * Checks if two projections are the same, that is every coordinate in one
   * projection does represent the same geographic point as the same coordinate in
   * the other projection.
   *
   * @param {Projection} projection1 Projection 1.
   * @param {Projection} projection2 Projection 2.
   * @return {boolean} Equivalent.
   * @api
   */
  function equivalent(projection1, projection2) {
      if (projection1 === projection2) {
          return true;
      }
      var equalUnits = projection1.getUnits() === projection2.getUnits();
      if (projection1.getCode() === projection2.getCode()) {
          return equalUnits;
      }
      else {
          var transformFunc = getTransformFromProjections(projection1, projection2);
          return transformFunc === cloneTransform && equalUnits;
      }
  }
  /**
   * Searches in the list of transform functions for the function for converting
   * coordinates from the source projection to the destination projection.
   *
   * @param {Projection} sourceProjection Source Projection object.
   * @param {Projection} destinationProjection Destination Projection
   *     object.
   * @return {TransformFunction} Transform function.
   */
  function getTransformFromProjections(sourceProjection, destinationProjection) {
      var sourceCode = sourceProjection.getCode();
      var destinationCode = destinationProjection.getCode();
      var transformFunc = get$2(sourceCode, destinationCode);
      if (!transformFunc) {
          transformFunc = identityTransform;
      }
      return transformFunc;
  }
  /**
   * Given the projection-like objects, searches for a transformation
   * function to convert a coordinates array from the source projection to the
   * destination projection.
   *
   * @param {ProjectionLike} source Source.
   * @param {ProjectionLike} destination Destination.
   * @return {TransformFunction} Transform function.
   * @api
   */
  function getTransform(source, destination) {
      var sourceProjection = get$3(source);
      var destinationProjection = get$3(destination);
      return getTransformFromProjections(sourceProjection, destinationProjection);
  }
  /**
   * Transforms a coordinate from source projection to destination projection.
   * This returns a new coordinate (and does not modify the original).
   *
   * See {@link module:ol/proj~transformExtent} for extent transformation.
   * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
   * subclasses for geometry transforms.
   *
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {ProjectionLike} source Source projection-like.
   * @param {ProjectionLike} destination Destination projection-like.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  function transform(coordinate, source, destination) {
      var transformFunc = getTransform(source, destination);
      return transformFunc(coordinate, undefined, coordinate.length);
  }
  /**
   * Transforms an extent from source projection to destination projection.  This
   * returns a new extent (and does not modify the original).
   *
   * @param {import("./extent.js").Extent} extent The extent to transform.
   * @param {ProjectionLike} source Source projection-like.
   * @param {ProjectionLike} destination Destination projection-like.
   * @param {number=} opt_stops Number of stops per side used for the transform.
   * By default only the corners are used.
   * @return {import("./extent.js").Extent} The transformed extent.
   * @api
   */
  function transformExtent(extent, source, destination, opt_stops) {
      var transformFunc = getTransform(source, destination);
      return applyTransform$1(extent, transformFunc, undefined, opt_stops);
  }
  /**
   * @type {?Projection}
   */
  var userProjection = null;
  /**
   * Get the projection for coordinates supplied from and returned by API methods.
   * Note that this method is not yet a part of the stable API.  Support for user
   * projections is not yet complete and should be considered experimental.
   * @returns {?Projection} The user projection (or null if not set).
   */
  function getUserProjection() {
      return userProjection;
  }
  /**
   * Return a coordinate transformed into the user projection.  If no user projection
   * is set, the original coordinate is returned.
   * @param {Array<number>} coordinate Input coordinate.
   * @param {ProjectionLike} sourceProjection The input coordinate projection.
   * @returns {Array<number>} The input coordinate in the user projection.
   */
  function toUserCoordinate(coordinate, sourceProjection) {
      if (!userProjection) {
          return coordinate;
      }
      return transform(coordinate, sourceProjection, userProjection);
  }
  /**
   * Return a coordinate transformed from the user projection.  If no user projection
   * is set, the original coordinate is returned.
   * @param {Array<number>} coordinate Input coordinate.
   * @param {ProjectionLike} destProjection The destination projection.
   * @returns {Array<number>} The input coordinate transformed.
   */
  function fromUserCoordinate(coordinate, destProjection) {
      if (!userProjection) {
          return coordinate;
      }
      return transform(coordinate, userProjection, destProjection);
  }
  /**
   * Return an extent transformed into the user projection.  If no user projection
   * is set, the original extent is returned.
   * @param {import("./extent.js").Extent} extent Input extent.
   * @param {ProjectionLike} sourceProjection The input extent projection.
   * @returns {import("./extent.js").Extent} The input extent in the user projection.
   */
  function toUserExtent(extent, sourceProjection) {
      if (!userProjection) {
          return extent;
      }
      return transformExtent(extent, sourceProjection, userProjection);
  }
  /**
   * Return an extent transformed from the user projection.  If no user projection
   * is set, the original extent is returned.
   * @param {import("./extent.js").Extent} extent Input extent.
   * @param {ProjectionLike} destProjection The destination projection.
   * @returns {import("./extent.js").Extent} The input extent transformed.
   */
  function fromUserExtent(extent, destProjection) {
      if (!userProjection) {
          return extent;
      }
      return transformExtent(extent, userProjection, destProjection);
  }
  /**
   * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
   * by when this module is executed and should only need to be called again after
   * `clearAllProjections()` is called (e.g. in tests).
   */
  function addCommon() {
      // Add transformations that don't alter coordinates to convert within set of
      // projections with equal meaning.
      addEquivalentProjections(PROJECTIONS);
      addEquivalentProjections(PROJECTIONS$1);
      // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
      // coordinates and back.
      addEquivalentTransforms(PROJECTIONS$1, PROJECTIONS, fromEPSG4326, toEPSG4326);
  }
  addCommon();

  /**
   * @module ol/geom/flat/transform
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Transformed coordinates.
   */
  function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {
      var dest = opt_dest ? opt_dest : [];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
          var x = flatCoordinates[j];
          var y = flatCoordinates[j + 1];
          dest[i++] = transform[0] * x + transform[2] * y + transform[4];
          dest[i++] = transform[1] * x + transform[3] * y + transform[5];
      }
      if (opt_dest && dest.length != i) {
          dest.length = i;
      }
      return dest;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} angle Angle.
   * @param {Array<number>} anchor Rotation anchor point.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Transformed coordinates.
   */
  function rotate$2(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
      var dest = opt_dest ? opt_dest : [];
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      var anchorX = anchor[0];
      var anchorY = anchor[1];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
          var deltaX = flatCoordinates[j] - anchorX;
          var deltaY = flatCoordinates[j + 1] - anchorY;
          dest[i++] = anchorX + deltaX * cos - deltaY * sin;
          dest[i++] = anchorY + deltaX * sin + deltaY * cos;
          for (var k = j + 2; k < j + stride; ++k) {
              dest[i++] = flatCoordinates[k];
          }
      }
      if (opt_dest && dest.length != i) {
          dest.length = i;
      }
      return dest;
  }
  /**
   * Scale the coordinates.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} sx Scale factor in the x-direction.
   * @param {number} sy Scale factor in the y-direction.
   * @param {Array<number>} anchor Scale anchor point.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Transformed coordinates.
   */
  function scale$2(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
      var dest = opt_dest ? opt_dest : [];
      var anchorX = anchor[0];
      var anchorY = anchor[1];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
          var deltaX = flatCoordinates[j] - anchorX;
          var deltaY = flatCoordinates[j + 1] - anchorY;
          dest[i++] = anchorX + sx * deltaX;
          dest[i++] = anchorY + sy * deltaY;
          for (var k = j + 2; k < j + stride; ++k) {
              dest[i++] = flatCoordinates[k];
          }
      }
      if (opt_dest && dest.length != i) {
          dest.length = i;
      }
      return dest;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Transformed coordinates.
   */
  function translate$1(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
      var dest = opt_dest ? opt_dest : [];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
          dest[i++] = flatCoordinates[j] + deltaX;
          dest[i++] = flatCoordinates[j + 1] + deltaY;
          for (var k = j + 2; k < j + stride; ++k) {
              dest[i++] = flatCoordinates[k];
          }
      }
      if (opt_dest && dest.length != i) {
          dest.length = i;
      }
      return dest;
  }

  var __extends$7 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @type {import("../transform.js").Transform}
   */
  var tmpTransform = create$2();
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Base class for vector geometries.
   *
   * To get notified of changes to the geometry, register a listener for the
   * generic `change` event on your geometry instance.
   *
   * @abstract
   * @api
   */
  var Geometry = /** @class */ (function (_super) {
      __extends$7(Geometry, _super);
      function Geometry() {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {import("../extent.js").Extent}
           */
          _this.extent_ = createEmpty();
          /**
           * @private
           * @type {number}
           */
          _this.extentRevision_ = -1;
          /**
           * @protected
           * @type {number}
           */
          _this.simplifiedGeometryMaxMinSquaredTolerance = 0;
          /**
           * @protected
           * @type {number}
           */
          _this.simplifiedGeometryRevision = 0;
          /**
           * Get a transformed and simplified version of the geometry.
           * @abstract
           * @param {number} revision The geometry revision.
           * @param {number} squaredTolerance Squared tolerance.
           * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
           * @return {Geometry} Simplified geometry.
           */
          _this.simplifyTransformedInternal = memoizeOne(function (revision, squaredTolerance, opt_transform) {
              if (!opt_transform) {
                  return this.getSimplifiedGeometry(squaredTolerance);
              }
              var clone = this.clone();
              clone.applyTransform(opt_transform);
              return clone.getSimplifiedGeometry(squaredTolerance);
          });
          return _this;
      }
      /**
       * Get a transformed and simplified version of the geometry.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
       * @return {Geometry} Simplified geometry.
       */
      Geometry.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {
          return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);
      };
      /**
       * Make a complete copy of the geometry.
       * @abstract
       * @return {!Geometry} Clone.
       */
      Geometry.prototype.clone = function () {
          return abstract();
      };
      /**
       * @abstract
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      Geometry.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          return abstract();
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      Geometry.prototype.containsXY = function (x, y) {
          var coord = this.getClosestPoint([x, y]);
          return coord[0] === x && coord[1] === y;
      };
      /**
       * Return the closest point of the geometry to the passed point as
       * {@link module:ol/coordinate~Coordinate coordinate}.
       * @param {import("../coordinate.js").Coordinate} point Point.
       * @param {import("../coordinate.js").Coordinate=} opt_closestPoint Closest point.
       * @return {import("../coordinate.js").Coordinate} Closest point.
       * @api
       */
      Geometry.prototype.getClosestPoint = function (point, opt_closestPoint) {
          var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
          this.closestPointXY(point[0], point[1], closestPoint, Infinity);
          return closestPoint;
      };
      /**
       * Returns true if this geometry includes the specified coordinate. If the
       * coordinate is on the boundary of the geometry, returns false.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains coordinate.
       * @api
       */
      Geometry.prototype.intersectsCoordinate = function (coordinate) {
          return this.containsXY(coordinate[0], coordinate[1]);
      };
      /**
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      Geometry.prototype.computeExtent = function (extent) {
          return abstract();
      };
      /**
       * Get the extent of the geometry.
       * @param {import("../extent.js").Extent=} opt_extent Extent.
       * @return {import("../extent.js").Extent} extent Extent.
       * @api
       */
      Geometry.prototype.getExtent = function (opt_extent) {
          if (this.extentRevision_ != this.getRevision()) {
              var extent = this.computeExtent(this.extent_);
              if (isNaN(extent[0]) || isNaN(extent[1])) {
                  createOrUpdateEmpty(extent);
              }
              this.extentRevision_ = this.getRevision();
          }
          return returnOrUpdate(this.extent_, opt_extent);
      };
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      Geometry.prototype.rotate = function (angle, anchor) {
          abstract();
      };
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number=} opt_sy The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      Geometry.prototype.scale = function (sx, opt_sy, opt_anchor) {
          abstract();
      };
      /**
       * Create a simplified version of this geometry.  For linestrings, this uses
       * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
       * algorithm.  For polygons, a quantization-based
       * simplification is used to preserve topology.
       * @param {number} tolerance The tolerance distance for simplification.
       * @return {Geometry} A new, simplified version of the original geometry.
       * @api
       */
      Geometry.prototype.simplify = function (tolerance) {
          return this.getSimplifiedGeometry(tolerance * tolerance);
      };
      /**
       * Create a simplified version of this geometry using the Douglas Peucker
       * algorithm.
       * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Geometry} Simplified geometry.
       */
      Geometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {
          return abstract();
      };
      /**
       * Get the type of this geometry.
       * @abstract
       * @return {import("./GeometryType.js").default} Geometry type.
       */
      Geometry.prototype.getType = function () {
          return abstract();
      };
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @abstract
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       */
      Geometry.prototype.applyTransform = function (transformFn) {
          abstract();
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       */
      Geometry.prototype.intersectsExtent = function (extent) {
          return abstract();
      };
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @abstract
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      Geometry.prototype.translate = function (deltaX, deltaY) {
          abstract();
      };
      /**
       * Transform each coordinate of the geometry from one coordinate reference
       * system to another. The geometry is modified in place.
       * For example, a line will be transformed to a line and a circle to a circle.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       *
       * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @return {Geometry} This geometry.  Note that original geometry is
       *     modified in place.
       * @api
       */
      Geometry.prototype.transform = function (source, destination) {
          /** @type {import("../proj/Projection.js").default} */
          var sourceProj = get$3(source);
          var transformFn = sourceProj.getUnits() == Units.TILE_PIXELS
              ? function (inCoordinates, outCoordinates, stride) {
                  var pixelExtent = sourceProj.getExtent();
                  var projectedExtent = sourceProj.getWorldExtent();
                  var scale$$1 = getHeight(projectedExtent) / getHeight(pixelExtent);
                  compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale$$1, -scale$$1, 0, 0, 0);
                  transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
                  return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);
              }
              : getTransform(sourceProj, destination);
          this.applyTransform(transformFn);
          return this;
      };
      return Geometry;
  }(BaseObject));

  /**
   * @module ol/geom/GeometryLayout
   */
  /**
   * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
   * or measure ('M') coordinate is available. Supported values are `'XY'`,
   * `'XYZ'`, `'XYM'`, `'XYZM'`.
   * @enum {string}
   */
  var GeometryLayout = {
      XY: 'XY',
      XYZ: 'XYZ',
      XYM: 'XYM',
      XYZM: 'XYZM',
  };

  var __extends$8 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Abstract base class; only used for creating subclasses; do not instantiate
   * in apps, as cannot be rendered.
   *
   * @abstract
   * @api
   */
  var SimpleGeometry = /** @class */ (function (_super) {
      __extends$8(SimpleGeometry, _super);
      function SimpleGeometry() {
          var _this = _super.call(this) || this;
          /**
           * @protected
           * @type {import("./GeometryLayout.js").default}
           */
          _this.layout = GeometryLayout.XY;
          /**
           * @protected
           * @type {number}
           */
          _this.stride = 2;
          /**
           * @protected
           * @type {Array<number>}
           */
          _this.flatCoordinates = null;
          return _this;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      SimpleGeometry.prototype.computeExtent = function (extent) {
          return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
      };
      /**
       * @abstract
       * @return {Array<*>} Coordinates.
       */
      SimpleGeometry.prototype.getCoordinates = function () {
          return abstract();
      };
      /**
       * Return the first coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} First coordinate.
       * @api
       */
      SimpleGeometry.prototype.getFirstCoordinate = function () {
          return this.flatCoordinates.slice(0, this.stride);
      };
      /**
       * @return {Array<number>} Flat coordinates.
       */
      SimpleGeometry.prototype.getFlatCoordinates = function () {
          return this.flatCoordinates;
      };
      /**
       * Return the last coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} Last point.
       * @api
       */
      SimpleGeometry.prototype.getLastCoordinate = function () {
          return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
      };
      /**
       * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.
       * @return {import("./GeometryLayout.js").default} Layout.
       * @api
       */
      SimpleGeometry.prototype.getLayout = function () {
          return this.layout;
      };
      /**
       * Create a simplified version of this geometry using the Douglas Peucker algorithm.
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       */
      SimpleGeometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {
          if (this.simplifiedGeometryRevision !== this.getRevision()) {
              this.simplifiedGeometryMaxMinSquaredTolerance = 0;
              this.simplifiedGeometryRevision = this.getRevision();
          }
          // If squaredTolerance is negative or if we know that simplification will not
          // have any effect then just return this.
          if (squaredTolerance < 0 ||
              (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
                  squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {
              return this;
          }
          var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
          var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
          if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
              return simplifiedGeometry;
          }
          else {
              // Simplification did not actually remove any coordinates.  We now know
              // that any calls to getSimplifiedGeometry with a squaredTolerance less
              // than or equal to the current squaredTolerance will also not have any
              // effect.  This allows us to short circuit simplification (saving CPU
              // cycles) and prevents the cache of simplified geometries from filling
              // up with useless identical copies of this geometry (saving memory).
              this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
              return this;
          }
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       * @protected
       */
      SimpleGeometry.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          return this;
      };
      /**
       * @return {number} Stride.
       */
      SimpleGeometry.prototype.getStride = function () {
          return this.stride;
      };
      /**
       * @param {import("./GeometryLayout.js").default} layout Layout.
       * @param {Array<number>} flatCoordinates Flat coordinates.
       */
      SimpleGeometry.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
          this.stride = getStrideForLayout(layout);
          this.layout = layout;
          this.flatCoordinates = flatCoordinates;
      };
      /**
       * @abstract
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       */
      SimpleGeometry.prototype.setCoordinates = function (coordinates, opt_layout) {
          abstract();
      };
      /**
       * @param {import("./GeometryLayout.js").default|undefined} layout Layout.
       * @param {Array<*>} coordinates Coordinates.
       * @param {number} nesting Nesting.
       * @protected
       */
      SimpleGeometry.prototype.setLayout = function (layout, coordinates, nesting) {
          /** @type {number} */
          var stride;
          if (layout) {
              stride = getStrideForLayout(layout);
          }
          else {
              for (var i = 0; i < nesting; ++i) {
                  if (coordinates.length === 0) {
                      this.layout = GeometryLayout.XY;
                      this.stride = 2;
                      return;
                  }
                  else {
                      coordinates = /** @type {Array} */ (coordinates[0]);
                  }
              }
              stride = coordinates.length;
              layout = getLayoutForStride(stride);
          }
          this.layout = layout;
          this.stride = stride;
      };
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       * @api
       */
      SimpleGeometry.prototype.applyTransform = function (transformFn) {
          if (this.flatCoordinates) {
              transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
              this.changed();
          }
      };
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      SimpleGeometry.prototype.rotate = function (angle, anchor) {
          var flatCoordinates = this.getFlatCoordinates();
          if (flatCoordinates) {
              var stride = this.getStride();
              rotate$2(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
              this.changed();
          }
      };
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number=} opt_sy The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      SimpleGeometry.prototype.scale = function (sx, opt_sy, opt_anchor) {
          var sy = opt_sy;
          if (sy === undefined) {
              sy = sx;
          }
          var anchor = opt_anchor;
          if (!anchor) {
              anchor = getCenter(this.getExtent());
          }
          var flatCoordinates = this.getFlatCoordinates();
          if (flatCoordinates) {
              var stride = this.getStride();
              scale$2(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
              this.changed();
          }
      };
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      SimpleGeometry.prototype.translate = function (deltaX, deltaY) {
          var flatCoordinates = this.getFlatCoordinates();
          if (flatCoordinates) {
              var stride = this.getStride();
              translate$1(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
              this.changed();
          }
      };
      return SimpleGeometry;
  }(Geometry));
  /**
   * @param {number} stride Stride.
   * @return {import("./GeometryLayout.js").default} layout Layout.
   */
  function getLayoutForStride(stride) {
      var layout;
      if (stride == 2) {
          layout = GeometryLayout.XY;
      }
      else if (stride == 3) {
          layout = GeometryLayout.XYZ;
      }
      else if (stride == 4) {
          layout = GeometryLayout.XYZM;
      }
      return /** @type {import("./GeometryLayout.js").default} */ (layout);
  }
  /**
   * @param {import("./GeometryLayout.js").default} layout Layout.
   * @return {number} Stride.
   */
  function getStrideForLayout(layout) {
      var stride;
      if (layout == GeometryLayout.XY) {
          stride = 2;
      }
      else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {
          stride = 3;
      }
      else if (layout == GeometryLayout.XYZM) {
          stride = 4;
      }
      return /** @type {number} */ (stride);
  }
  /**
   * @param {SimpleGeometry} simpleGeometry Simple geometry.
   * @param {import("../transform.js").Transform} transform Transform.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Transformed flat coordinates.
   */
  function transformGeom2D(simpleGeometry, transform, opt_dest) {
      var flatCoordinates = simpleGeometry.getFlatCoordinates();
      if (!flatCoordinates) {
          return null;
      }
      else {
          var stride = simpleGeometry.getStride();
          return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);
      }
  }

  /**
   * @module ol/geom/flat/deflate
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} stride Stride.
   * @return {number} offset Offset.
   */
  function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
      for (var i = 0, ii = coordinate.length; i < ii; ++i) {
          flatCoordinates[offset++] = coordinate[i];
      }
      return offset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {number} stride Stride.
   * @return {number} offset Offset.
   */
  function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
          var coordinate = coordinates[i];
          for (var j = 0; j < stride; ++j) {
              flatCoordinates[offset++] = coordinate[j];
          }
      }
      return offset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
   * @param {number} stride Stride.
   * @param {Array<number>=} opt_ends Ends.
   * @return {Array<number>} Ends.
   */
  function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {
      var ends = opt_ends ? opt_ends : [];
      var i = 0;
      for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
          var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
          ends[i++] = end;
          offset = end;
      }
      ends.length = i;
      return ends;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
   * @param {number} stride Stride.
   * @param {Array<Array<number>>=} opt_endss Endss.
   * @return {Array<Array<number>>} Endss.
   */
  function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
      var endss = opt_endss ? opt_endss : [];
      var i = 0;
      for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
          var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
          endss[i++] = ends;
          offset = ends[ends.length - 1];
      }
      endss.length = i;
      return endss;
  }

  var __extends$9 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Circle geometry.
   *
   * @api
   */
  var Circle = /** @class */ (function (_super) {
      __extends$9(Circle, _super);
      /**
       * @param {!import("../coordinate.js").Coordinate} center Center.
       *     For internal use, flat coordinates in combination with `opt_layout` and no
       *     `opt_radius` are also accepted.
       * @param {number=} opt_radius Radius.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       */
      function Circle(center, opt_radius, opt_layout) {
          var _this = _super.call(this) || this;
          if (opt_layout !== undefined && opt_radius === undefined) {
              _this.setFlatCoordinates(opt_layout, center);
          }
          else {
              var radius = opt_radius ? opt_radius : 0;
              _this.setCenterAndRadius(center, radius, opt_layout);
          }
          return _this;
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Circle} Clone.
       * @api
       */
      Circle.prototype.clone = function () {
          return new Circle(this.flatCoordinates.slice(), undefined, this.layout);
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      Circle.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          var flatCoordinates = this.flatCoordinates;
          var dx = x - flatCoordinates[0];
          var dy = y - flatCoordinates[1];
          var squaredDistance = dx * dx + dy * dy;
          if (squaredDistance < minSquaredDistance) {
              if (squaredDistance === 0) {
                  for (var i = 0; i < this.stride; ++i) {
                      closestPoint[i] = flatCoordinates[i];
                  }
              }
              else {
                  var delta = this.getRadius() / Math.sqrt(squaredDistance);
                  closestPoint[0] = flatCoordinates[0] + delta * dx;
                  closestPoint[1] = flatCoordinates[1] + delta * dy;
                  for (var i = 2; i < this.stride; ++i) {
                      closestPoint[i] = flatCoordinates[i];
                  }
              }
              closestPoint.length = this.stride;
              return squaredDistance;
          }
          else {
              return minSquaredDistance;
          }
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      Circle.prototype.containsXY = function (x, y) {
          var flatCoordinates = this.flatCoordinates;
          var dx = x - flatCoordinates[0];
          var dy = y - flatCoordinates[1];
          return dx * dx + dy * dy <= this.getRadiusSquared_();
      };
      /**
       * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
       * @return {import("../coordinate.js").Coordinate} Center.
       * @api
       */
      Circle.prototype.getCenter = function () {
          return this.flatCoordinates.slice(0, this.stride);
      };
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      Circle.prototype.computeExtent = function (extent) {
          var flatCoordinates = this.flatCoordinates;
          var radius = flatCoordinates[this.stride] - flatCoordinates[0];
          return createOrUpdate(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);
      };
      /**
       * Return the radius of the circle.
       * @return {number} Radius.
       * @api
       */
      Circle.prototype.getRadius = function () {
          return Math.sqrt(this.getRadiusSquared_());
      };
      /**
       * @private
       * @return {number} Radius squared.
       */
      Circle.prototype.getRadiusSquared_ = function () {
          var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
          var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
          return dx * dx + dy * dy;
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      Circle.prototype.getType = function () {
          return GeometryType.CIRCLE;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      Circle.prototype.intersectsExtent = function (extent) {
          var circleExtent = this.getExtent();
          if (intersects(extent, circleExtent)) {
              var center = this.getCenter();
              if (extent[0] <= center[0] && extent[2] >= center[0]) {
                  return true;
              }
              if (extent[1] <= center[1] && extent[3] >= center[1]) {
                  return true;
              }
              return forEachCorner(extent, this.intersectsCoordinate.bind(this));
          }
          return false;
      };
      /**
       * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
       * @param {import("../coordinate.js").Coordinate} center Center.
       * @api
       */
      Circle.prototype.setCenter = function (center) {
          var stride = this.stride;
          var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
          var flatCoordinates = center.slice();
          flatCoordinates[stride] = flatCoordinates[0] + radius;
          for (var i = 1; i < stride; ++i) {
              flatCoordinates[stride + i] = center[i];
          }
          this.setFlatCoordinates(this.layout, flatCoordinates);
          this.changed();
      };
      /**
       * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
       * number) of the circle.
       * @param {!import("../coordinate.js").Coordinate} center Center.
       * @param {number} radius Radius.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      Circle.prototype.setCenterAndRadius = function (center, radius, opt_layout) {
          this.setLayout(opt_layout, center, 0);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          /** @type {Array<number>} */
          var flatCoordinates = this.flatCoordinates;
          var offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);
          flatCoordinates[offset++] = flatCoordinates[0] + radius;
          for (var i = 1, ii = this.stride; i < ii; ++i) {
              flatCoordinates[offset++] = flatCoordinates[i];
          }
          flatCoordinates.length = offset;
          this.changed();
      };
      Circle.prototype.getCoordinates = function () {
          return null;
      };
      Circle.prototype.setCoordinates = function (coordinates, opt_layout) { };
      /**
       * Set the radius of the circle. The radius is in the units of the projection.
       * @param {number} radius Radius.
       * @api
       */
      Circle.prototype.setRadius = function (radius) {
          this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
          this.changed();
      };
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      Circle.prototype.rotate = function (angle, anchor) {
          var center = this.getCenter();
          var stride = this.getStride();
          this.setCenter(rotate$2(center, 0, center.length, stride, angle, anchor, center));
          this.changed();
      };
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      Circle.prototype.translate = function (deltaX, deltaY) {
          var center = this.getCenter();
          var stride = this.getStride();
          this.setCenter(translate$1(center, 0, center.length, stride, deltaX, deltaY, center));
          this.changed();
      };
      return Circle;
  }(SimpleGeometry));
  /**
   * Transform each coordinate of the circle from one coordinate reference system
   * to another. The geometry is modified in place.
   * If you do not want the geometry modified in place, first clone() it and
   * then use this function on the clone.
   *
   * Internally a circle is currently represented by two points: the center of
   * the circle `[cx, cy]`, and the point to the right of the circle
   * `[cx + r, cy]`. This `transform` function just transforms these two points.
   * So the resulting geometry is also a circle, and that circle does not
   * correspond to the shape that would be obtained by transforming every point
   * of the original circle.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {Circle} This geometry.  Note that original geometry is
   *     modified in place.
   * @function
   * @api
   */
  Circle.prototype.transform;

  var __extends$a = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
   */
  /**
   * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
   */
  /**
   * @classdesc
   * A vector object for geographic features with a geometry and other
   * attribute properties, similar to the features in vector file formats like
   * GeoJSON.
   *
   * Features can be styled individually with `setStyle`; otherwise they use the
   * style of their vector layer.
   *
   * Note that attribute properties are set as {@link module:ol/Object} properties on
   * the feature object, so they are observable, and have get/set accessors.
   *
   * Typically, a feature has a single geometry property. You can set the
   * geometry using the `setGeometry` method and get it with `getGeometry`.
   * It is possible to store more than one geometry on a feature using attribute
   * properties. By default, the geometry used for rendering is identified by
   * the property name `geometry`. If you want to use another geometry property
   * for rendering, use the `setGeometryName` method to change the attribute
   * property associated with the geometry for the feature.  For example:
   *
   * ```js
   *
   * import Feature from 'ol/Feature';
   * import Polygon from 'ol/geom/Polygon';
   * import Point from 'ol/geom/Point';
   *
   * var feature = new Feature({
   *   geometry: new Polygon(polyCoords),
   *   labelPoint: new Point(labelCoords),
   *   name: 'My Polygon'
   * });
   *
   * // get the polygon geometry
   * var poly = feature.getGeometry();
   *
   * // Render the feature as a point using the coordinates from labelPoint
   * feature.setGeometryName('labelPoint');
   *
   * // get the point geometry
   * var point = feature.getGeometry();
   * ```
   *
   * @api
   * @template {import("./geom/Geometry.js").default} Geometry
   */
  var Feature = /** @class */ (function (_super) {
      __extends$a(Feature, _super);
      /**
       * @param {Geometry|Object<string, *>=} opt_geometryOrProperties
       *     You may pass a Geometry object directly, or an object literal containing
       *     properties. If you pass an object literal, you may include a Geometry
       *     associated with a `geometry` key.
       */
      function Feature(opt_geometryOrProperties) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {number|string|undefined}
           */
          _this.id_ = undefined;
          /**
           * @type {string}
           * @private
           */
          _this.geometryName_ = 'geometry';
          /**
           * User provided style.
           * @private
           * @type {import("./style/Style.js").StyleLike}
           */
          _this.style_ = null;
          /**
           * @private
           * @type {import("./style/Style.js").StyleFunction|undefined}
           */
          _this.styleFunction_ = undefined;
          /**
           * @private
           * @type {?import("./events.js").EventsKey}
           */
          _this.geometryChangeKey_ = null;
          _this.addEventListener(getChangeEventType(_this.geometryName_), _this.handleGeometryChanged_);
          if (opt_geometryOrProperties) {
              if (typeof (
              /** @type {?} */ (opt_geometryOrProperties).getSimplifiedGeometry) === 'function') {
                  var geometry = /** @type {Geometry} */ (opt_geometryOrProperties);
                  _this.setGeometry(geometry);
              }
              else {
                  /** @type {Object<string, *>} */
                  var properties = opt_geometryOrProperties;
                  _this.setProperties(properties);
              }
          }
          return _this;
      }
      /**
       * Clone this feature. If the original feature has a geometry it
       * is also cloned. The feature id is not set in the clone.
       * @return {Feature} The clone.
       * @api
       */
      Feature.prototype.clone = function () {
          var clone = new Feature(this.hasProperties() ? this.getProperties() : null);
          clone.setGeometryName(this.getGeometryName());
          var geometry = this.getGeometry();
          if (geometry) {
              clone.setGeometry(geometry.clone());
          }
          var style = this.getStyle();
          if (style) {
              clone.setStyle(style);
          }
          return clone;
      };
      /**
       * Get the feature's default geometry.  A feature may have any number of named
       * geometries.  The "default" geometry (the one that is rendered by default) is
       * set when calling {@link module:ol/Feature~Feature#setGeometry}.
       * @return {Geometry|undefined} The default geometry for the feature.
       * @api
       * @observable
       */
      Feature.prototype.getGeometry = function () {
          return /** @type {Geometry|undefined} */ (this.get(this.geometryName_));
      };
      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is either set when reading data from a remote source or set explicitly by
       * calling {@link module:ol/Feature~Feature#setId}.
       * @return {number|string|undefined} Id.
       * @api
       */
      Feature.prototype.getId = function () {
          return this.id_;
      };
      /**
       * Get the name of the feature's default geometry.  By default, the default
       * geometry is named `geometry`.
       * @return {string} Get the property name associated with the default geometry
       *     for this feature.
       * @api
       */
      Feature.prototype.getGeometryName = function () {
          return this.geometryName_;
      };
      /**
       * Get the feature's style. Will return what was provided to the
       * {@link module:ol/Feature~Feature#setStyle} method.
       * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
       * @api
       */
      Feature.prototype.getStyle = function () {
          return this.style_;
      };
      /**
       * Get the feature's style function.
       * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
       * representing the current style of this feature.
       * @api
       */
      Feature.prototype.getStyleFunction = function () {
          return this.styleFunction_;
      };
      /**
       * @private
       */
      Feature.prototype.handleGeometryChange_ = function () {
          this.changed();
      };
      /**
       * @private
       */
      Feature.prototype.handleGeometryChanged_ = function () {
          if (this.geometryChangeKey_) {
              unlistenByKey(this.geometryChangeKey_);
              this.geometryChangeKey_ = null;
          }
          var geometry = this.getGeometry();
          if (geometry) {
              this.geometryChangeKey_ = listen(geometry, EventType.CHANGE, this.handleGeometryChange_, this);
          }
          this.changed();
      };
      /**
       * Set the default geometry for the feature.  This will update the property
       * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
       * @param {Geometry|undefined} geometry The new geometry.
       * @api
       * @observable
       */
      Feature.prototype.setGeometry = function (geometry) {
          this.set(this.geometryName_, geometry);
      };
      /**
       * Set the style for the feature to override the layer style.  This can be a
       * single style object, an array of styles, or a function that takes a
       * resolution and returns an array of styles. To unset the feature style, call
       * `setStyle()` without arguments or a falsey value.
       * @param {import("./style/Style.js").StyleLike=} opt_style Style for this feature.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      Feature.prototype.setStyle = function (opt_style) {
          this.style_ = opt_style;
          this.styleFunction_ = !opt_style
              ? undefined
              : createStyleFunction(opt_style);
          this.changed();
      };
      /**
       * Set the feature id.  The feature id is considered stable and may be used when
       * requesting features or comparing identifiers returned from a remote source.
       * The feature id can be used with the
       * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
       * @param {number|string|undefined} id The feature id.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      Feature.prototype.setId = function (id) {
          this.id_ = id;
          this.changed();
      };
      /**
       * Set the property name to be used when getting the feature's default geometry.
       * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
       * this name will be returned.
       * @param {string} name The property name of the default geometry.
       * @api
       */
      Feature.prototype.setGeometryName = function (name) {
          this.removeEventListener(getChangeEventType(this.geometryName_), this.handleGeometryChanged_);
          this.geometryName_ = name;
          this.addEventListener(getChangeEventType(this.geometryName_), this.handleGeometryChanged_);
          this.handleGeometryChanged_();
      };
      return Feature;
  }(BaseObject));
  /**
   * Convert the provided object into a feature style function.  Functions passed
   * through unchanged.  Arrays of Style or single style objects wrapped
   * in a new feature style function.
   * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
   *     A feature style function, a single style, or an array of styles.
   * @return {import("./style/Style.js").StyleFunction} A style function.
   */
  function createStyleFunction(obj) {
      if (typeof obj === 'function') {
          return obj;
      }
      else {
          /**
           * @type {Array<import("./style/Style.js").default>}
           */
          var styles_1;
          if (Array.isArray(obj)) {
              styles_1 = obj;
          }
          else {
              assert(typeof ( /** @type {?} */(obj).getZIndex) === 'function', 41); // Expected an `import("./style/Style.js").Style` or an array of `import("./style/Style.js").Style`
              var style = /** @type {import("./style/Style.js").default} */ (obj);
              styles_1 = [style];
          }
          return function () {
              return styles_1;
          };
      }
  }

  /**
   * @module ol/interaction/Property
   */
  /**
   * @enum {string}
   */
  var InteractionProperty = {
      ACTIVE: 'active',
  };

  /**
   * @module ol/geom/flat/closest
   */
  /**
   * Returns the point on the 2D line segment flatCoordinates[offset1] to
   * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
   * dimensions are linearly interpolated.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset1 Offset 1.
   * @param {number} offset2 Offset 2.
   * @param {number} stride Stride.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {Array<number>} closestPoint Closest point.
   */
  function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
      var x1 = flatCoordinates[offset1];
      var y1 = flatCoordinates[offset1 + 1];
      var dx = flatCoordinates[offset2] - x1;
      var dy = flatCoordinates[offset2 + 1] - y1;
      var offset;
      if (dx === 0 && dy === 0) {
          offset = offset1;
      }
      else {
          var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
          if (t > 1) {
              offset = offset2;
          }
          else if (t > 0) {
              for (var i = 0; i < stride; ++i) {
                  closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
              }
              closestPoint.length = stride;
              return;
          }
          else {
              offset = offset1;
          }
      }
      for (var i = 0; i < stride; ++i) {
          closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
  }
  /**
   * Return the squared of the largest distance between any pair of consecutive
   * coordinates.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} max Max squared delta.
   * @return {number} Max squared delta.
   */
  function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
      var x1 = flatCoordinates[offset];
      var y1 = flatCoordinates[offset + 1];
      for (offset += stride; offset < end; offset += stride) {
          var x2 = flatCoordinates[offset];
          var y2 = flatCoordinates[offset + 1];
          var squaredDelta = squaredDistance(x1, y1, x2, y2);
          if (squaredDelta > max) {
              max = squaredDelta;
          }
          x1 = x2;
          y1 = y2;
      }
      return max;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} max Max squared delta.
   * @return {number} Max squared delta.
   */
  function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
          offset = end;
      }
      return max;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {number} max Max squared delta.
   * @return {number} Max squared delta.
   */
  function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
          offset = ends[ends.length - 1];
      }
      return max;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} maxDelta Max delta.
   * @param {boolean} isRing Is ring.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {Array<number>} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @param {Array<number>=} opt_tmpPoint Temporary point object.
   * @return {number} Minimum squared distance.
   */
  function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
      if (offset == end) {
          return minSquaredDistance;
      }
      var i, squaredDistance$$1;
      if (maxDelta === 0) {
          // All points are identical, so just test the first point.
          squaredDistance$$1 = squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
          if (squaredDistance$$1 < minSquaredDistance) {
              for (i = 0; i < stride; ++i) {
                  closestPoint[i] = flatCoordinates[offset + i];
              }
              closestPoint.length = stride;
              return squaredDistance$$1;
          }
          else {
              return minSquaredDistance;
          }
      }
      var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
      var index = offset + stride;
      while (index < end) {
          assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
          squaredDistance$$1 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
          if (squaredDistance$$1 < minSquaredDistance) {
              minSquaredDistance = squaredDistance$$1;
              for (i = 0; i < stride; ++i) {
                  closestPoint[i] = tmpPoint[i];
              }
              closestPoint.length = stride;
              index += stride;
          }
          else {
              // Skip ahead multiple points, because we know that all the skipped
              // points cannot be any closer than the closest point we have found so
              // far.  We know this because we know how close the current point is, how
              // close the closest point we have found so far is, and the maximum
              // distance between consecutive points.  For example, if we're currently
              // at distance 10, the best we've found so far is 3, and that the maximum
              // distance between consecutive points is 2, then we'll need to skip at
              // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
              // finding a closer point.  We use Math.max(..., 1) to ensure that we
              // always advance at least one point, to avoid an infinite loop.
              index +=
                  stride *
                      Math.max(((Math.sqrt(squaredDistance$$1) - Math.sqrt(minSquaredDistance)) /
                          maxDelta) |
                          0, 1);
          }
      }
      if (isRing) {
          // Check the closing segment.
          assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
          squaredDistance$$1 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
          if (squaredDistance$$1 < minSquaredDistance) {
              minSquaredDistance = squaredDistance$$1;
              for (i = 0; i < stride; ++i) {
                  closestPoint[i] = tmpPoint[i];
              }
              closestPoint.length = stride;
          }
      }
      return minSquaredDistance;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} maxDelta Max delta.
   * @param {boolean} isRing Is ring.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {Array<number>} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @param {Array<number>=} opt_tmpPoint Temporary point object.
   * @return {number} Minimum squared distance.
   */
  function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
      var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
          offset = end;
      }
      return minSquaredDistance;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {number} maxDelta Max delta.
   * @param {boolean} isRing Is ring.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {Array<number>} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @param {Array<number>=} opt_tmpPoint Temporary point object.
   * @return {number} Minimum squared distance.
   */
  function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
      var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
          offset = ends[ends.length - 1];
      }
      return minSquaredDistance;
  }

  /**
   * @module ol/geom/flat/simplify
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @return {number} Simplified offset.
   */
  function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
      var n = (end - offset) / stride;
      if (n < 3) {
          for (; offset < end; offset += stride) {
              simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
              simplifiedFlatCoordinates[simplifiedOffset++] =
                  flatCoordinates[offset + 1];
          }
          return simplifiedOffset;
      }
      /** @type {Array<number>} */
      var markers = new Array(n);
      markers[0] = 1;
      markers[n - 1] = 1;
      /** @type {Array<number>} */
      var stack = [offset, end - stride];
      var index = 0;
      while (stack.length > 0) {
          var last = stack.pop();
          var first = stack.pop();
          var maxSquaredDistance = 0;
          var x1 = flatCoordinates[first];
          var y1 = flatCoordinates[first + 1];
          var x2 = flatCoordinates[last];
          var y2 = flatCoordinates[last + 1];
          for (var i = first + stride; i < last; i += stride) {
              var x = flatCoordinates[i];
              var y = flatCoordinates[i + 1];
              var squaredDistance_1 = squaredSegmentDistance(x, y, x1, y1, x2, y2);
              if (squaredDistance_1 > maxSquaredDistance) {
                  index = i;
                  maxSquaredDistance = squaredDistance_1;
              }
          }
          if (maxSquaredDistance > squaredTolerance) {
              markers[(index - offset) / stride] = 1;
              if (first + stride < index) {
                  stack.push(first, index);
              }
              if (index + stride < last) {
                  stack.push(index, last);
              }
          }
      }
      for (var i = 0; i < n; ++i) {
          if (markers[i]) {
              simplifiedFlatCoordinates[simplifiedOffset++] =
                  flatCoordinates[offset + i * stride];
              simplifiedFlatCoordinates[simplifiedOffset++] =
                  flatCoordinates[offset + i * stride + 1];
          }
      }
      return simplifiedOffset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @param {Array<number>} simplifiedEnds Simplified ends.
   * @return {number} Simplified offset.
   */
  function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
          simplifiedEnds.push(simplifiedOffset);
          offset = end;
      }
      return simplifiedOffset;
  }
  /**
   * @param {number} value Value.
   * @param {number} tolerance Tolerance.
   * @return {number} Rounded value.
   */
  function snap(value, tolerance) {
      return tolerance * Math.round(value / tolerance);
  }
  /**
   * Simplifies a line string using an algorithm designed by Tim Schaub.
   * Coordinates are snapped to the nearest value in a virtual grid and
   * consecutive duplicate coordinates are discarded.  This effectively preserves
   * topology as the simplification of any subsection of a line string is
   * independent of the rest of the line string.  This means that, for examples,
   * the common edge between two polygons will be simplified to the same line
   * string independently in both polygons.  This implementation uses a single
   * pass over the coordinates and eliminates intermediate collinear points.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} tolerance Tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @return {number} Simplified offset.
   */
  function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
      // do nothing if the line is empty
      if (offset == end) {
          return simplifiedOffset;
      }
      // snap the first coordinate (P1)
      var x1 = snap(flatCoordinates[offset], tolerance);
      var y1 = snap(flatCoordinates[offset + 1], tolerance);
      offset += stride;
      // add the first coordinate to the output
      simplifiedFlatCoordinates[simplifiedOffset++] = x1;
      simplifiedFlatCoordinates[simplifiedOffset++] = y1;
      // find the next coordinate that does not snap to the same value as the first
      // coordinate (P2)
      var x2, y2;
      do {
          x2 = snap(flatCoordinates[offset], tolerance);
          y2 = snap(flatCoordinates[offset + 1], tolerance);
          offset += stride;
          if (offset == end) {
              // all coordinates snap to the same value, the line collapses to a point
              // push the last snapped value anyway to ensure that the output contains
              // at least two points
              // FIXME should we really return at least two points anyway?
              simplifiedFlatCoordinates[simplifiedOffset++] = x2;
              simplifiedFlatCoordinates[simplifiedOffset++] = y2;
              return simplifiedOffset;
          }
      } while (x2 == x1 && y2 == y1);
      while (offset < end) {
          // snap the next coordinate (P3)
          var x3 = snap(flatCoordinates[offset], tolerance);
          var y3 = snap(flatCoordinates[offset + 1], tolerance);
          offset += stride;
          // skip P3 if it is equal to P2
          if (x3 == x2 && y3 == y2) {
              continue;
          }
          // calculate the delta between P1 and P2
          var dx1 = x2 - x1;
          var dy1 = y2 - y1;
          // calculate the delta between P3 and P1
          var dx2 = x3 - x1;
          var dy2 = y3 - y1;
          // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
          // P1 in the same direction then P2 is on the straight line between P1 and
          // P3
          if (dx1 * dy2 == dy1 * dx2 &&
              ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&
              ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {
              // discard P2 and set P2 = P3
              x2 = x3;
              y2 = y3;
              continue;
          }
          // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
          // between P3 and P1 or on the opposite half of the line to P2.  add P2,
          // and continue with P1 = P2 and P2 = P3
          simplifiedFlatCoordinates[simplifiedOffset++] = x2;
          simplifiedFlatCoordinates[simplifiedOffset++] = y2;
          x1 = x2;
          y1 = y2;
          x2 = x3;
          y2 = y3;
      }
      // add the last point (P2)
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} tolerance Tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @param {Array<number>} simplifiedEnds Simplified ends.
   * @return {number} Simplified offset.
   */
  function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
          simplifiedEnds.push(simplifiedOffset);
          offset = end;
      }
      return simplifiedOffset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {number} tolerance Tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
   * @return {number} Simplified offset.
   */
  function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          var simplifiedEnds = [];
          simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
          simplifiedEndss.push(simplifiedEnds);
          offset = ends[ends.length - 1];
      }
      return simplifiedOffset;
  }

  /**
   * @module ol/geom/flat/segments
   */
  /**
   * This function calls `callback` for each segment of the flat coordinates
   * array. If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
   *     called for each segment.
   * @return {T|boolean} Value.
   * @template T
   */
  function forEach$2(flatCoordinates, offset, end, stride, callback) {
      var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
      var point2 = [];
      var ret;
      for (; offset + stride < end; offset += stride) {
          point2[0] = flatCoordinates[offset + stride];
          point2[1] = flatCoordinates[offset + stride + 1];
          ret = callback(point1, point2);
          if (ret) {
              return ret;
          }
          point1[0] = point2[0];
          point1[1] = point2[1];
      }
      return false;
  }

  /**
   * @module ol/geom/flat/inflate
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {Array<import("../../coordinate.js").Coordinate>=} opt_coordinates Coordinates.
   * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
   */
  function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
      var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
          coordinates[i++] = flatCoordinates.slice(j, j + stride);
      }
      coordinates.length = i;
      return coordinates;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<Array<import("../../coordinate.js").Coordinate>>=} opt_coordinatess Coordinatess.
   * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
   */
  function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
      var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
      var i = 0;
      for (var j = 0, jj = ends.length; j < jj; ++j) {
          var end = ends[j];
          coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
          offset = end;
      }
      coordinatess.length = i;
      return coordinatess;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>=} opt_coordinatesss
   *     Coordinatesss.
   * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
   */
  function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
      var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
      var i = 0;
      for (var j = 0, jj = endss.length; j < jj; ++j) {
          var ends = endss[j];
          coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
          offset = ends[ends.length - 1];
      }
      coordinatesss.length = i;
      return coordinatesss;
  }

  /**
   * @module ol/geom/flat/interpolate
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} fraction Fraction.
   * @param {Array<number>=} opt_dest Destination.
   * @param {number=} opt_dimension Destination dimension (default is `2`)
   * @return {Array<number>} Destination.
   */
  function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {
      var o, t;
      var n = (end - offset) / stride;
      if (n === 1) {
          o = offset;
      }
      else if (n === 2) {
          o = offset;
          t = fraction;
      }
      else if (n !== 0) {
          var x1 = flatCoordinates[offset];
          var y1 = flatCoordinates[offset + 1];
          var length_1 = 0;
          var cumulativeLengths = [0];
          for (var i = offset + stride; i < end; i += stride) {
              var x2 = flatCoordinates[i];
              var y2 = flatCoordinates[i + 1];
              length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
              cumulativeLengths.push(length_1);
              x1 = x2;
              y1 = y2;
          }
          var target = fraction * length_1;
          var index = binarySearch(cumulativeLengths, target);
          if (index < 0) {
              t =
                  (target - cumulativeLengths[-index - 2]) /
                      (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
              o = offset + (-index - 2) * stride;
          }
          else {
              o = offset + index * stride;
          }
      }
      var dimension = opt_dimension > 1 ? opt_dimension : 2;
      var dest = opt_dest ? opt_dest : new Array(dimension);
      for (var i = 0; i < dimension; ++i) {
          dest[i] =
              o === undefined
                  ? NaN
                  : t === undefined
                      ? flatCoordinates[o + i]
                      : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
      }
      return dest;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} m M.
   * @param {boolean} extrapolate Extrapolate.
   * @return {import("../../coordinate.js").Coordinate} Coordinate.
   */
  function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
      if (end == offset) {
          return null;
      }
      var coordinate;
      if (m < flatCoordinates[offset + stride - 1]) {
          if (extrapolate) {
              coordinate = flatCoordinates.slice(offset, offset + stride);
              coordinate[stride - 1] = m;
              return coordinate;
          }
          else {
              return null;
          }
      }
      else if (flatCoordinates[end - 1] < m) {
          if (extrapolate) {
              coordinate = flatCoordinates.slice(end - stride, end);
              coordinate[stride - 1] = m;
              return coordinate;
          }
          else {
              return null;
          }
      }
      // FIXME use O(1) search
      if (m == flatCoordinates[offset + stride - 1]) {
          return flatCoordinates.slice(offset, offset + stride);
      }
      var lo = offset / stride;
      var hi = end / stride;
      while (lo < hi) {
          var mid = (lo + hi) >> 1;
          if (m < flatCoordinates[(mid + 1) * stride - 1]) {
              hi = mid;
          }
          else {
              lo = mid + 1;
          }
      }
      var m0 = flatCoordinates[lo * stride - 1];
      if (m == m0) {
          return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
      }
      var m1 = flatCoordinates[(lo + 1) * stride - 1];
      var t = (m - m0) / (m1 - m0);
      coordinate = [];
      for (var i = 0; i < stride - 1; ++i) {
          coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
      }
      coordinate.push(m);
      return coordinate;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} m M.
   * @param {boolean} extrapolate Extrapolate.
   * @param {boolean} interpolate Interpolate.
   * @return {import("../../coordinate.js").Coordinate} Coordinate.
   */
  function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
      if (interpolate) {
          return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
      }
      var coordinate;
      if (m < flatCoordinates[stride - 1]) {
          if (extrapolate) {
              coordinate = flatCoordinates.slice(0, stride);
              coordinate[stride - 1] = m;
              return coordinate;
          }
          else {
              return null;
          }
      }
      if (flatCoordinates[flatCoordinates.length - 1] < m) {
          if (extrapolate) {
              coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
              coordinate[stride - 1] = m;
              return coordinate;
          }
          else {
              return null;
          }
      }
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          if (offset == end) {
              continue;
          }
          if (m < flatCoordinates[offset + stride - 1]) {
              return null;
          }
          else if (m <= flatCoordinates[end - 1]) {
              return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
          }
          offset = end;
      }
      return null;
  }

  /**
   * @module ol/geom/flat/contains
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} Contains extent.
   */
  function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
      var outside = forEachCorner(extent, 
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains (x, y).
       */
      function (coordinate) {
          return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
      });
      return !outside;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
      // http://geomalgorithms.com/a03-_inclusion.html
      // Copyright 2000 softSurfer, 2012 Dan Sunday
      // This code may be freely used and modified for any purpose
      // providing that this copyright notice is included with it.
      // SoftSurfer makes no warranty for this code, and cannot be held
      // liable for any real or imagined damage resulting from its use.
      // Users of this code must verify correctness for their application.
      var wn = 0;
      var x1 = flatCoordinates[end - stride];
      var y1 = flatCoordinates[end - stride + 1];
      for (; offset < end; offset += stride) {
          var x2 = flatCoordinates[offset];
          var y2 = flatCoordinates[offset + 1];
          if (y1 <= y) {
              if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
                  wn++;
              }
          }
          else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
              wn--;
          }
          x1 = x2;
          y1 = y2;
      }
      return wn !== 0;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
      if (ends.length === 0) {
          return false;
      }
      if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
          return false;
      }
      for (var i = 1, ii = ends.length; i < ii; ++i) {
          if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
              return false;
          }
      }
      return true;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
      if (endss.length === 0) {
          return false;
      }
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
              return true;
          }
          offset = ends[ends.length - 1];
      }
      return false;
  }

  /**
   * @module ol/geom/flat/intersectsextent
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */
  function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
      var coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);
      if (!intersects(extent, coordinatesExtent)) {
          return false;
      }
      if (containsExtent(extent, coordinatesExtent)) {
          return true;
      }
      if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
          return true;
      }
      if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
          return true;
      }
      return forEach$2(flatCoordinates, offset, end, stride, 
      /**
       * @param {import("../../coordinate.js").Coordinate} point1 Start point.
       * @param {import("../../coordinate.js").Coordinate} point2 End point.
       * @return {boolean} `true` if the segment and the extent intersect,
       *     `false` otherwise.
       */
      function (point1, point2) {
          return intersectsSegment(extent, point1, point2);
      });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */
  function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {
              return true;
          }
          offset = ends[i];
      }
      return false;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */
  function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
      if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
          return true;
      }
      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
          return true;
      }
      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
          return true;
      }
      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
          return true;
      }
      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
          return true;
      }
      return false;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */
  function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
      if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
          return false;
      }
      if (ends.length === 1) {
          return true;
      }
      for (var i = 1, ii = ends.length; i < ii; ++i) {
          if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
              if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
                  return false;
              }
          }
      }
      return true;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */
  function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {
              return true;
          }
          offset = ends[ends.length - 1];
      }
      return false;
  }

  /**
   * @module ol/geom/flat/length
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {number} Length.
   */
  function lineStringLength(flatCoordinates, offset, end, stride) {
      var x1 = flatCoordinates[offset];
      var y1 = flatCoordinates[offset + 1];
      var length = 0;
      for (var i = offset + stride; i < end; i += stride) {
          var x2 = flatCoordinates[i];
          var y2 = flatCoordinates[i + 1];
          length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
          x1 = x2;
          y1 = y2;
      }
      return length;
  }

  var __extends$b = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Linestring geometry.
   *
   * @api
   */
  var LineString = /** @class */ (function (_super) {
      __extends$b(LineString, _super);
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       */
      function LineString(coordinates, opt_layout) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {import("../coordinate.js").Coordinate}
           */
          _this.flatMidpoint_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.flatMidpointRevision_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDeltaRevision_ = -1;
          if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
          }
          else {
              _this.setCoordinates(
              /** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
          }
          return _this;
      }
      /**
       * Append the passed coordinate to the coordinates of the linestring.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @api
       */
      LineString.prototype.appendCoordinate = function (coordinate) {
          if (!this.flatCoordinates) {
              this.flatCoordinates = coordinate.slice();
          }
          else {
              extend$1(this.flatCoordinates, coordinate);
          }
          this.changed();
      };
      /**
       * Make a complete copy of the geometry.
       * @return {!LineString} Clone.
       * @api
       */
      LineString.prototype.clone = function () {
          return new LineString(this.flatCoordinates.slice(), this.layout);
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      LineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
          }
          return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
      };
      /**
       * Iterate over each segment, calling the provided callback.
       * If the callback returns a truthy value the function returns that
       * value immediately. Otherwise the function returns `false`.
       *
       * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
       *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
       * @return {T|boolean} Value.
       * @template T,S
       * @api
       */
      LineString.prototype.forEachSegment = function (callback) {
          return forEach$2(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
      };
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * @param {number} m M.
       * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate} Coordinate.
       * @api
       */
      LineString.prototype.getCoordinateAtM = function (m, opt_extrapolate) {
          if (this.layout != GeometryLayout.XYM &&
              this.layout != GeometryLayout.XYZM) {
              return null;
          }
          var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
          return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
      };
      /**
       * Return the coordinates of the linestring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */
      LineString.prototype.getCoordinates = function () {
          return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };
      /**
       * Return the coordinate at the provided fraction along the linestring.
       * The `fraction` is a number between 0 and 1, where 0 is the start of the
       * linestring and 1 is the end.
       * @param {number} fraction Fraction.
       * @param {import("../coordinate.js").Coordinate=} opt_dest Optional coordinate whose values will
       *     be modified. If not provided, a new coordinate will be returned.
       * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
       * @api
       */
      LineString.prototype.getCoordinateAt = function (fraction, opt_dest) {
          return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);
      };
      /**
       * Return the length of the linestring on projected plane.
       * @return {number} Length (on projected plane).
       * @api
       */
      LineString.prototype.getLength = function () {
          return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };
      /**
       * @return {Array<number>} Flat midpoint.
       */
      LineString.prototype.getFlatMidpoint = function () {
          if (this.flatMidpointRevision_ != this.getRevision()) {
              this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
              this.flatMidpointRevision_ = this.getRevision();
          }
          return this.flatMidpoint_;
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LineString} Simplified LineString.
       * @protected
       */
      LineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          var simplifiedFlatCoordinates = [];
          simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
          return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      LineString.prototype.getType = function () {
          return GeometryType.LINE_STRING;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      LineString.prototype.intersectsExtent = function (extent) {
          return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
      };
      /**
       * Set the coordinates of the linestring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      LineString.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 1);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
          this.changed();
      };
      return LineString;
  }(SimpleGeometry));

  var __extends$c = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Events emitted as map events are instances of this type.
   * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map event.
   */
  var MapEvent = /** @class */ (function (_super) {
      __extends$c(MapEvent, _super);
      /**
       * @param {string} type Event type.
       * @param {import("./PluggableMap.js").default} map Map.
       * @param {?import("./PluggableMap.js").FrameState=} opt_frameState Frame state.
       */
      function MapEvent(type, map, opt_frameState) {
          var _this = _super.call(this, type) || this;
          /**
           * The map where the event occurred.
           * @type {import("./PluggableMap.js").default}
           * @api
           */
          _this.map = map;
          /**
           * The frame state at the time of the event.
           * @type {?import("./PluggableMap.js").FrameState}
           * @api
           */
          _this.frameState = opt_frameState !== undefined ? opt_frameState : null;
          return _this;
      }
      return MapEvent;
  }(BaseEvent));

  var __extends$d = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Events emitted as map browser events are instances of this type.
   * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map browser event.
   * @template {UIEvent} EVENT
   */
  var MapBrowserEvent = /** @class */ (function (_super) {
      __extends$d(MapBrowserEvent, _super);
      /**
       * @param {string} type Event type.
       * @param {import("./PluggableMap.js").default} map Map.
       * @param {EVENT} originalEvent Original event.
       * @param {boolean=} opt_dragging Is the map currently being dragged?
       * @param {?import("./PluggableMap.js").FrameState=} opt_frameState Frame state.
       */
      function MapBrowserEvent(type, map, originalEvent, opt_dragging, opt_frameState) {
          var _this = _super.call(this, type, map, opt_frameState) || this;
          /**
           * The original browser event.
           * @const
           * @type {EVENT}
           * @api
           */
          _this.originalEvent = originalEvent;
          /**
           * The map pixel relative to the viewport corresponding to the original browser event.
           * @type {?import("./pixel.js").Pixel}
           */
          _this.pixel_ = null;
          /**
           * The coordinate in the user projection corresponding to the original browser event.
           * @type {?import("./coordinate.js").Coordinate}
           */
          _this.coordinate_ = null;
          /**
           * Indicates if the map is currently being dragged. Only set for
           * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
           *
           * @type {boolean}
           * @api
           */
          _this.dragging = opt_dragging !== undefined ? opt_dragging : false;
          return _this;
      }
      Object.defineProperty(MapBrowserEvent.prototype, "pixel", {
          /**
           * The map pixel relative to the viewport corresponding to the original event.
           * @type {import("./pixel.js").Pixel}
           * @api
           */
          get: function () {
              if (!this.pixel_) {
                  this.pixel_ = this.map.getEventPixel(this.originalEvent);
              }
              return this.pixel_;
          },
          set: function (pixel) {
              this.pixel_ = pixel;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(MapBrowserEvent.prototype, "coordinate", {
          /**
           * The coordinate corresponding to the original browser event.  This will be in the user
           * projection if one is set.  Otherwise it will be in the view projection.
           * @type {import("./coordinate.js").Coordinate}
           * @api
           */
          get: function () {
              if (!this.coordinate_) {
                  this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
              }
              return this.coordinate_;
          },
          set: function (coordinate) {
              this.coordinate_ = coordinate;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * Prevents the default browser action.
       * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
       * @api
       */
      MapBrowserEvent.prototype.preventDefault = function () {
          _super.prototype.preventDefault.call(this);
          this.originalEvent.preventDefault();
      };
      /**
       * Prevents further propagation of the current event.
       * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
       * @api
       */
      MapBrowserEvent.prototype.stopPropagation = function () {
          _super.prototype.stopPropagation.call(this);
          this.originalEvent.stopPropagation();
      };
      return MapBrowserEvent;
  }(MapEvent));

  /**
   * @module ol/MapBrowserEventType
   */
  /**
   * Constants for event names.
   * @enum {string}
   */
  var MapBrowserEventType = {
      /**
       * A true single click with no dragging and no double click. Note that this
       * event is delayed by 250 ms to ensure that it is not a double click.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
       * @api
       */
      SINGLECLICK: 'singleclick',
      /**
       * A click with no dragging. A double click will fire two of this.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
       * @api
       */
      CLICK: EventType.CLICK,
      /**
       * A true double click, with no dragging.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
       * @api
       */
      DBLCLICK: EventType.DBLCLICK,
      /**
       * Triggered when a pointer is dragged.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
       * @api
       */
      POINTERDRAG: 'pointerdrag',
      /**
       * Triggered when a pointer is moved. Note that on touch devices this is
       * triggered when the map is panned, so is not the same as mousemove.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
       * @api
       */
      POINTERMOVE: 'pointermove',
      POINTERDOWN: 'pointerdown',
      POINTERUP: 'pointerup',
      POINTEROVER: 'pointerover',
      POINTEROUT: 'pointerout',
      POINTERENTER: 'pointerenter',
      POINTERLEAVE: 'pointerleave',
      POINTERCANCEL: 'pointercancel',
  };

  var __extends$e = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Multi-linestring geometry.
   *
   * @api
   */
  var MultiLineString = /** @class */ (function (_super) {
      __extends$e(MultiLineString, _super);
      /**
       * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
       *     Coordinates or LineString geometries. (For internal use, flat coordinates in
       *     combination with `opt_layout` and `opt_ends` are also accepted.)
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @param {Array<number>=} opt_ends Flat coordinate ends for internal use.
       */
      function MultiLineString(coordinates, opt_layout, opt_ends) {
          var _this = _super.call(this) || this;
          /**
           * @type {Array<number>}
           * @private
           */
          _this.ends_ = [];
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDeltaRevision_ = -1;
          if (Array.isArray(coordinates[0])) {
              _this.setCoordinates(
              /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (coordinates), opt_layout);
          }
          else if (opt_layout !== undefined && opt_ends) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
              _this.ends_ = opt_ends;
          }
          else {
              var layout = _this.getLayout();
              var lineStrings = /** @type {Array<LineString>} */ (coordinates);
              var flatCoordinates = [];
              var ends = [];
              for (var i = 0, ii = lineStrings.length; i < ii; ++i) {
                  var lineString = lineStrings[i];
                  if (i === 0) {
                      layout = lineString.getLayout();
                  }
                  extend$1(flatCoordinates, lineString.getFlatCoordinates());
                  ends.push(flatCoordinates.length);
              }
              _this.setFlatCoordinates(layout, flatCoordinates);
              _this.ends_ = ends;
          }
          return _this;
      }
      /**
       * Append the passed linestring to the multilinestring.
       * @param {LineString} lineString LineString.
       * @api
       */
      MultiLineString.prototype.appendLineString = function (lineString) {
          if (!this.flatCoordinates) {
              this.flatCoordinates = lineString.getFlatCoordinates().slice();
          }
          else {
              extend$1(this.flatCoordinates, lineString.getFlatCoordinates().slice());
          }
          this.ends_.push(this.flatCoordinates.length);
          this.changed();
      };
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiLineString} Clone.
       * @api
       */
      MultiLineString.prototype.clone = function () {
          return new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      MultiLineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
          }
          return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
      };
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * `opt_interpolate` controls interpolation between consecutive LineStrings
       * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
       * will be linearly interpolated between the last coordinate of one LineString
       * and the first coordinate of the next LineString.  If `opt_interpolate` is
       * `false` then the function will return `null` for Ms falling between
       * LineStrings.
       *
       * @param {number} m M.
       * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
       * @param {boolean=} opt_interpolate Interpolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate} Coordinate.
       * @api
       */
      MultiLineString.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {
          if ((this.layout != GeometryLayout.XYM &&
              this.layout != GeometryLayout.XYZM) ||
              this.flatCoordinates.length === 0) {
              return null;
          }
          var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
          var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
          return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
      };
      /**
       * Return the coordinates of the multilinestring.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       */
      MultiLineString.prototype.getCoordinates = function () {
          return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);
      };
      /**
       * @return {Array<number>} Ends.
       */
      MultiLineString.prototype.getEnds = function () {
          return this.ends_;
      };
      /**
       * Return the linestring at the specified index.
       * @param {number} index Index.
       * @return {LineString} LineString.
       * @api
       */
      MultiLineString.prototype.getLineString = function (index) {
          if (index < 0 || this.ends_.length <= index) {
              return null;
          }
          return new LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
      };
      /**
       * Return the linestrings of this multilinestring.
       * @return {Array<LineString>} LineStrings.
       * @api
       */
      MultiLineString.prototype.getLineStrings = function () {
          var flatCoordinates = this.flatCoordinates;
          var ends = this.ends_;
          var layout = this.layout;
          /** @type {Array<LineString>} */
          var lineStrings = [];
          var offset = 0;
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var lineString = new LineString(flatCoordinates.slice(offset, end), layout);
              lineStrings.push(lineString);
              offset = end;
          }
          return lineStrings;
      };
      /**
       * @return {Array<number>} Flat midpoints.
       */
      MultiLineString.prototype.getFlatMidpoints = function () {
          var midpoints = [];
          var flatCoordinates = this.flatCoordinates;
          var offset = 0;
          var ends = this.ends_;
          var stride = this.stride;
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);
              extend$1(midpoints, midpoint);
              offset = end;
          }
          return midpoints;
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiLineString} Simplified MultiLineString.
       * @protected
       */
      MultiLineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          var simplifiedFlatCoordinates = [];
          var simplifiedEnds = [];
          simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
          return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      MultiLineString.prototype.getType = function () {
          return GeometryType.MULTI_LINE_STRING;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      MultiLineString.prototype.intersectsExtent = function (extent) {
          return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);
      };
      /**
       * Set the coordinates of the multilinestring.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {GeometryLayout=} opt_layout Layout.
       * @api
       */
      MultiLineString.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 2);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
          this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
          this.changed();
      };
      return MultiLineString;
  }(SimpleGeometry));

  var __extends$f = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Point geometry.
   *
   * @api
   */
  var Point$1 = /** @class */ (function (_super) {
      __extends$f(Point, _super);
      /**
       * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       */
      function Point(coordinates, opt_layout) {
          var _this = _super.call(this) || this;
          _this.setCoordinates(coordinates, opt_layout);
          return _this;
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Point} Clone.
       * @api
       */
      Point.prototype.clone = function () {
          var point = new Point(this.flatCoordinates.slice(), this.layout);
          return point;
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      Point.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          var flatCoordinates = this.flatCoordinates;
          var squaredDistance$$1 = squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);
          if (squaredDistance$$1 < minSquaredDistance) {
              var stride = this.stride;
              for (var i = 0; i < stride; ++i) {
                  closestPoint[i] = flatCoordinates[i];
              }
              closestPoint.length = stride;
              return squaredDistance$$1;
          }
          else {
              return minSquaredDistance;
          }
      };
      /**
       * Return the coordinate of the point.
       * @return {import("../coordinate.js").Coordinate} Coordinates.
       * @api
       */
      Point.prototype.getCoordinates = function () {
          return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
      };
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      Point.prototype.computeExtent = function (extent) {
          return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      Point.prototype.getType = function () {
          return GeometryType.POINT;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      Point.prototype.intersectsExtent = function (extent) {
          return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
      };
      /**
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      Point.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 0);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates, this.stride);
          this.changed();
      };
      return Point;
  }(SimpleGeometry));

  var __extends$g = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Multi-point geometry.
   *
   * @api
   */
  var MultiPoint = /** @class */ (function (_super) {
      __extends$g(MultiPoint, _super);
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       */
      function MultiPoint(coordinates, opt_layout) {
          var _this = _super.call(this) || this;
          if (opt_layout && !Array.isArray(coordinates[0])) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
          }
          else {
              _this.setCoordinates(
              /** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
          }
          return _this;
      }
      /**
       * Append the passed point to this multipoint.
       * @param {Point} point Point.
       * @api
       */
      MultiPoint.prototype.appendPoint = function (point) {
          if (!this.flatCoordinates) {
              this.flatCoordinates = point.getFlatCoordinates().slice();
          }
          else {
              extend$1(this.flatCoordinates, point.getFlatCoordinates());
          }
          this.changed();
      };
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPoint} Clone.
       * @api
       */
      MultiPoint.prototype.clone = function () {
          var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
          return multiPoint;
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      MultiPoint.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          var flatCoordinates = this.flatCoordinates;
          var stride = this.stride;
          for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              var squaredDistance$$1 = squaredDistance(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
              if (squaredDistance$$1 < minSquaredDistance) {
                  minSquaredDistance = squaredDistance$$1;
                  for (var j = 0; j < stride; ++j) {
                      closestPoint[j] = flatCoordinates[i + j];
                  }
                  closestPoint.length = stride;
              }
          }
          return minSquaredDistance;
      };
      /**
       * Return the coordinates of the multipoint.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */
      MultiPoint.prototype.getCoordinates = function () {
          return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };
      /**
       * Return the point at the specified index.
       * @param {number} index Index.
       * @return {Point} Point.
       * @api
       */
      MultiPoint.prototype.getPoint = function (index) {
          var n = !this.flatCoordinates
              ? 0
              : this.flatCoordinates.length / this.stride;
          if (index < 0 || n <= index) {
              return null;
          }
          return new Point$1(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
      };
      /**
       * Return the points of this multipoint.
       * @return {Array<Point>} Points.
       * @api
       */
      MultiPoint.prototype.getPoints = function () {
          var flatCoordinates = this.flatCoordinates;
          var layout = this.layout;
          var stride = this.stride;
          /** @type {Array<Point>} */
          var points = [];
          for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              var point = new Point$1(flatCoordinates.slice(i, i + stride), layout);
              points.push(point);
          }
          return points;
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      MultiPoint.prototype.getType = function () {
          return GeometryType.MULTI_POINT;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      MultiPoint.prototype.intersectsExtent = function (extent) {
          var flatCoordinates = this.flatCoordinates;
          var stride = this.stride;
          for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              var x = flatCoordinates[i];
              var y = flatCoordinates[i + 1];
              if (containsXY(extent, x, y)) {
                  return true;
              }
          }
          return false;
      };
      /**
       * Set the coordinates of the multipoint.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      MultiPoint.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 1);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
          this.changed();
      };
      return MultiPoint;
  }(SimpleGeometry));

  /**
   * @module ol/geom/flat/area
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {number} Area.
   */
  function linearRing(flatCoordinates, offset, end, stride) {
      var twiceArea = 0;
      var x1 = flatCoordinates[end - stride];
      var y1 = flatCoordinates[end - stride + 1];
      for (; offset < end; offset += stride) {
          var x2 = flatCoordinates[offset];
          var y2 = flatCoordinates[offset + 1];
          twiceArea += y1 * x2 - x1 * y2;
          x1 = x2;
          y1 = y2;
      }
      return twiceArea / 2;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @return {number} Area.
   */
  function linearRings(flatCoordinates, offset, ends, stride) {
      var area = 0;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          area += linearRing(flatCoordinates, offset, end, stride);
          offset = end;
      }
      return area;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @return {number} Area.
   */
  function linearRingss(flatCoordinates, offset, endss, stride) {
      var area = 0;
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          area += linearRings(flatCoordinates, offset, ends, stride);
          offset = ends[ends.length - 1];
      }
      return area;
  }

  var __extends$h = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Linear ring geometry. Only used as part of polygon; cannot be rendered
   * on its own.
   *
   * @api
   */
  var LinearRing = /** @class */ (function (_super) {
      __extends$h(LinearRing, _super);
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       */
      function LinearRing(coordinates, opt_layout) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDeltaRevision_ = -1;
          if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
          }
          else {
              _this.setCoordinates(
              /** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
          }
          return _this;
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!LinearRing} Clone.
       * @api
       */
      LinearRing.prototype.clone = function () {
          return new LinearRing(this.flatCoordinates.slice(), this.layout);
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      LinearRing.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
          }
          return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
      };
      /**
       * Return the area of the linear ring on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      LinearRing.prototype.getArea = function () {
          return linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };
      /**
       * Return the coordinates of the linear ring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */
      LinearRing.prototype.getCoordinates = function () {
          return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LinearRing} Simplified LinearRing.
       * @protected
       */
      LinearRing.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          var simplifiedFlatCoordinates = [];
          simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
          return new LinearRing(simplifiedFlatCoordinates, GeometryLayout.XY);
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      LinearRing.prototype.getType = function () {
          return GeometryType.LINEAR_RING;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      LinearRing.prototype.intersectsExtent = function (extent) {
          return false;
      };
      /**
       * Set the coordinates of the linear ring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      LinearRing.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 1);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
          this.changed();
      };
      return LinearRing;
  }(SimpleGeometry));

  /**
   * @module ol/geom/flat/interiorpoint
   */
  /**
   * Calculates a point that is likely to lie in the interior of the linear rings.
   * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} flatCenters Flat centers.
   * @param {number} flatCentersOffset Flat center offset.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Destination point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   */
  function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
      var i, ii, x, x1, x2, y1, y2;
      var y = flatCenters[flatCentersOffset + 1];
      /** @type {Array<number>} */
      var intersections = [];
      // Calculate intersections with the horizontal line
      for (var r = 0, rr = ends.length; r < rr; ++r) {
          var end = ends[r];
          x1 = flatCoordinates[end - stride];
          y1 = flatCoordinates[end - stride + 1];
          for (i = offset; i < end; i += stride) {
              x2 = flatCoordinates[i];
              y2 = flatCoordinates[i + 1];
              if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {
                  x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;
                  intersections.push(x);
              }
              x1 = x2;
              y1 = y2;
          }
      }
      // Find the longest segment of the horizontal line that has its center point
      // inside the linear ring.
      var pointX = NaN;
      var maxSegmentLength = -Infinity;
      intersections.sort(numberSafeCompareFunction);
      x1 = intersections[0];
      for (i = 1, ii = intersections.length; i < ii; ++i) {
          x2 = intersections[i];
          var segmentLength = Math.abs(x2 - x1);
          if (segmentLength > maxSegmentLength) {
              x = (x1 + x2) / 2;
              if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
                  pointX = x;
                  maxSegmentLength = segmentLength;
              }
          }
          x1 = x2;
      }
      if (isNaN(pointX)) {
          // There is no horizontal line that has its center point inside the linear
          // ring.  Use the center of the the linear ring's extent.
          pointX = flatCenters[flatCentersOffset];
      }
      if (opt_dest) {
          opt_dest.push(pointX, y, maxSegmentLength);
          return opt_dest;
      }
      else {
          return [pointX, y, maxSegmentLength];
      }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {Array<number>} flatCenters Flat centers.
   * @return {Array<number>} Interior points as XYM coordinates, where M is the
   * length of the horizontal intersection that the point belongs to.
   */
  function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
      var interiorPoints = [];
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
          offset = ends[ends.length - 1];
      }
      return interiorPoints;
  }

  /**
   * @module ol/geom/flat/reverse
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   */
  function coordinates(flatCoordinates, offset, end, stride) {
      while (offset < end - stride) {
          for (var i = 0; i < stride; ++i) {
              var tmp = flatCoordinates[offset + i];
              flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
              flatCoordinates[end - stride + i] = tmp;
          }
          offset += stride;
          end -= stride;
      }
  }

  /**
   * @module ol/geom/flat/orient
   */
  /**
   * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
   * coordinate origin? For a coordinate system with a top-left coordinate origin,
   * the ring's orientation is clockwise when this function returns false.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {boolean} Is clockwise.
   */
  function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
      // https://stackoverflow.com/a/1180256/2389327
      // https://en.wikipedia.org/wiki/Curve_orientation#Orientation_of_a_simple_polygon
      var firstVertexRepeated = true;
      for (var i = 0; i < stride; ++i) {
          if (flatCoordinates[offset + i] !== flatCoordinates[end - stride + i]) {
              firstVertexRepeated = false;
              break;
          }
      }
      if (firstVertexRepeated) {
          end -= stride;
      }
      var iMinVertex = findCornerVertex(flatCoordinates, offset, end, stride);
      // Orientation matrix:
      //     [ 1  xa  ya ]
      // O = | 1  xb  yb |
      //     [ 1  xc  yc ]
      var iPreviousVertex = iMinVertex - stride;
      if (iPreviousVertex < offset) {
          iPreviousVertex = end - stride;
      }
      var iNextVertex = iMinVertex + stride;
      if (iNextVertex >= end) {
          iNextVertex = offset;
      }
      var aX = flatCoordinates[iPreviousVertex];
      var aY = flatCoordinates[iPreviousVertex + 1];
      var bX = flatCoordinates[iMinVertex];
      var bY = flatCoordinates[iMinVertex + 1];
      var cX = flatCoordinates[iNextVertex];
      var cY = flatCoordinates[iNextVertex + 1];
      var determinant = bX * cY + aX * bY + aY * cX - (aY * bX + bY * cX + aX * cY);
      return determinant < 0;
  }
  // Find vertex along one edge of bounding box.
  // In this case, we find smallest y; in case of tie also smallest x.
  function findCornerVertex(flatCoordinates, offset, end, stride) {
      var iMinVertex = -1;
      var minY = Infinity;
      var minXAtMinY = Infinity;
      for (var i = offset; i < end; i += stride) {
          var x = flatCoordinates[i];
          var y = flatCoordinates[i + 1];
          if (y > minY) {
              continue;
          }
          if (y == minY) {
              if (x >= minXAtMinY) {
                  continue;
              }
          }
          // Minimum so far.
          iMinVertex = i;
          minY = y;
          minXAtMinY = x;
      }
      return iMinVertex;
  }
  /**
   * Determines if linear rings are oriented.  By default, left-hand orientation
   * is tested (first ring must be clockwise, remaining rings counter-clockwise).
   * To test for right-hand orientation, use the `opt_right` argument.
   *
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Array of end indexes.
   * @param {number} stride Stride.
   * @param {boolean=} opt_right Test for right-hand orientation
   *     (counter-clockwise exterior ring and clockwise interior rings).
   * @return {boolean} Rings are correctly oriented.
   */
  function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {
      var right = opt_right !== undefined ? opt_right : false;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
          if (i === 0) {
              if ((right && isClockwise) || (!right && !isClockwise)) {
                  return false;
              }
          }
          else {
              if ((right && !isClockwise) || (!right && isClockwise)) {
                  return false;
              }
          }
          offset = end;
      }
      return true;
  }
  /**
   * Determines if linear rings are oriented.  By default, left-hand orientation
   * is tested (first ring must be clockwise, remaining rings counter-clockwise).
   * To test for right-hand orientation, use the `opt_right` argument.
   *
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Array of array of end indexes.
   * @param {number} stride Stride.
   * @param {boolean=} opt_right Test for right-hand orientation
   *     (counter-clockwise exterior ring and clockwise interior rings).
   * @return {boolean} Rings are correctly oriented.
   */
  function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {
              return false;
          }
          if (ends.length) {
              offset = ends[ends.length - 1];
          }
      }
      return true;
  }
  /**
   * Orient coordinates in a flat array of linear rings.  By default, rings
   * are oriented following the left-hand rule (clockwise for exterior and
   * counter-clockwise for interior rings).  To orient according to the
   * right-hand rule, use the `opt_right` argument.
   *
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {boolean=} opt_right Follow the right-hand rule for orientation.
   * @return {number} End.
   */
  function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {
      var right = opt_right !== undefined ? opt_right : false;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
          var reverse = i === 0
              ? (right && isClockwise) || (!right && !isClockwise)
              : (right && !isClockwise) || (!right && isClockwise);
          if (reverse) {
              coordinates(flatCoordinates, offset, end, stride);
          }
          offset = end;
      }
      return offset;
  }
  /**
   * Orient coordinates in a flat array of linear rings.  By default, rings
   * are oriented following the left-hand rule (clockwise for exterior and
   * counter-clockwise for interior rings).  To orient according to the
   * right-hand rule, use the `opt_right` argument.
   *
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Array of array of end indexes.
   * @param {number} stride Stride.
   * @param {boolean=} opt_right Follow the right-hand rule for orientation.
   * @return {number} End.
   */
  function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);
      }
      return offset;
  }

  var __extends$i = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Polygon geometry.
   *
   * @api
   */
  var Polygon$1 = /** @class */ (function (_super) {
      __extends$i(Polygon, _super);
      /**
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
       *     Array of linear rings that define the polygon. The first linear ring of the
       *     array defines the outer-boundary or surface of the polygon. Each subsequent
       *     linear ring defines a hole in the surface of the polygon. A linear ring is
       *     an array of vertices' coordinates where the first coordinate and the last are
       *     equivalent. (For internal use, flat coordinates in combination with
       *     `opt_layout` and `opt_ends` are also accepted.)
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @param {Array<number>=} opt_ends Ends (for internal use with flat coordinates).
       */
      function Polygon(coordinates, opt_layout, opt_ends) {
          var _this = _super.call(this) || this;
          /**
           * @type {Array<number>}
           * @private
           */
          _this.ends_ = [];
          /**
           * @private
           * @type {number}
           */
          _this.flatInteriorPointRevision_ = -1;
          /**
           * @private
           * @type {import("../coordinate.js").Coordinate}
           */
          _this.flatInteriorPoint_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDeltaRevision_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.orientedRevision_ = -1;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.orientedFlatCoordinates_ = null;
          if (opt_layout !== undefined && opt_ends) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
              _this.ends_ = opt_ends;
          }
          else {
              _this.setCoordinates(
              /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (coordinates), opt_layout);
          }
          return _this;
      }
      /**
       * Append the passed linear ring to this polygon.
       * @param {LinearRing} linearRing Linear ring.
       * @api
       */
      Polygon.prototype.appendLinearRing = function (linearRing$$1) {
          if (!this.flatCoordinates) {
              this.flatCoordinates = linearRing$$1.getFlatCoordinates().slice();
          }
          else {
              extend$1(this.flatCoordinates, linearRing$$1.getFlatCoordinates());
          }
          this.ends_.push(this.flatCoordinates.length);
          this.changed();
      };
      /**
       * Make a complete copy of the geometry.
       * @return {!Polygon} Clone.
       * @api
       */
      Polygon.prototype.clone = function () {
          return new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      Polygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
          }
          return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      Polygon.prototype.containsXY = function (x, y) {
          return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
      };
      /**
       * Return the area of the polygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      Polygon.prototype.getArea = function () {
          return linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
      };
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for polygons.
       *
       * @param {boolean=} opt_right Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       */
      Polygon.prototype.getCoordinates = function (opt_right) {
          var flatCoordinates;
          if (opt_right !== undefined) {
              flatCoordinates = this.getOrientedFlatCoordinates().slice();
              orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);
          }
          else {
              flatCoordinates = this.flatCoordinates;
          }
          return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
      };
      /**
       * @return {Array<number>} Ends.
       */
      Polygon.prototype.getEnds = function () {
          return this.ends_;
      };
      /**
       * @return {Array<number>} Interior point.
       */
      Polygon.prototype.getFlatInteriorPoint = function () {
          if (this.flatInteriorPointRevision_ != this.getRevision()) {
              var flatCenter = getCenter(this.getExtent());
              this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
              this.flatInteriorPointRevision_ = this.getRevision();
          }
          return this.flatInteriorPoint_;
      };
      /**
       * Return an interior point of the polygon.
       * @return {Point} Interior point as XYM coordinate, where M is the
       * length of the horizontal intersection that the point belongs to.
       * @api
       */
      Polygon.prototype.getInteriorPoint = function () {
          return new Point$1(this.getFlatInteriorPoint(), GeometryLayout.XYM);
      };
      /**
       * Return the number of rings of the polygon,  this includes the exterior
       * ring and any interior rings.
       *
       * @return {number} Number of rings.
       * @api
       */
      Polygon.prototype.getLinearRingCount = function () {
          return this.ends_.length;
      };
      /**
       * Return the Nth linear ring of the polygon geometry. Return `null` if the
       * given index is out of range.
       * The exterior linear ring is available at index `0` and the interior rings
       * at index `1` and beyond.
       *
       * @param {number} index Index.
       * @return {LinearRing} Linear ring.
       * @api
       */
      Polygon.prototype.getLinearRing = function (index) {
          if (index < 0 || this.ends_.length <= index) {
              return null;
          }
          return new LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
      };
      /**
       * Return the linear rings of the polygon.
       * @return {Array<LinearRing>} Linear rings.
       * @api
       */
      Polygon.prototype.getLinearRings = function () {
          var layout = this.layout;
          var flatCoordinates = this.flatCoordinates;
          var ends = this.ends_;
          var linearRings$$1 = [];
          var offset$$1 = 0;
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var linearRing$$1 = new LinearRing(flatCoordinates.slice(offset$$1, end), layout);
              linearRings$$1.push(linearRing$$1);
              offset$$1 = end;
          }
          return linearRings$$1;
      };
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      Polygon.prototype.getOrientedFlatCoordinates = function () {
          if (this.orientedRevision_ != this.getRevision()) {
              var flatCoordinates = this.flatCoordinates;
              if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
                  this.orientedFlatCoordinates_ = flatCoordinates;
              }
              else {
                  this.orientedFlatCoordinates_ = flatCoordinates.slice();
                  this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
              }
              this.orientedRevision_ = this.getRevision();
          }
          return this.orientedFlatCoordinates_;
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Polygon} Simplified Polygon.
       * @protected
       */
      Polygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          var simplifiedFlatCoordinates = [];
          var simplifiedEnds = [];
          simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
          return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      Polygon.prototype.getType = function () {
          return GeometryType.POLYGON;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      Polygon.prototype.intersectsExtent = function (extent) {
          return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
      };
      /**
       * Set the coordinates of the polygon.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      Polygon.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 2);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
          this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
          this.changed();
      };
      return Polygon;
  }(SimpleGeometry));
  /**
   * Create a polygon from an extent. The layout used is `XY`.
   * @param {import("../extent.js").Extent} extent The extent.
   * @return {Polygon} The polygon.
   * @api
   */
  function fromExtent(extent) {
      var minX = extent[0];
      var minY = extent[1];
      var maxX = extent[2];
      var maxY = extent[3];
      var flatCoordinates = [
          minX,
          minY,
          minX,
          maxY,
          maxX,
          maxY,
          maxX,
          minY,
          minX,
          minY,
      ];
      return new Polygon$1(flatCoordinates, GeometryLayout.XY, [
          flatCoordinates.length,
      ]);
  }
  /**
   * Create a regular polygon from a circle.
   * @param {import("./Circle.js").default} circle Circle geometry.
   * @param {number=} opt_sides Number of sides of the polygon. Default is 32.
   * @param {number=} opt_angle Start angle for the first vertex of the polygon in
   *     radians. Default is 0.
   * @return {Polygon} Polygon geometry.
   * @api
   */
  function fromCircle(circle, opt_sides, opt_angle) {
      var sides = opt_sides ? opt_sides : 32;
      var stride = circle.getStride();
      var layout = circle.getLayout();
      var center = circle.getCenter();
      var arrayLength = stride * (sides + 1);
      var flatCoordinates = new Array(arrayLength);
      for (var i = 0; i < arrayLength; i += stride) {
          flatCoordinates[i] = 0;
          flatCoordinates[i + 1] = 0;
          for (var j = 2; j < stride; j++) {
              flatCoordinates[i + j] = center[j];
          }
      }
      var ends = [flatCoordinates.length];
      var polygon = new Polygon$1(flatCoordinates, layout, ends);
      makeRegular(polygon, center, circle.getRadius(), opt_angle);
      return polygon;
  }
  /**
   * Modify the coordinates of a polygon to make it a regular polygon.
   * @param {Polygon} polygon Polygon geometry.
   * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.
   * @param {number} radius Radius of the regular polygon.
   * @param {number=} opt_angle Start angle for the first vertex of the polygon in
   *     radians. Default is 0.
   */
  function makeRegular(polygon, center, radius, opt_angle) {
      var flatCoordinates = polygon.getFlatCoordinates();
      var stride = polygon.getStride();
      var sides = flatCoordinates.length / stride - 1;
      var startAngle = opt_angle ? opt_angle : 0;
      for (var i = 0; i <= sides; ++i) {
          var offset$$1 = i * stride;
          var angle = startAngle + (modulo(i, sides) * 2 * Math.PI) / sides;
          flatCoordinates[offset$$1] = center[0] + radius * Math.cos(angle);
          flatCoordinates[offset$$1 + 1] = center[1] + radius * Math.sin(angle);
      }
      polygon.changed();
  }

  /**
   * @module ol/geom/flat/center
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @return {Array<number>} Flat centers.
   */
  function linearRingss$1(flatCoordinates, offset, endss, stride) {
      var flatCenters = [];
      var extent = createEmpty();
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);
          flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
          offset = ends[ends.length - 1];
      }
      return flatCenters;
  }

  var __extends$j = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Multi-polygon geometry.
   *
   * @api
   */
  var MultiPolygon = /** @class */ (function (_super) {
      __extends$j(MultiPolygon, _super);
      /**
       * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @param {Array<Array<number>>=} opt_endss Array of ends for internal use with flat coordinates.
       */
      function MultiPolygon(coordinates, opt_layout, opt_endss) {
          var _this = _super.call(this) || this;
          /**
           * @type {Array<Array<number>>}
           * @private
           */
          _this.endss_ = [];
          /**
           * @private
           * @type {number}
           */
          _this.flatInteriorPointsRevision_ = -1;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.flatInteriorPoints_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDeltaRevision_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.orientedRevision_ = -1;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.orientedFlatCoordinates_ = null;
          if (!opt_endss && !Array.isArray(coordinates[0])) {
              var layout = _this.getLayout();
              var polygons = /** @type {Array<Polygon>} */ (coordinates);
              var flatCoordinates = [];
              var endss = [];
              for (var i = 0, ii = polygons.length; i < ii; ++i) {
                  var polygon = polygons[i];
                  if (i === 0) {
                      layout = polygon.getLayout();
                  }
                  var offset = flatCoordinates.length;
                  var ends = polygon.getEnds();
                  for (var j = 0, jj = ends.length; j < jj; ++j) {
                      ends[j] += offset;
                  }
                  extend$1(flatCoordinates, polygon.getFlatCoordinates());
                  endss.push(ends);
              }
              opt_layout = layout;
              coordinates = flatCoordinates;
              opt_endss = endss;
          }
          if (opt_layout !== undefined && opt_endss) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
              _this.endss_ = opt_endss;
          }
          else {
              _this.setCoordinates(
              /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */ (coordinates), opt_layout);
          }
          return _this;
      }
      /**
       * Append the passed polygon to this multipolygon.
       * @param {Polygon} polygon Polygon.
       * @api
       */
      MultiPolygon.prototype.appendPolygon = function (polygon) {
          /** @type {Array<number>} */
          var ends;
          if (!this.flatCoordinates) {
              this.flatCoordinates = polygon.getFlatCoordinates().slice();
              ends = polygon.getEnds().slice();
              this.endss_.push();
          }
          else {
              var offset = this.flatCoordinates.length;
              extend$1(this.flatCoordinates, polygon.getFlatCoordinates());
              ends = polygon.getEnds().slice();
              for (var i = 0, ii = ends.length; i < ii; ++i) {
                  ends[i] += offset;
              }
          }
          this.endss_.push(ends);
          this.changed();
      };
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPolygon} Clone.
       * @api
       */
      MultiPolygon.prototype.clone = function () {
          var len = this.endss_.length;
          var newEndss = new Array(len);
          for (var i = 0; i < len; ++i) {
              newEndss[i] = this.endss_[i].slice();
          }
          return new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      MultiPolygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
          }
          return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      MultiPolygon.prototype.containsXY = function (x, y) {
          return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
      };
      /**
       * Return the area of the multipolygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      MultiPolygon.prototype.getArea = function () {
          return linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
      };
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for multi-polygons.
       *
       * @param {boolean=} opt_right Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
       * @api
       */
      MultiPolygon.prototype.getCoordinates = function (opt_right) {
          var flatCoordinates;
          if (opt_right !== undefined) {
              flatCoordinates = this.getOrientedFlatCoordinates().slice();
              orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);
          }
          else {
              flatCoordinates = this.flatCoordinates;
          }
          return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);
      };
      /**
       * @return {Array<Array<number>>} Endss.
       */
      MultiPolygon.prototype.getEndss = function () {
          return this.endss_;
      };
      /**
       * @return {Array<number>} Flat interior points.
       */
      MultiPolygon.prototype.getFlatInteriorPoints = function () {
          if (this.flatInteriorPointsRevision_ != this.getRevision()) {
              var flatCenters = linearRingss$1(this.flatCoordinates, 0, this.endss_, this.stride);
              this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
              this.flatInteriorPointsRevision_ = this.getRevision();
          }
          return this.flatInteriorPoints_;
      };
      /**
       * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.
       * @return {MultiPoint} Interior points as XYM coordinates, where M is
       * the length of the horizontal intersection that the point belongs to.
       * @api
       */
      MultiPolygon.prototype.getInteriorPoints = function () {
          return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);
      };
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      MultiPolygon.prototype.getOrientedFlatCoordinates = function () {
          if (this.orientedRevision_ != this.getRevision()) {
              var flatCoordinates = this.flatCoordinates;
              if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
                  this.orientedFlatCoordinates_ = flatCoordinates;
              }
              else {
                  this.orientedFlatCoordinates_ = flatCoordinates.slice();
                  this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
              }
              this.orientedRevision_ = this.getRevision();
          }
          return this.orientedFlatCoordinates_;
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiPolygon} Simplified MultiPolygon.
       * @protected
       */
      MultiPolygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          var simplifiedFlatCoordinates = [];
          var simplifiedEndss = [];
          simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
          return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);
      };
      /**
       * Return the polygon at the specified index.
       * @param {number} index Index.
       * @return {Polygon} Polygon.
       * @api
       */
      MultiPolygon.prototype.getPolygon = function (index) {
          if (index < 0 || this.endss_.length <= index) {
              return null;
          }
          var offset;
          if (index === 0) {
              offset = 0;
          }
          else {
              var prevEnds = this.endss_[index - 1];
              offset = prevEnds[prevEnds.length - 1];
          }
          var ends = this.endss_[index].slice();
          var end = ends[ends.length - 1];
          if (offset !== 0) {
              for (var i = 0, ii = ends.length; i < ii; ++i) {
                  ends[i] -= offset;
              }
          }
          return new Polygon$1(this.flatCoordinates.slice(offset, end), this.layout, ends);
      };
      /**
       * Return the polygons of this multipolygon.
       * @return {Array<Polygon>} Polygons.
       * @api
       */
      MultiPolygon.prototype.getPolygons = function () {
          var layout = this.layout;
          var flatCoordinates = this.flatCoordinates;
          var endss = this.endss_;
          var polygons = [];
          var offset = 0;
          for (var i = 0, ii = endss.length; i < ii; ++i) {
              var ends = endss[i].slice();
              var end = ends[ends.length - 1];
              if (offset !== 0) {
                  for (var j = 0, jj = ends.length; j < jj; ++j) {
                      ends[j] -= offset;
                  }
              }
              var polygon = new Polygon$1(flatCoordinates.slice(offset, end), layout, ends);
              polygons.push(polygon);
              offset = end;
          }
          return polygons;
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      MultiPolygon.prototype.getType = function () {
          return GeometryType.MULTI_POLYGON;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      MultiPolygon.prototype.intersectsExtent = function (extent) {
          return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
      };
      /**
       * Set the coordinates of the multipolygon.
       * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      MultiPolygon.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 3);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
          if (endss.length === 0) {
              this.flatCoordinates.length = 0;
          }
          else {
              var lastEnds = endss[endss.length - 1];
              this.flatCoordinates.length =
                  lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
          }
          this.changed();
      };
      return MultiPolygon;
  }(SimpleGeometry));

  /**
   * @module ol/easing
   */
  /**
   * Start slow and speed up.
   * @param {number} t Input between 0 and 1.
   * @return {number} Output between 0 and 1.
   * @api
   */
  function easeIn(t) {
      return Math.pow(t, 3);
  }
  /**
   * Start fast and slow down.
   * @param {number} t Input between 0 and 1.
   * @return {number} Output between 0 and 1.
   * @api
   */
  function easeOut(t) {
      return 1 - easeIn(1 - t);
  }
  /**
   * Start slow, speed up, and then slow down again.
   * @param {number} t Input between 0 and 1.
   * @return {number} Output between 0 and 1.
   * @api
   */
  function inAndOut(t) {
      return 3 * t * t - 2 * t * t * t;
  }
  /**
   * Maintain a constant speed over time.
   * @param {number} t Input between 0 and 1.
   * @return {number} Output between 0 and 1.
   * @api
   */
  function linear(t) {
      return t;
  }

  var __extends$k = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Object literal with config options for interactions.
   * @typedef {Object} InteractionOptions
   * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
   * Method called by the map to notify the interaction that a browser event was
   * dispatched to the map. If the function returns a falsy value, propagation of
   * the event to other interactions in the map's interactions chain will be
   * prevented (this includes functions with no explicit return). The interactions
   * are traversed in reverse order of the interactions collection of the map.
   */
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * User actions that change the state of the map. Some are similar to controls,
   * but are not associated with a DOM element.
   * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
   * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
   * by a keyboard event not a button element event.
   * Although interactions do not have a DOM element, some of them do render
   * vectors and so are visible on the screen.
   * @api
   */
  var Interaction = /** @class */ (function (_super) {
      __extends$k(Interaction, _super);
      /**
       * @param {InteractionOptions=} opt_options Options.
       */
      function Interaction(opt_options) {
          var _this = _super.call(this) || this;
          if (opt_options && opt_options.handleEvent) {
              _this.handleEvent = opt_options.handleEvent;
          }
          /**
           * @private
           * @type {import("../PluggableMap.js").default}
           */
          _this.map_ = null;
          _this.setActive(true);
          return _this;
      }
      /**
       * Return whether the interaction is currently active.
       * @return {boolean} `true` if the interaction is active, `false` otherwise.
       * @observable
       * @api
       */
      Interaction.prototype.getActive = function () {
          return /** @type {boolean} */ (this.get(InteractionProperty.ACTIVE));
      };
      /**
       * Get the map associated with this interaction.
       * @return {import("../PluggableMap.js").default} Map.
       * @api
       */
      Interaction.prototype.getMap = function () {
          return this.map_;
      };
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event}.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @api
       */
      Interaction.prototype.handleEvent = function (mapBrowserEvent) {
          return true;
      };
      /**
       * Activate or deactivate the interaction.
       * @param {boolean} active Active.
       * @observable
       * @api
       */
      Interaction.prototype.setActive = function (active) {
          this.set(InteractionProperty.ACTIVE, active);
      };
      /**
       * Remove the interaction from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       */
      Interaction.prototype.setMap = function (map) {
          this.map_ = map;
      };
      return Interaction;
  }(BaseObject));
  /**
   * @param {import("../View.js").default} view View.
   * @param {import("../coordinate.js").Coordinate} delta Delta.
   * @param {number=} opt_duration Duration.
   */
  function pan(view, delta, opt_duration) {
      var currentCenter = view.getCenterInternal();
      if (currentCenter) {
          var center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
          view.animateInternal({
              duration: opt_duration !== undefined ? opt_duration : 250,
              easing: linear,
              center: view.getConstrainedCenter(center),
          });
      }
  }
  /**
   * @param {import("../View.js").default} view View.
   * @param {number} delta Delta from previous zoom level.
   * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate in the user projection.
   * @param {number=} opt_duration Duration.
   */
  function zoomByDelta(view, delta, opt_anchor, opt_duration) {
      var currentZoom = view.getZoom();
      if (currentZoom === undefined) {
          return;
      }
      var newZoom = view.getConstrainedZoom(currentZoom + delta);
      var newResolution = view.getResolutionForZoom(newZoom);
      if (view.getAnimating()) {
          view.cancelAnimations();
      }
      view.animate({
          resolution: newResolution,
          anchor: opt_anchor,
          duration: opt_duration !== undefined ? opt_duration : 250,
          easing: easeOut,
      });
  }

  var __extends$l = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
   * Function handling "down" events. If the function returns `true` then a drag
   * sequence is started.
   * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
   * Function handling "drag" events. This function is called on "move" events
   * during a drag sequence.
   * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
   * Method called by the map to notify the interaction that a browser event was
   * dispatched to the map. The function may return `false` to prevent the
   * propagation of the event to other interactions in the map's interactions
   * chain.
   * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
   * Function handling "move" events. This function is called on "move" events.
   * This functions is also called during a drag sequence, so during a drag
   * sequence both the `handleDragEvent` function and this function are called.
   * If `handleDownEvent` is defined and it returns true this function will not
   * be called during a drag sequence.
   * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
   *  Function handling "up" events. If the function returns `false` then the
   * current drag sequence is stopped.
   * @property {function(boolean):boolean} [stopDown]
   * Should the down event be propagated to other interactions, or should be
   * stopped?
   */
  /**
   * @classdesc
   * Base class that calls user-defined functions on `down`, `move` and `up`
   * events. This class also manages "drag sequences".
   *
   * When the `handleDownEvent` user function returns `true` a drag sequence is
   * started. During a drag sequence the `handleDragEvent` user function is
   * called on `move` events. The drag sequence ends when the `handleUpEvent`
   * user function is called and returns `false`.
   * @api
   */
  var PointerInteraction = /** @class */ (function (_super) {
      __extends$l(PointerInteraction, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function PointerInteraction(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, 
          /** @type {import("./Interaction.js").InteractionOptions} */ (options)) || this;
          if (options.handleDownEvent) {
              _this.handleDownEvent = options.handleDownEvent;
          }
          if (options.handleDragEvent) {
              _this.handleDragEvent = options.handleDragEvent;
          }
          if (options.handleMoveEvent) {
              _this.handleMoveEvent = options.handleMoveEvent;
          }
          if (options.handleUpEvent) {
              _this.handleUpEvent = options.handleUpEvent;
          }
          if (options.stopDown) {
              _this.stopDown = options.stopDown;
          }
          /**
           * @type {boolean}
           * @protected
           */
          _this.handlingDownUpSequence = false;
          /**
           * @type {!Object<string, PointerEvent>}
           * @private
           */
          _this.trackedPointers_ = {};
          /**
           * @type {Array<PointerEvent>}
           * @protected
           */
          _this.targetPointers = [];
          return _this;
      }
      /**
       * Returns the current number of pointers involved in the interaction,
       * e.g. `2` when two fingers are used.
       * @return {number} The number of pointers.
       * @api
       */
      PointerInteraction.prototype.getPointerCount = function () {
          return this.targetPointers.length;
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       * @protected
       */
      PointerInteraction.prototype.handleDownEvent = function (mapBrowserEvent) {
          return false;
      };
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @protected
       */
      PointerInteraction.prototype.handleDragEvent = function (mapBrowserEvent) { };
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} and may call into
       * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
       * detected.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @api
       */
      PointerInteraction.prototype.handleEvent = function (mapBrowserEvent) {
          if (!mapBrowserEvent.originalEvent) {
              return true;
          }
          var stopEvent = false;
          this.updateTrackedPointers_(mapBrowserEvent);
          if (this.handlingDownUpSequence) {
              if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {
                  this.handleDragEvent(mapBrowserEvent);
                  // prevent page scrolling during dragging
                  mapBrowserEvent.preventDefault();
              }
              else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
                  var handledUp = this.handleUpEvent(mapBrowserEvent);
                  this.handlingDownUpSequence =
                      handledUp && this.targetPointers.length > 0;
              }
          }
          else {
              if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
                  var handled = this.handleDownEvent(mapBrowserEvent);
                  this.handlingDownUpSequence = handled;
                  stopEvent = this.stopDown(handled);
              }
              else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {
                  this.handleMoveEvent(mapBrowserEvent);
              }
          }
          return !stopEvent;
      };
      /**
       * Handle pointer move events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @protected
       */
      PointerInteraction.prototype.handleMoveEvent = function (mapBrowserEvent) { };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       * @protected
       */
      PointerInteraction.prototype.handleUpEvent = function (mapBrowserEvent) {
          return false;
      };
      /**
       * This function is used to determine if "down" events should be propagated
       * to other interactions or should be stopped.
       * @param {boolean} handled Was the event handled by the interaction?
       * @return {boolean} Should the `down` event be stopped?
       */
      PointerInteraction.prototype.stopDown = function (handled) {
          return handled;
      };
      /**
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @private
       */
      PointerInteraction.prototype.updateTrackedPointers_ = function (mapBrowserEvent) {
          if (isPointerDraggingEvent(mapBrowserEvent)) {
              var event_1 = mapBrowserEvent.originalEvent;
              var id = event_1.pointerId.toString();
              if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
                  delete this.trackedPointers_[id];
              }
              else if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
                  this.trackedPointers_[id] = event_1;
              }
              else if (id in this.trackedPointers_) {
                  // update only when there was a pointerdown event for this pointer
                  this.trackedPointers_[id] = event_1;
              }
              this.targetPointers = getValues(this.trackedPointers_);
          }
      };
      return PointerInteraction;
  }(Interaction));
  /**
   * @param {Array<PointerEvent>} pointerEvents List of events.
   * @return {import("../pixel.js").Pixel} Centroid pixel.
   */
  function centroid(pointerEvents) {
      var length = pointerEvents.length;
      var clientX = 0;
      var clientY = 0;
      for (var i = 0; i < length; i++) {
          clientX += pointerEvents[i].clientX;
          clientY += pointerEvents[i].clientY;
      }
      return [clientX / length, clientY / length];
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} Whether the event is a pointerdown, pointerdrag
   *     or pointerup event.
   */
  function isPointerDraggingEvent(mapBrowserEvent) {
      var type = mapBrowserEvent.type;
      return (type === MapBrowserEventType.POINTERDOWN ||
          type === MapBrowserEventType.POINTERDRAG ||
          type === MapBrowserEventType.POINTERUP);
  }

  /**
   * @module ol/layer/Property
   */
  /**
   * @enum {string}
   */
  var LayerProperty = {
      OPACITY: 'opacity',
      VISIBLE: 'visible',
      EXTENT: 'extent',
      Z_INDEX: 'zIndex',
      MAX_RESOLUTION: 'maxResolution',
      MIN_RESOLUTION: 'minResolution',
      MAX_ZOOM: 'maxZoom',
      MIN_ZOOM: 'minZoom',
      SOURCE: 'source',
  };

  var __extends$m = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   */
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Note that with {@link module:ol/layer/Base} and all its subclasses, any property set in
   * the options is set as a {@link module:ol/Object} property on the layer object, so
   * is observable, and has get/set accessors.
   *
   * @api
   */
  var BaseLayer = /** @class */ (function (_super) {
      __extends$m(BaseLayer, _super);
      /**
       * @param {Options} options Layer options.
       */
      function BaseLayer(options) {
          var _this = _super.call(this) || this;
          /**
           * @type {Object<string, *>}
           */
          var properties = assign({}, options);
          properties[LayerProperty.OPACITY] =
              options.opacity !== undefined ? options.opacity : 1;
          assert(typeof properties[LayerProperty.OPACITY] === 'number', 64); // Layer opacity must be a number
          properties[LayerProperty.VISIBLE] =
              options.visible !== undefined ? options.visible : true;
          properties[LayerProperty.Z_INDEX] = options.zIndex;
          properties[LayerProperty.MAX_RESOLUTION] =
              options.maxResolution !== undefined ? options.maxResolution : Infinity;
          properties[LayerProperty.MIN_RESOLUTION] =
              options.minResolution !== undefined ? options.minResolution : 0;
          properties[LayerProperty.MIN_ZOOM] =
              options.minZoom !== undefined ? options.minZoom : -Infinity;
          properties[LayerProperty.MAX_ZOOM] =
              options.maxZoom !== undefined ? options.maxZoom : Infinity;
          /**
           * @type {string}
           * @private
           */
          _this.className_ =
              properties.className !== undefined ? options.className : 'ol-layer';
          delete properties.className;
          _this.setProperties(properties);
          /**
           * @type {import("./Layer.js").State}
           * @private
           */
          _this.state_ = null;
          return _this;
      }
      /**
       * @return {string} CSS class name.
       */
      BaseLayer.prototype.getClassName = function () {
          return this.className_;
      };
      /**
       * This method is not meant to be called by layers or layer renderers because the state
       * is incorrect if the layer is included in a layer group.
       *
       * @param {boolean=} opt_managed Layer is managed.
       * @return {import("./Layer.js").State} Layer state.
       */
      BaseLayer.prototype.getLayerState = function (opt_managed) {
          /** @type {import("./Layer.js").State} */
          var state = this.state_ ||
              /** @type {?} */ ({
                  layer: this,
                  managed: opt_managed === undefined ? true : opt_managed,
              });
          var zIndex = this.getZIndex();
          state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
          state.sourceState = this.getSourceState();
          state.visible = this.getVisible();
          state.extent = this.getExtent();
          state.zIndex =
              zIndex !== undefined ? zIndex : state.managed === false ? Infinity : 0;
          state.maxResolution = this.getMaxResolution();
          state.minResolution = Math.max(this.getMinResolution(), 0);
          state.minZoom = this.getMinZoom();
          state.maxZoom = this.getMaxZoom();
          this.state_ = state;
          return state;
      };
      /**
       * @abstract
       * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be
       *     modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      BaseLayer.prototype.getLayersArray = function (opt_array) {
          return abstract();
      };
      /**
       * @abstract
       * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer
       *     states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      BaseLayer.prototype.getLayerStatesArray = function (opt_states) {
          return abstract();
      };
      /**
       * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
       * will be visible regardless of extent.
       * @return {import("../extent.js").Extent|undefined} The layer extent.
       * @observable
       * @api
       */
      BaseLayer.prototype.getExtent = function () {
          return /** @type {import("../extent.js").Extent|undefined} */ (this.get(LayerProperty.EXTENT));
      };
      /**
       * Return the maximum resolution of the layer.
       * @return {number} The maximum resolution of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getMaxResolution = function () {
          return /** @type {number} */ (this.get(LayerProperty.MAX_RESOLUTION));
      };
      /**
       * Return the minimum resolution of the layer.
       * @return {number} The minimum resolution of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getMinResolution = function () {
          return /** @type {number} */ (this.get(LayerProperty.MIN_RESOLUTION));
      };
      /**
       * Return the minimum zoom level of the layer.
       * @return {number} The minimum zoom level of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getMinZoom = function () {
          return /** @type {number} */ (this.get(LayerProperty.MIN_ZOOM));
      };
      /**
       * Return the maximum zoom level of the layer.
       * @return {number} The maximum zoom level of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getMaxZoom = function () {
          return /** @type {number} */ (this.get(LayerProperty.MAX_ZOOM));
      };
      /**
       * Return the opacity of the layer (between 0 and 1).
       * @return {number} The opacity of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getOpacity = function () {
          return /** @type {number} */ (this.get(LayerProperty.OPACITY));
      };
      /**
       * @abstract
       * @return {import("../source/State.js").default} Source state.
       */
      BaseLayer.prototype.getSourceState = function () {
          return abstract();
      };
      /**
       * Return the visibility of the layer (`true` or `false`).
       * @return {boolean} The visibility of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getVisible = function () {
          return /** @type {boolean} */ (this.get(LayerProperty.VISIBLE));
      };
      /**
       * Return the Z-index of the layer, which is used to order layers before
       * rendering. The default Z-index is 0.
       * @return {number} The Z-index of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getZIndex = function () {
          return /** @type {number} */ (this.get(LayerProperty.Z_INDEX));
      };
      /**
       * Set the extent at which the layer is visible.  If `undefined`, the layer
       * will be visible at all extents.
       * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setExtent = function (extent) {
          this.set(LayerProperty.EXTENT, extent);
      };
      /**
       * Set the maximum resolution at which the layer is visible.
       * @param {number} maxResolution The maximum resolution of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setMaxResolution = function (maxResolution) {
          this.set(LayerProperty.MAX_RESOLUTION, maxResolution);
      };
      /**
       * Set the minimum resolution at which the layer is visible.
       * @param {number} minResolution The minimum resolution of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setMinResolution = function (minResolution) {
          this.set(LayerProperty.MIN_RESOLUTION, minResolution);
      };
      /**
       * Set the maximum zoom (exclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} maxZoom The maximum zoom of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setMaxZoom = function (maxZoom) {
          this.set(LayerProperty.MAX_ZOOM, maxZoom);
      };
      /**
       * Set the minimum zoom (inclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} minZoom The minimum zoom of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setMinZoom = function (minZoom) {
          this.set(LayerProperty.MIN_ZOOM, minZoom);
      };
      /**
       * Set the opacity of the layer, allowed values range from 0 to 1.
       * @param {number} opacity The opacity of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setOpacity = function (opacity) {
          assert(typeof opacity === 'number', 64); // Layer opacity must be a number
          this.set(LayerProperty.OPACITY, opacity);
      };
      /**
       * Set the visibility of the layer (`true` or `false`).
       * @param {boolean} visible The visibility of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setVisible = function (visible) {
          this.set(LayerProperty.VISIBLE, visible);
      };
      /**
       * Set Z-index of the layer, which is used to order layers before rendering.
       * The default Z-index is 0.
       * @param {number} zindex The z-index of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setZIndex = function (zindex) {
          this.set(LayerProperty.Z_INDEX, zindex);
      };
      /**
       * Clean up.
       */
      BaseLayer.prototype.disposeInternal = function () {
          if (this.state_) {
              this.state_.layer = null;
              this.state_ = null;
          }
          _super.prototype.disposeInternal.call(this);
      };
      return BaseLayer;
  }(BaseObject));

  /**
   * @module ol/render/EventType
   */
  /**
   * @enum {string}
   */
  var RenderEventType = {
      /**
       * Triggered before a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#prerender
       * @api
       */
      PRERENDER: 'prerender',
      /**
       * Triggered after a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#postrender
       * @api
       */
      POSTRENDER: 'postrender',
      /**
       * Triggered before layers are rendered.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#precompose
       * @api
       */
      PRECOMPOSE: 'precompose',
      /**
       * Triggered after all layers are rendered.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#postcompose
       * @api
       */
      POSTCOMPOSE: 'postcompose',
      /**
       * Triggered when rendering is complete, i.e. all sources and tiles have
       * finished loading for the current viewport, and all tiles are faded in.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#rendercomplete
       * @api
       */
      RENDERCOMPLETE: 'rendercomplete',
  };

  /**
   * @module ol/source/State
   */
  /**
   * @enum {string}
   * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
   */
  var SourceState = {
      UNDEFINED: 'undefined',
      LOADING: 'loading',
      READY: 'ready',
      ERROR: 'error',
  };

  var __extends$n = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {function(import("../PluggableMap.js").FrameState):HTMLElement} RenderFunction
   */
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {import("../source/Source.js").default} [source] Source for this layer.  If not provided to the constructor,
   * the source can be set by calling {@link module:ol/layer/Layer#setSource layer.setSource(source)} after
   * construction.
   * @property {import("../PluggableMap.js").default} [map] Map.
   * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
   * HTML element. Will overwrite the default rendering for the layer.
   */
  /**
   * @typedef {Object} State
   * @property {import("./Layer.js").default} layer
   * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
   * @property {import("../source/State.js").default} sourceState
   * @property {boolean} visible
   * @property {boolean} managed
   * @property {import("../extent.js").Extent} [extent]
   * @property {number} zIndex
   * @property {number} maxResolution
   * @property {number} minResolution
   * @property {number} minZoom
   * @property {number} maxZoom
   */
  /**
   * @classdesc
   * Base class from which all layer types are derived. This should only be instantiated
   * in the case where a custom layer is be added to the map with a custom `render` function.
   * Such a function can be specified in the `options` object, and is expected to return an HTML element.
   *
   * A visual representation of raster or vector map data.
   * Layers group together those properties that pertain to how the data is to be
   * displayed, irrespective of the source of that data.
   *
   * Layers are usually added to a map with {@link module:ol/Map#addLayer}. Components
   * like {@link module:ol/interaction/Select~Select} use unmanaged layers
   * internally. These unmanaged layers are associated with the map using
   * {@link module:ol/layer/Layer~Layer#setMap} instead.
   *
   * A generic `change` event is fired when the state of the source changes.
   *
   * Please note that for performance reasons several layers might get rendered to
   * the same HTML element, which will cause {@link module:ol/Map~Map#forEachLayerAtPixel} to
   * give false positives. To avoid this, apply different `className` properties to the
   * layers at creation time.
   *
   * @fires import("../render/Event.js").RenderEvent#prerender
   * @fires import("../render/Event.js").RenderEvent#postrender
   *
   * @template {import("../source/Source.js").default} SourceType
   * @api
   */
  var Layer = /** @class */ (function (_super) {
      __extends$n(Layer, _super);
      /**
       * @param {Options} options Layer options.
       */
      function Layer(options) {
          var _this = this;
          var baseOptions = assign({}, options);
          delete baseOptions.source;
          _this = _super.call(this, baseOptions) || this;
          /**
           * @private
           * @type {?import("../events.js").EventsKey}
           */
          _this.mapPrecomposeKey_ = null;
          /**
           * @private
           * @type {?import("../events.js").EventsKey}
           */
          _this.mapRenderKey_ = null;
          /**
           * @private
           * @type {?import("../events.js").EventsKey}
           */
          _this.sourceChangeKey_ = null;
          /**
           * @private
           * @type {import("../renderer/Layer.js").default}
           */
          _this.renderer_ = null;
          // Overwrite default render method with a custom one
          if (options.render) {
              _this.render = options.render;
          }
          if (options.map) {
              _this.setMap(options.map);
          }
          _this.addEventListener(getChangeEventType(LayerProperty.SOURCE), _this.handleSourcePropertyChange_);
          var source = options.source
              ? /** @type {SourceType} */ (options.source)
              : null;
          _this.setSource(source);
          return _this;
      }
      /**
       * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      Layer.prototype.getLayersArray = function (opt_array) {
          var array = opt_array ? opt_array : [];
          array.push(this);
          return array;
      };
      /**
       * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      Layer.prototype.getLayerStatesArray = function (opt_states) {
          var states = opt_states ? opt_states : [];
          states.push(this.getLayerState());
          return states;
      };
      /**
       * Get the layer source.
       * @return {SourceType} The layer source (or `null` if not yet set).
       * @observable
       * @api
       */
      Layer.prototype.getSource = function () {
          return /** @type {SourceType} */ (this.get(LayerProperty.SOURCE)) || null;
      };
      /**
       * @return {import("../source/State.js").default} Source state.
       */
      Layer.prototype.getSourceState = function () {
          var source = this.getSource();
          return !source ? SourceState.UNDEFINED : source.getState();
      };
      /**
       * @private
       */
      Layer.prototype.handleSourceChange_ = function () {
          this.changed();
      };
      /**
       * @private
       */
      Layer.prototype.handleSourcePropertyChange_ = function () {
          if (this.sourceChangeKey_) {
              unlistenByKey(this.sourceChangeKey_);
              this.sourceChangeKey_ = null;
          }
          var source = this.getSource();
          if (source) {
              this.sourceChangeKey_ = listen(source, EventType.CHANGE, this.handleSourceChange_, this);
          }
          this.changed();
      };
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
       * an array of features.
       */
      Layer.prototype.getFeatures = function (pixel) {
          return this.renderer_.getFeatures(pixel);
      };
      /**
       * In charge to manage the rendering of the layer. One layer type is
       * bounded with one layer renderer.
       * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target which the renderer may (but need not) use
       * for rendering its content.
       * @return {HTMLElement} The rendered element.
       */
      Layer.prototype.render = function (frameState, target) {
          var layerRenderer = this.getRenderer();
          if (layerRenderer.prepareFrame(frameState)) {
              return layerRenderer.renderFrame(frameState, target);
          }
      };
      /**
       * Sets the layer to be rendered on top of other layers on a map. The map will
       * not manage this layer in its layers collection, and the callback in
       * {@link module:ol/Map#forEachLayerAtPixel} will receive `null` as layer. This
       * is useful for temporary layers. To remove an unmanaged layer from the map,
       * use `#setMap(null)`.
       *
       * To add the layer to a map and have it managed by the map, use
       * {@link module:ol/Map#addLayer} instead.
       * @param {import("../PluggableMap.js").default} map Map.
       * @api
       */
      Layer.prototype.setMap = function (map) {
          if (this.mapPrecomposeKey_) {
              unlistenByKey(this.mapPrecomposeKey_);
              this.mapPrecomposeKey_ = null;
          }
          if (!map) {
              this.changed();
          }
          if (this.mapRenderKey_) {
              unlistenByKey(this.mapRenderKey_);
              this.mapRenderKey_ = null;
          }
          if (map) {
              this.mapPrecomposeKey_ = listen(map, RenderEventType.PRECOMPOSE, function (evt) {
                  var renderEvent = /** @type {import("../render/Event.js").default} */ (evt);
                  var layerStatesArray = renderEvent.frameState.layerStatesArray;
                  var layerState = this.getLayerState(false);
                  // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.
                  assert(!layerStatesArray.some(function (arrayLayerState) {
                      return arrayLayerState.layer === layerState.layer;
                  }), 67);
                  layerStatesArray.push(layerState);
              }, this);
              this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);
              this.changed();
          }
      };
      /**
       * Set the layer source.
       * @param {SourceType} source The layer source.
       * @observable
       * @api
       */
      Layer.prototype.setSource = function (source) {
          this.set(LayerProperty.SOURCE, source);
      };
      /**
       * Get the renderer for this layer.
       * @return {import("../renderer/Layer.js").default} The layer renderer.
       */
      Layer.prototype.getRenderer = function () {
          if (!this.renderer_) {
              this.renderer_ = this.createRenderer();
          }
          return this.renderer_;
      };
      /**
       * @return {boolean} The layer has a renderer.
       */
      Layer.prototype.hasRenderer = function () {
          return !!this.renderer_;
      };
      /**
       * Create a renderer for this layer.
       * @return {import("../renderer/Layer.js").default} A layer renderer.
       * @protected
       */
      Layer.prototype.createRenderer = function () {
          return null;
      };
      /**
       * Clean up.
       */
      Layer.prototype.disposeInternal = function () {
          this.setSource(null);
          _super.prototype.disposeInternal.call(this);
      };
      return Layer;
  }(BaseLayer));
  /**
   * Return `true` if the layer is visible and if the provided view state
   * has resolution and zoom levels that are in range of the layer's min/max.
   * @param {State} layerState Layer state.
   * @param {import("../View.js").State} viewState View state.
   * @return {boolean} The layer is visible at the given view state.
   */
  function inView(layerState, viewState) {
      if (!layerState.visible) {
          return false;
      }
      var resolution = viewState.resolution;
      if (resolution < layerState.minResolution ||
          resolution >= layerState.maxResolution) {
          return false;
      }
      var zoom = viewState.zoom;
      return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
  }

  /**
   * @module ol/ImageState
   */
  /**
   * @enum {number}
   */
  var ImageState = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      ERROR: 3,
      EMPTY: 4,
  };

  /**
   * @module ol/size
   */
  /**
   * Determines if a size has a positive area.
   * @param {Size} size The size to test.
   * @return {boolean} The size has a positive area.
   */
  function hasArea(size) {
      return size[0] > 0 && size[1] > 0;
  }
  /**
   * Returns a size scaled by a ratio. The result will be an array of integers.
   * @param {Size} size Size.
   * @param {number} ratio Ratio.
   * @param {Size=} opt_size Optional reusable size array.
   * @return {Size} The scaled size.
   */
  function scale$3(size, ratio, opt_size) {
      if (opt_size === undefined) {
          opt_size = [0, 0];
      }
      opt_size[0] = (size[0] * ratio + 0.5) | 0;
      opt_size[1] = (size[1] * ratio + 0.5) | 0;
      return opt_size;
  }
  /**
   * Returns an `Size` array for the passed in number (meaning: square) or
   * `Size` array.
   * (meaning: non-square),
   * @param {number|Size} size Width and height.
   * @param {Size=} opt_size Optional reusable size array.
   * @return {Size} Size.
   * @api
   */
  function toSize(size, opt_size) {
      if (Array.isArray(size)) {
          return size;
      }
      else {
          if (opt_size === undefined) {
              opt_size = [size, size];
          }
          else {
              opt_size[0] = size;
              opt_size[1] = size;
          }
          return opt_size;
      }
  }

  /**
   * @module ol/style/Image
   */
  /**
   * @typedef {Object} Options
   * @property {number} opacity
   * @property {boolean} rotateWithView
   * @property {number} rotation
   * @property {number|import("../size.js").Size} scale
   * @property {Array<number>} displacement
   */
  /**
   * @classdesc
   * A base class used for creating subclasses and not instantiated in
   * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
   * {@link module:ol/style/RegularShape~RegularShape}.
   * @abstract
   * @api
   */
  var ImageStyle = /** @class */ (function () {
      /**
       * @param {Options} options Options.
       */
      function ImageStyle(options) {
          /**
           * @private
           * @type {number}
           */
          this.opacity_ = options.opacity;
          /**
           * @private
           * @type {boolean}
           */
          this.rotateWithView_ = options.rotateWithView;
          /**
           * @private
           * @type {number}
           */
          this.rotation_ = options.rotation;
          /**
           * @private
           * @type {number|import("../size.js").Size}
           */
          this.scale_ = options.scale;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          this.scaleArray_ = toSize(options.scale);
          /**
           * @private
           * @type {Array<number>}
           */
          this.displacement_ = options.displacement;
      }
      /**
       * Clones the style.
       * @return {ImageStyle} The cloned style.
       * @api
       */
      ImageStyle.prototype.clone = function () {
          var scale = this.getScale();
          return new ImageStyle({
              opacity: this.getOpacity(),
              scale: Array.isArray(scale) ? scale.slice() : scale,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
              displacement: this.getDisplacement().slice(),
          });
      };
      /**
       * Get the symbolizer opacity.
       * @return {number} Opacity.
       * @api
       */
      ImageStyle.prototype.getOpacity = function () {
          return this.opacity_;
      };
      /**
       * Determine whether the symbolizer rotates with the map.
       * @return {boolean} Rotate with map.
       * @api
       */
      ImageStyle.prototype.getRotateWithView = function () {
          return this.rotateWithView_;
      };
      /**
       * Get the symoblizer rotation.
       * @return {number} Rotation.
       * @api
       */
      ImageStyle.prototype.getRotation = function () {
          return this.rotation_;
      };
      /**
       * Get the symbolizer scale.
       * @return {number|import("../size.js").Size} Scale.
       * @api
       */
      ImageStyle.prototype.getScale = function () {
          return this.scale_;
      };
      /**
       * Get the symbolizer scale array.
       * @return {import("../size.js").Size} Scale array.
       */
      ImageStyle.prototype.getScaleArray = function () {
          return this.scaleArray_;
      };
      /**
       * Get the displacement of the shape
       * @return {Array<number>} Shape's center displacement
       * @api
       */
      ImageStyle.prototype.getDisplacement = function () {
          return this.displacement_;
      };
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @abstract
       * @return {Array<number>} Anchor.
       */
      ImageStyle.prototype.getAnchor = function () {
          return abstract();
      };
      /**
       * Get the image element for the symbolizer.
       * @abstract
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
       */
      ImageStyle.prototype.getImage = function (pixelRatio) {
          return abstract();
      };
      /**
       * @abstract
       * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
       */
      ImageStyle.prototype.getHitDetectionImage = function () {
          return abstract();
      };
      /*
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * */
      ImageStyle.prototype.getPixelRatio = function (pixelRatio) {
          return 1;
      };
      /**
       * @abstract
       * @return {import("../ImageState.js").default} Image state.
       */
      ImageStyle.prototype.getImageState = function () {
          return abstract();
      };
      /**
       * @abstract
       * @return {import("../size.js").Size} Image size.
       */
      ImageStyle.prototype.getImageSize = function () {
          return abstract();
      };
      /**
       * @abstract
       * @return {import("../size.js").Size} Size of the hit-detection image.
       */
      ImageStyle.prototype.getHitDetectionImageSize = function () {
          return abstract();
      };
      /**
       * Get the origin of the symbolizer.
       * @abstract
       * @return {Array<number>} Origin.
       */
      ImageStyle.prototype.getOrigin = function () {
          return abstract();
      };
      /**
       * Get the size of the symbolizer (in pixels).
       * @abstract
       * @return {import("../size.js").Size} Size.
       */
      ImageStyle.prototype.getSize = function () {
          return abstract();
      };
      /**
       * Set the opacity.
       *
       * @param {number} opacity Opacity.
       * @api
       */
      ImageStyle.prototype.setOpacity = function (opacity) {
          this.opacity_ = opacity;
      };
      /**
       * Set whether to rotate the style with the view.
       *
       * @param {boolean} rotateWithView Rotate with map.
       * @api
       */
      ImageStyle.prototype.setRotateWithView = function (rotateWithView) {
          this.rotateWithView_ = rotateWithView;
      };
      /**
       * Set the rotation.
       *
       * @param {number} rotation Rotation.
       * @api
       */
      ImageStyle.prototype.setRotation = function (rotation) {
          this.rotation_ = rotation;
      };
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size} scale Scale.
       * @api
       */
      ImageStyle.prototype.setScale = function (scale) {
          this.scale_ = scale;
          this.scaleArray_ = toSize(scale);
      };
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      ImageStyle.prototype.listenImageChange = function (listener) {
          abstract();
      };
      /**
       * Load not yet loaded URI.
       * @abstract
       */
      ImageStyle.prototype.load = function () {
          abstract();
      };
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      ImageStyle.prototype.unlistenImageChange = function (listener) {
          abstract();
      };
      return ImageStyle;
  }());

  /**
   * @module ol/color
   */
  /**
   * A color represented as a short array [red, green, blue, alpha].
   * red, green, and blue should be integers in the range 0..255 inclusive.
   * alpha should be a float in the range 0..1 inclusive. If no alpha value is
   * given then `1` will be used.
   * @typedef {Array<number>} Color
   * @api
   */
  /**
   * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
   * @const
   * @type {RegExp}
   * @private
   */
  var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
  /**
   * Regular expression for matching potential named color style strings.
   * @const
   * @type {RegExp}
   * @private
   */
  var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
  /**
   * Return the color as an rgba string.
   * @param {Color|string} color Color.
   * @return {string} Rgba string.
   * @api
   */
  function asString(color) {
      if (typeof color === 'string') {
          return color;
      }
      else {
          return toString$1(color);
      }
  }
  /**
   * Return named color as an rgba string.
   * @param {string} color Named color.
   * @return {string} Rgb string.
   */
  function fromNamed(color) {
      var el = document.createElement('div');
      el.style.color = color;
      if (el.style.color !== '') {
          document.body.appendChild(el);
          var rgb = getComputedStyle(el).color;
          document.body.removeChild(el);
          return rgb;
      }
      else {
          return '';
      }
  }
  /**
   * @param {string} s String.
   * @return {Color} Color.
   */
  var fromString = (function () {
      // We maintain a small cache of parsed strings.  To provide cheap LRU-like
      // semantics, whenever the cache grows too large we simply delete an
      // arbitrary 25% of the entries.
      /**
       * @const
       * @type {number}
       */
      var MAX_CACHE_SIZE = 1024;
      /**
       * @type {Object<string, Color>}
       */
      var cache = {};
      /**
       * @type {number}
       */
      var cacheSize = 0;
      return (
      /**
       * @param {string} s String.
       * @return {Color} Color.
       */
      function (s) {
          var color;
          if (cache.hasOwnProperty(s)) {
              color = cache[s];
          }
          else {
              if (cacheSize >= MAX_CACHE_SIZE) {
                  var i = 0;
                  for (var key in cache) {
                      if ((i++ & 3) === 0) {
                          delete cache[key];
                          --cacheSize;
                      }
                  }
              }
              color = fromStringInternal_(s);
              cache[s] = color;
              ++cacheSize;
          }
          return color;
      });
  })();
  /**
   * Return the color as an array. This function maintains a cache of calculated
   * arrays which means the result should not be modified.
   * @param {Color|string} color Color.
   * @return {Color} Color.
   * @api
   */
  function asArray(color) {
      if (Array.isArray(color)) {
          return color;
      }
      else {
          return fromString(color);
      }
  }
  /**
   * @param {string} s String.
   * @private
   * @return {Color} Color.
   */
  function fromStringInternal_(s) {
      var r, g, b, a, color;
      if (NAMED_COLOR_RE_.exec(s)) {
          s = fromNamed(s);
      }
      if (HEX_COLOR_RE_.exec(s)) {
          // hex
          var n = s.length - 1; // number of hex digits
          var d = // number of digits per channel
           void 0; // number of digits per channel
          if (n <= 4) {
              d = 1;
          }
          else {
              d = 2;
          }
          var hasAlpha = n === 4 || n === 8;
          r = parseInt(s.substr(1 + 0 * d, d), 16);
          g = parseInt(s.substr(1 + 1 * d, d), 16);
          b = parseInt(s.substr(1 + 2 * d, d), 16);
          if (hasAlpha) {
              a = parseInt(s.substr(1 + 3 * d, d), 16);
          }
          else {
              a = 255;
          }
          if (d == 1) {
              r = (r << 4) + r;
              g = (g << 4) + g;
              b = (b << 4) + b;
              if (hasAlpha) {
                  a = (a << 4) + a;
              }
          }
          color = [r, g, b, a / 255];
      }
      else if (s.indexOf('rgba(') == 0) {
          // rgba()
          color = s.slice(5, -1).split(',').map(Number);
          normalize(color);
      }
      else if (s.indexOf('rgb(') == 0) {
          // rgb()
          color = s.slice(4, -1).split(',').map(Number);
          color.push(1);
          normalize(color);
      }
      else {
          assert(false, 14); // Invalid color
      }
      return color;
  }
  /**
   * TODO this function is only used in the test, we probably shouldn't export it
   * @param {Color} color Color.
   * @return {Color} Clamped color.
   */
  function normalize(color) {
      color[0] = clamp((color[0] + 0.5) | 0, 0, 255);
      color[1] = clamp((color[1] + 0.5) | 0, 0, 255);
      color[2] = clamp((color[2] + 0.5) | 0, 0, 255);
      color[3] = clamp(color[3], 0, 1);
      return color;
  }
  /**
   * @param {Color} color Color.
   * @return {string} String.
   */
  function toString$1(color) {
      var r = color[0];
      if (r != (r | 0)) {
          r = (r + 0.5) | 0;
      }
      var g = color[1];
      if (g != (g | 0)) {
          g = (g + 0.5) | 0;
      }
      var b = color[2];
      if (b != (b | 0)) {
          b = (b + 0.5) | 0;
      }
      var a = color[3] === undefined ? 1 : color[3];
      return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  }

  /**
   * @module ol/colorlike
   */
  /**
   * A type accepted by CanvasRenderingContext2D.fillStyle
   * or CanvasRenderingContext2D.strokeStyle.
   * Represents a color, pattern, or gradient. The origin for patterns and
   * gradients as fill style is an increment of 512 css pixels from map coordinate
   * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
   * must be a factor of two (2, 4, 8, ..., 512).
   *
   * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
   * @api
   */
  /**
   * @param {import("./color.js").Color|ColorLike} color Color.
   * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
   * @api
   */
  function asColorLike(color) {
      if (Array.isArray(color)) {
          return toString$1(color);
      }
      else {
          return color;
      }
  }

  /**
   * @module ol/has
   */
  var ua = typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined'
      ? navigator.userAgent.toLowerCase()
      : '';
  /**
   * User agent string says we are dealing with Firefox as browser.
   * @type {boolean}
   */
  var FIREFOX = ua.indexOf('firefox') !== -1;
  /**
   * User agent string says we are dealing with Safari as browser.
   * @type {boolean}
   */
  var SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;
  /**
   * User agent string says we are dealing with a WebKit engine.
   * @type {boolean}
   */
  var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;
  /**
   * User agent string says we are dealing with a Mac as platform.
   * @type {boolean}
   */
  var MAC = ua.indexOf('macintosh') !== -1;
  /**
   * The ratio between physical pixels and device-independent pixels
   * (dips) on the device (`window.devicePixelRatio`).
   * @const
   * @type {number}
   * @api
   */
  var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;
  /**
   * The execution context is a worker with OffscreenCanvas available.
   * @const
   * @type {boolean}
   */
  var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== 'undefined' &&
      typeof OffscreenCanvas !== 'undefined' &&
      self instanceof WorkerGlobalScope; //eslint-disable-line
  /**
   * Image.prototype.decode() is supported.
   * @type {boolean}
   */
  var IMAGE_DECODE = typeof Image !== 'undefined' && Image.prototype.decode;
  /**
   * @type {boolean}
   */
  var PASSIVE_EVENT_LISTENERS = (function () {
      var passive = false;
      try {
          var options = Object.defineProperty({}, 'passive', {
              get: function () {
                  passive = true;
              },
          });
          window.addEventListener('_', null, options);
          window.removeEventListener('_', null, options);
      }
      catch (error) {
          // passive not supported
      }
      return passive;
  })();

  /**
   * @module ol/dom
   */
  //FIXME Move this function to the canvas module
  /**
   * Create an html canvas element and returns its 2d context.
   * @param {number=} opt_width Canvas width.
   * @param {number=} opt_height Canvas height.
   * @param {Array<HTMLCanvasElement>=} opt_canvasPool Canvas pool to take existing canvas from.
   * @return {CanvasRenderingContext2D} The context.
   */
  function createCanvasContext2D(opt_width, opt_height, opt_canvasPool) {
      var canvas = opt_canvasPool && opt_canvasPool.length
          ? opt_canvasPool.shift()
          : WORKER_OFFSCREEN_CANVAS
              ? new OffscreenCanvas(opt_width || 300, opt_height || 300)
              : document.createElement('canvas');
      if (opt_width) {
          canvas.width = opt_width;
      }
      if (opt_height) {
          canvas.height = opt_height;
      }
      //FIXME Allow OffscreenCanvasRenderingContext2D as return type
      return /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
  }
  /**
   * Get the current computed width for the given element including margin,
   * padding and border.
   * Equivalent to jQuery's `$(el).outerWidth(true)`.
   * @param {!HTMLElement} element Element.
   * @return {number} The width.
   */
  function outerWidth(element) {
      var width = element.offsetWidth;
      var style = getComputedStyle(element);
      width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
      return width;
  }
  /**
   * Get the current computed height for the given element including margin,
   * padding and border.
   * Equivalent to jQuery's `$(el).outerHeight(true)`.
   * @param {!HTMLElement} element Element.
   * @return {number} The height.
   */
  function outerHeight(element) {
      var height = element.offsetHeight;
      var style = getComputedStyle(element);
      height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
      return height;
  }
  /**
   * @param {Node} newNode Node to replace old node
   * @param {Node} oldNode The node to be replaced
   */
  function replaceNode(newNode, oldNode) {
      var parent = oldNode.parentNode;
      if (parent) {
          parent.replaceChild(newNode, oldNode);
      }
  }
  /**
   * @param {Node} node The node to remove.
   * @returns {Node} The node that was removed or null.
   */
  function removeNode(node) {
      return node && node.parentNode ? node.parentNode.removeChild(node) : null;
  }
  /**
   * @param {Node} node The node to remove the children from.
   */
  function removeChildren(node) {
      while (node.lastChild) {
          node.removeChild(node.lastChild);
      }
  }
  /**
   * Transform the children of a parent node so they match the
   * provided list of children.  This function aims to efficiently
   * remove, add, and reorder child nodes while maintaining a simple
   * implementation (it is not guaranteed to minimize DOM operations).
   * @param {Node} node The parent node whose children need reworking.
   * @param {Array<Node>} children The desired children.
   */
  function replaceChildren(node, children) {
      var oldChildren = node.childNodes;
      for (var i = 0; true; ++i) {
          var oldChild = oldChildren[i];
          var newChild = children[i];
          // check if our work is done
          if (!oldChild && !newChild) {
              break;
          }
          // check if children match
          if (oldChild === newChild) {
              continue;
          }
          // check if a new child needs to be added
          if (!oldChild) {
              node.appendChild(newChild);
              continue;
          }
          // check if an old child needs to be removed
          if (!newChild) {
              node.removeChild(oldChild);
              --i;
              continue;
          }
          // reorder
          node.insertBefore(newChild, oldChild);
      }
  }

  /**
   * @module ol/css
   */
  /**
   * @typedef {Object} FontParameters
   * @property {string} style
   * @property {string} variant
   * @property {string} weight
   * @property {string} size
   * @property {string} lineHeight
   * @property {string} family
   * @property {Array<string>} families
   */
  /**
   * The CSS class for hidden feature.
   *
   * @const
   * @type {string}
   */
  var CLASS_HIDDEN = 'ol-hidden';
  /**
   * The CSS class that we'll give the DOM elements to have them selectable.
   *
   * @const
   * @type {string}
   */
  var CLASS_SELECTABLE = 'ol-selectable';
  /**
   * The CSS class that we'll give the DOM elements to have them unselectable.
   *
   * @const
   * @type {string}
   */
  var CLASS_UNSELECTABLE = 'ol-unselectable';
  /**
   * The CSS class for unsupported feature.
   *
   * @const
   * @type {string}
   */
  var CLASS_UNSUPPORTED = 'ol-unsupported';
  /**
   * The CSS class for controls.
   *
   * @const
   * @type {string}
   */
  var CLASS_CONTROL = 'ol-control';
  /**
   * The CSS class that we'll give the DOM elements that are collapsed, i.e.
   * to those elements which usually can be expanded.
   *
   * @const
   * @type {string}
   */
  var CLASS_COLLAPSED = 'ol-collapsed';
  /**
   * From http://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
   * @type {RegExp}
   */
  var fontRegEx = new RegExp([
      '^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)',
      '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)',
      '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)',
      '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?',
      '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))',
      '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))',
      '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$',
  ].join(''), 'i');
  var fontRegExMatchIndex = [
      'style',
      'variant',
      'weight',
      'size',
      'lineHeight',
      'family',
  ];
  /**
   * Get the list of font families from a font spec.  Note that this doesn't work
   * for font families that have commas in them.
   * @param {string} fontSpec The CSS font property.
   * @return {FontParameters} The font parameters (or null if the input spec is invalid).
   */
  var getFontParameters = function (fontSpec) {
      var match = fontSpec.match(fontRegEx);
      if (!match) {
          return null;
      }
      var style = /** @type {FontParameters} */ ({
          lineHeight: 'normal',
          size: '1.2em',
          style: 'normal',
          weight: 'normal',
          variant: 'normal',
      });
      for (var i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
          var value = match[i + 1];
          if (value !== undefined) {
              style[fontRegExMatchIndex[i]] = value;
          }
      }
      style.families = style.family.split(/,\s?/);
      return style;
  };

  /**
   * @module ol/render/canvas
   */
  /**
   * @typedef {Object} FillState
   * @property {import("../colorlike.js").ColorLike} fillStyle
   */
  /**
   * @typedef Label
   * @property {number} width
   * @property {number} height
   * @property {Array<string|number>} contextInstructions
   */
  /**
   * @typedef {Object} FillStrokeState
   * @property {import("../colorlike.js").ColorLike} [currentFillStyle]
   * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle]
   * @property {CanvasLineCap} [currentLineCap]
   * @property {Array<number>} currentLineDash
   * @property {number} [currentLineDashOffset]
   * @property {CanvasLineJoin} [currentLineJoin]
   * @property {number} [currentLineWidth]
   * @property {number} [currentMiterLimit]
   * @property {number} [lastStroke]
   * @property {import("../colorlike.js").ColorLike} [fillStyle]
   * @property {import("../colorlike.js").ColorLike} [strokeStyle]
   * @property {CanvasLineCap} [lineCap]
   * @property {Array<number>} lineDash
   * @property {number} [lineDashOffset]
   * @property {CanvasLineJoin} [lineJoin]
   * @property {number} [lineWidth]
   * @property {number} [miterLimit]
   */
  /**
   * @typedef {Object} StrokeState
   * @property {CanvasLineCap} lineCap
   * @property {Array<number>} lineDash
   * @property {number} lineDashOffset
   * @property {CanvasLineJoin} lineJoin
   * @property {number} lineWidth
   * @property {number} miterLimit
   * @property {import("../colorlike.js").ColorLike} strokeStyle
   */
  /**
   * @typedef {Object} TextState
   * @property {string} font
   * @property {string} [textAlign]
   * @property {string} textBaseline
   * @property {string} [placement]
   * @property {number} [maxAngle]
   * @property {boolean} [overflow]
   * @property {import("../style/Fill.js").default} [backgroundFill]
   * @property {import("../style/Stroke.js").default} [backgroundStroke]
   * @property {import("../size.js").Size} [scale]
   * @property {Array<number>} [padding]
   */
  /**
   * Container for decluttered replay instructions that need to be rendered or
   * omitted together, i.e. when styles render both an image and text, or for the
   * characters that form text along lines. The basic elements of this array are
   * `[minX, minY, maxX, maxY, count]`, where the first four entries are the
   * rendered extent of the group in pixel space. `count` is the number of styles
   * in the group, i.e. 2 when an image and a text are grouped, or 1 otherwise.
   * In addition to these four elements, declutter instruction arrays (i.e. the
   * arguments to {@link module:ol/render/canvas~drawImage} are appended to the array.
   * @typedef {Array<*>} DeclutterGroup
   */
  /**
   * Declutter groups for support of multi geometries.
   * @typedef {Array<DeclutterGroup>} DeclutterGroups
   */
  /**
   * @const
   * @type {string}
   */
  var defaultFont = '10px sans-serif';
  /**
   * @const
   * @type {import("../colorlike.js").ColorLike}
   */
  var defaultFillStyle = '#000';
  /**
   * @const
   * @type {CanvasLineCap}
   */
  var defaultLineCap = 'round';
  /**
   * @const
   * @type {Array<number>}
   */
  var defaultLineDash = [];
  /**
   * @const
   * @type {number}
   */
  var defaultLineDashOffset = 0;
  /**
   * @const
   * @type {CanvasLineJoin}
   */
  var defaultLineJoin = 'round';
  /**
   * @const
   * @type {number}
   */
  var defaultMiterLimit = 10;
  /**
   * @const
   * @type {import("../colorlike.js").ColorLike}
   */
  var defaultStrokeStyle = '#000';
  /**
   * @const
   * @type {string}
   */
  var defaultTextAlign = 'center';
  /**
   * @const
   * @type {string}
   */
  var defaultTextBaseline = 'middle';
  /**
   * @const
   * @type {Array<number>}
   */
  var defaultPadding = [0, 0, 0, 0];
  /**
   * @const
   * @type {number}
   */
  var defaultLineWidth = 1;
  /**
   * @type {BaseObject}
   */
  var checkedFonts = new BaseObject();
  /**
   * The label cache for text rendering. To change the default cache size of 2048
   * entries, use {@link module:ol/structs/LRUCache#setSize}.
   * Deprecated - there is no label cache any more.
   * @type {?}
   * @api
   * @deprecated
   */
  var labelCache = new Target();
  labelCache.setSize = function () {
      console.warn('labelCache is deprecated.'); //eslint-disable-line
  };
  /**
   * @type {CanvasRenderingContext2D}
   */
  var measureContext = null;
  /**
   * @type {string}
   */
  var measureFont;
  /**
   * @type {!Object<string, number>}
   */
  var textHeights = {};
  /**
   * Clears the label cache when a font becomes available.
   * @param {string} fontSpec CSS font spec.
   */
  var registerFont = (function () {
      var retries = 100;
      var size = '32px ';
      var referenceFonts = ['monospace', 'serif'];
      var len = referenceFonts.length;
      var text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
      var interval, referenceWidth;
      /**
       * @param {string} fontStyle Css font-style
       * @param {string} fontWeight Css font-weight
       * @param {*} fontFamily Css font-family
       * @return {boolean} Font with style and weight is available
       */
      function isAvailable(fontStyle, fontWeight, fontFamily) {
          var available = true;
          for (var i = 0; i < len; ++i) {
              var referenceFont = referenceFonts[i];
              referenceWidth = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + referenceFont, text);
              if (fontFamily != referenceFont) {
                  var width = measureTextWidth(fontStyle +
                      ' ' +
                      fontWeight +
                      ' ' +
                      size +
                      fontFamily +
                      ',' +
                      referenceFont, text);
                  // If width and referenceWidth are the same, then the fallback was used
                  // instead of the font we wanted, so the font is not available.
                  available = available && width != referenceWidth;
              }
          }
          if (available) {
              return true;
          }
          return false;
      }
      function check() {
          var done = true;
          var fonts = checkedFonts.getKeys();
          for (var i = 0, ii = fonts.length; i < ii; ++i) {
              var font = fonts[i];
              if (checkedFonts.get(font) < retries) {
                  if (isAvailable.apply(this, font.split('\n'))) {
                      clear(textHeights);
                      // Make sure that loaded fonts are picked up by Safari
                      measureContext = null;
                      measureFont = undefined;
                      checkedFonts.set(font, retries);
                  }
                  else {
                      checkedFonts.set(font, checkedFonts.get(font) + 1, true);
                      done = false;
                  }
              }
          }
          if (done) {
              clearInterval(interval);
              interval = undefined;
          }
      }
      return function (fontSpec) {
          var font = getFontParameters(fontSpec);
          if (!font) {
              return;
          }
          var families = font.families;
          for (var i = 0, ii = families.length; i < ii; ++i) {
              var family = families[i];
              var key = font.style + '\n' + font.weight + '\n' + family;
              if (checkedFonts.get(key) === undefined) {
                  checkedFonts.set(key, retries, true);
                  if (!isAvailable(font.style, font.weight, family)) {
                      checkedFonts.set(key, 0, true);
                      if (interval === undefined) {
                          interval = setInterval(check, 32);
                      }
                  }
              }
          }
      };
  })();
  /**
   * @param {string} font Font to use for measuring.
   * @return {import("../size.js").Size} Measurement.
   */
  var measureTextHeight = (function () {
      /**
       * @type {HTMLDivElement}
       */
      var div;
      var heights = textHeights;
      return function (fontSpec) {
          var height = heights[fontSpec];
          if (height == undefined) {
              if (WORKER_OFFSCREEN_CANVAS) {
                  var font = getFontParameters(fontSpec);
                  var metrics = measureText(fontSpec, 'g');
                  var lineHeight = isNaN(Number(font.lineHeight))
                      ? 1.2
                      : Number(font.lineHeight);
                  textHeights[fontSpec] =
                      lineHeight *
                          (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
              }
              else {
                  if (!div) {
                      div = document.createElement('div');
                      div.innerHTML = 'M';
                      div.style.margin = '0 !important';
                      div.style.padding = '0 !important';
                      div.style.position = 'absolute !important';
                      div.style.left = '-99999px !important';
                  }
                  div.style.font = fontSpec;
                  document.body.appendChild(div);
                  height = div.offsetHeight;
                  heights[fontSpec] = height;
                  document.body.removeChild(div);
              }
          }
          return height;
      };
  })();
  /**
   * @param {string} font Font.
   * @param {string} text Text.
   * @return {TextMetrics} Text metrics.
   */
  function measureText(font, text) {
      if (!measureContext) {
          measureContext = createCanvasContext2D(1, 1);
      }
      if (font != measureFont) {
          measureContext.font = font;
          measureFont = measureContext.font;
      }
      return measureContext.measureText(text);
  }
  /**
   * @param {string} font Font.
   * @param {string} text Text.
   * @return {number} Width.
   */
  function measureTextWidth(font, text) {
      return measureText(font, text).width;
  }
  /**
   * Measure text width using a cache.
   * @param {string} font The font.
   * @param {string} text The text to measure.
   * @param {Object<string, number>} cache A lookup of cached widths by text.
   * @returns {number} The text width.
   */
  function measureAndCacheTextWidth(font, text, cache) {
      if (text in cache) {
          return cache[text];
      }
      var width = measureTextWidth(font, text);
      cache[text] = width;
      return width;
  }
  /**
   * @param {string} font Font to use for measuring.
   * @param {Array<string>} lines Lines to measure.
   * @param {Array<number>} widths Array will be populated with the widths of
   * each line.
   * @return {number} Width of the whole text.
   */
  function measureTextWidths(font, lines, widths) {
      var numLines = lines.length;
      var width = 0;
      for (var i = 0; i < numLines; ++i) {
          var currentWidth = measureTextWidth(font, lines[i]);
          width = Math.max(width, currentWidth);
          widths.push(currentWidth);
      }
      return width;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} rotation Rotation.
   * @param {number} offsetX X offset.
   * @param {number} offsetY Y offset.
   */
  function rotateAtOffset(context, rotation, offsetX, offsetY) {
      if (rotation !== 0) {
          context.translate(offsetX, offsetY);
          context.rotate(rotation);
          context.translate(-offsetX, -offsetY);
      }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../transform.js").Transform|null} transform Transform.
   * @param {number} opacity Opacity.
   * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} w Width.
   * @param {number} h Height.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../size.js").Size} scale Scale.
   */
  function drawImageOrLabel(context, transform, opacity, labelOrImage, originX, originY, w, h, x, y, scale$$1) {
      context.save();
      if (opacity !== 1) {
          context.globalAlpha *= opacity;
      }
      if (transform) {
          context.setTransform.apply(context, transform);
      }
      if ( /** @type {*} */(labelOrImage).contextInstructions) {
          // label
          context.translate(x, y);
          context.scale(scale$$1[0], scale$$1[1]);
          executeLabelInstructions(/** @type {Label} */ (labelOrImage), context);
      }
      else if (scale$$1[0] < 0 || scale$$1[1] < 0) {
          // flipped image
          context.translate(x, y);
          context.scale(scale$$1[0], scale$$1[1]);
          context.drawImage(
          /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ (labelOrImage), originX, originY, w, h, 0, 0, w, h);
      }
      else {
          // if image not flipped translate and scale can be avoided
          context.drawImage(
          /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ (labelOrImage), originX, originY, w, h, x, y, w * scale$$1[0], h * scale$$1[1]);
      }
      context.restore();
  }
  /**
   * @param {Label} label Label.
   * @param {CanvasRenderingContext2D} context Context.
   */
  function executeLabelInstructions(label, context) {
      var contextInstructions = label.contextInstructions;
      for (var i = 0, ii = contextInstructions.length; i < ii; i += 2) {
          if (Array.isArray(contextInstructions[i + 1])) {
              context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
          }
          else {
              context[contextInstructions[i]] = contextInstructions[i + 1];
          }
      }
  }
  /**
   * @type {HTMLCanvasElement}
   * @private
   */
  var createTransformStringCanvas = null;
  /**
   * @param {import("../transform.js").Transform} transform Transform.
   * @return {string} CSS transform.
   */
  function createTransformString(transform) {
      if (WORKER_OFFSCREEN_CANVAS) {
          return toString(transform);
      }
      else {
          if (!createTransformStringCanvas) {
              createTransformStringCanvas = createCanvasContext2D(1, 1).canvas;
          }
          createTransformStringCanvas.style.transform = toString(transform);
          return createTransformStringCanvas.style.transform;
      }
  }

  /**
   * @module ol/style/RegularShape
   */
  var __extends$o = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Specify radius for regular polygons, or radius1 and radius2 for stars.
   * @typedef {Object} Options
   * @property {import("./Fill.js").default} [fill] Fill style.
   * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
   * is the number of sides.
   * @property {number} [radius] Radius of a regular polygon.
   * @property {number} [radius1] Outer radius of a star.
   * @property {number} [radius2] Inner radius of a star.
   * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
   * @property {Array<number>} [displacement=[0,0]] Displacement of the shape
   * @property {import("./Stroke.js").default} [stroke] Stroke style.
   * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
   * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
   */
  /**
   * @typedef {Object} RenderOptions
   * @property {import("../colorlike.js").ColorLike} [strokeStyle]
   * @property {number} strokeWidth
   * @property {number} size
   * @property {CanvasLineCap} lineCap
   * @property {Array<number>} lineDash
   * @property {number} lineDashOffset
   * @property {CanvasLineJoin} lineJoin
   * @property {number} miterLimit
   */
  /**
   * @classdesc
   * Set regular shape style for vector features. The resulting shape will be
   * a regular polygon when `radius` is provided, or a star when `radius1` and
   * `radius2` are provided.
   * @api
   */
  var RegularShape = /** @class */ (function (_super) {
      __extends$o(RegularShape, _super);
      /**
       * @param {Options} options Options.
       */
      function RegularShape(options) {
          var _this = this;
          /**
           * @type {boolean}
           */
          var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
          _this = _super.call(this, {
              opacity: 1,
              rotateWithView: rotateWithView,
              rotation: options.rotation !== undefined ? options.rotation : 0,
              scale: 1,
              displacement: options.displacement !== undefined ? options.displacement : [0, 0],
          }) || this;
          /**
           * @private
           * @type {Object<number, HTMLCanvasElement>}
           */
          _this.canvas_ = {};
          /**
           * @private
           * @type {HTMLCanvasElement}
           */
          _this.hitDetectionCanvas_ = null;
          /**
           * @private
           * @type {import("./Fill.js").default}
           */
          _this.fill_ = options.fill !== undefined ? options.fill : null;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.origin_ = [0, 0];
          /**
           * @private
           * @type {number}
           */
          _this.points_ = options.points;
          /**
           * @protected
           * @type {number}
           */
          _this.radius_ =
              options.radius !== undefined ? options.radius : options.radius1;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.radius2_ = options.radius2;
          /**
           * @private
           * @type {number}
           */
          _this.angle_ = options.angle !== undefined ? options.angle : 0;
          /**
           * @private
           * @type {import("./Stroke.js").default}
           */
          _this.stroke_ = options.stroke !== undefined ? options.stroke : null;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.anchor_ = null;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          _this.size_ = null;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          _this.imageSize_ = null;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          _this.hitDetectionImageSize_ = null;
          _this.render();
          return _this;
      }
      /**
       * Clones the style.
       * @return {RegularShape} The cloned style.
       * @api
       */
      RegularShape.prototype.clone = function () {
          var style = new RegularShape({
              fill: this.getFill() ? this.getFill().clone() : undefined,
              points: this.getPoints(),
              radius: this.getRadius(),
              radius2: this.getRadius2(),
              angle: this.getAngle(),
              stroke: this.getStroke() ? this.getStroke().clone() : undefined,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
              displacement: this.getDisplacement().slice(),
          });
          style.setOpacity(this.getOpacity());
          style.setScale(this.getScale());
          return style;
      };
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @return {Array<number>} Anchor.
       * @api
       */
      RegularShape.prototype.getAnchor = function () {
          return this.anchor_;
      };
      /**
       * Get the angle used in generating the shape.
       * @return {number} Shape's rotation in radians.
       * @api
       */
      RegularShape.prototype.getAngle = function () {
          return this.angle_;
      };
      /**
       * Get the fill style for the shape.
       * @return {import("./Fill.js").default} Fill style.
       * @api
       */
      RegularShape.prototype.getFill = function () {
          return this.fill_;
      };
      /**
       * @return {HTMLCanvasElement} Image element.
       */
      RegularShape.prototype.getHitDetectionImage = function () {
          if (!this.hitDetectionCanvas_) {
              var renderOptions = this.createRenderOptions();
              this.createHitDetectionCanvas_(renderOptions);
          }
          return this.hitDetectionCanvas_;
      };
      /**
       * Get the image icon.
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLCanvasElement} Image or Canvas element.
       * @api
       */
      RegularShape.prototype.getImage = function (pixelRatio) {
          if (!this.canvas_[pixelRatio || 1]) {
              var renderOptions = this.createRenderOptions();
              var context = createCanvasContext2D(renderOptions.size * pixelRatio || 1, renderOptions.size * pixelRatio || 1);
              this.draw_(renderOptions, context, 0, 0, pixelRatio || 1);
              this.canvas_[pixelRatio || 1] = context.canvas;
          }
          return this.canvas_[pixelRatio || 1];
      };
      /*
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * */
      RegularShape.prototype.getPixelRatio = function (pixelRatio) {
          return pixelRatio;
      };
      /**
       * @return {import("../size.js").Size} Image size.
       */
      RegularShape.prototype.getImageSize = function () {
          return this.imageSize_;
      };
      /**
       * @return {import("../size.js").Size} Size of the hit-detection image.
       */
      RegularShape.prototype.getHitDetectionImageSize = function () {
          return this.hitDetectionImageSize_;
      };
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      RegularShape.prototype.getImageState = function () {
          return ImageState.LOADED;
      };
      /**
       * Get the origin of the symbolizer.
       * @return {Array<number>} Origin.
       * @api
       */
      RegularShape.prototype.getOrigin = function () {
          return this.origin_;
      };
      /**
       * Get the number of points for generating the shape.
       * @return {number} Number of points for stars and regular polygons.
       * @api
       */
      RegularShape.prototype.getPoints = function () {
          return this.points_;
      };
      /**
       * Get the (primary) radius for the shape.
       * @return {number} Radius.
       * @api
       */
      RegularShape.prototype.getRadius = function () {
          return this.radius_;
      };
      /**
       * Get the secondary radius for the shape.
       * @return {number|undefined} Radius2.
       * @api
       */
      RegularShape.prototype.getRadius2 = function () {
          return this.radius2_;
      };
      /**
       * Get the size of the symbolizer (in pixels).
       * @return {import("../size.js").Size} Size.
       * @api
       */
      RegularShape.prototype.getSize = function () {
          return this.size_;
      };
      /**
       * Get the stroke style for the shape.
       * @return {import("./Stroke.js").default} Stroke style.
       * @api
       */
      RegularShape.prototype.getStroke = function () {
          return this.stroke_;
      };
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      RegularShape.prototype.listenImageChange = function (listener) { };
      /**
       * Load not yet loaded URI.
       */
      RegularShape.prototype.load = function () { };
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      RegularShape.prototype.unlistenImageChange = function (listener) { };
      /**
       * @returns {RenderOptions}  The render options
       * @protected
       */
      RegularShape.prototype.createRenderOptions = function () {
          var lineCap = defaultLineCap;
          var lineJoin = defaultLineJoin;
          var miterLimit = 0;
          var lineDash = null;
          var lineDashOffset = 0;
          var strokeStyle;
          var strokeWidth = 0;
          if (this.stroke_) {
              strokeStyle = this.stroke_.getColor();
              if (strokeStyle === null) {
                  strokeStyle = defaultStrokeStyle;
              }
              strokeStyle = asColorLike(strokeStyle);
              strokeWidth = this.stroke_.getWidth();
              if (strokeWidth === undefined) {
                  strokeWidth = defaultLineWidth;
              }
              lineDash = this.stroke_.getLineDash();
              lineDashOffset = this.stroke_.getLineDashOffset();
              lineJoin = this.stroke_.getLineJoin();
              if (lineJoin === undefined) {
                  lineJoin = defaultLineJoin;
              }
              lineCap = this.stroke_.getLineCap();
              if (lineCap === undefined) {
                  lineCap = defaultLineCap;
              }
              miterLimit = this.stroke_.getMiterLimit();
              if (miterLimit === undefined) {
                  miterLimit = defaultMiterLimit;
              }
          }
          var size = 2 * (this.radius_ + strokeWidth) + 1;
          return {
              strokeStyle: strokeStyle,
              strokeWidth: strokeWidth,
              size: size,
              lineCap: lineCap,
              lineDash: lineDash,
              lineDashOffset: lineDashOffset,
              lineJoin: lineJoin,
              miterLimit: miterLimit,
          };
      };
      /**
       * @protected
       */
      RegularShape.prototype.render = function () {
          var renderOptions = this.createRenderOptions();
          var context = createCanvasContext2D(renderOptions.size, renderOptions.size);
          this.draw_(renderOptions, context, 0, 0, 1);
          this.canvas_[1] = context.canvas;
          // canvas.width and height are rounded to the closest integer
          var size = context.canvas.width;
          var imageSize = size;
          var displacement = this.getDisplacement();
          this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];
          this.createHitDetectionCanvas_(renderOptions);
          this.anchor_ = [size / 2 - displacement[0], size / 2 + displacement[1]];
          this.size_ = [size, size];
          this.imageSize_ = [imageSize, imageSize];
      };
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The rendering context.
       * @param {number} x The origin for the symbol (x).
       * @param {number} y The origin for the symbol (y).
       * @param {number} pixelRatio The pixel ratio.
       */
      RegularShape.prototype.draw_ = function (renderOptions, context, x, y, pixelRatio) {
          var i, angle0, radiusC;
          // reset transform
          context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          // then move to (x, y)
          context.translate(x, y);
          context.beginPath();
          var points = this.points_;
          if (points === Infinity) {
              context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
          }
          else {
              var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;
              if (radius2 !== this.radius_) {
                  points = 2 * points;
              }
              for (i = 0; i <= points; i++) {
                  angle0 = (i * 2 * Math.PI) / points - Math.PI / 2 + this.angle_;
                  radiusC = i % 2 === 0 ? this.radius_ : radius2;
                  context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
              }
          }
          if (this.fill_) {
              var color = this.fill_.getColor();
              if (color === null) {
                  color = defaultFillStyle;
              }
              context.fillStyle = asColorLike(color);
              context.fill();
          }
          if (this.stroke_) {
              context.strokeStyle = renderOptions.strokeStyle;
              context.lineWidth = renderOptions.strokeWidth;
              if (context.setLineDash && renderOptions.lineDash) {
                  context.setLineDash(renderOptions.lineDash);
                  context.lineDashOffset = renderOptions.lineDashOffset;
              }
              context.lineCap = renderOptions.lineCap;
              context.lineJoin = renderOptions.lineJoin;
              context.miterLimit = renderOptions.miterLimit;
              context.stroke();
          }
          context.closePath();
      };
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       */
      RegularShape.prototype.createHitDetectionCanvas_ = function (renderOptions) {
          this.hitDetectionCanvas_ = this.getImage(1);
          if (this.fill_) {
              var color = this.fill_.getColor();
              // determine if fill is transparent (or pattern or gradient)
              var opacity = 0;
              if (typeof color === 'string') {
                  color = asArray(color);
              }
              if (color === null) {
                  opacity = 1;
              }
              else if (Array.isArray(color)) {
                  opacity = color.length === 4 ? color[3] : 1;
              }
              if (opacity === 0) {
                  // if a transparent fill style is set, create an extra hit-detection image
                  // with a default fill style
                  var context = createCanvasContext2D(renderOptions.size, renderOptions.size);
                  this.hitDetectionCanvas_ = context.canvas;
                  this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
              }
          }
      };
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The context.
       * @param {number} x The origin for the symbol (x).
       * @param {number} y The origin for the symbol (y).
       */
      RegularShape.prototype.drawHitDetectionCanvas_ = function (renderOptions, context, x, y) {
          // move to (x, y)
          context.translate(x, y);
          context.beginPath();
          var points = this.points_;
          if (points === Infinity) {
              context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
          }
          else {
              var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;
              if (radius2 !== this.radius_) {
                  points = 2 * points;
              }
              var i = void 0, radiusC = void 0, angle0 = void 0;
              for (i = 0; i <= points; i++) {
                  angle0 = (i * 2 * Math.PI) / points - Math.PI / 2 + this.angle_;
                  radiusC = i % 2 === 0 ? this.radius_ : radius2;
                  context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
              }
          }
          context.fillStyle = defaultFillStyle;
          context.fill();
          if (this.stroke_) {
              context.strokeStyle = renderOptions.strokeStyle;
              context.lineWidth = renderOptions.strokeWidth;
              if (renderOptions.lineDash) {
                  context.setLineDash(renderOptions.lineDash);
                  context.lineDashOffset = renderOptions.lineDashOffset;
              }
              context.stroke();
          }
          context.closePath();
      };
      return RegularShape;
  }(ImageStyle));

  /**
   * @module ol/style/Circle
   */
  var __extends$p = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("./Fill.js").default} [fill] Fill style.
   * @property {number} radius Circle radius.
   * @property {import("./Stroke.js").default} [stroke] Stroke style.
   * @property {Array<number>} [displacement=[0,0]] displacement
   */
  /**
   * @classdesc
   * Set circle style for vector features.
   * @api
   */
  var CircleStyle = /** @class */ (function (_super) {
      __extends$p(CircleStyle, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function CircleStyle(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              points: Infinity,
              fill: options.fill,
              radius: options.radius,
              stroke: options.stroke,
              displacement: options.displacement !== undefined ? options.displacement : [0, 0],
          }) || this;
          return _this;
      }
      /**
       * Clones the style.
       * @return {CircleStyle} The cloned style.
       * @api
       */
      CircleStyle.prototype.clone = function () {
          var style = new CircleStyle({
              fill: this.getFill() ? this.getFill().clone() : undefined,
              stroke: this.getStroke() ? this.getStroke().clone() : undefined,
              radius: this.getRadius(),
              displacement: this.getDisplacement().slice(),
          });
          style.setOpacity(this.getOpacity());
          style.setScale(this.getScale());
          return style;
      };
      /**
       * Set the circle radius.
       *
       * @param {number} radius Circle radius.
       * @api
       */
      CircleStyle.prototype.setRadius = function (radius) {
          this.radius_ = radius;
          this.render();
      };
      return CircleStyle;
  }(RegularShape));

  /**
   * @module ol/style/Fill
   */
  /**
   * @typedef {Object} Options
   * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color=null] A color, gradient or pattern.
   * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
   * Default null; if null, the Canvas/renderer default black will be used.
   */
  /**
   * @classdesc
   * Set fill style for vector features.
   * @api
   */
  var Fill = /** @class */ (function () {
      /**
       * @param {Options=} opt_options Options.
       */
      function Fill(opt_options) {
          var options = opt_options || {};
          /**
           * @private
           * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
           */
          this.color_ = options.color !== undefined ? options.color : null;
      }
      /**
       * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
       * @return {Fill} The cloned style.
       * @api
       */
      Fill.prototype.clone = function () {
          var color = this.getColor();
          return new Fill({
              color: Array.isArray(color) ? color.slice() : color || undefined,
          });
      };
      /**
       * Get the fill color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
       * @api
       */
      Fill.prototype.getColor = function () {
          return this.color_;
      };
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
       * @api
       */
      Fill.prototype.setColor = function (color) {
          this.color_ = color;
      };
      return Fill;
  }());

  /**
   * @module ol/style/Stroke
   */
  /**
   * @typedef {Object} Options
   * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
   * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
   * Default null; if null, the Canvas/renderer default black will be used.
   * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
   * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
   * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
   * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on
   * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.
   * @property {number} [lineDashOffset=0] Line dash offset.
   * @property {number} [miterLimit=10] Miter limit.
   * @property {number} [width] Width.
   */
  /**
   * @classdesc
   * Set stroke style for vector features.
   * Note that the defaults given are the Canvas defaults, which will be used if
   * option is not defined. The `get` functions return whatever was entered in
   * the options; they will not return the default.
   * @api
   */
  var Stroke = /** @class */ (function () {
      /**
       * @param {Options=} opt_options Options.
       */
      function Stroke(opt_options) {
          var options = opt_options || {};
          /**
           * @private
           * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
           */
          this.color_ = options.color !== undefined ? options.color : null;
          /**
           * @private
           * @type {CanvasLineCap|undefined}
           */
          this.lineCap_ = options.lineCap;
          /**
           * @private
           * @type {Array<number>}
           */
          this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
          /**
           * @private
           * @type {number|undefined}
           */
          this.lineDashOffset_ = options.lineDashOffset;
          /**
           * @private
           * @type {CanvasLineJoin|undefined}
           */
          this.lineJoin_ = options.lineJoin;
          /**
           * @private
           * @type {number|undefined}
           */
          this.miterLimit_ = options.miterLimit;
          /**
           * @private
           * @type {number|undefined}
           */
          this.width_ = options.width;
      }
      /**
       * Clones the style.
       * @return {Stroke} The cloned style.
       * @api
       */
      Stroke.prototype.clone = function () {
          var color = this.getColor();
          return new Stroke({
              color: Array.isArray(color) ? color.slice() : color || undefined,
              lineCap: this.getLineCap(),
              lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
              lineDashOffset: this.getLineDashOffset(),
              lineJoin: this.getLineJoin(),
              miterLimit: this.getMiterLimit(),
              width: this.getWidth(),
          });
      };
      /**
       * Get the stroke color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
       * @api
       */
      Stroke.prototype.getColor = function () {
          return this.color_;
      };
      /**
       * Get the line cap type for the stroke.
       * @return {CanvasLineCap|undefined} Line cap.
       * @api
       */
      Stroke.prototype.getLineCap = function () {
          return this.lineCap_;
      };
      /**
       * Get the line dash style for the stroke.
       * @return {Array<number>} Line dash.
       * @api
       */
      Stroke.prototype.getLineDash = function () {
          return this.lineDash_;
      };
      /**
       * Get the line dash offset for the stroke.
       * @return {number|undefined} Line dash offset.
       * @api
       */
      Stroke.prototype.getLineDashOffset = function () {
          return this.lineDashOffset_;
      };
      /**
       * Get the line join type for the stroke.
       * @return {CanvasLineJoin|undefined} Line join.
       * @api
       */
      Stroke.prototype.getLineJoin = function () {
          return this.lineJoin_;
      };
      /**
       * Get the miter limit for the stroke.
       * @return {number|undefined} Miter limit.
       * @api
       */
      Stroke.prototype.getMiterLimit = function () {
          return this.miterLimit_;
      };
      /**
       * Get the stroke width.
       * @return {number|undefined} Width.
       * @api
       */
      Stroke.prototype.getWidth = function () {
          return this.width_;
      };
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
       * @api
       */
      Stroke.prototype.setColor = function (color) {
          this.color_ = color;
      };
      /**
       * Set the line cap.
       *
       * @param {CanvasLineCap|undefined} lineCap Line cap.
       * @api
       */
      Stroke.prototype.setLineCap = function (lineCap) {
          this.lineCap_ = lineCap;
      };
      /**
       * Set the line dash.
       *
       * Please note that Internet Explorer 10 and lower [do not support][mdn] the
       * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
       * property will have no visual effect in these browsers.
       *
       * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
       *
       * @param {Array<number>} lineDash Line dash.
       * @api
       */
      Stroke.prototype.setLineDash = function (lineDash) {
          this.lineDash_ = lineDash;
      };
      /**
       * Set the line dash offset.
       *
       * @param {number|undefined} lineDashOffset Line dash offset.
       * @api
       */
      Stroke.prototype.setLineDashOffset = function (lineDashOffset) {
          this.lineDashOffset_ = lineDashOffset;
      };
      /**
       * Set the line join.
       *
       * @param {CanvasLineJoin|undefined} lineJoin Line join.
       * @api
       */
      Stroke.prototype.setLineJoin = function (lineJoin) {
          this.lineJoin_ = lineJoin;
      };
      /**
       * Set the miter limit.
       *
       * @param {number|undefined} miterLimit Miter limit.
       * @api
       */
      Stroke.prototype.setMiterLimit = function (miterLimit) {
          this.miterLimit_ = miterLimit;
      };
      /**
       * Set the width.
       *
       * @param {number|undefined} width Width.
       * @api
       */
      Stroke.prototype.setWidth = function (width) {
          this.width_ = width;
      };
      return Stroke;
  }());

  /**
   * @module ol/style/Style
   */
  /**
   * A function that takes an {@link module:ol/Feature} and a `{number}`
   * representing the view's resolution. The function should return a
   * {@link module:ol/style/Style} or an array of them. This way e.g. a
   * vector layer can be styled. If the function returns `undefined`, the
   * feature will not be rendered.
   *
   * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
   */
  /**
   * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
   * @typedef {Style|Array<Style>|StyleFunction} StyleLike
   */
  /**
   * A function that takes an {@link module:ol/Feature} as argument and returns an
   * {@link module:ol/geom/Geometry} that will be rendered and styled for the feature.
   *
   * @typedef {function(import("../Feature.js").FeatureLike):
   *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
   */
  /**
   * Custom renderer function. Takes two arguments:
   *
   * 1. The pixel coordinates of the geometry in GeoJSON notation.
   * 2. The {@link module:ol/render~State} of the layer renderer.
   *
   * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State): void}
   * RenderFunction
   */
  /**
   * @typedef {Object} Options
   * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
   * or function returning a geometry to render for this style.
   * @property {import("./Fill.js").default} [fill] Fill style.
   * @property {import("./Image.js").default} [image] Image style.
   * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
   * ignored, and the provided function will be called with each render frame for each geometry.
   * @property {import("./Stroke.js").default} [stroke] Stroke style.
   * @property {import("./Text.js").default} [text] Text style.
   * @property {number} [zIndex] Z index.
   */
  /**
   * @classdesc
   * Container for vector feature rendering styles. Any changes made to the style
   * or its children through `set*()` methods will not take effect until the
   * feature or layer that uses the style is re-rendered.
   *
   * ## Feature styles
   *
   * If no style is defined, the following default style is used:
   * ```js
   *  import {Fill, Stroke, Circle, Style} from 'ol/style';
   *
   *  var fill = new Fill({
   *    color: 'rgba(255,255,255,0.4)'
   *  });
   *  var stroke = new Stroke({
   *    color: '#3399CC',
   *    width: 1.25
   *  });
   *  var styles = [
   *    new Style({
   *      image: new Circle({
   *        fill: fill,
   *        stroke: stroke,
   *        radius: 5
   *      }),
   *      fill: fill,
   *      stroke: stroke
   *    })
   *  ];
   * ```
   *
   * A separate editing style has the following defaults:
   * ```js
   *  import {Fill, Stroke, Circle, Style} from 'ol/style';
   *  import GeometryType from 'ol/geom/GeometryType';
   *
   *  var white = [255, 255, 255, 1];
   *  var blue = [0, 153, 255, 1];
   *  var width = 3;
   *  styles[GeometryType.POLYGON] = [
   *    new Style({
   *      fill: new Fill({
   *        color: [255, 255, 255, 0.5]
   *      })
   *    })
   *  ];
   *  styles[GeometryType.MULTI_POLYGON] =
   *      styles[GeometryType.POLYGON];
   *  styles[GeometryType.LINE_STRING] = [
   *    new Style({
   *      stroke: new Stroke({
   *        color: white,
   *        width: width + 2
   *      })
   *    }),
   *    new Style({
   *      stroke: new Stroke({
   *        color: blue,
   *        width: width
   *      })
   *    })
   *  ];
   *  styles[GeometryType.MULTI_LINE_STRING] =
   *      styles[GeometryType.LINE_STRING];
   *  styles[GeometryType.POINT] = [
   *    new Style({
   *      image: new Circle({
   *        radius: width * 2,
   *        fill: new Fill({
   *          color: blue
   *        }),
   *        stroke: new Stroke({
   *          color: white,
   *          width: width / 2
   *        })
   *      }),
   *      zIndex: Infinity
   *    })
   *  ];
   *  styles[GeometryType.MULTI_POINT] =
   *      styles[GeometryType.POINT];
   *  styles[GeometryType.GEOMETRY_COLLECTION] =
   *      styles[GeometryType.POLYGON].concat(
   *          styles[GeometryType.LINE_STRING],
   *          styles[GeometryType.POINT]
   *      );
   * ```
   *
   * @api
   */
  var Style = /** @class */ (function () {
      /**
       * @param {Options=} opt_options Style options.
       */
      function Style(opt_options) {
          var options = opt_options || {};
          /**
           * @private
           * @type {string|import("../geom/Geometry.js").default|GeometryFunction}
           */
          this.geometry_ = null;
          /**
           * @private
           * @type {!GeometryFunction}
           */
          this.geometryFunction_ = defaultGeometryFunction;
          if (options.geometry !== undefined) {
              this.setGeometry(options.geometry);
          }
          /**
           * @private
           * @type {import("./Fill.js").default}
           */
          this.fill_ = options.fill !== undefined ? options.fill : null;
          /**
           * @private
           * @type {import("./Image.js").default}
           */
          this.image_ = options.image !== undefined ? options.image : null;
          /**
           * @private
           * @type {RenderFunction|null}
           */
          this.renderer_ = options.renderer !== undefined ? options.renderer : null;
          /**
           * @private
           * @type {import("./Stroke.js").default}
           */
          this.stroke_ = options.stroke !== undefined ? options.stroke : null;
          /**
           * @private
           * @type {import("./Text.js").default}
           */
          this.text_ = options.text !== undefined ? options.text : null;
          /**
           * @private
           * @type {number|undefined}
           */
          this.zIndex_ = options.zIndex;
      }
      /**
       * Clones the style.
       * @return {Style} The cloned style.
       * @api
       */
      Style.prototype.clone = function () {
          var geometry = this.getGeometry();
          if (geometry && typeof geometry === 'object') {
              geometry = /** @type {import("../geom/Geometry.js").default} */ (geometry).clone();
          }
          return new Style({
              geometry: geometry,
              fill: this.getFill() ? this.getFill().clone() : undefined,
              image: this.getImage() ? this.getImage().clone() : undefined,
              stroke: this.getStroke() ? this.getStroke().clone() : undefined,
              text: this.getText() ? this.getText().clone() : undefined,
              zIndex: this.getZIndex(),
          });
      };
      /**
       * Get the custom renderer function that was configured with
       * {@link #setRenderer} or the `renderer` constructor option.
       * @return {RenderFunction|null} Custom renderer function.
       * @api
       */
      Style.prototype.getRenderer = function () {
          return this.renderer_;
      };
      /**
       * Sets a custom renderer function for this style. When set, `fill`, `stroke`
       * and `image` options of the style will be ignored.
       * @param {RenderFunction|null} renderer Custom renderer function.
       * @api
       */
      Style.prototype.setRenderer = function (renderer) {
          this.renderer_ = renderer;
      };
      /**
       * Get the geometry to be rendered.
       * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
       * Feature property or geometry or function that returns the geometry that will
       * be rendered with this style.
       * @api
       */
      Style.prototype.getGeometry = function () {
          return this.geometry_;
      };
      /**
       * Get the function used to generate a geometry for rendering.
       * @return {!GeometryFunction} Function that is called with a feature
       * and returns the geometry to render instead of the feature's geometry.
       * @api
       */
      Style.prototype.getGeometryFunction = function () {
          return this.geometryFunction_;
      };
      /**
       * Get the fill style.
       * @return {import("./Fill.js").default} Fill style.
       * @api
       */
      Style.prototype.getFill = function () {
          return this.fill_;
      };
      /**
       * Set the fill style.
       * @param {import("./Fill.js").default} fill Fill style.
       * @api
       */
      Style.prototype.setFill = function (fill) {
          this.fill_ = fill;
      };
      /**
       * Get the image style.
       * @return {import("./Image.js").default} Image style.
       * @api
       */
      Style.prototype.getImage = function () {
          return this.image_;
      };
      /**
       * Set the image style.
       * @param {import("./Image.js").default} image Image style.
       * @api
       */
      Style.prototype.setImage = function (image) {
          this.image_ = image;
      };
      /**
       * Get the stroke style.
       * @return {import("./Stroke.js").default} Stroke style.
       * @api
       */
      Style.prototype.getStroke = function () {
          return this.stroke_;
      };
      /**
       * Set the stroke style.
       * @param {import("./Stroke.js").default} stroke Stroke style.
       * @api
       */
      Style.prototype.setStroke = function (stroke) {
          this.stroke_ = stroke;
      };
      /**
       * Get the text style.
       * @return {import("./Text.js").default} Text style.
       * @api
       */
      Style.prototype.getText = function () {
          return this.text_;
      };
      /**
       * Set the text style.
       * @param {import("./Text.js").default} text Text style.
       * @api
       */
      Style.prototype.setText = function (text) {
          this.text_ = text;
      };
      /**
       * Get the z-index for the style.
       * @return {number|undefined} ZIndex.
       * @api
       */
      Style.prototype.getZIndex = function () {
          return this.zIndex_;
      };
      /**
       * Set a geometry that is rendered instead of the feature's geometry.
       *
       * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
       *     Feature property or geometry or function returning a geometry to render
       *     for this style.
       * @api
       */
      Style.prototype.setGeometry = function (geometry) {
          if (typeof geometry === 'function') {
              this.geometryFunction_ = geometry;
          }
          else if (typeof geometry === 'string') {
              this.geometryFunction_ = function (feature) {
                  return /** @type {import("../geom/Geometry.js").default} */ (feature.get(geometry));
              };
          }
          else if (!geometry) {
              this.geometryFunction_ = defaultGeometryFunction;
          }
          else if (geometry !== undefined) {
              this.geometryFunction_ = function () {
                  return /** @type {import("../geom/Geometry.js").default} */ (geometry);
              };
          }
          this.geometry_ = geometry;
      };
      /**
       * Set the z-index.
       *
       * @param {number|undefined} zIndex ZIndex.
       * @api
       */
      Style.prototype.setZIndex = function (zIndex) {
          this.zIndex_ = zIndex;
      };
      return Style;
  }());
  /**
   * Convert the provided object into a style function.  Functions passed through
   * unchanged.  Arrays of Style or single style objects wrapped in a
   * new style function.
   * @param {StyleFunction|Array<Style>|Style} obj
   *     A style function, a single style, or an array of styles.
   * @return {StyleFunction} A style function.
   */
  function toFunction(obj) {
      var styleFunction;
      if (typeof obj === 'function') {
          styleFunction = obj;
      }
      else {
          /**
           * @type {Array<Style>}
           */
          var styles_1;
          if (Array.isArray(obj)) {
              styles_1 = obj;
          }
          else {
              assert(typeof ( /** @type {?} */(obj).getZIndex) === 'function', 41); // Expected an `Style` or an array of `Style`
              var style = /** @type {Style} */ (obj);
              styles_1 = [style];
          }
          styleFunction = function () {
              return styles_1;
          };
      }
      return styleFunction;
  }
  /**
   * @type {Array<Style>}
   */
  var defaultStyles = null;
  /**
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} resolution Resolution.
   * @return {Array<Style>} Style.
   */
  function createDefaultStyle(feature, resolution) {
      // We don't use an immediately-invoked function
      // and a closure so we don't get an error at script evaluation time in
      // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
      // canvas.getContext('2d') at construction time, which will cause an.error
      // in such browsers.)
      if (!defaultStyles) {
          var fill = new Fill({
              color: 'rgba(255,255,255,0.4)',
          });
          var stroke = new Stroke({
              color: '#3399CC',
              width: 1.25,
          });
          defaultStyles = [
              new Style({
                  image: new CircleStyle({
                      fill: fill,
                      stroke: stroke,
                      radius: 5,
                  }),
                  fill: fill,
                  stroke: stroke,
              }),
          ];
      }
      return defaultStyles;
  }
  /**
   * Default styles for editing features.
   * @return {Object<import("../geom/GeometryType.js").default, Array<Style>>} Styles
   */
  function createEditingStyle() {
      /** @type {Object<import("../geom/GeometryType.js").default, Array<Style>>} */
      var styles = {};
      var white = [255, 255, 255, 1];
      var blue = [0, 153, 255, 1];
      var width = 3;
      styles[GeometryType.POLYGON] = [
          new Style({
              fill: new Fill({
                  color: [255, 255, 255, 0.5],
              }),
          }),
      ];
      styles[GeometryType.MULTI_POLYGON] = styles[GeometryType.POLYGON];
      styles[GeometryType.LINE_STRING] = [
          new Style({
              stroke: new Stroke({
                  color: white,
                  width: width + 2,
              }),
          }),
          new Style({
              stroke: new Stroke({
                  color: blue,
                  width: width,
              }),
          }),
      ];
      styles[GeometryType.MULTI_LINE_STRING] = styles[GeometryType.LINE_STRING];
      styles[GeometryType.CIRCLE] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING]);
      styles[GeometryType.POINT] = [
          new Style({
              image: new CircleStyle({
                  radius: width * 2,
                  fill: new Fill({
                      color: blue,
                  }),
                  stroke: new Stroke({
                      color: white,
                      width: width / 2,
                  }),
              }),
              zIndex: Infinity,
          }),
      ];
      styles[GeometryType.MULTI_POINT] = styles[GeometryType.POINT];
      styles[GeometryType.GEOMETRY_COLLECTION] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING], styles[GeometryType.POINT]);
      return styles;
  }
  /**
   * Function that is called with a feature and returns its default geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
   * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
   */
  function defaultGeometryFunction(feature) {
      return feature.getGeometry();
  }

  var __extends$q = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
   * features before rendering. By default features are drawn in the order that they are created. Use
   * `null` to avoid the sort, but get an undefined draw order.
   * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
   * renderer when getting features from the vector source for the rendering or hit-detection.
   * Recommended value: the size of the largest symbol, line width or label.
   * @property {import("../source/Vector.js").default} [source] Source.
   * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
   * this layer in its layers collection, and the layer will be rendered on top. This is useful for
   * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
   * use {@link module:ol/Map#addLayer}.
   * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
   * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
   * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
   * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
   * higher priority.
   * @property {import("../style/Style.js").StyleLike|null} [style] Layer style. When set to `null`, only
   * features that have their own style will be rendered. See {@link module:ol/style} for default style
   * which will be used if this is not set.
   * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
   * be recreated during animations. This means that no vectors will be shown clipped, but the
   * setting will have a performance impact for large amounts of vector data. When set to `false`,
   * batches will be recreated when no animation is active.
   * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
   * be recreated during interactions. See also `updateWhileAnimating`.
   */
  /**
   * @enum {string}
   * @private
   */
  var Property$1 = {
      RENDER_ORDER: 'renderOrder',
  };
  /**
   * @classdesc
   * Vector data that is rendered client-side.
   * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
   * property on the layer object; for example, setting `title: 'My Title'` in the
   * options means that `title` is observable, and has get/set accessors.
   *
   * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
   * @extends {Layer<VectorSourceType>}
   * @api
   */
  var BaseVectorLayer = /** @class */ (function (_super) {
      __extends$q(BaseVectorLayer, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function BaseVectorLayer(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var baseOptions = assign({}, options);
          delete baseOptions.style;
          delete baseOptions.renderBuffer;
          delete baseOptions.updateWhileAnimating;
          delete baseOptions.updateWhileInteracting;
          _this = _super.call(this, baseOptions) || this;
          /**
           * @private
           * @type {boolean}
           */
          _this.declutter_ =
              options.declutter !== undefined ? options.declutter : false;
          /**
           * @type {number}
           * @private
           */
          _this.renderBuffer_ =
              options.renderBuffer !== undefined ? options.renderBuffer : 100;
          /**
           * User provided style.
           * @type {import("../style/Style.js").StyleLike}
           * @private
           */
          _this.style_ = null;
          /**
           * Style function for use within the library.
           * @type {import("../style/Style.js").StyleFunction|undefined}
           * @private
           */
          _this.styleFunction_ = undefined;
          _this.setStyle(options.style);
          /**
           * @type {boolean}
           * @private
           */
          _this.updateWhileAnimating_ =
              options.updateWhileAnimating !== undefined
                  ? options.updateWhileAnimating
                  : false;
          /**
           * @type {boolean}
           * @private
           */
          _this.updateWhileInteracting_ =
              options.updateWhileInteracting !== undefined
                  ? options.updateWhileInteracting
                  : false;
          return _this;
      }
      /**
       * @return {boolean} Declutter.
       */
      BaseVectorLayer.prototype.getDeclutter = function () {
          return this.declutter_;
      };
      /**
       * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
       * that resolves with an array of features. The array will either contain the topmost feature
       * when a hit was detected, or it will be empty.
       *
       * The hit detection algorithm used for this method is optimized for performance, but is less
       * accurate than the one used in {@link import("../PluggableMap.js").default#getFeaturesAtPixel}: Text
       * is not considered, and icons are only represented by their bounding box instead of the exact
       * image.
       *
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
       * @api
       */
      BaseVectorLayer.prototype.getFeatures = function (pixel) {
          return _super.prototype.getFeatures.call(this, pixel);
      };
      /**
       * @return {number|undefined} Render buffer.
       */
      BaseVectorLayer.prototype.getRenderBuffer = function () {
          return this.renderBuffer_;
      };
      /**
       * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
       *     order.
       */
      BaseVectorLayer.prototype.getRenderOrder = function () {
          return /** @type {import("../render.js").OrderFunction|null|undefined} */ (this.get(Property$1.RENDER_ORDER));
      };
      /**
       * Get the style for features.  This returns whatever was passed to the `style`
       * option at construction or to the `setStyle` method.
       * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
       * @api
       */
      BaseVectorLayer.prototype.getStyle = function () {
          return this.style_;
      };
      /**
       * Get the style function.
       * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
       * @api
       */
      BaseVectorLayer.prototype.getStyleFunction = function () {
          return this.styleFunction_;
      };
      /**
       * @return {boolean} Whether the rendered layer should be updated while
       *     animating.
       */
      BaseVectorLayer.prototype.getUpdateWhileAnimating = function () {
          return this.updateWhileAnimating_;
      };
      /**
       * @return {boolean} Whether the rendered layer should be updated while
       *     interacting.
       */
      BaseVectorLayer.prototype.getUpdateWhileInteracting = function () {
          return this.updateWhileInteracting_;
      };
      /**
       * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
       *     Render order.
       */
      BaseVectorLayer.prototype.setRenderOrder = function (renderOrder) {
          this.set(Property$1.RENDER_ORDER, renderOrder);
      };
      /**
       * Set the style for features.  This can be a single style object, an array
       * of styles, or a function that takes a feature and resolution and returns
       * an array of styles. If set to `null`, the layer has no style (a `null` style),
       * so only features that have their own styles will be rendered in the layer. Call
       * `setStyle()` without arguments to reset to the default style. See
       * {@link module:ol/style} for information on the default style.
       * @param {(import("../style/Style.js").StyleLike|null)=} opt_style Layer style.
       * @api
       */
      BaseVectorLayer.prototype.setStyle = function (opt_style) {
          this.style_ = opt_style !== undefined ? opt_style : createDefaultStyle;
          this.styleFunction_ =
              opt_style === null ? undefined : toFunction(this.style_);
          this.changed();
      };
      return BaseVectorLayer;
  }(Layer));

  /**
   * @module ol/render/canvas/Instruction
   */
  /**
   * @enum {number}
   */
  var Instruction = {
      BEGIN_GEOMETRY: 0,
      BEGIN_PATH: 1,
      CIRCLE: 2,
      CLOSE_PATH: 3,
      CUSTOM: 4,
      DRAW_CHARS: 5,
      DRAW_IMAGE: 6,
      END_GEOMETRY: 7,
      FILL: 8,
      MOVE_TO_LINE_TO: 9,
      SET_FILL_STYLE: 10,
      SET_STROKE_STYLE: 11,
      STROKE: 12,
  };
  /**
   * @type {Array<Instruction>}
   */
  var fillInstruction = [Instruction.FILL];
  /**
   * @type {Array<Instruction>}
   */
  var strokeInstruction = [Instruction.STROKE];
  /**
   * @type {Array<Instruction>}
   */
  var beginPathInstruction = [Instruction.BEGIN_PATH];
  /**
   * @type {Array<Instruction>}
   */
  var closePathInstruction = [Instruction.CLOSE_PATH];

  /**
   * @module ol/render/VectorContext
   */
  /**
   * @classdesc
   * Context for drawing geometries.  A vector context is available on render
   * events and does not need to be constructed directly.
   * @api
   */
  var VectorContext = /** @class */ (function () {
      function VectorContext() {
      }
      /**
       * Render a geometry with a custom renderer.
       *
       * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {Function} renderer Renderer.
       */
      VectorContext.prototype.drawCustom = function (geometry, feature, renderer) { };
      /**
       * Render a geometry.
       *
       * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
       */
      VectorContext.prototype.drawGeometry = function (geometry) { };
      /**
       * Set the rendering style.
       *
       * @param {import("../style/Style.js").default} style The rendering style.
       */
      VectorContext.prototype.setStyle = function (style) { };
      /**
       * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
       * @param {import("../Feature.js").default} feature Feature.
       */
      VectorContext.prototype.drawCircle = function (circleGeometry, feature) { };
      /**
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("../style/Style.js").default} style Style.
       */
      VectorContext.prototype.drawFeature = function (feature, style) { };
      /**
       * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
       * @param {import("../Feature.js").default} feature Feature.
       */
      VectorContext.prototype.drawGeometryCollection = function (geometryCollectionGeometry, feature) { };
      /**
       * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawLineString = function (lineStringGeometry, feature) { };
      /**
       * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) { };
      /**
       * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawMultiPoint = function (multiPointGeometry, feature) { };
      /**
       * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) { };
      /**
       * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawPoint = function (pointGeometry, feature) { };
      /**
       * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawPolygon = function (polygonGeometry, feature) { };
      /**
       * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawText = function (geometry, feature) { };
      /**
       * @param {import("../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
       */
      VectorContext.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) { };
      /**
       * @param {import("../style/Image.js").default} imageStyle Image style.
       * @param {import("./canvas.js").DeclutterGroup=} opt_declutterGroup Declutter.
       */
      VectorContext.prototype.setImageStyle = function (imageStyle, opt_declutterGroup) { };
      /**
       * @param {import("../style/Text.js").default} textStyle Text style.
       * @param {import("./canvas.js").DeclutterGroups=} opt_declutterGroups Declutter.
       */
      VectorContext.prototype.setTextStyle = function (textStyle, opt_declutterGroups) { };
      return VectorContext;
  }());

  var __extends$r = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} SerializableInstructions
   * @property {Array<*>} instructions The rendering instructions.
   * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
   * @property {Array<number>} coordinates The array of all coordinates.
   * @property {!Object<string, import("../canvas.js").TextState>} [textStates] The text states (decluttering).
   * @property {!Object<string, import("../canvas.js").FillState>} [fillStates] The fill states (decluttering).
   * @property {!Object<string, import("../canvas.js").StrokeState>} [strokeStates] The stroke states (decluttering).
   */
  var CanvasBuilder = /** @class */ (function (_super) {
      __extends$r(CanvasBuilder, _super);
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {
          var _this = _super.call(this) || this;
          /**
           * @protected
           * @type {number}
           */
          _this.tolerance = tolerance;
          /**
           * @protected
           * @const
           * @type {import("../../extent.js").Extent}
           */
          _this.maxExtent = maxExtent;
          /**
           * @protected
           * @type {number}
           */
          _this.pixelRatio = pixelRatio;
          /**
           * @protected
           * @type {number}
           */
          _this.maxLineWidth = 0;
          /**
           * @protected
           * @const
           * @type {number}
           */
          _this.resolution = resolution;
          /**
           * @private
           * @type {Array<*>}
           */
          _this.beginGeometryInstruction1_ = null;
          /**
           * @private
           * @type {Array<*>}
           */
          _this.beginGeometryInstruction2_ = null;
          /**
           * @private
           * @type {import("../../extent.js").Extent}
           */
          _this.bufferedMaxExtent_ = null;
          /**
           * @protected
           * @type {Array<*>}
           */
          _this.instructions = [];
          /**
           * @protected
           * @type {Array<number>}
           */
          _this.coordinates = [];
          /**
           * @private
           * @type {import("../../coordinate.js").Coordinate}
           */
          _this.tmpCoordinate_ = [];
          /**
           * @protected
           * @type {Array<*>}
           */
          _this.hitDetectionInstructions = [];
          /**
           * @protected
           * @type {import("../canvas.js").FillStrokeState}
           */
          _this.state = /** @type {import("../canvas.js").FillStrokeState} */ ({});
          return _this;
      }
      /**
       * @protected
       * @param {Array<number>} dashArray Dash array.
       * @return {Array<number>} Dash array with pixel ratio applied
       */
      CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {
          var pixelRatio = this.pixelRatio;
          return pixelRatio == 1
              ? dashArray
              : dashArray.map(function (dash) {
                  return dash * pixelRatio;
              });
      };
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @param {boolean} closed Last input coordinate equals first.
       * @param {boolean} skipFirst Skip first coordinate.
       * @protected
       * @return {number} My end.
       */
      CanvasBuilder.prototype.appendFlatCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {
          var myEnd = this.coordinates.length;
          var extent = this.getBufferedMaxExtent();
          if (skipFirst) {
              offset += stride;
          }
          var lastXCoord = flatCoordinates[offset];
          var lastYCoord = flatCoordinates[offset + 1];
          var nextCoord = this.tmpCoordinate_;
          var skipped = true;
          var i, lastRel, nextRel;
          for (i = offset + stride; i < end; i += stride) {
              nextCoord[0] = flatCoordinates[i];
              nextCoord[1] = flatCoordinates[i + 1];
              nextRel = coordinateRelationship(extent, nextCoord);
              if (nextRel !== lastRel) {
                  if (skipped) {
                      this.coordinates[myEnd++] = lastXCoord;
                      this.coordinates[myEnd++] = lastYCoord;
                  }
                  this.coordinates[myEnd++] = nextCoord[0];
                  this.coordinates[myEnd++] = nextCoord[1];
                  skipped = false;
              }
              else if (nextRel === Relationship.INTERSECTING) {
                  this.coordinates[myEnd++] = nextCoord[0];
                  this.coordinates[myEnd++] = nextCoord[1];
                  skipped = false;
              }
              else {
                  skipped = true;
              }
              lastXCoord = nextCoord[0];
              lastYCoord = nextCoord[1];
              lastRel = nextRel;
          }
          // Last coordinate equals first or only one point to append:
          if ((closed && skipped) || i === offset + stride) {
              this.coordinates[myEnd++] = lastXCoord;
              this.coordinates[myEnd++] = lastYCoord;
          }
          return myEnd;
      };
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @param {Array<number>} builderEnds Builder ends.
       * @return {number} Offset.
       */
      CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var builderEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
              builderEnds.push(builderEnd);
              offset = end;
          }
          return offset;
      };
      /**
       * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {Function} renderer Renderer.
       */
      CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer) {
          this.beginGeometry(geometry, feature);
          var type = geometry.getType();
          var stride = geometry.getStride();
          var builderBegin = this.coordinates.length;
          var flatCoordinates, builderEnd, builderEnds, builderEndss;
          var offset;
          if (type == GeometryType.MULTI_POLYGON) {
              flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getOrientedFlatCoordinates();
              builderEndss = [];
              var endss = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getEndss();
              offset = 0;
              for (var i = 0, ii = endss.length; i < ii; ++i) {
                  var myEnds = [];
                  offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
                  builderEndss.push(myEnds);
              }
              this.instructions.push([
                  Instruction.CUSTOM,
                  builderBegin,
                  builderEndss,
                  geometry,
                  renderer,
                  inflateMultiCoordinatesArray,
              ]);
          }
          else if (type == GeometryType.POLYGON ||
              type == GeometryType.MULTI_LINE_STRING) {
              builderEnds = [];
              flatCoordinates =
                  type == GeometryType.POLYGON
                      ? /** @type {import("../../geom/Polygon.js").default} */ (geometry).getOrientedFlatCoordinates()
                      : geometry.getFlatCoordinates();
              offset = this.drawCustomCoordinates_(flatCoordinates, 0, 
              /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */ (geometry).getEnds(), stride, builderEnds);
              this.instructions.push([
                  Instruction.CUSTOM,
                  builderBegin,
                  builderEnds,
                  geometry,
                  renderer,
                  inflateCoordinatesArray,
              ]);
          }
          else if (type == GeometryType.LINE_STRING ||
              type == GeometryType.MULTI_POINT) {
              flatCoordinates = geometry.getFlatCoordinates();
              builderEnd = this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
              this.instructions.push([
                  Instruction.CUSTOM,
                  builderBegin,
                  builderEnd,
                  geometry,
                  renderer,
                  inflateCoordinates,
              ]);
          }
          else if (type == GeometryType.POINT) {
              flatCoordinates = geometry.getFlatCoordinates();
              this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
              builderEnd = this.coordinates.length;
              this.instructions.push([
                  Instruction.CUSTOM,
                  builderBegin,
                  builderEnd,
                  geometry,
                  renderer,
              ]);
          }
          this.endGeometry(feature);
      };
      /**
       * @protected
       * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {
          var extent = geometry.getExtent();
          this.beginGeometryInstruction1_ = [
              Instruction.BEGIN_GEOMETRY,
              feature,
              0,
              extent,
          ];
          this.instructions.push(this.beginGeometryInstruction1_);
          this.beginGeometryInstruction2_ = [
              Instruction.BEGIN_GEOMETRY,
              feature,
              0,
              extent,
          ];
          this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
      };
      /**
       * @return {SerializableInstructions} the serializable instructions.
       */
      CanvasBuilder.prototype.finish = function () {
          return {
              instructions: this.instructions,
              hitDetectionInstructions: this.hitDetectionInstructions,
              coordinates: this.coordinates,
          };
      };
      /**
       * Reverse the hit detection instructions.
       */
      CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {
          var hitDetectionInstructions = this.hitDetectionInstructions;
          // step 1 - reverse array
          hitDetectionInstructions.reverse();
          // step 2 - reverse instructions within geometry blocks
          var i;
          var n = hitDetectionInstructions.length;
          var instruction;
          var type;
          var begin = -1;
          for (i = 0; i < n; ++i) {
              instruction = hitDetectionInstructions[i];
              type = /** @type {import("./Instruction.js").default} */ (instruction[0]);
              if (type == Instruction.END_GEOMETRY) {
                  begin = i;
              }
              else if (type == Instruction.BEGIN_GEOMETRY) {
                  instruction[2] = i;
                  reverseSubArray(this.hitDetectionInstructions, begin, i);
                  begin = -1;
              }
          }
      };
      /**
       * @param {import("../../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
       */
      CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
          var state = this.state;
          if (fillStyle) {
              var fillStyleColor = fillStyle.getColor();
              state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);
          }
          else {
              state.fillStyle = undefined;
          }
          if (strokeStyle) {
              var strokeStyleColor = strokeStyle.getColor();
              state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);
              var strokeStyleLineCap = strokeStyle.getLineCap();
              state.lineCap =
                  strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;
              var strokeStyleLineDash = strokeStyle.getLineDash();
              state.lineDash = strokeStyleLineDash
                  ? strokeStyleLineDash.slice()
                  : defaultLineDash;
              var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
              state.lineDashOffset = strokeStyleLineDashOffset
                  ? strokeStyleLineDashOffset
                  : defaultLineDashOffset;
              var strokeStyleLineJoin = strokeStyle.getLineJoin();
              state.lineJoin =
                  strokeStyleLineJoin !== undefined
                      ? strokeStyleLineJoin
                      : defaultLineJoin;
              var strokeStyleWidth = strokeStyle.getWidth();
              state.lineWidth =
                  strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;
              var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
              state.miterLimit =
                  strokeStyleMiterLimit !== undefined
                      ? strokeStyleMiterLimit
                      : defaultMiterLimit;
              if (state.lineWidth > this.maxLineWidth) {
                  this.maxLineWidth = state.lineWidth;
                  // invalidate the buffered max extent cache
                  this.bufferedMaxExtent_ = null;
              }
          }
          else {
              state.strokeStyle = undefined;
              state.lineCap = undefined;
              state.lineDash = null;
              state.lineDashOffset = undefined;
              state.lineJoin = undefined;
              state.lineWidth = undefined;
              state.miterLimit = undefined;
          }
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @return {Array<*>} Fill instruction.
       */
      CanvasBuilder.prototype.createFill = function (state) {
          var fillStyle = state.fillStyle;
          /** @type {Array<*>} */
          var fillInstruction$$1 = [Instruction.SET_FILL_STYLE, fillStyle];
          if (typeof fillStyle !== 'string') {
              // Fill is a pattern or gradient - align it!
              fillInstruction$$1.push(true);
          }
          return fillInstruction$$1;
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       */
      CanvasBuilder.prototype.applyStroke = function (state) {
          this.instructions.push(this.createStroke(state));
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @return {Array<*>} Stroke instruction.
       */
      CanvasBuilder.prototype.createStroke = function (state) {
          return [
              Instruction.SET_STROKE_STYLE,
              state.strokeStyle,
              state.lineWidth * this.pixelRatio,
              state.lineCap,
              state.lineJoin,
              state.miterLimit,
              this.applyPixelRatio(state.lineDash),
              state.lineDashOffset * this.pixelRatio,
          ];
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
       */
      CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {
          var fillStyle = state.fillStyle;
          if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
              if (fillStyle !== undefined) {
                  this.instructions.push(createFill.call(this, state));
              }
              state.currentFillStyle = fillStyle;
          }
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
       */
      CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {
          var strokeStyle = state.strokeStyle;
          var lineCap = state.lineCap;
          var lineDash = state.lineDash;
          var lineDashOffset = state.lineDashOffset;
          var lineJoin = state.lineJoin;
          var lineWidth = state.lineWidth;
          var miterLimit = state.miterLimit;
          if (state.currentStrokeStyle != strokeStyle ||
              state.currentLineCap != lineCap ||
              (lineDash != state.currentLineDash &&
                  !equals(state.currentLineDash, lineDash)) ||
              state.currentLineDashOffset != lineDashOffset ||
              state.currentLineJoin != lineJoin ||
              state.currentLineWidth != lineWidth ||
              state.currentMiterLimit != miterLimit) {
              if (strokeStyle !== undefined) {
                  applyStroke.call(this, state);
              }
              state.currentStrokeStyle = strokeStyle;
              state.currentLineCap = lineCap;
              state.currentLineDash = lineDash;
              state.currentLineDashOffset = lineDashOffset;
              state.currentLineJoin = lineJoin;
              state.currentLineWidth = lineWidth;
              state.currentMiterLimit = miterLimit;
          }
      };
      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasBuilder.prototype.endGeometry = function (feature) {
          this.beginGeometryInstruction1_[2] = this.instructions.length;
          this.beginGeometryInstruction1_ = null;
          this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
          this.beginGeometryInstruction2_ = null;
          var endGeometryInstruction = [Instruction.END_GEOMETRY, feature];
          this.instructions.push(endGeometryInstruction);
          this.hitDetectionInstructions.push(endGeometryInstruction);
      };
      /**
       * Get the buffered rendering extent.  Rendering will be clipped to the extent
       * provided to the constructor.  To account for symbolizers that may intersect
       * this extent, we calculate a buffered extent (e.g. based on stroke width).
       * @return {import("../../extent.js").Extent} The buffered rendering extent.
       * @protected
       */
      CanvasBuilder.prototype.getBufferedMaxExtent = function () {
          if (!this.bufferedMaxExtent_) {
              this.bufferedMaxExtent_ = clone$2(this.maxExtent);
              if (this.maxLineWidth > 0) {
                  var width = (this.resolution * (this.maxLineWidth + 1)) / 2;
                  buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
              }
          }
          return this.bufferedMaxExtent_;
      };
      return CanvasBuilder;
  }(VectorContext));

  var __extends$s = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var CanvasImageBuilder = /** @class */ (function (_super) {
      __extends$s(CanvasImageBuilder, _super);
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      function CanvasImageBuilder(tolerance, maxExtent, resolution, pixelRatio) {
          var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
          /**
           * @private
           * @type {import("../canvas.js").DeclutterGroups}
           */
          _this.declutterGroups_ = null;
          /**
           * @private
           * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
           */
          _this.hitDetectionImage_ = null;
          /**
           * @private
           * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
           */
          _this.image_ = null;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.imagePixelRatio_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.anchorX_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.anchorY_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.height_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.opacity_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.originX_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.originY_ = undefined;
          /**
           * @private
           * @type {boolean|undefined}
           */
          _this.rotateWithView_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.rotation_ = undefined;
          /**
           * @private
           * @type {import("../../size.js").Size|undefined}
           */
          _this.scale_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.width_ = undefined;
          return _this;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       * @return {number} My end.
       */
      CanvasImageBuilder.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {
          return this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
      };
      /**
       * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasImageBuilder.prototype.drawPoint = function (pointGeometry, feature) {
          if (!this.image_) {
              return;
          }
          this.beginGeometry(pointGeometry, feature);
          var flatCoordinates = pointGeometry.getFlatCoordinates();
          var stride = pointGeometry.getStride();
          var myBegin = this.coordinates.length;
          var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
          this.instructions.push([
              Instruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.image_,
              // Remaining arguments to DRAW_IMAGE are in alphabetical order
              this.anchorX_ * this.imagePixelRatio_,
              this.anchorY_ * this.imagePixelRatio_,
              this.declutterGroups_,
              Math.ceil(this.height_ * this.imagePixelRatio_),
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              [
                  (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
                  (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
              ],
              Math.ceil(this.width_ * this.imagePixelRatio_),
          ]);
          this.hitDetectionInstructions.push([
              Instruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.hitDetectionImage_,
              // Remaining arguments to DRAW_IMAGE are in alphabetical order
              this.anchorX_,
              this.anchorY_,
              this.declutterGroups_,
              this.height_,
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              this.scale_,
              this.width_,
          ]);
          this.endGeometry(feature);
      };
      /**
       * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasImageBuilder.prototype.drawMultiPoint = function (multiPointGeometry, feature) {
          if (!this.image_) {
              return;
          }
          this.beginGeometry(multiPointGeometry, feature);
          var flatCoordinates = multiPointGeometry.getFlatCoordinates();
          var stride = multiPointGeometry.getStride();
          var myBegin = this.coordinates.length;
          var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
          this.instructions.push([
              Instruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.image_,
              // Remaining arguments to DRAW_IMAGE are in alphabetical order
              this.anchorX_ * this.imagePixelRatio_,
              this.anchorY_ * this.imagePixelRatio_,
              this.declutterGroups_,
              Math.ceil(this.height_ * this.imagePixelRatio_),
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              [
                  (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
                  (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
              ],
              Math.ceil(this.width_ * this.imagePixelRatio_),
          ]);
          this.hitDetectionInstructions.push([
              Instruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.hitDetectionImage_,
              // Remaining arguments to DRAW_IMAGE are in alphabetical order
              this.anchorX_,
              this.anchorY_,
              this.declutterGroups_,
              this.height_,
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              this.scale_,
              this.width_,
          ]);
          this.endGeometry(feature);
      };
      /**
       * @return {import("./Builder.js").SerializableInstructions} the serializable instructions.
       */
      CanvasImageBuilder.prototype.finish = function () {
          this.reverseHitDetectionInstructions();
          // FIXME this doesn't really protect us against further calls to draw*Geometry
          this.anchorX_ = undefined;
          this.anchorY_ = undefined;
          this.hitDetectionImage_ = null;
          this.image_ = null;
          this.imagePixelRatio_ = undefined;
          this.height_ = undefined;
          this.scale_ = undefined;
          this.opacity_ = undefined;
          this.originX_ = undefined;
          this.originY_ = undefined;
          this.rotateWithView_ = undefined;
          this.rotation_ = undefined;
          this.width_ = undefined;
          return _super.prototype.finish.call(this);
      };
      /**
       * @param {import("../../style/Image.js").default} imageStyle Image style.
       * @param {import("../canvas.js").DeclutterGroup} declutterGroups Declutter.
       */
      CanvasImageBuilder.prototype.setImageStyle = function (imageStyle, declutterGroups) {
          var anchor = imageStyle.getAnchor();
          var size = imageStyle.getSize();
          var hitDetectionImage = imageStyle.getHitDetectionImage();
          var image = imageStyle.getImage(this.pixelRatio);
          var origin = imageStyle.getOrigin();
          this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
          this.anchorX_ = anchor[0];
          this.anchorY_ = anchor[1];
          this.declutterGroups_ = declutterGroups;
          this.hitDetectionImage_ = hitDetectionImage;
          this.image_ = image;
          this.height_ = size[1];
          this.opacity_ = imageStyle.getOpacity();
          this.originX_ = origin[0];
          this.originY_ = origin[1];
          this.rotateWithView_ = imageStyle.getRotateWithView();
          this.rotation_ = imageStyle.getRotation();
          this.scale_ = imageStyle.getScaleArray();
          this.width_ = size[0];
      };
      return CanvasImageBuilder;
  }(CanvasBuilder));

  var __extends$t = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var CanvasLineStringBuilder = /** @class */ (function (_super) {
      __extends$t(CanvasLineStringBuilder, _super);
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      function CanvasLineStringBuilder(tolerance, maxExtent, resolution, pixelRatio) {
          return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       * @return {number} end.
       */
      CanvasLineStringBuilder.prototype.drawFlatCoordinates_ = function (flatCoordinates, offset, end, stride) {
          var myBegin = this.coordinates.length;
          var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
          var moveToLineToInstruction = [
              Instruction.MOVE_TO_LINE_TO,
              myBegin,
              myEnd,
          ];
          this.instructions.push(moveToLineToInstruction);
          this.hitDetectionInstructions.push(moveToLineToInstruction);
          return end;
      };
      /**
       * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasLineStringBuilder.prototype.drawLineString = function (lineStringGeometry, feature) {
          var state = this.state;
          var strokeStyle = state.strokeStyle;
          var lineWidth = state.lineWidth;
          if (strokeStyle === undefined || lineWidth === undefined) {
              return;
          }
          this.updateStrokeStyle(state, this.applyStroke);
          this.beginGeometry(lineStringGeometry, feature);
          this.hitDetectionInstructions.push([
              Instruction.SET_STROKE_STYLE,
              state.strokeStyle,
              state.lineWidth,
              state.lineCap,
              state.lineJoin,
              state.miterLimit,
              state.lineDash,
              state.lineDashOffset,
          ], beginPathInstruction);
          var flatCoordinates = lineStringGeometry.getFlatCoordinates();
          var stride = lineStringGeometry.getStride();
          this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
          this.hitDetectionInstructions.push(strokeInstruction);
          this.endGeometry(feature);
      };
      /**
       * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasLineStringBuilder.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {
          var state = this.state;
          var strokeStyle = state.strokeStyle;
          var lineWidth = state.lineWidth;
          if (strokeStyle === undefined || lineWidth === undefined) {
              return;
          }
          this.updateStrokeStyle(state, this.applyStroke);
          this.beginGeometry(multiLineStringGeometry, feature);
          this.hitDetectionInstructions.push([
              Instruction.SET_STROKE_STYLE,
              state.strokeStyle,
              state.lineWidth,
              state.lineCap,
              state.lineJoin,
              state.miterLimit,
              state.lineDash,
              state.lineDashOffset,
          ], beginPathInstruction);
          var ends = multiLineStringGeometry.getEnds();
          var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
          var stride = multiLineStringGeometry.getStride();
          var offset = 0;
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              offset = this.drawFlatCoordinates_(flatCoordinates, offset, 
              /** @type {number} */ (ends[i]), stride);
          }
          this.hitDetectionInstructions.push(strokeInstruction);
          this.endGeometry(feature);
      };
      /**
       * @return {import("./Builder.js").SerializableInstructions} the serializable instructions.
       */
      CanvasLineStringBuilder.prototype.finish = function () {
          var state = this.state;
          if (state.lastStroke != undefined &&
              state.lastStroke != this.coordinates.length) {
              this.instructions.push(strokeInstruction);
          }
          this.reverseHitDetectionInstructions();
          this.state = null;
          return _super.prototype.finish.call(this);
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       */
      CanvasLineStringBuilder.prototype.applyStroke = function (state) {
          if (state.lastStroke != undefined &&
              state.lastStroke != this.coordinates.length) {
              this.instructions.push(strokeInstruction);
              state.lastStroke = this.coordinates.length;
          }
          state.lastStroke = 0;
          _super.prototype.applyStroke.call(this, state);
          this.instructions.push(beginPathInstruction);
      };
      return CanvasLineStringBuilder;
  }(CanvasBuilder));

  var __extends$u = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var CanvasPolygonBuilder = /** @class */ (function (_super) {
      __extends$u(CanvasPolygonBuilder, _super);
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {
          return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @private
       * @return {number} End.
       */
      CanvasPolygonBuilder.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {
          var state = this.state;
          var fill = state.fillStyle !== undefined;
          var stroke = state.strokeStyle !== undefined;
          var numEnds = ends.length;
          this.instructions.push(beginPathInstruction);
          this.hitDetectionInstructions.push(beginPathInstruction);
          for (var i = 0; i < numEnds; ++i) {
              var end = ends[i];
              var myBegin = this.coordinates.length;
              var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
              var moveToLineToInstruction = [
                  Instruction.MOVE_TO_LINE_TO,
                  myBegin,
                  myEnd,
              ];
              this.instructions.push(moveToLineToInstruction);
              this.hitDetectionInstructions.push(moveToLineToInstruction);
              if (stroke) {
                  // Performance optimization: only call closePath() when we have a stroke.
                  // Otherwise the ring is closed already (see appendFlatCoordinates above).
                  this.instructions.push(closePathInstruction);
                  this.hitDetectionInstructions.push(closePathInstruction);
              }
              offset = end;
          }
          if (fill) {
              this.instructions.push(fillInstruction);
              this.hitDetectionInstructions.push(fillInstruction);
          }
          if (stroke) {
              this.instructions.push(strokeInstruction);
              this.hitDetectionInstructions.push(strokeInstruction);
          }
          return offset;
      };
      /**
       * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
       * @param {import("../../Feature.js").default} feature Feature.
       */
      CanvasPolygonBuilder.prototype.drawCircle = function (circleGeometry, feature) {
          var state = this.state;
          var fillStyle = state.fillStyle;
          var strokeStyle = state.strokeStyle;
          if (fillStyle === undefined && strokeStyle === undefined) {
              return;
          }
          this.setFillStrokeStyles_();
          this.beginGeometry(circleGeometry, feature);
          if (state.fillStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_FILL_STYLE,
                  defaultFillStyle,
              ]);
          }
          if (state.strokeStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_STROKE_STYLE,
                  state.strokeStyle,
                  state.lineWidth,
                  state.lineCap,
                  state.lineJoin,
                  state.miterLimit,
                  state.lineDash,
                  state.lineDashOffset,
              ]);
          }
          var flatCoordinates = circleGeometry.getFlatCoordinates();
          var stride = circleGeometry.getStride();
          var myBegin = this.coordinates.length;
          this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
          var circleInstruction = [Instruction.CIRCLE, myBegin];
          this.instructions.push(beginPathInstruction, circleInstruction);
          this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
          if (state.fillStyle !== undefined) {
              this.instructions.push(fillInstruction);
              this.hitDetectionInstructions.push(fillInstruction);
          }
          if (state.strokeStyle !== undefined) {
              this.instructions.push(strokeInstruction);
              this.hitDetectionInstructions.push(strokeInstruction);
          }
          this.endGeometry(feature);
      };
      /**
       * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasPolygonBuilder.prototype.drawPolygon = function (polygonGeometry, feature) {
          var state = this.state;
          var fillStyle = state.fillStyle;
          var strokeStyle = state.strokeStyle;
          if (fillStyle === undefined && strokeStyle === undefined) {
              return;
          }
          this.setFillStrokeStyles_();
          this.beginGeometry(polygonGeometry, feature);
          if (state.fillStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_FILL_STYLE,
                  defaultFillStyle,
              ]);
          }
          if (state.strokeStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_STROKE_STYLE,
                  state.strokeStyle,
                  state.lineWidth,
                  state.lineCap,
                  state.lineJoin,
                  state.miterLimit,
                  state.lineDash,
                  state.lineDashOffset,
              ]);
          }
          var ends = polygonGeometry.getEnds();
          var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
          var stride = polygonGeometry.getStride();
          this.drawFlatCoordinatess_(flatCoordinates, 0, 
          /** @type {Array<number>} */ (ends), stride);
          this.endGeometry(feature);
      };
      /**
       * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasPolygonBuilder.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {
          var state = this.state;
          var fillStyle = state.fillStyle;
          var strokeStyle = state.strokeStyle;
          if (fillStyle === undefined && strokeStyle === undefined) {
              return;
          }
          this.setFillStrokeStyles_();
          this.beginGeometry(multiPolygonGeometry, feature);
          if (state.fillStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_FILL_STYLE,
                  defaultFillStyle,
              ]);
          }
          if (state.strokeStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_STROKE_STYLE,
                  state.strokeStyle,
                  state.lineWidth,
                  state.lineCap,
                  state.lineJoin,
                  state.miterLimit,
                  state.lineDash,
                  state.lineDashOffset,
              ]);
          }
          var endss = multiPolygonGeometry.getEndss();
          var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
          var stride = multiPolygonGeometry.getStride();
          var offset = 0;
          for (var i = 0, ii = endss.length; i < ii; ++i) {
              offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
          }
          this.endGeometry(feature);
      };
      /**
       * @return {import("./Builder.js").SerializableInstructions} the serializable instructions.
       */
      CanvasPolygonBuilder.prototype.finish = function () {
          this.reverseHitDetectionInstructions();
          this.state = null;
          // We want to preserve topology when drawing polygons.  Polygons are
          // simplified using quantization and point elimination. However, we might
          // have received a mix of quantized and non-quantized geometries, so ensure
          // that all are quantized by quantizing all coordinates in the batch.
          var tolerance = this.tolerance;
          if (tolerance !== 0) {
              var coordinates = this.coordinates;
              for (var i = 0, ii = coordinates.length; i < ii; ++i) {
                  coordinates[i] = snap(coordinates[i], tolerance);
              }
          }
          return _super.prototype.finish.call(this);
      };
      /**
       * @private
       */
      CanvasPolygonBuilder.prototype.setFillStrokeStyles_ = function () {
          var state = this.state;
          var fillStyle = state.fillStyle;
          if (fillStyle !== undefined) {
              this.updateFillStyle(state, this.createFill);
          }
          if (state.strokeStyle !== undefined) {
              this.updateStrokeStyle(state, this.applyStroke);
          }
      };
      return CanvasPolygonBuilder;
  }(CanvasBuilder));

  /**
   * @module ol/style/TextPlacement
   */
  /**
   * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that
   * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
   * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
   * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
   * @enum {string}
   */
  var TextPlacement = {
      POINT: 'point',
      LINE: 'line',
  };

  /**
   * @module ol/geom/flat/straightchunk
   */
  /**
   * @param {number} maxAngle Maximum acceptable angle delta between segments.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {Array<number>} Start and end of the first suitable chunk of the
   * given `flatCoordinates`.
   */
  function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
      var chunkStart = offset;
      var chunkEnd = offset;
      var chunkM = 0;
      var m = 0;
      var start = offset;
      var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
      for (i = offset; i < end; i += stride) {
          var x2 = flatCoordinates[i];
          var y2 = flatCoordinates[i + 1];
          if (x1 !== undefined) {
              x23 = x2 - x1;
              y23 = y2 - y1;
              m23 = Math.sqrt(x23 * x23 + y23 * y23);
              if (x12 !== undefined) {
                  m += m12;
                  acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
                  if (acos > maxAngle) {
                      if (m > chunkM) {
                          chunkM = m;
                          chunkStart = start;
                          chunkEnd = i;
                      }
                      m = 0;
                      start = i - stride;
                  }
              }
              m12 = m23;
              x12 = x23;
              y12 = y23;
          }
          x1 = x2;
          y1 = y2;
      }
      m += m23;
      return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
  }

  var __extends$v = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @const
   * @enum {number}
   */
  var TEXT_ALIGN = {
      'left': 0,
      'end': 0,
      'center': 0.5,
      'right': 1,
      'start': 1,
      'top': 0,
      'middle': 0.5,
      'hanging': 0.2,
      'alphabetic': 0.8,
      'ideographic': 0.8,
      'bottom': 1,
  };
  var CanvasTextBuilder = /** @class */ (function (_super) {
      __extends$v(CanvasTextBuilder, _super);
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      function CanvasTextBuilder(tolerance, maxExtent, resolution, pixelRatio) {
          var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
          /**
           * @private
           * @type {import("../canvas.js").DeclutterGroups}
           */
          _this.declutterGroups_;
          /**
           * @private
           * @type {Array<HTMLCanvasElement>}
           */
          _this.labels_ = null;
          /**
           * @private
           * @type {string}
           */
          _this.text_ = '';
          /**
           * @private
           * @type {number}
           */
          _this.textOffsetX_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.textOffsetY_ = 0;
          /**
           * @private
           * @type {boolean|undefined}
           */
          _this.textRotateWithView_ = undefined;
          /**
           * @private
           * @type {number}
           */
          _this.textRotation_ = 0;
          /**
           * @private
           * @type {?import("../canvas.js").FillState}
           */
          _this.textFillState_ = null;
          /**
           * @type {!Object<string, import("../canvas.js").FillState>}
           */
          _this.fillStates = {};
          /**
           * @private
           * @type {?import("../canvas.js").StrokeState}
           */
          _this.textStrokeState_ = null;
          /**
           * @type {!Object<string, import("../canvas.js").StrokeState>}
           */
          _this.strokeStates = {};
          /**
           * @private
           * @type {import("../canvas.js").TextState}
           */
          _this.textState_ = /** @type {import("../canvas.js").TextState} */ ({});
          /**
           * @type {!Object<string, import("../canvas.js").TextState>}
           */
          _this.textStates = {};
          /**
           * @private
           * @type {string}
           */
          _this.textKey_ = '';
          /**
           * @private
           * @type {string}
           */
          _this.fillKey_ = '';
          /**
           * @private
           * @type {string}
           */
          _this.strokeKey_ = '';
          return _this;
      }
      /**
       * @return {import("./Builder.js").SerializableInstructions} the serializable instructions.
       */
      CanvasTextBuilder.prototype.finish = function () {
          var instructions = _super.prototype.finish.call(this);
          instructions.textStates = this.textStates;
          instructions.fillStates = this.fillStates;
          instructions.strokeStates = this.strokeStates;
          return instructions;
      };
      /**
       * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasTextBuilder.prototype.drawText = function (geometry, feature) {
          var fillState = this.textFillState_;
          var strokeState = this.textStrokeState_;
          var textState = this.textState_;
          if (this.text_ === '' || !textState || (!fillState && !strokeState)) {
              return;
          }
          var begin = this.coordinates.length;
          var geometryType = geometry.getType();
          var flatCoordinates = null;
          var end = 2;
          var stride = geometry.getStride();
          var i, ii;
          if (textState.placement === TextPlacement.LINE) {
              if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
                  return;
              }
              var ends = void 0;
              flatCoordinates = geometry.getFlatCoordinates();
              if (geometryType == GeometryType.LINE_STRING) {
                  ends = [flatCoordinates.length];
              }
              else if (geometryType == GeometryType.MULTI_LINE_STRING) {
                  ends = /** @type {import("../../geom/MultiLineString.js").default} */ (geometry).getEnds();
              }
              else if (geometryType == GeometryType.POLYGON) {
                  ends = /** @type {import("../../geom/Polygon.js").default} */ (geometry)
                      .getEnds()
                      .slice(0, 1);
              }
              else if (geometryType == GeometryType.MULTI_POLYGON) {
                  var endss = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getEndss();
                  ends = [];
                  for (i = 0, ii = endss.length; i < ii; ++i) {
                      ends.push(endss[i][0]);
                  }
              }
              this.beginGeometry(geometry, feature);
              var textAlign = textState.textAlign;
              var flatOffset = 0;
              var flatEnd = void 0;
              for (var o = 0, oo = ends.length; o < oo; ++o) {
                  if (textAlign == undefined) {
                      var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
                      flatOffset = range[0];
                      flatEnd = range[1];
                  }
                  else {
                      flatEnd = ends[o];
                  }
                  for (i = flatOffset; i < flatEnd; i += stride) {
                      this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
                  }
                  end = this.coordinates.length;
                  flatOffset = ends[o];
                  var declutterGroup = this.declutterGroups_
                      ? o === 0
                          ? this.declutterGroups_[0]
                          : [].concat(this.declutterGroups_[0])
                      : null;
                  this.drawChars_(begin, end, declutterGroup);
                  begin = end;
              }
              this.endGeometry(feature);
          }
          else {
              var geometryWidths = null;
              if (!textState.overflow) {
                  geometryWidths = [];
              }
              switch (geometryType) {
                  case GeometryType.POINT:
                  case GeometryType.MULTI_POINT:
                      flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */ (geometry).getFlatCoordinates();
                      end = flatCoordinates.length;
                      break;
                  case GeometryType.LINE_STRING:
                      flatCoordinates = /** @type {import("../../geom/LineString.js").default} */ (geometry).getFlatMidpoint();
                      break;
                  case GeometryType.CIRCLE:
                      flatCoordinates = /** @type {import("../../geom/Circle.js").default} */ (geometry).getCenter();
                      break;
                  case GeometryType.MULTI_LINE_STRING:
                      flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */ (geometry).getFlatMidpoints();
                      stride = 2;
                      end = flatCoordinates.length;
                      break;
                  case GeometryType.POLYGON:
                      flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */ (geometry).getFlatInteriorPoint();
                      if (!textState.overflow) {
                          geometryWidths.push(flatCoordinates[2] / this.resolution);
                      }
                      stride = 3;
                      break;
                  case GeometryType.MULTI_POLYGON:
                      var interiorPoints = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getFlatInteriorPoints();
                      flatCoordinates = [];
                      for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {
                          if (!textState.overflow) {
                              geometryWidths.push(interiorPoints[i + 2] / this.resolution);
                          }
                          flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
                      }
                      stride = 2;
                      end = flatCoordinates.length;
                      if (end == 0) {
                          return;
                      }
                      break;
                  default:
              }
              end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);
              this.saveTextStates_();
              if (textState.backgroundFill || textState.backgroundStroke) {
                  this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
                  if (textState.backgroundFill) {
                      this.updateFillStyle(this.state, this.createFill);
                      this.hitDetectionInstructions.push(this.createFill(this.state));
                  }
                  if (textState.backgroundStroke) {
                      this.updateStrokeStyle(this.state, this.applyStroke);
                      this.hitDetectionInstructions.push(this.createStroke(this.state));
                  }
              }
              this.beginGeometry(geometry, feature);
              // adjust padding for negative scale
              var padding = textState.padding;
              if (padding != defaultPadding &&
                  (textState.scale[0] < 0 || textState.scale[1] < 0)) {
                  var p0 = textState.padding[0];
                  var p1 = textState.padding[1];
                  var p2 = textState.padding[2];
                  var p3 = textState.padding[3];
                  if (textState.scale[0] < 0) {
                      p1 = -p1;
                      p3 = -p3;
                  }
                  if (textState.scale[1] < 0) {
                      p0 = -p0;
                      p2 = -p2;
                  }
                  padding = [p0, p1, p2, p3];
              }
              // The image is unknown at this stage so we pass null; it will be computed at render time.
              // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at
              // render time.
              var pixelRatio_1 = this.pixelRatio;
              this.instructions.push([
                  Instruction.DRAW_IMAGE,
                  begin,
                  end,
                  null,
                  NaN,
                  NaN,
                  this.declutterGroups_,
                  NaN,
                  1,
                  0,
                  0,
                  this.textRotateWithView_,
                  this.textRotation_,
                  [1, 1],
                  NaN,
                  padding == defaultPadding
                      ? defaultPadding
                      : padding.map(function (p) {
                          return p * pixelRatio_1;
                      }),
                  !!textState.backgroundFill,
                  !!textState.backgroundStroke,
                  this.text_,
                  this.textKey_,
                  this.strokeKey_,
                  this.fillKey_,
                  this.textOffsetX_,
                  this.textOffsetY_,
                  geometryWidths,
              ]);
              var scale = 1 / pixelRatio_1;
              this.hitDetectionInstructions.push([
                  Instruction.DRAW_IMAGE,
                  begin,
                  end,
                  null,
                  NaN,
                  NaN,
                  this.declutterGroups_,
                  NaN,
                  1,
                  0,
                  0,
                  this.textRotateWithView_,
                  this.textRotation_,
                  [scale, scale],
                  NaN,
                  padding,
                  !!textState.backgroundFill,
                  !!textState.backgroundStroke,
                  this.text_,
                  this.textKey_,
                  this.strokeKey_,
                  this.fillKey_,
                  this.textOffsetX_,
                  this.textOffsetY_,
                  geometryWidths,
              ]);
              this.endGeometry(feature);
          }
      };
      /**
       * @private
       */
      CanvasTextBuilder.prototype.saveTextStates_ = function () {
          var strokeState = this.textStrokeState_;
          var textState = this.textState_;
          var fillState = this.textFillState_;
          var strokeKey = this.strokeKey_;
          if (strokeState) {
              if (!(strokeKey in this.strokeStates)) {
                  this.strokeStates[strokeKey] = {
                      strokeStyle: strokeState.strokeStyle,
                      lineCap: strokeState.lineCap,
                      lineDashOffset: strokeState.lineDashOffset,
                      lineWidth: strokeState.lineWidth,
                      lineJoin: strokeState.lineJoin,
                      miterLimit: strokeState.miterLimit,
                      lineDash: strokeState.lineDash,
                  };
              }
          }
          var textKey = this.textKey_;
          if (!(textKey in this.textStates)) {
              this.textStates[textKey] = {
                  font: textState.font,
                  textAlign: textState.textAlign || defaultTextAlign,
                  textBaseline: textState.textBaseline || defaultTextBaseline,
                  scale: textState.scale,
              };
          }
          var fillKey = this.fillKey_;
          if (fillState) {
              if (!(fillKey in this.fillStates)) {
                  this.fillStates[fillKey] = {
                      fillStyle: fillState.fillStyle,
                  };
              }
          }
      };
      /**
       * @private
       * @param {number} begin Begin.
       * @param {number} end End.
       * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
       */
      CanvasTextBuilder.prototype.drawChars_ = function (begin, end, declutterGroup) {
          var strokeState = this.textStrokeState_;
          var textState = this.textState_;
          var strokeKey = this.strokeKey_;
          var textKey = this.textKey_;
          var fillKey = this.fillKey_;
          this.saveTextStates_();
          var pixelRatio = this.pixelRatio;
          var baseline = TEXT_ALIGN[textState.textBaseline];
          var offsetY = this.textOffsetY_ * pixelRatio;
          var text = this.text_;
          var strokeWidth = strokeState
              ? (strokeState.lineWidth * Math.abs(textState.scale[0])) / 2
              : 0;
          this.instructions.push([
              Instruction.DRAW_CHARS,
              begin,
              end,
              baseline,
              declutterGroup,
              textState.overflow,
              fillKey,
              textState.maxAngle,
              pixelRatio,
              offsetY,
              strokeKey,
              strokeWidth * pixelRatio,
              text,
              textKey,
              1,
          ]);
          this.hitDetectionInstructions.push([
              Instruction.DRAW_CHARS,
              begin,
              end,
              baseline,
              declutterGroup,
              textState.overflow,
              fillKey,
              textState.maxAngle,
              1,
              offsetY,
              strokeKey,
              strokeWidth,
              text,
              textKey,
              1 / pixelRatio,
          ]);
      };
      /**
       * @param {import("../../style/Text.js").default} textStyle Text style.
       * @param {import("../canvas.js").DeclutterGroups} declutterGroups Declutter.
       */
      CanvasTextBuilder.prototype.setTextStyle = function (textStyle, declutterGroups) {
          var textState, fillState, strokeState;
          if (!textStyle) {
              this.text_ = '';
          }
          else {
              this.declutterGroups_ = declutterGroups;
              var textFillStyle = textStyle.getFill();
              if (!textFillStyle) {
                  fillState = null;
                  this.textFillState_ = fillState;
              }
              else {
                  fillState = this.textFillState_;
                  if (!fillState) {
                      fillState = /** @type {import("../canvas.js").FillState} */ ({});
                      this.textFillState_ = fillState;
                  }
                  fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);
              }
              var textStrokeStyle = textStyle.getStroke();
              if (!textStrokeStyle) {
                  strokeState = null;
                  this.textStrokeState_ = strokeState;
              }
              else {
                  strokeState = this.textStrokeState_;
                  if (!strokeState) {
                      strokeState = /** @type {import("../canvas.js").StrokeState} */ ({});
                      this.textStrokeState_ = strokeState;
                  }
                  var lineDash = textStrokeStyle.getLineDash();
                  var lineDashOffset = textStrokeStyle.getLineDashOffset();
                  var lineWidth = textStrokeStyle.getWidth();
                  var miterLimit = textStrokeStyle.getMiterLimit();
                  strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
                  strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
                  strokeState.lineDashOffset =
                      lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;
                  strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
                  strokeState.lineWidth =
                      lineWidth === undefined ? defaultLineWidth : lineWidth;
                  strokeState.miterLimit =
                      miterLimit === undefined ? defaultMiterLimit : miterLimit;
                  strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);
              }
              textState = this.textState_;
              var font = textStyle.getFont() || defaultFont;
              registerFont(font);
              var textScale = textStyle.getScaleArray();
              textState.overflow = textStyle.getOverflow();
              textState.font = font;
              textState.maxAngle = textStyle.getMaxAngle();
              textState.placement = textStyle.getPlacement();
              textState.textAlign = textStyle.getTextAlign();
              textState.textBaseline =
                  textStyle.getTextBaseline() || defaultTextBaseline;
              textState.backgroundFill = textStyle.getBackgroundFill();
              textState.backgroundStroke = textStyle.getBackgroundStroke();
              textState.padding = textStyle.getPadding() || defaultPadding;
              textState.scale = textScale === undefined ? [1, 1] : textScale;
              var textOffsetX = textStyle.getOffsetX();
              var textOffsetY = textStyle.getOffsetY();
              var textRotateWithView = textStyle.getRotateWithView();
              var textRotation = textStyle.getRotation();
              this.text_ = textStyle.getText() || '';
              this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
              this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
              this.textRotateWithView_ =
                  textRotateWithView === undefined ? false : textRotateWithView;
              this.textRotation_ = textRotation === undefined ? 0 : textRotation;
              this.strokeKey_ = strokeState
                  ? (typeof strokeState.strokeStyle == 'string'
                      ? strokeState.strokeStyle
                      : getUid(strokeState.strokeStyle)) +
                      strokeState.lineCap +
                      strokeState.lineDashOffset +
                      '|' +
                      strokeState.lineWidth +
                      strokeState.lineJoin +
                      strokeState.miterLimit +
                      '[' +
                      strokeState.lineDash.join() +
                      ']'
                  : '';
              this.textKey_ =
                  textState.font +
                      textState.scale +
                      (textState.textAlign || '?') +
                      (textState.textBaseline || '?');
              this.fillKey_ = fillState
                  ? typeof fillState.fillStyle == 'string'
                      ? fillState.fillStyle
                      : '|' + getUid(fillState.fillStyle)
                  : '';
          }
      };
      return CanvasTextBuilder;
  }(CanvasBuilder));

  /**
   * @module ol/render/canvas/BuilderGroup
   */
  /**
   * @type {Object<import("./BuilderType").default, typeof Builder>}
   */
  var BATCH_CONSTRUCTORS = {
      'Circle': CanvasPolygonBuilder,
      'Default': CanvasBuilder,
      'Image': CanvasImageBuilder,
      'LineString': CanvasLineStringBuilder,
      'Polygon': CanvasPolygonBuilder,
      'Text': CanvasTextBuilder,
  };
  var BuilderGroup = /** @class */ (function () {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Max extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} declutter Decluttering enabled.
       */
      function BuilderGroup(tolerance, maxExtent, resolution, pixelRatio, declutter) {
          /**
           * @type {boolean}
           * @private
           */
          this.declutter_ = declutter;
          /**
           * @type {import("../canvas.js").DeclutterGroups}
           * @private
           */
          this.declutterGroups_ = null;
          /**
           * @private
           * @type {number}
           */
          this.tolerance_ = tolerance;
          /**
           * @private
           * @type {import("../../extent.js").Extent}
           */
          this.maxExtent_ = maxExtent;
          /**
           * @private
           * @type {number}
           */
          this.pixelRatio_ = pixelRatio;
          /**
           * @private
           * @type {number}
           */
          this.resolution_ = resolution;
          /**
           * @private
           * @type {!Object<string, !Object<import("./BuilderType").default, Builder>>}
           */
          this.buildersByZIndex_ = {};
      }
      /**
       * @param {boolean} group Group with previous builder.
       * @return {import("../canvas").DeclutterGroups} The resulting instruction groups.
       */
      BuilderGroup.prototype.addDeclutter = function (group) {
          /** @type {Array<*>} */
          var declutter = null;
          if (this.declutter_) {
              if (group) {
                  declutter = this.declutterGroups_;
                  /** @type {number} */ (declutter[0][0])++;
              }
              else {
                  declutter = [[1]];
                  this.declutterGroups_ = declutter;
              }
          }
          return declutter;
      };
      /**
       * @return {!Object<string, !Object<import("./BuilderType").default, import("./Builder.js").SerializableInstructions>>} The serializable instructions
       */
      BuilderGroup.prototype.finish = function () {
          var builderInstructions = {};
          for (var zKey in this.buildersByZIndex_) {
              builderInstructions[zKey] = builderInstructions[zKey] || {};
              var builders = this.buildersByZIndex_[zKey];
              for (var builderKey in builders) {
                  var builderInstruction = builders[builderKey].finish();
                  builderInstructions[zKey][builderKey] = builderInstruction;
              }
          }
          return builderInstructions;
      };
      /**
       * @param {number|undefined} zIndex Z index.
       * @param {import("./BuilderType.js").default} builderType Replay type.
       * @return {import("../VectorContext.js").default} Replay.
       */
      BuilderGroup.prototype.getBuilder = function (zIndex, builderType) {
          var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
          var replays = this.buildersByZIndex_[zIndexKey];
          if (replays === undefined) {
              replays = {};
              this.buildersByZIndex_[zIndexKey] = replays;
          }
          var replay = replays[builderType];
          if (replay === undefined) {
              var Constructor = BATCH_CONSTRUCTORS[builderType];
              replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
              replays[builderType] = replay;
          }
          return replay;
      };
      return BuilderGroup;
  }());

  var __extends$w = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @template {import("../layer/Layer.js").default} LayerType
   */
  var LayerRenderer = /** @class */ (function (_super) {
      __extends$w(LayerRenderer, _super);
      /**
       * @param {LayerType} layer Layer.
       */
      function LayerRenderer(layer) {
          var _this = _super.call(this) || this;
          /** @private */
          _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);
          /**
           * @protected
           * @type {LayerType}
           */
          _this.layer_ = layer;
          return _this;
      }
      /**
       * Asynchronous layer level hit detection.
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
       * an array of features.
       */
      LayerRenderer.prototype.getFeatures = function (pixel) {
          return abstract();
      };
      /**
       * Determine whether render should be called.
       * @abstract
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      LayerRenderer.prototype.prepareFrame = function (frameState) {
          return abstract();
      };
      /**
       * Render the layer.
       * @abstract
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target that may be used to render content to.
       * @return {HTMLElement} The rendered element.
       */
      LayerRenderer.prototype.renderFrame = function (frameState, target) {
          return abstract();
      };
      /**
       * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @param {number} zoom Zoom level.
       * @param {import("../Tile.js").default} tile Tile.
       * @return {boolean|void} If `false`, the tile will not be considered loaded.
       */
      LayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {
          if (!tiles[zoom]) {
              tiles[zoom] = {};
          }
          tiles[zoom][tile.tileCoord.toString()] = tile;
          return undefined;
      };
      /**
       * Create a function that adds loaded tiles to the tile lookup.
       * @param {import("../source/Tile.js").default} source Tile source.
       * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
       * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
       *     called with a zoom level and a tile range to add loaded tiles to the lookup.
       * @protected
       */
      LayerRenderer.prototype.createLoadedTileFinder = function (source, projection, tiles) {
          return (
          /**
           * @param {number} zoom Zoom level.
           * @param {import("../TileRange.js").default} tileRange Tile range.
           * @return {boolean} The tile range is fully loaded.
           * @this {LayerRenderer}
           */
          function (zoom, tileRange) {
              var callback = this.loadedTileCallback.bind(this, tiles, zoom);
              return source.forEachLoadedTile(projection, zoom, tileRange, callback);
          }.bind(this));
      };
      /**
       * @abstract
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default): T} callback Feature callback.
       * @param {Array<import("../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
       * @return {T|void} Callback result.
       * @template T
       */
      LayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, declutteredFeatures) { };
      /**
       * @abstract
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
       *    location, null will be returned.  If there is data, but pixel values cannot be
       *    returned, and empty array will be returned.
       */
      LayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
          return abstract();
      };
      /**
       * @return {LayerType} Layer.
       */
      LayerRenderer.prototype.getLayer = function () {
          return this.layer_;
      };
      /**
       * Perform action necessary to get the layer rendered after new fonts have loaded
       * @abstract
       */
      LayerRenderer.prototype.handleFontsChanged = function () { };
      /**
       * Handle changes in image state.
       * @param {import("../events/Event.js").default} event Image change event.
       * @private
       */
      LayerRenderer.prototype.handleImageChange_ = function (event) {
          var image = /** @type {import("../Image.js").default} */ (event.target);
          if (image.getState() === ImageState.LOADED) {
              this.renderIfReadyAndVisible();
          }
      };
      /**
       * Load the image if not already loaded, and register the image change
       * listener if needed.
       * @param {import("../ImageBase.js").default} image Image.
       * @return {boolean} `true` if the image is already loaded, `false` otherwise.
       * @protected
       */
      LayerRenderer.prototype.loadImage = function (image) {
          var imageState = image.getState();
          if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {
              image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);
          }
          if (imageState == ImageState.IDLE) {
              image.load();
              imageState = image.getState();
          }
          return imageState == ImageState.LOADED;
      };
      /**
       * @protected
       */
      LayerRenderer.prototype.renderIfReadyAndVisible = function () {
          var layer = this.getLayer();
          if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {
              layer.changed();
          }
      };
      return LayerRenderer;
  }(Observable));

  /**
   * @module ol/render/Event
   */
  var __extends$x = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var RenderEvent = /** @class */ (function (_super) {
      __extends$x(RenderEvent, _super);
      /**
       * @param {import("./EventType.js").default} type Type.
       * @param {import("../transform.js").Transform=} opt_inversePixelTransform Transform for
       *     CSS pixels to rendered pixels.
       * @param {import("../PluggableMap.js").FrameState=} opt_frameState Frame state.
       * @param {?CanvasRenderingContext2D=} opt_context Context.
       */
      function RenderEvent(type, opt_inversePixelTransform, opt_frameState, opt_context) {
          var _this = _super.call(this, type) || this;
          /**
           * Transform from CSS pixels (relative to the top-left corner of the map viewport)
           * to rendered pixels on this event's `context`.
           * @type {import("../transform.js").Transform|undefined}
           * @api
           */
          _this.inversePixelTransform = opt_inversePixelTransform;
          /**
           * An object representing the current render frame state.
           * @type {import("../PluggableMap.js").FrameState|undefined}
           * @api
           */
          _this.frameState = opt_frameState;
          /**
           * Canvas context. Not available when the event is dispatched by the map. Only available
           * when a Canvas renderer is used, null otherwise.
           * @type {CanvasRenderingContext2D|null|undefined}
           * @api
           */
          _this.context = opt_context;
          return _this;
      }
      return RenderEvent;
  }(BaseEvent));

  var __extends$y = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @abstract
   * @template {import("../../layer/Layer.js").default} LayerType
   */
  var CanvasLayerRenderer = /** @class */ (function (_super) {
      __extends$y(CanvasLayerRenderer, _super);
      /**
       * @param {LayerType} layer Layer.
       */
      function CanvasLayerRenderer(layer) {
          var _this = _super.call(this, layer) || this;
          /**
           * @protected
           * @type {HTMLElement}
           */
          _this.container = null;
          /**
           * @protected
           * @type {number}
           */
          _this.renderedResolution;
          /**
           * A temporary transform.  The values in this transform should only be used in a
           * function that sets the values.
           * @protected
           * @type {import("../../transform.js").Transform}
           */
          _this.tempTransform = create$2();
          /**
           * The transform for rendered pixels to viewport CSS pixels.  This transform must
           * be set when rendering a frame and may be used by other functions after rendering.
           * @protected
           * @type {import("../../transform.js").Transform}
           */
          _this.pixelTransform = create$2();
          /**
           * The transform for viewport CSS pixels to rendered pixels.  This transform must
           * be set when rendering a frame and may be used by other functions after rendering.
           * @protected
           * @type {import("../../transform.js").Transform}
           */
          _this.inversePixelTransform = create$2();
          /**
           * @type {CanvasRenderingContext2D}
           */
          _this.context = null;
          /**
           * @type {boolean}
           */
          _this.containerReused = false;
          return _this;
      }
      /**
       * Get a rendering container from an existing target, if compatible.
       * @param {HTMLElement} target Potential render target.
       * @param {string} transform CSS Transform.
       * @param {number} opacity Opacity.
       */
      CanvasLayerRenderer.prototype.useContainer = function (target, transform, opacity) {
          var layerClassName = this.getLayer().getClassName();
          var container, context;
          if (target &&
              target.style.opacity === '' &&
              target.className === layerClassName) {
              var canvas = target.firstElementChild;
              if (canvas instanceof HTMLCanvasElement) {
                  context = canvas.getContext('2d');
              }
          }
          if (context &&
              (context.canvas.width === 0 ||
                  context.canvas.style.transform === transform)) {
              // Container of the previous layer renderer can be used.
              this.container = target;
              this.context = context;
              this.containerReused = true;
          }
          else if (this.containerReused) {
              // Previously reused container cannot be used any more.
              this.container = null;
              this.context = null;
              this.containerReused = false;
          }
          if (!this.container) {
              container = document.createElement('div');
              container.className = layerClassName;
              var style = container.style;
              style.position = 'absolute';
              style.width = '100%';
              style.height = '100%';
              context = createCanvasContext2D();
              var canvas = context.canvas;
              container.appendChild(canvas);
              style = canvas.style;
              style.position = 'absolute';
              style.left = '0';
              style.transformOrigin = 'top left';
              this.container = container;
              this.context = context;
          }
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {import("../../extent.js").Extent} extent Clip extent.
       * @protected
       */
      CanvasLayerRenderer.prototype.clip = function (context, frameState, extent) {
          var pixelRatio = frameState.pixelRatio;
          var halfWidth = (frameState.size[0] * pixelRatio) / 2;
          var halfHeight = (frameState.size[1] * pixelRatio) / 2;
          var rotation = frameState.viewState.rotation;
          var topLeft = getTopLeft(extent);
          var topRight = getTopRight(extent);
          var bottomRight = getBottomRight(extent);
          var bottomLeft = getBottomLeft(extent);
          apply$1(frameState.coordinateToPixelTransform, topLeft);
          apply$1(frameState.coordinateToPixelTransform, topRight);
          apply$1(frameState.coordinateToPixelTransform, bottomRight);
          apply$1(frameState.coordinateToPixelTransform, bottomLeft);
          context.save();
          rotateAtOffset(context, -rotation, halfWidth, halfHeight);
          context.beginPath();
          context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);
          context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);
          context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);
          context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);
          context.clip();
          rotateAtOffset(context, rotation, halfWidth, halfHeight);
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {import("../../extent.js").Extent} extent Clip extent.
       * @protected
       */
      CanvasLayerRenderer.prototype.clipUnrotated = function (context, frameState, extent) {
          var topLeft = getTopLeft(extent);
          var topRight = getTopRight(extent);
          var bottomRight = getBottomRight(extent);
          var bottomLeft = getBottomLeft(extent);
          apply$1(frameState.coordinateToPixelTransform, topLeft);
          apply$1(frameState.coordinateToPixelTransform, topRight);
          apply$1(frameState.coordinateToPixelTransform, bottomRight);
          apply$1(frameState.coordinateToPixelTransform, bottomLeft);
          var inverted = this.inversePixelTransform;
          apply$1(inverted, topLeft);
          apply$1(inverted, topRight);
          apply$1(inverted, bottomRight);
          apply$1(inverted, bottomLeft);
          context.save();
          context.beginPath();
          context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
          context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
          context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
          context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
          context.clip();
      };
      /**
       * @param {import("../../render/EventType.js").default} type Event type.
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @private
       */
      CanvasLayerRenderer.prototype.dispatchRenderEvent_ = function (type, context, frameState) {
          var layer = this.getLayer();
          if (layer.hasListener(type)) {
              var event_1 = new RenderEvent(type, this.inversePixelTransform, frameState, context);
              layer.dispatchEvent(event_1);
          }
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @protected
       */
      CanvasLayerRenderer.prototype.preRender = function (context, frameState) {
          this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @protected
       */
      CanvasLayerRenderer.prototype.postRender = function (context, frameState) {
          this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);
      };
      /**
       * Creates a transform for rendering to an element that will be rotated after rendering.
       * @param {import("../../coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} pixelRatio Pixel ratio.
       * @param {number} width Width of the rendered element (in pixels).
       * @param {number} height Height of the rendered element (in pixels).
       * @param {number} offsetX Offset on the x-axis in view coordinates.
       * @protected
       * @return {!import("../../transform.js").Transform} Transform.
       */
      CanvasLayerRenderer.prototype.getRenderTransform = function (center, resolution, rotation, pixelRatio, width, height, offsetX) {
          var dx1 = width / 2;
          var dy1 = height / 2;
          var sx = pixelRatio / resolution;
          var sy = -sx;
          var dx2 = -center[0] + offsetX;
          var dy2 = -center[1];
          return compose(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
      };
      /**
       * @param {import("../../pixel.js").Pixel} pixel Pixel.
       * @param {import("../../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
       *    location, null will be returned.  If there is data, but pixel values cannot be
       *    returned, and empty array will be returned.
       */
      CanvasLayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
          var renderPixel = apply$1(this.inversePixelTransform, pixel.slice());
          var context = this.context;
          var data;
          try {
              var x = Math.round(renderPixel[0]);
              var y = Math.round(renderPixel[1]);
              var newCanvas = document.createElement('canvas');
              var newContext = newCanvas.getContext('2d');
              newCanvas.width = 1;
              newCanvas.height = 1;
              newContext.clearRect(0, 0, 1, 1);
              newContext.drawImage(context.canvas, x, y, 1, 1, 0, 0, 1, 1);
              data = newContext.getImageData(0, 0, 1, 1).data;
          }
          catch (err) {
              if (err.name === 'SecurityError') {
                  // tainted canvas, we assume there is data at the given pixel (although there might not be)
                  return new Uint8Array();
              }
              return data;
          }
          if (data[3] === 0) {
              return null;
          }
          return data;
      };
      return CanvasLayerRenderer;
  }(LayerRenderer));

  /**
   * @module ol/render/canvas/BuilderType
   */
  /**
   * @enum {string}
   */
  var BuilderType = {
      CIRCLE: 'Circle',
      DEFAULT: 'Default',
      IMAGE: 'Image',
      LINE_STRING: 'LineString',
      POLYGON: 'Polygon',
      TEXT: 'Text',
  };

  var rbush = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
  module.exports = factory();
  }(commonjsGlobal, function () {
  function quickselect(arr, k, left, right, compare) {
      quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
  }

  function quickselectStep(arr, k, left, right, compare) {

      while (right > left) {
          if (right - left > 600) {
              var n = right - left + 1;
              var m = k - left + 1;
              var z = Math.log(n);
              var s = 0.5 * Math.exp(2 * z / 3);
              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
              quickselectStep(arr, k, newLeft, newRight, compare);
          }

          var t = arr[k];
          var i = left;
          var j = right;

          swap(arr, left, k);
          if (compare(arr[right], t) > 0) { swap(arr, left, right); }

          while (i < j) {
              swap(arr, i, j);
              i++;
              j--;
              while (compare(arr[i], t) < 0) { i++; }
              while (compare(arr[j], t) > 0) { j--; }
          }

          if (compare(arr[left], t) === 0) { swap(arr, left, j); }
          else {
              j++;
              swap(arr, j, right);
          }

          if (j <= k) { left = j + 1; }
          if (k <= j) { right = j - 1; }
      }
  }

  function swap(arr, i, j) {
      var tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
  }

  function defaultCompare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
  }

  var RBush = function RBush(maxEntries) {
      if ( maxEntries === void 0 ) maxEntries = 9;

      // max entries in a node is 9 by default; min node fill is 40% for best performance
      this._maxEntries = Math.max(4, maxEntries);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
      this.clear();
  };

  RBush.prototype.all = function all () {
      return this._all(this.data, []);
  };

  RBush.prototype.search = function search (bbox) {
      var node = this.data;
      var result = [];

      if (!intersects(bbox, node)) { return result; }

      var toBBox = this.toBBox;
      var nodesToSearch = [];

      while (node) {
          for (var i = 0; i < node.children.length; i++) {
              var child = node.children[i];
              var childBBox = node.leaf ? toBBox(child) : child;

              if (intersects(bbox, childBBox)) {
                  if (node.leaf) { result.push(child); }
                  else if (contains(bbox, childBBox)) { this._all(child, result); }
                  else { nodesToSearch.push(child); }
              }
          }
          node = nodesToSearch.pop();
      }

      return result;
  };

  RBush.prototype.collides = function collides (bbox) {
      var node = this.data;

      if (!intersects(bbox, node)) { return false; }

      var nodesToSearch = [];
      while (node) {
          for (var i = 0; i < node.children.length; i++) {
              var child = node.children[i];
              var childBBox = node.leaf ? this.toBBox(child) : child;

              if (intersects(bbox, childBBox)) {
                  if (node.leaf || contains(bbox, childBBox)) { return true; }
                  nodesToSearch.push(child);
              }
          }
          node = nodesToSearch.pop();
      }

      return false;
  };

  RBush.prototype.load = function load (data) {
      if (!(data && data.length)) { return this; }

      if (data.length < this._minEntries) {
          for (var i = 0; i < data.length; i++) {
              this.insert(data[i]);
          }
          return this;
      }

      // recursively build the tree with the given data from scratch using OMT algorithm
      var node = this._build(data.slice(), 0, data.length - 1, 0);

      if (!this.data.children.length) {
          // save as is if tree is empty
          this.data = node;

      } else if (this.data.height === node.height) {
          // split root if trees have the same height
          this._splitRoot(this.data, node);

      } else {
          if (this.data.height < node.height) {
              // swap trees if inserted one is bigger
              var tmpNode = this.data;
              this.data = node;
              node = tmpNode;
          }

          // insert the small tree into the large tree at appropriate level
          this._insert(node, this.data.height - node.height - 1, true);
      }

      return this;
  };

  RBush.prototype.insert = function insert (item) {
      if (item) { this._insert(item, this.data.height - 1); }
      return this;
  };

  RBush.prototype.clear = function clear () {
      this.data = createNode([]);
      return this;
  };

  RBush.prototype.remove = function remove (item, equalsFn) {
      if (!item) { return this; }

      var node = this.data;
      var bbox = this.toBBox(item);
      var path = [];
      var indexes = [];
      var i, parent, goingUp;

      // depth-first iterative tree traversal
      while (node || path.length) {

          if (!node) { // go up
              node = path.pop();
              parent = path[path.length - 1];
              i = indexes.pop();
              goingUp = true;
          }

          if (node.leaf) { // check current node
              var index = findItem(item, node.children, equalsFn);

              if (index !== -1) {
                  // item found, remove the item and condense tree upwards
                  node.children.splice(index, 1);
                  path.push(node);
                  this._condense(path);
                  return this;
              }
          }

          if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
              path.push(node);
              indexes.push(i);
              i = 0;
              parent = node;
              node = node.children[0];

          } else if (parent) { // go right
              i++;
              node = parent.children[i];
              goingUp = false;

          } else { node = null; } // nothing found
      }

      return this;
  };

  RBush.prototype.toBBox = function toBBox (item) { return item; };

  RBush.prototype.compareMinX = function compareMinX (a, b) { return a.minX - b.minX; };
  RBush.prototype.compareMinY = function compareMinY (a, b) { return a.minY - b.minY; };

  RBush.prototype.toJSON = function toJSON () { return this.data; };

  RBush.prototype.fromJSON = function fromJSON (data) {
      this.data = data;
      return this;
  };

  RBush.prototype._all = function _all (node, result) {
      var nodesToSearch = [];
      while (node) {
          if (node.leaf) { result.push.apply(result, node.children); }
          else { nodesToSearch.push.apply(nodesToSearch, node.children); }

          node = nodesToSearch.pop();
      }
      return result;
  };

  RBush.prototype._build = function _build (items, left, right, height) {

      var N = right - left + 1;
      var M = this._maxEntries;
      var node;

      if (N <= M) {
          // reached leaf level; return leaf
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
      }

      if (!height) {
          // target height of the bulk-loaded tree
          height = Math.ceil(Math.log(N) / Math.log(M));

          // target number of root entries to maximize storage utilization
          M = Math.ceil(N / Math.pow(M, height - 1));
      }

      node = createNode([]);
      node.leaf = false;
      node.height = height;

      // split the items into M mostly square tiles

      var N2 = Math.ceil(N / M);
      var N1 = N2 * Math.ceil(Math.sqrt(M));

      multiSelect(items, left, right, N1, this.compareMinX);

      for (var i = left; i <= right; i += N1) {

          var right2 = Math.min(i + N1 - 1, right);

          multiSelect(items, i, right2, N2, this.compareMinY);

          for (var j = i; j <= right2; j += N2) {

              var right3 = Math.min(j + N2 - 1, right2);

              // pack each entry recursively
              node.children.push(this._build(items, j, right3, height - 1));
          }
      }

      calcBBox(node, this.toBBox);

      return node;
  };

  RBush.prototype._chooseSubtree = function _chooseSubtree (bbox, node, level, path) {
      while (true) {
          path.push(node);

          if (node.leaf || path.length - 1 === level) { break; }

          var minArea = Infinity;
          var minEnlargement = Infinity;
          var targetNode = (void 0);

          for (var i = 0; i < node.children.length; i++) {
              var child = node.children[i];
              var area = bboxArea(child);
              var enlargement = enlargedArea(bbox, child) - area;

              // choose entry with the least area enlargement
              if (enlargement < minEnlargement) {
                  minEnlargement = enlargement;
                  minArea = area < minArea ? area : minArea;
                  targetNode = child;

              } else if (enlargement === minEnlargement) {
                  // otherwise choose one with the smallest area
                  if (area < minArea) {
                      minArea = area;
                      targetNode = child;
                  }
              }
          }

          node = targetNode || node.children[0];
      }

      return node;
  };

  RBush.prototype._insert = function _insert (item, level, isNode) {
      var bbox = isNode ? item : this.toBBox(item);
      var insertPath = [];

      // find the best node for accommodating the item, saving all nodes along the path too
      var node = this._chooseSubtree(bbox, this.data, level, insertPath);

      // put the item into the node
      node.children.push(item);
      extend(node, bbox);

      // split on node overflow; propagate upwards if necessary
      while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
              this._split(insertPath, level);
              level--;
          } else { break; }
      }

      // adjust bboxes along the insertion path
      this._adjustParentBBoxes(bbox, insertPath, level);
  };

  // split overflowed node into two
  RBush.prototype._split = function _split (insertPath, level) {
      var node = insertPath[level];
      var M = node.children.length;
      var m = this._minEntries;

      this._chooseSplitAxis(node, m, M);

      var splitIndex = this._chooseSplitIndex(node, m, M);

      var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
      newNode.height = node.height;
      newNode.leaf = node.leaf;

      calcBBox(node, this.toBBox);
      calcBBox(newNode, this.toBBox);

      if (level) { insertPath[level - 1].children.push(newNode); }
      else { this._splitRoot(node, newNode); }
  };

  RBush.prototype._splitRoot = function _splitRoot (node, newNode) {
      // split root node
      this.data = createNode([node, newNode]);
      this.data.height = node.height + 1;
      this.data.leaf = false;
      calcBBox(this.data, this.toBBox);
  };

  RBush.prototype._chooseSplitIndex = function _chooseSplitIndex (node, m, M) {
      var index;
      var minOverlap = Infinity;
      var minArea = Infinity;

      for (var i = m; i <= M - m; i++) {
          var bbox1 = distBBox(node, 0, i, this.toBBox);
          var bbox2 = distBBox(node, i, M, this.toBBox);

          var overlap = intersectionArea(bbox1, bbox2);
          var area = bboxArea(bbox1) + bboxArea(bbox2);

          // choose distribution with minimum overlap
          if (overlap < minOverlap) {
              minOverlap = overlap;
              index = i;

              minArea = area < minArea ? area : minArea;

          } else if (overlap === minOverlap) {
              // otherwise choose distribution with minimum area
              if (area < minArea) {
                  minArea = area;
                  index = i;
              }
          }
      }

      return index || M - m;
  };

  // sorts node children by the best axis for split
  RBush.prototype._chooseSplitAxis = function _chooseSplitAxis (node, m, M) {
      var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
      var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
      var xMargin = this._allDistMargin(node, m, M, compareMinX);
      var yMargin = this._allDistMargin(node, m, M, compareMinY);

      // if total distributions margin value is minimal for x, sort by minX,
      // otherwise it's already sorted by minY
      if (xMargin < yMargin) { node.children.sort(compareMinX); }
  };

  // total margin of all possible split distributions where each node is at least m full
  RBush.prototype._allDistMargin = function _allDistMargin (node, m, M, compare) {
      node.children.sort(compare);

      var toBBox = this.toBBox;
      var leftBBox = distBBox(node, 0, m, toBBox);
      var rightBBox = distBBox(node, M - m, M, toBBox);
      var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);

      for (var i = m; i < M - m; i++) {
          var child = node.children[i];
          extend(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
      }

      for (var i$1 = M - m - 1; i$1 >= m; i$1--) {
          var child$1 = node.children[i$1];
          extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);
          margin += bboxMargin(rightBBox);
      }

      return margin;
  };

  RBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes (bbox, path, level) {
      // adjust bboxes along the given tree path
      for (var i = level; i >= 0; i--) {
          extend(path[i], bbox);
      }
  };

  RBush.prototype._condense = function _condense (path) {
      // go through the path, removing empty nodes and updating bboxes
      for (var i = path.length - 1, siblings = (void 0); i >= 0; i--) {
          if (path[i].children.length === 0) {
              if (i > 0) {
                  siblings = path[i - 1].children;
                  siblings.splice(siblings.indexOf(path[i]), 1);

              } else { this.clear(); }

          } else { calcBBox(path[i], this.toBBox); }
      }
  };

  function findItem(item, items, equalsFn) {
      if (!equalsFn) { return items.indexOf(item); }

      for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i])) { return i; }
      }
      return -1;
  }

  // calculate node's bbox from bboxes of its children
  function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
  }

  // min bounding rectangle of node children from k to p-1
  function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode) { destNode = createNode(null); }
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;

      for (var i = k; i < p; i++) {
          var child = node.children[i];
          extend(destNode, node.leaf ? toBBox(child) : child);
      }

      return destNode;
  }

  function extend(a, b) {
      a.minX = Math.min(a.minX, b.minX);
      a.minY = Math.min(a.minY, b.minY);
      a.maxX = Math.max(a.maxX, b.maxX);
      a.maxY = Math.max(a.maxY, b.maxY);
      return a;
  }

  function compareNodeMinX(a, b) { return a.minX - b.minX; }
  function compareNodeMinY(a, b) { return a.minY - b.minY; }

  function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
  function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

  function enlargedArea(a, b) {
      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
             (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
  }

  function intersectionArea(a, b) {
      var minX = Math.max(a.minX, b.minX);
      var minY = Math.max(a.minY, b.minY);
      var maxX = Math.min(a.maxX, b.maxX);
      var maxY = Math.min(a.maxY, b.maxY);

      return Math.max(0, maxX - minX) *
             Math.max(0, maxY - minY);
  }

  function contains(a, b) {
      return a.minX <= b.minX &&
             a.minY <= b.minY &&
             b.maxX <= a.maxX &&
             b.maxY <= a.maxY;
  }

  function intersects(a, b) {
      return b.minX <= a.maxX &&
             b.minY <= a.maxY &&
             b.maxX >= a.minX &&
             b.maxY >= a.minY;
  }

  function createNode(children) {
      return {
          children: children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
      };
  }

  // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
  // combines selection algorithm with binary divide & conquer approach

  function multiSelect(arr, left, right, n, compare) {
      var stack = [left, right];

      while (stack.length) {
          right = stack.pop();
          left = stack.pop();

          if (right - left <= n) { continue; }

          var mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare);

          stack.push(left, mid, mid, right);
      }
  }

  return RBush;

  }));
  });

  /**
   * @module ol/geom/flat/textpath
   */
  /**
   * @param {Array<number>} flatCoordinates Path to put text on.
   * @param {number} offset Start offset of the `flatCoordinates`.
   * @param {number} end End offset of the `flatCoordinates`.
   * @param {number} stride Stride.
   * @param {string} text Text to place on the path.
   * @param {number} startM m along the path where the text starts.
   * @param {number} maxAngle Max angle between adjacent chars in radians.
   * @param {number} scale The product of the text scale and the device pixel ratio.
   * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
   * @param {string} font The font.
   * @param {Object<string, number>} cache A cache of measured widths.
   * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.
   * @return {Array<Array<*>>} The result array (or null if `maxAngle` was
   * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
   */
  function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {
      var result = [];
      // Keep text upright
      var reverse;
      if (rotation) {
          var rotatedCoordinates = rotate$2(flatCoordinates, offset, end, stride, rotation, [flatCoordinates[offset], flatCoordinates[offset + 1]]);
          reverse =
              rotatedCoordinates[0] >
                  rotatedCoordinates[rotatedCoordinates.length - stride];
      }
      else {
          reverse = flatCoordinates[offset] > flatCoordinates[end - stride];
      }
      var numChars = text.length;
      var x1 = flatCoordinates[offset];
      var y1 = flatCoordinates[offset + 1];
      offset += stride;
      var x2 = flatCoordinates[offset];
      var y2 = flatCoordinates[offset + 1];
      var segmentM = 0;
      var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      var angleChanged = false;
      var index, previousAngle;
      for (var i = 0; i < numChars; ++i) {
          index = reverse ? numChars - i - 1 : i;
          var char = text[index];
          var charLength = scale * measureAndCacheTextWidth(font, char, cache);
          var charM = startM + charLength / 2;
          while (offset < end - stride && segmentM + segmentLength < charM) {
              x1 = x2;
              y1 = y2;
              offset += stride;
              x2 = flatCoordinates[offset];
              y2 = flatCoordinates[offset + 1];
              segmentM += segmentLength;
              segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
          }
          var segmentPos = charM - segmentM;
          var angle = Math.atan2(y2 - y1, x2 - x1);
          if (reverse) {
              angle += angle > 0 ? -Math.PI : Math.PI;
          }
          if (previousAngle !== undefined) {
              var delta = angle - previousAngle;
              angleChanged = angleChanged || delta !== 0;
              delta +=
                  delta > Math.PI ? -2 * Math.PI : delta < -Math.PI ? 2 * Math.PI : 0;
              if (Math.abs(delta) > maxAngle) {
                  return null;
              }
          }
          previousAngle = angle;
          var interpolate = segmentPos / segmentLength;
          var x = lerp(x1, x2, interpolate);
          var y = lerp(y1, y2, interpolate);
          result[index] = [x, y, charLength / 2, angle, char];
          startM += charLength;
      }
      return angleChanged
          ? result
          : [[result[0][0], result[0][1], result[0][2], result[0][3], text]];
  }

  /**
   * @module ol/render/canvas/Executor
   */
  /**
   * @typedef {Object} SerializableInstructions
   * @property {Array<*>} instructions The rendering instructions.
   * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
   * @property {Array<number>} coordinates The array of all coordinates.
   * @property {!Object<string, import("../canvas.js").TextState>} textStates The text states (decluttering).
   * @property {!Object<string, import("../canvas.js").FillState>} fillStates The fill states (decluttering).
   * @property {!Object<string, import("../canvas.js").StrokeState>} strokeStates The stroke states (decluttering).
   */
  /**
   * @type {import("../../extent.js").Extent}
   */
  var tmpExtent = createEmpty();
  /**
   * @type {!import("../../transform.js").Transform}
   */
  var tmpTransform$1 = create$2();
  /** @type {import("../../coordinate.js").Coordinate} */
  var p1 = [];
  /** @type {import("../../coordinate.js").Coordinate} */
  var p2 = [];
  /** @type {import("../../coordinate.js").Coordinate} */
  var p3 = [];
  /** @type {import("../../coordinate.js").Coordinate} */
  var p4 = [];
  var Executor = /** @class */ (function () {
      /**
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} overlaps The replay can have overlapping geometries.
       * @param {SerializableInstructions} instructions The serializable instructions
       * @param {import("../../size.js").Size} renderBuffer Render buffer (width/height) in pixels.
       */
      function Executor(resolution, pixelRatio, overlaps, instructions, renderBuffer) {
          /**
           * @protected
           * @type {boolean}
           */
          this.overlaps = overlaps;
          /**
           * @protected
           * @type {number}
           */
          this.pixelRatio = pixelRatio;
          /**
           * @protected
           * @const
           * @type {number}
           */
          this.resolution = resolution;
          /**
           * @private
           * @type {boolean}
           */
          this.alignFill_;
          /**
           * @type {Array<*>}
           */
          this.declutterItems = [];
          /**
           * @protected
           * @type {Array<*>}
           */
          this.instructions = instructions.instructions;
          /**
           * @protected
           * @type {Array<number>}
           */
          this.coordinates = instructions.coordinates;
          /**
           * @private
           * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
           */
          this.coordinateCache_ = {};
          /**
           * @private
           * @type {import("../../size.js").Size}
           */
          this.renderBuffer_ = renderBuffer;
          /**
           * @private
           * @type {!import("../../transform.js").Transform}
           */
          this.renderedTransform_ = create$2();
          /**
           * @protected
           * @type {Array<*>}
           */
          this.hitDetectionInstructions = instructions.hitDetectionInstructions;
          /**
           * @private
           * @type {Array<number>}
           */
          this.pixelCoordinates_ = null;
          /**
           * @private
           * @type {number}
           */
          this.viewRotation_ = 0;
          /**
           * @type {!Object<string, import("../canvas.js").FillState>}
           */
          this.fillStates = instructions.fillStates || {};
          /**
           * @type {!Object<string, import("../canvas.js").StrokeState>}
           */
          this.strokeStates = instructions.strokeStates || {};
          /**
           * @type {!Object<string, import("../canvas.js").TextState>}
           */
          this.textStates = instructions.textStates || {};
          /**
           * @private
           * @type {Object<string, Object<string, number>>}
           */
          this.widths_ = {};
          /**
           * @private
           * @type {Object<string, import("../canvas.js").Label>}
           */
          this.labels_ = {};
      }
      /**
       * @param {string} text Text.
       * @param {string} textKey Text style key.
       * @param {string} fillKey Fill style key.
       * @param {string} strokeKey Stroke style key.
       * @return {import("../canvas.js").Label} Label.
       */
      Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {
          var key = text + textKey + fillKey + strokeKey;
          if (this.labels_[key]) {
              return this.labels_[key];
          }
          var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
          var fillState = fillKey ? this.fillStates[fillKey] : null;
          var textState = this.textStates[textKey];
          var pixelRatio = this.pixelRatio;
          var scale$$1 = [
              textState.scale[0] * pixelRatio,
              textState.scale[1] * pixelRatio,
          ];
          var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];
          var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
          var lines = text.split('\n');
          var numLines = lines.length;
          var widths = [];
          var width = measureTextWidths(textState.font, lines, widths);
          var lineHeight = measureTextHeight(textState.font);
          var height = lineHeight * numLines;
          var renderWidth = width + strokeWidth;
          var contextInstructions = [];
          // make canvas 2 pixels wider to account for italic text width measurement errors
          var w = (renderWidth + 2) * scale$$1[0];
          var h = (height + strokeWidth) * scale$$1[1];
          /** @type {import("../canvas.js").Label} */
          var label = {
              width: w < 0 ? Math.floor(w) : Math.ceil(w),
              height: h < 0 ? Math.floor(h) : Math.ceil(h),
              contextInstructions: contextInstructions,
          };
          if (scale$$1[0] != 1 || scale$$1[1] != 1) {
              contextInstructions.push('scale', scale$$1);
          }
          contextInstructions.push('font', textState.font);
          if (strokeKey) {
              contextInstructions.push('strokeStyle', strokeState.strokeStyle);
              contextInstructions.push('lineWidth', strokeWidth);
              contextInstructions.push('lineCap', strokeState.lineCap);
              contextInstructions.push('lineJoin', strokeState.lineJoin);
              contextInstructions.push('miterLimit', strokeState.miterLimit);
              // eslint-disable-next-line
              var Context = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;
              if (Context.prototype.setLineDash) {
                  contextInstructions.push('setLineDash', [strokeState.lineDash]);
                  contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);
              }
          }
          if (fillKey) {
              contextInstructions.push('fillStyle', fillState.fillStyle);
          }
          contextInstructions.push('textBaseline', 'middle');
          contextInstructions.push('textAlign', 'center');
          var leftRight = 0.5 - align;
          var x = align * renderWidth + leftRight * strokeWidth;
          var i;
          if (strokeKey) {
              for (i = 0; i < numLines; ++i) {
                  contextInstructions.push('strokeText', [
                      lines[i],
                      x + leftRight * widths[i],
                      0.5 * (strokeWidth + lineHeight) + i * lineHeight,
                  ]);
              }
          }
          if (fillKey) {
              for (i = 0; i < numLines; ++i) {
                  contextInstructions.push('fillText', [
                      lines[i],
                      x + leftRight * widths[i],
                      0.5 * (strokeWidth + lineHeight) + i * lineHeight,
                  ]);
              }
          }
          this.labels_[key] = label;
          return label;
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
       * @param {Array<*>} fillInstruction Fill instruction.
       * @param {Array<*>} strokeInstruction Stroke instruction.
       * @param {boolean} declutter Declutter.
       */
      Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction$$1, strokeInstruction$$1, declutter) {
          context.beginPath();
          context.moveTo.apply(context, p1);
          context.lineTo.apply(context, p2);
          context.lineTo.apply(context, p3);
          context.lineTo.apply(context, p4);
          context.lineTo.apply(context, p1);
          if (fillInstruction$$1) {
              this.alignFill_ = /** @type {boolean} */ (fillInstruction$$1[2]);
              if (declutter) {
                  context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */ (fillInstruction$$1[1]);
              }
              this.fill_(context);
          }
          if (strokeInstruction$$1) {
              this.setStrokeStyle_(context, 
              /** @type {Array<*>} */ (strokeInstruction$$1));
              context.stroke();
          }
      };
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
       * @param {number} anchorX Anchor X.
       * @param {number} anchorY Anchor Y.
       * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
       * @param {number} height Height.
       * @param {number} opacity Opacity.
       * @param {number} originX Origin X.
       * @param {number} originY Origin Y.
       * @param {number} rotation Rotation.
       * @param {import("../../size.js").Size} scale Scale.
       * @param {boolean} snapToPixel Snap to pixel.
       * @param {number} width Width.
       * @param {Array<number>} padding Padding.
       * @param {Array<*>} fillInstruction Fill instruction.
       * @param {Array<*>} strokeInstruction Stroke instruction.
       * @return {boolean} The image or label was rendered.
       */
      Executor.prototype.replayImageOrLabel_ = function (context, contextScale, x, y, imageOrLabel, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale$$1, snapToPixel, width, padding, fillInstruction$$1, strokeInstruction$$1) {
          var fillStroke = fillInstruction$$1 || strokeInstruction$$1;
          anchorX *= scale$$1[0];
          anchorY *= scale$$1[1];
          x -= anchorX;
          y -= anchorY;
          var w = width + originX > imageOrLabel.width
              ? imageOrLabel.width - originX
              : width;
          var h = height + originY > imageOrLabel.height
              ? imageOrLabel.height - originY
              : height;
          var boxW = padding[3] + w * scale$$1[0] + padding[1];
          var boxH = padding[0] + h * scale$$1[1] + padding[2];
          var boxX = x - padding[3];
          var boxY = y - padding[0];
          if (fillStroke || rotation !== 0) {
              p1[0] = boxX;
              p4[0] = boxX;
              p1[1] = boxY;
              p2[1] = boxY;
              p2[0] = boxX + boxW;
              p3[0] = p2[0];
              p3[1] = boxY + boxH;
              p4[1] = p3[1];
          }
          var transform = null;
          if (rotation !== 0) {
              var centerX = x + anchorX;
              var centerY = y + anchorY;
              transform = compose(tmpTransform$1, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
              apply$1(tmpTransform$1, p1);
              apply$1(tmpTransform$1, p2);
              apply$1(tmpTransform$1, p3);
              apply$1(tmpTransform$1, p4);
              createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
          }
          else {
              createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);
          }
          var renderBufferX = 0;
          var renderBufferY = 0;
          if (declutterGroup) {
              var renderBuffer = this.renderBuffer_;
              renderBuffer[0] = Math.max(renderBuffer[0], getWidth(tmpExtent));
              renderBufferX = renderBuffer[0];
              renderBuffer[1] = Math.max(renderBuffer[1], getHeight(tmpExtent));
              renderBufferY = renderBuffer[1];
          }
          var canvas = context.canvas;
          var strokePadding = strokeInstruction$$1
              ? (strokeInstruction$$1[2] * scale$$1[0]) / 2
              : 0;
          var intersects$$1 = tmpExtent[0] - strokePadding <=
              (canvas.width + renderBufferX) / contextScale &&
              tmpExtent[2] + strokePadding >= -renderBufferX / contextScale &&
              tmpExtent[1] - strokePadding <=
                  (canvas.height + renderBufferY) / contextScale &&
              tmpExtent[3] + strokePadding >= -renderBufferY / contextScale;
          if (snapToPixel) {
              x = Math.round(x);
              y = Math.round(y);
          }
          if (declutterGroup) {
              if (!intersects$$1 && declutterGroup[0] == 1) {
                  return false;
              }
              var declutterArgs = intersects$$1
                  ? [
                      context,
                      transform ? transform.slice(0) : null,
                      opacity,
                      imageOrLabel,
                      originX,
                      originY,
                      w,
                      h,
                      x,
                      y,
                      scale$$1,
                      tmpExtent.slice(),
                  ]
                  : null;
              if (declutterArgs) {
                  if (fillStroke) {
                      declutterArgs.push(fillInstruction$$1, strokeInstruction$$1, p1.slice(0), p2.slice(0), p3.slice(0), p4.slice(0));
                  }
                  declutterGroup.push(declutterArgs);
              }
          }
          else if (intersects$$1) {
              if (fillStroke) {
                  this.replayTextBackground_(context, p1, p2, p3, p4, 
                  /** @type {Array<*>} */ (fillInstruction$$1), 
                  /** @type {Array<*>} */ (strokeInstruction$$1), false);
              }
              drawImageOrLabel(context, transform, opacity, imageOrLabel, originX, originY, w, h, x, y, scale$$1);
          }
          return true;
      };
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       */
      Executor.prototype.fill_ = function (context) {
          if (this.alignFill_) {
              var origin_1 = apply$1(this.renderedTransform_, [0, 0]);
              var repeatSize = 512 * this.pixelRatio;
              context.save();
              context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);
              context.rotate(this.viewRotation_);
          }
          context.fill();
          if (this.alignFill_) {
              context.restore();
          }
      };
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {Array<*>} instruction Instruction.
       */
      Executor.prototype.setStrokeStyle_ = function (context, instruction) {
          context.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */ (instruction[1]);
          context.lineWidth = /** @type {number} */ (instruction[2]);
          context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);
          context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);
          context.miterLimit = /** @type {number} */ (instruction[5]);
          if (context.setLineDash) {
              context.lineDashOffset = /** @type {number} */ (instruction[7]);
              context.setLineDash(/** @type {Array<number>} */ (instruction[6]));
          }
      };
      /**
       * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} opacity Layer opacity.
       * @param {?} declutterTree Declutter tree.
       * @return {?} Declutter tree.
       */
      Executor.prototype.renderDeclutter = function (declutterGroup, feature, opacity, declutterTree) {
          /** @type {Array<import("../../structs/RBush.js").Entry>} */
          var boxes = [];
          for (var i = 1, ii = declutterGroup.length; i < ii; ++i) {
              var declutterData = declutterGroup[i];
              var box = declutterData[11];
              boxes.push({
                  minX: box[0],
                  minY: box[1],
                  maxX: box[2],
                  maxY: box[3],
                  value: feature,
              });
          }
          if (!declutterTree) {
              declutterTree = new rbush(9);
          }
          var collides = false;
          for (var i = 0, ii = boxes.length; i < ii; ++i) {
              if (declutterTree.collides(boxes[i])) {
                  collides = true;
                  break;
              }
          }
          if (!collides) {
              declutterTree.load(boxes);
              for (var j = 1, jj = declutterGroup.length; j < jj; ++j) {
                  var declutterData = /** @type {Array} */ (declutterGroup[j]);
                  var context = declutterData[0];
                  var currentAlpha = context.globalAlpha;
                  if (currentAlpha !== opacity) {
                      context.globalAlpha = opacity;
                  }
                  if (declutterData.length > 12) {
                      this.replayTextBackground_(declutterData[0], declutterData[14], declutterData[15], declutterData[16], declutterData[17], declutterData[12], declutterData[13], true);
                  }
                  drawImageOrLabel.apply(undefined, declutterData);
                  if (currentAlpha !== opacity) {
                      context.globalAlpha = currentAlpha;
                  }
              }
          }
          declutterGroup.length = 1;
          return declutterTree;
      };
      /**
       * @private
       * @param {string} text The text to draw.
       * @param {string} textKey The key of the text state.
       * @param {string} strokeKey The key for the stroke state.
       * @param {string} fillKey The key for the fill state.
       * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
       */
      Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {
          var textState = this.textStates[textKey];
          var label = this.createLabel(text, textKey, fillKey, strokeKey);
          var strokeState = this.strokeStates[strokeKey];
          var pixelRatio = this.pixelRatio;
          var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];
          var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
          var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
          // Remove the 2 pixels we added in createLabel() for the anchor
          var width = label.width / pixelRatio - 2 * textState.scale[0];
          var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
          var anchorY = (baseline * label.height) / pixelRatio +
              2 * (0.5 - baseline) * strokeWidth;
          return {
              label: label,
              anchorX: anchorX,
              anchorY: anchorY,
          };
      };
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {Array<*>} instructions Instructions array.
       * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
       * @param {function(import("../../Feature.js").FeatureLike): T|undefined} featureCallback Feature callback.
       * @param {import("../../extent.js").Extent=} opt_hitExtent Only check features that intersect this
       *     extent.
       * @return {T|undefined} Callback result.
       * @template T
       */
      Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, featureCallback, opt_hitExtent) {
          this.declutterItems.length = 0;
          /** @type {Array<number>} */
          var pixelCoordinates;
          if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {
              pixelCoordinates = this.pixelCoordinates_;
          }
          else {
              if (!this.pixelCoordinates_) {
                  this.pixelCoordinates_ = [];
              }
              pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
              setFromArray(this.renderedTransform_, transform);
          }
          var i = 0; // instruction index
          var ii = instructions.length; // end of instructions
          var d = 0; // data index
          var dd; // end of per-instruction data
          var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, declutterGroups, image, text, textKey;
          var strokeKey, fillKey;
          var pendingFill = 0;
          var pendingStroke = 0;
          var lastFillInstruction = null;
          var lastStrokeInstruction = null;
          var coordinateCache = this.coordinateCache_;
          var viewRotation = this.viewRotation_;
          var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;
          var state = /** @type {import("../../render.js").State} */ ({
              context: context,
              pixelRatio: this.pixelRatio,
              resolution: this.resolution,
              rotation: viewRotation,
          });
          // When the batch size gets too big, performance decreases. 200 is a good
          // balance between batch size and number of fill/stroke instructions.
          var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
          var /** @type {import("../../Feature.js").FeatureLike} */ feature;
          var x, y;
          while (i < ii) {
              var instruction = instructions[i];
              var type = /** @type {import("./Instruction.js").default} */ (instruction[0]);
              switch (type) {
                  case Instruction.BEGIN_GEOMETRY:
                      feature = /** @type {import("../../Feature.js").FeatureLike} */ (instruction[1]);
                      if (!feature.getGeometry()) {
                          i = /** @type {number} */ (instruction[2]);
                      }
                      else if (opt_hitExtent !== undefined &&
                          !intersects(opt_hitExtent, instruction[3])) {
                          i = /** @type {number} */ (instruction[2]) + 1;
                      }
                      else {
                          ++i;
                      }
                      break;
                  case Instruction.BEGIN_PATH:
                      if (pendingFill > batchSize) {
                          this.fill_(context);
                          pendingFill = 0;
                      }
                      if (pendingStroke > batchSize) {
                          context.stroke();
                          pendingStroke = 0;
                      }
                      if (!pendingFill && !pendingStroke) {
                          context.beginPath();
                          prevX = NaN;
                          prevY = NaN;
                      }
                      ++i;
                      break;
                  case Instruction.CIRCLE:
                      d = /** @type {number} */ (instruction[1]);
                      var x1 = pixelCoordinates[d];
                      var y1 = pixelCoordinates[d + 1];
                      var x2 = pixelCoordinates[d + 2];
                      var y2 = pixelCoordinates[d + 3];
                      var dx = x2 - x1;
                      var dy = y2 - y1;
                      var r = Math.sqrt(dx * dx + dy * dy);
                      context.moveTo(x1 + r, y1);
                      context.arc(x1, y1, r, 0, 2 * Math.PI, true);
                      ++i;
                      break;
                  case Instruction.CLOSE_PATH:
                      context.closePath();
                      ++i;
                      break;
                  case Instruction.CUSTOM:
                      d = /** @type {number} */ (instruction[1]);
                      dd = instruction[2];
                      var geometry = /** @type {import("../../geom/SimpleGeometry.js").default} */ (instruction[3]);
                      var renderer = instruction[4];
                      var fn = instruction.length == 6 ? instruction[5] : undefined;
                      state.geometry = geometry;
                      state.feature = feature;
                      if (!(i in coordinateCache)) {
                          coordinateCache[i] = [];
                      }
                      var coords = coordinateCache[i];
                      if (fn) {
                          fn(pixelCoordinates, d, dd, 2, coords);
                      }
                      else {
                          coords[0] = pixelCoordinates[d];
                          coords[1] = pixelCoordinates[d + 1];
                          coords.length = 2;
                      }
                      renderer(coords, state);
                      ++i;
                      break;
                  case Instruction.DRAW_IMAGE:
                      d = /** @type {number} */ (instruction[1]);
                      dd = /** @type {number} */ (instruction[2]);
                      image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (instruction[3]);
                      // Remaining arguments in DRAW_IMAGE are in alphabetical order
                      anchorX = /** @type {number} */ (instruction[4]);
                      anchorY = /** @type {number} */ (instruction[5]);
                      declutterGroups = featureCallback ? null : instruction[6];
                      var height = /** @type {number} */ (instruction[7]);
                      var opacity = /** @type {number} */ (instruction[8]);
                      var originX = /** @type {number} */ (instruction[9]);
                      var originY = /** @type {number} */ (instruction[10]);
                      var rotateWithView = /** @type {boolean} */ (instruction[11]);
                      var rotation = /** @type {number} */ (instruction[12]);
                      var scale$$1 = /** @type {import("../../size.js").Size} */ (instruction[13]);
                      var width = /** @type {number} */ (instruction[14]);
                      if (!image && instruction.length >= 19) {
                          // create label images
                          text = /** @type {string} */ (instruction[18]);
                          textKey = /** @type {string} */ (instruction[19]);
                          strokeKey = /** @type {string} */ (instruction[20]);
                          fillKey = /** @type {string} */ (instruction[21]);
                          var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
                          image = labelWithAnchor.label;
                          instruction[3] = image;
                          var textOffsetX = /** @type {number} */ (instruction[22]);
                          anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
                          instruction[4] = anchorX;
                          var textOffsetY = /** @type {number} */ (instruction[23]);
                          anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
                          instruction[5] = anchorY;
                          height = image.height;
                          instruction[7] = height;
                          width = image.width;
                          instruction[14] = width;
                      }
                      var geometryWidths = void 0;
                      if (instruction.length > 24) {
                          geometryWidths = /** @type {number} */ (instruction[24]);
                      }
                      var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;
                      if (instruction.length > 16) {
                          padding = /** @type {Array<number>} */ (instruction[15]);
                          backgroundFill = /** @type {boolean} */ (instruction[16]);
                          backgroundStroke = /** @type {boolean} */ (instruction[17]);
                      }
                      else {
                          padding = defaultPadding;
                          backgroundFill = false;
                          backgroundStroke = false;
                      }
                      if (rotateWithView && viewRotationFromTransform) {
                          // Canvas is expected to be rotated to reverse view rotation.
                          rotation += viewRotation;
                      }
                      else if (!rotateWithView && !viewRotationFromTransform) {
                          // Canvas is not rotated, images need to be rotated back to be north-up.
                          rotation -= viewRotation;
                      }
                      var widthIndex = 0;
                      var declutterGroupIndex = 0;
                      for (; d < dd; d += 2) {
                          if (geometryWidths &&
                              geometryWidths[widthIndex++] < width / this.pixelRatio) {
                              continue;
                          }
                          if (declutterGroups) {
                              var index = Math.floor(declutterGroupIndex);
                              declutterGroup =
                                  declutterGroups.length < index + 1
                                      ? [declutterGroups[0][0]]
                                      : declutterGroups[index];
                          }
                          var rendered = this.replayImageOrLabel_(context, contextScale, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale$$1, snapToPixel, width, padding, backgroundFill
                              ? /** @type {Array<*>} */ (lastFillInstruction)
                              : null, backgroundStroke
                              ? /** @type {Array<*>} */ (lastStrokeInstruction)
                              : null);
                          if (rendered &&
                              declutterGroup &&
                              declutterGroups[declutterGroups.length - 1] !== declutterGroup) {
                              declutterGroups.push(declutterGroup);
                          }
                          if (declutterGroup) {
                              if (declutterGroup.length - 1 === declutterGroup[0]) {
                                  this.declutterItems.push(this, declutterGroup, feature);
                              }
                              declutterGroupIndex += 1 / declutterGroup[0];
                          }
                      }
                      ++i;
                      break;
                  case Instruction.DRAW_CHARS:
                      var begin = /** @type {number} */ (instruction[1]);
                      var end = /** @type {number} */ (instruction[2]);
                      var baseline = /** @type {number} */ (instruction[3]);
                      declutterGroup = featureCallback ? null : instruction[4];
                      var overflow = /** @type {number} */ (instruction[5]);
                      fillKey = /** @type {string} */ (instruction[6]);
                      var maxAngle = /** @type {number} */ (instruction[7]);
                      var measurePixelRatio = /** @type {number} */ (instruction[8]);
                      var offsetY = /** @type {number} */ (instruction[9]);
                      strokeKey = /** @type {string} */ (instruction[10]);
                      var strokeWidth = /** @type {number} */ (instruction[11]);
                      text = /** @type {string} */ (instruction[12]);
                      textKey = /** @type {string} */ (instruction[13]);
                      var pixelRatioScale = [
                          /** @type {number} */ (instruction[14]),
                          /** @type {number} */ (instruction[14]),
                      ];
                      var textState = this.textStates[textKey];
                      var font = textState.font;
                      var textScale = [
                          textState.scale[0] * measurePixelRatio,
                          textState.scale[1] * measurePixelRatio,
                      ];
                      var cachedWidths = void 0;
                      if (font in this.widths_) {
                          cachedWidths = this.widths_[font];
                      }
                      else {
                          cachedWidths = {};
                          this.widths_[font] = cachedWidths;
                      }
                      var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
                      var textLength = Math.abs(textScale[0]) *
                          measureAndCacheTextWidth(font, text, cachedWidths);
                      if (overflow || textLength <= pathLength) {
                          var textAlign = this.textStates[textKey].textAlign;
                          var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];
                          var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);
                          if (parts) {
                              var rendered = false;
                              var c = void 0, cc = void 0, chars = void 0, label = void 0, part = void 0;
                              if (strokeKey) {
                                  for (c = 0, cc = parts.length; c < cc; ++c) {
                                      part = parts[c]; // x, y, anchorX, rotation, chunk
                                      chars = /** @type {string} */ (part[4]);
                                      label = this.createLabel(chars, textKey, '', strokeKey);
                                      anchorX = /** @type {number} */ (part[2]) + strokeWidth;
                                      anchorY =
                                          baseline * label.height +
                                              ((0.5 - baseline) * 2 * strokeWidth * textScale[1]) /
                                                  textScale[0] -
                                              offsetY;
                                      rendered =
                                          this.replayImageOrLabel_(context, contextScale, 
                                          /** @type {number} */ (part[0]), 
                                          /** @type {number} */ (part[1]), label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, 
                                          /** @type {number} */ (part[3]), pixelRatioScale, false, label.width, defaultPadding, null, null) || rendered;
                                  }
                              }
                              if (fillKey) {
                                  for (c = 0, cc = parts.length; c < cc; ++c) {
                                      part = parts[c]; // x, y, anchorX, rotation, chunk
                                      chars = /** @type {string} */ (part[4]);
                                      label = this.createLabel(chars, textKey, fillKey, '');
                                      anchorX = /** @type {number} */ (part[2]);
                                      anchorY = baseline * label.height - offsetY;
                                      rendered =
                                          this.replayImageOrLabel_(context, contextScale, 
                                          /** @type {number} */ (part[0]), 
                                          /** @type {number} */ (part[1]), label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, 
                                          /** @type {number} */ (part[3]), pixelRatioScale, false, label.width, defaultPadding, null, null) || rendered;
                                  }
                              }
                              if (rendered) {
                                  this.declutterItems.push(this, declutterGroup, feature);
                              }
                          }
                      }
                      ++i;
                      break;
                  case Instruction.END_GEOMETRY:
                      if (featureCallback !== undefined) {
                          feature = /** @type {import("../../Feature.js").FeatureLike} */ (instruction[1]);
                          var result = featureCallback(feature);
                          if (result) {
                              return result;
                          }
                      }
                      ++i;
                      break;
                  case Instruction.FILL:
                      if (batchSize) {
                          pendingFill++;
                      }
                      else {
                          this.fill_(context);
                      }
                      ++i;
                      break;
                  case Instruction.MOVE_TO_LINE_TO:
                      d = /** @type {number} */ (instruction[1]);
                      dd = /** @type {number} */ (instruction[2]);
                      x = pixelCoordinates[d];
                      y = pixelCoordinates[d + 1];
                      roundX = (x + 0.5) | 0;
                      roundY = (y + 0.5) | 0;
                      if (roundX !== prevX || roundY !== prevY) {
                          context.moveTo(x, y);
                          prevX = roundX;
                          prevY = roundY;
                      }
                      for (d += 2; d < dd; d += 2) {
                          x = pixelCoordinates[d];
                          y = pixelCoordinates[d + 1];
                          roundX = (x + 0.5) | 0;
                          roundY = (y + 0.5) | 0;
                          if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                              context.lineTo(x, y);
                              prevX = roundX;
                              prevY = roundY;
                          }
                      }
                      ++i;
                      break;
                  case Instruction.SET_FILL_STYLE:
                      lastFillInstruction = instruction;
                      this.alignFill_ = instruction[2];
                      if (pendingFill) {
                          this.fill_(context);
                          pendingFill = 0;
                          if (pendingStroke) {
                              context.stroke();
                              pendingStroke = 0;
                          }
                      }
                      context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */ (instruction[1]);
                      ++i;
                      break;
                  case Instruction.SET_STROKE_STYLE:
                      lastStrokeInstruction = instruction;
                      if (pendingStroke) {
                          context.stroke();
                          pendingStroke = 0;
                      }
                      this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));
                      ++i;
                      break;
                  case Instruction.STROKE:
                      if (batchSize) {
                          pendingStroke++;
                      }
                      else {
                          context.stroke();
                      }
                      ++i;
                      break;
                  default:
                      ++i; // consume the instruction anyway, to avoid an infinite loop
                      break;
              }
          }
          if (pendingFill) {
              this.fill_(context);
          }
          if (pendingStroke) {
              context.stroke();
          }
          return undefined;
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
       */
      Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel) {
          this.viewRotation_ = viewRotation;
          this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined);
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {function(import("../../Feature.js").FeatureLike): T=} opt_featureCallback
       *     Feature callback.
       * @param {import("../../extent.js").Extent=} opt_hitExtent Only check features that intersect this
       *     extent.
       * @return {T|undefined} Callback result.
       * @template T
       */
      Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {
          this.viewRotation_ = viewRotation;
          return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);
      };
      return Executor;
  }());

  /**
   * @module ol/render/canvas/ExecutorGroup
   */
  /**
   * @const
   * @type {Array<import("./BuilderType.js").default>}
   */
  var ORDER = [
      BuilderType.POLYGON,
      BuilderType.CIRCLE,
      BuilderType.LINE_STRING,
      BuilderType.IMAGE,
      BuilderType.TEXT,
      BuilderType.DEFAULT,
  ];
  var ExecutorGroup = /** @class */ (function () {
      /**
       * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
       * `maxExtent` was set on the Buillder for this executor group, the same `maxExtent`
       * should be set here, unless the target context does not exceet that extent (which
       * can be the case when rendering to tiles).
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} overlaps The executor group can have overlapping geometries.
       * @param {!Object<string, !Object<import("./BuilderType.js").default, import("./Builder.js").SerializableInstructions>>} allInstructions
       * The serializable instructions.
       * @param {number=} opt_renderBuffer Optional rendering buffer.
       */
      function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {
          /**
           * @private
           * @type {import("../../extent.js").Extent}
           */
          this.maxExtent_ = maxExtent;
          /**
           * @private
           * @type {boolean}
           */
          this.overlaps_ = overlaps;
          /**
           * @private
           * @type {number}
           */
          this.pixelRatio_ = pixelRatio;
          /**
           * @private
           * @type {number}
           */
          this.resolution_ = resolution;
          /**
           * @private
           * @type {number|undefined}
           */
          this.renderBuffer_ = opt_renderBuffer;
          /**
           * @private
           * @type {!Object<string, !Object<import("./BuilderType.js").default, import("./Executor").default>>}
           */
          this.executorsByZIndex_ = {};
          /**
           * @private
           * @type {CanvasRenderingContext2D}
           */
          this.hitDetectionContext_ = null;
          /**
           * @private
           * @type {import("../../transform.js").Transform}
           */
          this.hitDetectionTransform_ = create$2();
          this.createExecutors_(allInstructions);
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../transform.js").Transform} transform Transform.
       */
      ExecutorGroup.prototype.clip = function (context, transform) {
          var flatClipCoords = this.getClipCoords(transform);
          context.beginPath();
          context.moveTo(flatClipCoords[0], flatClipCoords[1]);
          context.lineTo(flatClipCoords[2], flatClipCoords[3]);
          context.lineTo(flatClipCoords[4], flatClipCoords[5]);
          context.lineTo(flatClipCoords[6], flatClipCoords[7]);
          context.clip();
      };
      /**
       * Create executors and populate them using the provided instructions.
       * @private
       * @param {!Object<string, !Object<import("./BuilderType.js").default, import("./Builder.js").SerializableInstructions>>} allInstructions The serializable instructions
       */
      ExecutorGroup.prototype.createExecutors_ = function (allInstructions) {
          for (var zIndex in allInstructions) {
              var executors = this.executorsByZIndex_[zIndex];
              if (executors === undefined) {
                  executors = {};
                  this.executorsByZIndex_[zIndex] = executors;
              }
              var instructionByZindex = allInstructions[zIndex];
              var renderBuffer = [this.renderBuffer_ || 0, this.renderBuffer_ || 0];
              for (var builderType in instructionByZindex) {
                  var instructions = instructionByZindex[builderType];
                  executors[builderType] = new Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions, renderBuffer);
              }
          }
      };
      /**
       * @param {Array<import("./BuilderType.js").default>} executors Executors.
       * @return {boolean} Has executors of the provided types.
       */
      ExecutorGroup.prototype.hasExecutors = function (executors) {
          for (var zIndex in this.executorsByZIndex_) {
              var candidates = this.executorsByZIndex_[zIndex];
              for (var i = 0, ii = executors.length; i < ii; ++i) {
                  if (executors[i] in candidates) {
                      return true;
                  }
              }
          }
          return false;
      };
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../../Feature.js").FeatureLike): T} callback Feature callback.
       * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
       * @return {T|undefined} Callback result.
       * @template T
       */
      ExecutorGroup.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
          hitTolerance = Math.round(hitTolerance);
          var contextSize = hitTolerance * 2 + 1;
          var transform = compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
          if (!this.hitDetectionContext_) {
              this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize);
          }
          var context = this.hitDetectionContext_;
          if (context.canvas.width !== contextSize ||
              context.canvas.height !== contextSize) {
              context.canvas.width = contextSize;
              context.canvas.height = contextSize;
          }
          else {
              context.clearRect(0, 0, contextSize, contextSize);
          }
          /**
           * @type {import("../../extent.js").Extent}
           */
          var hitExtent;
          if (this.renderBuffer_ !== undefined) {
              hitExtent = createEmpty();
              extendCoordinate(hitExtent, coordinate);
              buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
          }
          var mask = getCircleArray(hitTolerance);
          var builderType;
          /**
           * @param {import("../../Feature.js").FeatureLike} feature Feature.
           * @return {?} Callback result.
           */
          function featureCallback(feature) {
              var imageData = context.getImageData(0, 0, contextSize, contextSize)
                  .data;
              for (var i_1 = 0; i_1 < contextSize; i_1++) {
                  for (var j_1 = 0; j_1 < contextSize; j_1++) {
                      if (mask[i_1][j_1]) {
                          if (imageData[(j_1 * contextSize + i_1) * 4 + 3] > 0) {
                              var result_1 = void 0;
                              if (!(declutteredFeatures &&
                                  (builderType == BuilderType.IMAGE ||
                                      builderType == BuilderType.TEXT)) ||
                                  declutteredFeatures.indexOf(feature) !== -1) {
                                  result_1 = callback(feature);
                              }
                              if (result_1) {
                                  return result_1;
                              }
                              else {
                                  context.clearRect(0, 0, contextSize, contextSize);
                                  return undefined;
                              }
                          }
                      }
                  }
              }
          }
          /** @type {Array<number>} */
          var zs = Object.keys(this.executorsByZIndex_).map(Number);
          zs.sort(numberSafeCompareFunction);
          var i, j, executors, executor, result;
          for (i = zs.length - 1; i >= 0; --i) {
              var zIndexKey = zs[i].toString();
              executors = this.executorsByZIndex_[zIndexKey];
              for (j = ORDER.length - 1; j >= 0; --j) {
                  builderType = ORDER[j];
                  executor = executors[builderType];
                  if (executor !== undefined) {
                      result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);
                      if (result) {
                          return result;
                      }
                  }
              }
          }
          return undefined;
      };
      /**
       * @param {import("../../transform.js").Transform} transform Transform.
       * @return {Array<number>} Clip coordinates.
       */
      ExecutorGroup.prototype.getClipCoords = function (transform) {
          var maxExtent = this.maxExtent_;
          if (!maxExtent) {
              return null;
          }
          var minX = maxExtent[0];
          var minY = maxExtent[1];
          var maxX = maxExtent[2];
          var maxY = maxExtent[3];
          var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
          transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
          return flatClipCoords;
      };
      /**
       * @return {boolean} Is empty.
       */
      ExecutorGroup.prototype.isEmpty = function () {
          return isEmpty(this.executorsByZIndex_);
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
       * @param {Array<import("./BuilderType.js").default>=} opt_builderTypes Ordered replay types to replay.
       *     Default is {@link module:ol/render/replay~ORDER}
       * @param {Object<string, import("../canvas.js").DeclutterGroup>=} opt_declutterReplays Declutter replays.
       */
      ExecutorGroup.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_builderTypes, opt_declutterReplays) {
          /** @type {Array<number>} */
          var zs = Object.keys(this.executorsByZIndex_).map(Number);
          zs.sort(numberSafeCompareFunction);
          // setup clipping so that the parts of over-simplified geometries are not
          // visible outside the current extent when panning
          if (this.maxExtent_) {
              context.save();
              this.clip(context, transform);
          }
          var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;
          var i, ii, j, jj, replays, replay;
          for (i = 0, ii = zs.length; i < ii; ++i) {
              var zIndexKey = zs[i].toString();
              replays = this.executorsByZIndex_[zIndexKey];
              for (j = 0, jj = builderTypes.length; j < jj; ++j) {
                  var builderType = builderTypes[j];
                  replay = replays[builderType];
                  if (replay !== undefined) {
                      if (opt_declutterReplays &&
                          (builderType == BuilderType.IMAGE ||
                              builderType == BuilderType.TEXT)) {
                          var declutter = opt_declutterReplays[zIndexKey];
                          if (!declutter) {
                              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];
                          }
                          else {
                              declutter.push(replay, transform.slice(0));
                          }
                      }
                      else {
                          replay.execute(context, contextScale, transform, viewRotation, snapToPixel);
                      }
                  }
              }
          }
          if (this.maxExtent_) {
              context.restore();
          }
      };
      return ExecutorGroup;
  }());
  /**
   * This cache is used for storing calculated pixel circles for increasing performance.
   * It is a static property to allow each Replaygroup to access it.
   * @type {Object<number, Array<Array<(boolean|undefined)>>>}
   */
  var circleArrayCache = {
      0: [[true]],
  };
  /**
   * This method fills a row in the array from the given coordinate to the
   * middle with `true`.
   * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.
   * @param {number} x X coordinate.
   * @param {number} y Y coordinate.
   */
  function fillCircleArrayRowToMiddle(array, x, y) {
      var i;
      var radius = Math.floor(array.length / 2);
      if (x >= radius) {
          for (i = radius; i < x; i++) {
              array[i][y] = true;
          }
      }
      else if (x < radius) {
          for (i = x + 1; i < radius; i++) {
              array[i][y] = true;
          }
      }
  }
  /**
   * This methods creates a circle inside a fitting array. Points inside the
   * circle are marked by true, points on the outside are undefined.
   * It uses the midpoint circle algorithm.
   * A cache is used to increase performance.
   * @param {number} radius Radius.
   * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.
   */
  function getCircleArray(radius) {
      if (circleArrayCache[radius] !== undefined) {
          return circleArrayCache[radius];
      }
      var arraySize = radius * 2 + 1;
      var arr = new Array(arraySize);
      for (var i = 0; i < arraySize; i++) {
          arr[i] = new Array(arraySize);
      }
      var x = radius;
      var y = 0;
      var error = 0;
      while (x >= y) {
          fillCircleArrayRowToMiddle(arr, radius + x, radius + y);
          fillCircleArrayRowToMiddle(arr, radius + y, radius + x);
          fillCircleArrayRowToMiddle(arr, radius - y, radius + x);
          fillCircleArrayRowToMiddle(arr, radius - x, radius + y);
          fillCircleArrayRowToMiddle(arr, radius - x, radius - y);
          fillCircleArrayRowToMiddle(arr, radius - y, radius - x);
          fillCircleArrayRowToMiddle(arr, radius + y, radius - x);
          fillCircleArrayRowToMiddle(arr, radius + x, radius - y);
          y++;
          error += 1 + 2 * y;
          if (2 * (error - x) + 1 > 0) {
              x -= 1;
              error += 1 - 2 * x;
          }
      }
      circleArrayCache[radius] = arr;
      return arr;
  }
  /**
   * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} rotation Rotation.
   * @param {number} opacity Opacity.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {Array<import("../../PluggableMap.js").DeclutterItems>} declutterItems Declutter items.
   */
  function replayDeclutter(declutterReplays, context, rotation, opacity, snapToPixel, declutterItems) {
      var zs = Object.keys(declutterReplays)
          .map(Number)
          .sort(numberSafeCompareFunction);
      for (var z = 0, zz = zs.length; z < zz; ++z) {
          var executorData = declutterReplays[zs[z].toString()];
          var currentExecutor = void 0;
          for (var i = 0, ii = executorData.length; i < ii;) {
              var executor = executorData[i++];
              var transform = executorData[i++];
              executor.execute(context, 1, transform, rotation, snapToPixel);
              if (executor !== currentExecutor && executor.declutterItems.length > 0) {
                  currentExecutor = executor;
                  declutterItems.push({
                      items: executor.declutterItems,
                      opacity: opacity,
                  });
              }
          }
      }
  }

  /**
   * @module ol/ViewHint
   */
  /**
   * @enum {number}
   */
  var ViewHint = {
      ANIMATING: 0,
      INTERACTING: 1,
  };

  /**
   * @module ol/render/canvas/Immediate
   */
  // FIXME test, especially polygons with holes and multipolygons
  // FIXME need to handle large thick features (where pixel size matters)
  // FIXME add offset and end to ol/geom/flat/transform~transform2D?
  var __extends$z = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * A concrete subclass of {@link module:ol/render/VectorContext} that implements
   * direct rendering of features and geometries to an HTML5 Canvas context.
   * Instances of this class are created internally by the library and
   * provided to application code as vectorContext member of the
   * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
   * render events emitted by layers and maps.
   */
  var CanvasImmediateRenderer = /** @class */ (function (_super) {
      __extends$z(CanvasImmediateRenderer, _super);
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../../extent.js").Extent} extent Extent.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {number=} opt_squaredTolerance Optional squared tolerance for simplification.
       * @param {import("../../proj.js").TransformFunction=} opt_userTransform Transform from user to view projection.
       */
      function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation, opt_squaredTolerance, opt_userTransform) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {CanvasRenderingContext2D}
           */
          _this.context_ = context;
          /**
           * @private
           * @type {number}
           */
          _this.pixelRatio_ = pixelRatio;
          /**
           * @private
           * @type {import("../../extent.js").Extent}
           */
          _this.extent_ = extent;
          /**
           * @private
           * @type {import("../../transform.js").Transform}
           */
          _this.transform_ = transform;
          /**
           * @private
           * @type {number}
           */
          _this.viewRotation_ = viewRotation;
          /**
           * @private
           * @type {number}
           */
          _this.squaredTolerance_ = opt_squaredTolerance;
          /**
           * @private
           * @type {import("../../proj.js").TransformFunction}
           */
          _this.userTransform_ = opt_userTransform;
          /**
           * @private
           * @type {?import("../canvas.js").FillState}
           */
          _this.contextFillState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").StrokeState}
           */
          _this.contextStrokeState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").TextState}
           */
          _this.contextTextState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").FillState}
           */
          _this.fillState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").StrokeState}
           */
          _this.strokeState_ = null;
          /**
           * @private
           * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
           */
          _this.image_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.imageAnchorX_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.imageAnchorY_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.imageHeight_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.imageOpacity_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.imageOriginX_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.imageOriginY_ = 0;
          /**
           * @private
           * @type {boolean}
           */
          _this.imageRotateWithView_ = false;
          /**
           * @private
           * @type {number}
           */
          _this.imageRotation_ = 0;
          /**
           * @private
           * @type {import("../../size.js").Size}
           */
          _this.imageScale_ = [0, 0];
          /**
           * @private
           * @type {number}
           */
          _this.imageWidth_ = 0;
          /**
           * @private
           * @type {string}
           */
          _this.text_ = '';
          /**
           * @private
           * @type {number}
           */
          _this.textOffsetX_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.textOffsetY_ = 0;
          /**
           * @private
           * @type {boolean}
           */
          _this.textRotateWithView_ = false;
          /**
           * @private
           * @type {number}
           */
          _this.textRotation_ = 0;
          /**
           * @private
           * @type {import("../../size.js").Size}
           */
          _this.textScale_ = [0, 0];
          /**
           * @private
           * @type {?import("../canvas.js").FillState}
           */
          _this.textFillState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").StrokeState}
           */
          _this.textStrokeState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").TextState}
           */
          _this.textState_ = null;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.pixelCoordinates_ = [];
          /**
           * @private
           * @type {import("../../transform.js").Transform}
           */
          _this.tmpLocalTransform_ = create$2();
          return _this;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       */
      CanvasImmediateRenderer.prototype.drawImages_ = function (flatCoordinates, offset, end, stride) {
          if (!this.image_) {
              return;
          }
          var pixelCoordinates = transform2D(flatCoordinates, offset, end, 2, this.transform_, this.pixelCoordinates_);
          var context = this.context_;
          var localTransform = this.tmpLocalTransform_;
          var alpha = context.globalAlpha;
          if (this.imageOpacity_ != 1) {
              context.globalAlpha = alpha * this.imageOpacity_;
          }
          var rotation = this.imageRotation_;
          if (this.imageRotateWithView_) {
              rotation += this.viewRotation_;
          }
          for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
              var x = pixelCoordinates[i] - this.imageAnchorX_;
              var y = pixelCoordinates[i + 1] - this.imageAnchorY_;
              if (rotation !== 0 ||
                  this.imageScale_[0] != 1 ||
                  this.imageScale_[1] != 1) {
                  var centerX = x + this.imageAnchorX_;
                  var centerY = y + this.imageAnchorY_;
                  compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
                  context.setTransform.apply(context, localTransform);
                  context.translate(centerX, centerY);
                  context.scale(this.imageScale_[0], this.imageScale_[1]);
                  context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
                  context.setTransform(1, 0, 0, 1, 0, 0);
              }
              else {
                  context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
              }
          }
          if (this.imageOpacity_ != 1) {
              context.globalAlpha = alpha;
          }
      };
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       */
      CanvasImmediateRenderer.prototype.drawText_ = function (flatCoordinates, offset, end, stride) {
          if (!this.textState_ || this.text_ === '') {
              return;
          }
          if (this.textFillState_) {
              this.setContextFillState_(this.textFillState_);
          }
          if (this.textStrokeState_) {
              this.setContextStrokeState_(this.textStrokeState_);
          }
          this.setContextTextState_(this.textState_);
          var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
          var context = this.context_;
          var rotation = this.textRotation_;
          if (this.textRotateWithView_) {
              rotation += this.viewRotation_;
          }
          for (; offset < end; offset += stride) {
              var x = pixelCoordinates[offset] + this.textOffsetX_;
              var y = pixelCoordinates[offset + 1] + this.textOffsetY_;
              if (rotation !== 0 ||
                  this.textScale_[0] != 1 ||
                  this.textScale_[1] != 1) {
                  var localTransform = compose(this.tmpLocalTransform_, x, y, 1, 1, rotation, -x, -y);
                  context.setTransform.apply(context, localTransform);
                  context.translate(x, y);
                  context.scale(this.textScale_[0], this.textScale_[1]);
                  if (this.textStrokeState_) {
                      context.strokeText(this.text_, 0, 0);
                  }
                  if (this.textFillState_) {
                      context.fillText(this.text_, 0, 0);
                  }
                  context.setTransform(1, 0, 0, 1, 0, 0);
              }
              else {
                  if (this.textStrokeState_) {
                      context.strokeText(this.text_, x, y);
                  }
                  if (this.textFillState_) {
                      context.fillText(this.text_, x, y);
                  }
              }
          }
      };
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @param {boolean} close Close.
       * @private
       * @return {number} end End.
       */
      CanvasImmediateRenderer.prototype.moveToLineTo_ = function (flatCoordinates, offset, end, stride, close) {
          var context = this.context_;
          var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
          context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
          var length = pixelCoordinates.length;
          if (close) {
              length -= 2;
          }
          for (var i = 2; i < length; i += 2) {
              context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
          }
          if (close) {
              context.closePath();
          }
          return end;
      };
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @private
       * @return {number} End.
       */
      CanvasImmediateRenderer.prototype.drawRings_ = function (flatCoordinates, offset, ends, stride) {
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
          }
          return offset;
      };
      /**
       * Render a circle geometry into the canvas.  Rendering is immediate and uses
       * the current fill and stroke styles.
       *
       * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
       * @api
       */
      CanvasImmediateRenderer.prototype.drawCircle = function (geometry) {
          if (!intersects(this.extent_, geometry.getExtent())) {
              return;
          }
          if (this.fillState_ || this.strokeState_) {
              if (this.fillState_) {
                  this.setContextFillState_(this.fillState_);
              }
              if (this.strokeState_) {
                  this.setContextStrokeState_(this.strokeState_);
              }
              var pixelCoordinates = transformGeom2D(geometry, this.transform_, this.pixelCoordinates_);
              var dx = pixelCoordinates[2] - pixelCoordinates[0];
              var dy = pixelCoordinates[3] - pixelCoordinates[1];
              var radius = Math.sqrt(dx * dx + dy * dy);
              var context = this.context_;
              context.beginPath();
              context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
              if (this.fillState_) {
                  context.fill();
              }
              if (this.strokeState_) {
                  context.stroke();
              }
          }
          if (this.text_ !== '') {
              this.drawText_(geometry.getCenter(), 0, 2, 2);
          }
      };
      /**
       * Set the rendering style.  Note that since this is an immediate rendering API,
       * any `zIndex` on the provided style will be ignored.
       *
       * @param {import("../../style/Style.js").default} style The rendering style.
       * @api
       */
      CanvasImmediateRenderer.prototype.setStyle = function (style) {
          this.setFillStrokeStyle(style.getFill(), style.getStroke());
          this.setImageStyle(style.getImage());
          this.setTextStyle(style.getText());
      };
      /**
       * @param {import("../../transform.js").Transform} transform Transform.
       */
      CanvasImmediateRenderer.prototype.setTransform = function (transform) {
          this.transform_ = transform;
      };
      /**
       * Render a geometry into the canvas.  Call
       * {@link module:ol/render/canvas/Immediate#setStyle} first to set the rendering style.
       *
       * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
       * @api
       */
      CanvasImmediateRenderer.prototype.drawGeometry = function (geometry) {
          var type = geometry.getType();
          switch (type) {
              case GeometryType.POINT:
                  this.drawPoint(
                  /** @type {import("../../geom/Point.js").default} */ (geometry));
                  break;
              case GeometryType.LINE_STRING:
                  this.drawLineString(
                  /** @type {import("../../geom/LineString.js").default} */ (geometry));
                  break;
              case GeometryType.POLYGON:
                  this.drawPolygon(
                  /** @type {import("../../geom/Polygon.js").default} */ (geometry));
                  break;
              case GeometryType.MULTI_POINT:
                  this.drawMultiPoint(
                  /** @type {import("../../geom/MultiPoint.js").default} */ (geometry));
                  break;
              case GeometryType.MULTI_LINE_STRING:
                  this.drawMultiLineString(
                  /** @type {import("../../geom/MultiLineString.js").default} */ (geometry));
                  break;
              case GeometryType.MULTI_POLYGON:
                  this.drawMultiPolygon(
                  /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry));
                  break;
              case GeometryType.GEOMETRY_COLLECTION:
                  this.drawGeometryCollection(
                  /** @type {import("../../geom/GeometryCollection.js").default} */ (geometry));
                  break;
              case GeometryType.CIRCLE:
                  this.drawCircle(
                  /** @type {import("../../geom/Circle.js").default} */ (geometry));
                  break;
              default:
          }
      };
      /**
       * Render a feature into the canvas.  Note that any `zIndex` on the provided
       * style will be ignored - features are rendered immediately in the order that
       * this method is called.  If you need `zIndex` support, you should be using an
       * {@link module:ol/layer/Vector~VectorLayer} instead.
       *
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {import("../../style/Style.js").default} style Style.
       * @api
       */
      CanvasImmediateRenderer.prototype.drawFeature = function (feature, style) {
          var geometry = style.getGeometryFunction()(feature);
          if (!geometry || !intersects(this.extent_, geometry.getExtent())) {
              return;
          }
          this.setStyle(style);
          this.drawGeometry(geometry);
      };
      /**
       * Render a GeometryCollection to the canvas.  Rendering is immediate and
       * uses the current styles appropriate for each geometry in the collection.
       *
       * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
       */
      CanvasImmediateRenderer.prototype.drawGeometryCollection = function (geometry) {
          var geometries = geometry.getGeometriesArray();
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              this.drawGeometry(geometries[i]);
          }
      };
      /**
       * Render a Point geometry into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
       */
      CanvasImmediateRenderer.prototype.drawPoint = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/Point.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          var flatCoordinates = geometry.getFlatCoordinates();
          var stride = geometry.getStride();
          if (this.image_) {
              this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
          }
          if (this.text_ !== '') {
              this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
          }
      };
      /**
       * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
       * uses the current style.
       *
       * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
       */
      CanvasImmediateRenderer.prototype.drawMultiPoint = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/MultiPoint.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          var flatCoordinates = geometry.getFlatCoordinates();
          var stride = geometry.getStride();
          if (this.image_) {
              this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
          }
          if (this.text_ !== '') {
              this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
          }
      };
      /**
       * Render a LineString into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
       */
      CanvasImmediateRenderer.prototype.drawLineString = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/LineString.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          if (!intersects(this.extent_, geometry.getExtent())) {
              return;
          }
          if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              var context = this.context_;
              var flatCoordinates = geometry.getFlatCoordinates();
              context.beginPath();
              this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
              context.stroke();
          }
          if (this.text_ !== '') {
              var flatMidpoint = geometry.getFlatMidpoint();
              this.drawText_(flatMidpoint, 0, 2, 2);
          }
      };
      /**
       * Render a MultiLineString geometry into the canvas.  Rendering is immediate
       * and uses the current style.
       *
       * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
       */
      CanvasImmediateRenderer.prototype.drawMultiLineString = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/MultiLineString.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          var geometryExtent = geometry.getExtent();
          if (!intersects(this.extent_, geometryExtent)) {
              return;
          }
          if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              var context = this.context_;
              var flatCoordinates = geometry.getFlatCoordinates();
              var offset = 0;
              var ends = /** @type {Array<number>} */ (geometry.getEnds());
              var stride = geometry.getStride();
              context.beginPath();
              for (var i = 0, ii = ends.length; i < ii; ++i) {
                  offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
              }
              context.stroke();
          }
          if (this.text_ !== '') {
              var flatMidpoints = geometry.getFlatMidpoints();
              this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
          }
      };
      /**
       * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
       */
      CanvasImmediateRenderer.prototype.drawPolygon = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/Polygon.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          if (!intersects(this.extent_, geometry.getExtent())) {
              return;
          }
          if (this.strokeState_ || this.fillState_) {
              if (this.fillState_) {
                  this.setContextFillState_(this.fillState_);
              }
              if (this.strokeState_) {
                  this.setContextStrokeState_(this.strokeState_);
              }
              var context = this.context_;
              context.beginPath();
              this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, 
              /** @type {Array<number>} */ (geometry.getEnds()), geometry.getStride());
              if (this.fillState_) {
                  context.fill();
              }
              if (this.strokeState_) {
                  context.stroke();
              }
          }
          if (this.text_ !== '') {
              var flatInteriorPoint = geometry.getFlatInteriorPoint();
              this.drawText_(flatInteriorPoint, 0, 2, 2);
          }
      };
      /**
       * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
       * uses the current style.
       * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
       */
      CanvasImmediateRenderer.prototype.drawMultiPolygon = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          if (!intersects(this.extent_, geometry.getExtent())) {
              return;
          }
          if (this.strokeState_ || this.fillState_) {
              if (this.fillState_) {
                  this.setContextFillState_(this.fillState_);
              }
              if (this.strokeState_) {
                  this.setContextStrokeState_(this.strokeState_);
              }
              var context = this.context_;
              var flatCoordinates = geometry.getOrientedFlatCoordinates();
              var offset = 0;
              var endss = geometry.getEndss();
              var stride = geometry.getStride();
              context.beginPath();
              for (var i = 0, ii = endss.length; i < ii; ++i) {
                  var ends = endss[i];
                  offset = this.drawRings_(flatCoordinates, offset, ends, stride);
              }
              if (this.fillState_) {
                  context.fill();
              }
              if (this.strokeState_) {
                  context.stroke();
              }
          }
          if (this.text_ !== '') {
              var flatInteriorPoints = geometry.getFlatInteriorPoints();
              this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
          }
      };
      /**
       * @param {import("../canvas.js").FillState} fillState Fill state.
       * @private
       */
      CanvasImmediateRenderer.prototype.setContextFillState_ = function (fillState) {
          var context = this.context_;
          var contextFillState = this.contextFillState_;
          if (!contextFillState) {
              context.fillStyle = fillState.fillStyle;
              this.contextFillState_ = {
                  fillStyle: fillState.fillStyle,
              };
          }
          else {
              if (contextFillState.fillStyle != fillState.fillStyle) {
                  contextFillState.fillStyle = fillState.fillStyle;
                  context.fillStyle = fillState.fillStyle;
              }
          }
      };
      /**
       * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
       * @private
       */
      CanvasImmediateRenderer.prototype.setContextStrokeState_ = function (strokeState) {
          var context = this.context_;
          var contextStrokeState = this.contextStrokeState_;
          if (!contextStrokeState) {
              context.lineCap = strokeState.lineCap;
              if (context.setLineDash) {
                  context.setLineDash(strokeState.lineDash);
                  context.lineDashOffset = strokeState.lineDashOffset;
              }
              context.lineJoin = strokeState.lineJoin;
              context.lineWidth = strokeState.lineWidth;
              context.miterLimit = strokeState.miterLimit;
              context.strokeStyle = strokeState.strokeStyle;
              this.contextStrokeState_ = {
                  lineCap: strokeState.lineCap,
                  lineDash: strokeState.lineDash,
                  lineDashOffset: strokeState.lineDashOffset,
                  lineJoin: strokeState.lineJoin,
                  lineWidth: strokeState.lineWidth,
                  miterLimit: strokeState.miterLimit,
                  strokeStyle: strokeState.strokeStyle,
              };
          }
          else {
              if (contextStrokeState.lineCap != strokeState.lineCap) {
                  contextStrokeState.lineCap = strokeState.lineCap;
                  context.lineCap = strokeState.lineCap;
              }
              if (context.setLineDash) {
                  if (!equals(contextStrokeState.lineDash, strokeState.lineDash)) {
                      context.setLineDash((contextStrokeState.lineDash = strokeState.lineDash));
                  }
                  if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
                      contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
                      context.lineDashOffset = strokeState.lineDashOffset;
                  }
              }
              if (contextStrokeState.lineJoin != strokeState.lineJoin) {
                  contextStrokeState.lineJoin = strokeState.lineJoin;
                  context.lineJoin = strokeState.lineJoin;
              }
              if (contextStrokeState.lineWidth != strokeState.lineWidth) {
                  contextStrokeState.lineWidth = strokeState.lineWidth;
                  context.lineWidth = strokeState.lineWidth;
              }
              if (contextStrokeState.miterLimit != strokeState.miterLimit) {
                  contextStrokeState.miterLimit = strokeState.miterLimit;
                  context.miterLimit = strokeState.miterLimit;
              }
              if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
                  contextStrokeState.strokeStyle = strokeState.strokeStyle;
                  context.strokeStyle = strokeState.strokeStyle;
              }
          }
      };
      /**
       * @param {import("../canvas.js").TextState} textState Text state.
       * @private
       */
      CanvasImmediateRenderer.prototype.setContextTextState_ = function (textState) {
          var context = this.context_;
          var contextTextState = this.contextTextState_;
          var textAlign = textState.textAlign
              ? textState.textAlign
              : defaultTextAlign;
          if (!contextTextState) {
              context.font = textState.font;
              context.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
              context.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
              this.contextTextState_ = {
                  font: textState.font,
                  textAlign: textAlign,
                  textBaseline: textState.textBaseline,
              };
          }
          else {
              if (contextTextState.font != textState.font) {
                  contextTextState.font = textState.font;
                  context.font = textState.font;
              }
              if (contextTextState.textAlign != textAlign) {
                  contextTextState.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
                  context.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
              }
              if (contextTextState.textBaseline != textState.textBaseline) {
                  contextTextState.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
                  context.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
              }
          }
      };
      /**
       * Set the fill and stroke style for subsequent draw operations.  To clear
       * either fill or stroke styles, pass null for the appropriate parameter.
       *
       * @param {import("../../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
       */
      CanvasImmediateRenderer.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
          if (!fillStyle) {
              this.fillState_ = null;
          }
          else {
              var fillStyleColor = fillStyle.getColor();
              this.fillState_ = {
                  fillStyle: asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle),
              };
          }
          if (!strokeStyle) {
              this.strokeState_ = null;
          }
          else {
              var strokeStyleColor = strokeStyle.getColor();
              var strokeStyleLineCap = strokeStyle.getLineCap();
              var strokeStyleLineDash = strokeStyle.getLineDash();
              var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
              var strokeStyleLineJoin = strokeStyle.getLineJoin();
              var strokeStyleWidth = strokeStyle.getWidth();
              var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
              this.strokeState_ = {
                  lineCap: strokeStyleLineCap !== undefined
                      ? strokeStyleLineCap
                      : defaultLineCap,
                  lineDash: strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash,
                  lineDashOffset: strokeStyleLineDashOffset
                      ? strokeStyleLineDashOffset
                      : defaultLineDashOffset,
                  lineJoin: strokeStyleLineJoin !== undefined
                      ? strokeStyleLineJoin
                      : defaultLineJoin,
                  lineWidth: this.pixelRatio_ *
                      (strokeStyleWidth !== undefined
                          ? strokeStyleWidth
                          : defaultLineWidth),
                  miterLimit: strokeStyleMiterLimit !== undefined
                      ? strokeStyleMiterLimit
                      : defaultMiterLimit,
                  strokeStyle: asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle),
              };
          }
      };
      /**
       * Set the image style for subsequent draw operations.  Pass null to remove
       * the image style.
       *
       * @param {import("../../style/Image.js").default} imageStyle Image style.
       */
      CanvasImmediateRenderer.prototype.setImageStyle = function (imageStyle) {
          if (!imageStyle) {
              this.image_ = null;
          }
          else {
              var imageSize = imageStyle.getSize();
              if (!imageSize) {
                  this.image_ = null;
              }
              else {
                  var imageAnchor = imageStyle.getAnchor();
                  // FIXME pixel ratio
                  var imageImage = imageStyle.getImage(1);
                  var imageOrigin = imageStyle.getOrigin();
                  var imageScale = imageStyle.getScaleArray();
                  this.imageAnchorX_ = imageAnchor[0];
                  this.imageAnchorY_ = imageAnchor[1];
                  this.imageHeight_ = imageSize[1];
                  this.image_ = imageImage;
                  this.imageOpacity_ = imageStyle.getOpacity();
                  this.imageOriginX_ = imageOrigin[0];
                  this.imageOriginY_ = imageOrigin[1];
                  this.imageRotateWithView_ = imageStyle.getRotateWithView();
                  this.imageRotation_ = imageStyle.getRotation();
                  this.imageScale_ = [
                      this.pixelRatio_ * imageScale[0],
                      this.pixelRatio_ * imageScale[1],
                  ];
                  this.imageWidth_ = imageSize[0];
              }
          }
      };
      /**
       * Set the text style for subsequent draw operations.  Pass null to
       * remove the text style.
       *
       * @param {import("../../style/Text.js").default} textStyle Text style.
       */
      CanvasImmediateRenderer.prototype.setTextStyle = function (textStyle) {
          if (!textStyle) {
              this.text_ = '';
          }
          else {
              var textFillStyle = textStyle.getFill();
              if (!textFillStyle) {
                  this.textFillState_ = null;
              }
              else {
                  var textFillStyleColor = textFillStyle.getColor();
                  this.textFillState_ = {
                      fillStyle: asColorLike(textFillStyleColor ? textFillStyleColor : defaultFillStyle),
                  };
              }
              var textStrokeStyle = textStyle.getStroke();
              if (!textStrokeStyle) {
                  this.textStrokeState_ = null;
              }
              else {
                  var textStrokeStyleColor = textStrokeStyle.getColor();
                  var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
                  var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
                  var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
                  var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
                  var textStrokeStyleWidth = textStrokeStyle.getWidth();
                  var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
                  this.textStrokeState_ = {
                      lineCap: textStrokeStyleLineCap !== undefined
                          ? textStrokeStyleLineCap
                          : defaultLineCap,
                      lineDash: textStrokeStyleLineDash
                          ? textStrokeStyleLineDash
                          : defaultLineDash,
                      lineDashOffset: textStrokeStyleLineDashOffset
                          ? textStrokeStyleLineDashOffset
                          : defaultLineDashOffset,
                      lineJoin: textStrokeStyleLineJoin !== undefined
                          ? textStrokeStyleLineJoin
                          : defaultLineJoin,
                      lineWidth: textStrokeStyleWidth !== undefined
                          ? textStrokeStyleWidth
                          : defaultLineWidth,
                      miterLimit: textStrokeStyleMiterLimit !== undefined
                          ? textStrokeStyleMiterLimit
                          : defaultMiterLimit,
                      strokeStyle: asColorLike(textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle),
                  };
              }
              var textFont = textStyle.getFont();
              var textOffsetX = textStyle.getOffsetX();
              var textOffsetY = textStyle.getOffsetY();
              var textRotateWithView = textStyle.getRotateWithView();
              var textRotation = textStyle.getRotation();
              var textScale = textStyle.getScaleArray();
              var textText = textStyle.getText();
              var textTextAlign = textStyle.getTextAlign();
              var textTextBaseline = textStyle.getTextBaseline();
              this.textState_ = {
                  font: textFont !== undefined ? textFont : defaultFont,
                  textAlign: textTextAlign !== undefined ? textTextAlign : defaultTextAlign,
                  textBaseline: textTextBaseline !== undefined
                      ? textTextBaseline
                      : defaultTextBaseline,
              };
              this.text_ = textText !== undefined ? textText : '';
              this.textOffsetX_ =
                  textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
              this.textOffsetY_ =
                  textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
              this.textRotateWithView_ =
                  textRotateWithView !== undefined ? textRotateWithView : false;
              this.textRotation_ = textRotation !== undefined ? textRotation : 0;
              this.textScale_ = [
                  this.pixelRatio_ * textScale[0],
                  this.pixelRatio_ * textScale[1],
              ];
          }
      };
      return CanvasImmediateRenderer;
  }(VectorContext));

  /**
   * @module ol/style/IconAnchorUnits
   */
  /**
   * Icon anchor units. One of 'fraction', 'pixels'.
   * @enum {string}
   */
  var IconAnchorUnits = {
      /**
       * Anchor is a fraction
       * @api
       */
      FRACTION: 'fraction',
      /**
       * Anchor is in pixels
       * @api
       */
      PIXELS: 'pixels',
  };

  /**
   * @module ol/style/IconOrigin
   */
  /**
   * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
   * @enum {string}
   */
  var IconOrigin = {
      /**
       * Origin is at bottom left
       * @api
       */
      BOTTOM_LEFT: 'bottom-left',
      /**
       * Origin is at bottom right
       * @api
       */
      BOTTOM_RIGHT: 'bottom-right',
      /**
       * Origin is at top left
       * @api
       */
      TOP_LEFT: 'top-left',
      /**
       * Origin is at top right
       * @api
       */
      TOP_RIGHT: 'top-right',
  };

  /**
   * @module ol/style/IconImageCache
   */
  /**
   * @classdesc
   * Singleton class. Available through {@link module:ol/style/IconImageCache~shared}.
   */
  var IconImageCache = /** @class */ (function () {
      function IconImageCache() {
          /**
           * @type {!Object<string, import("./IconImage.js").default>}
           * @private
           */
          this.cache_ = {};
          /**
           * @type {number}
           * @private
           */
          this.cacheSize_ = 0;
          /**
           * @type {number}
           * @private
           */
          this.maxCacheSize_ = 32;
      }
      /**
       * FIXME empty description for jsdoc
       */
      IconImageCache.prototype.clear = function () {
          this.cache_ = {};
          this.cacheSize_ = 0;
      };
      /**
       * @return {boolean} Can expire cache.
       */
      IconImageCache.prototype.canExpireCache = function () {
          return this.cacheSize_ > this.maxCacheSize_;
      };
      /**
       * FIXME empty description for jsdoc
       */
      IconImageCache.prototype.expire = function () {
          if (this.canExpireCache()) {
              var i = 0;
              for (var key in this.cache_) {
                  var iconImage = this.cache_[key];
                  if ((i++ & 3) === 0 && !iconImage.hasListener()) {
                      delete this.cache_[key];
                      --this.cacheSize_;
                  }
              }
          }
      };
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color} color Color.
       * @return {import("./IconImage.js").default} Icon image.
       */
      IconImageCache.prototype.get = function (src, crossOrigin, color) {
          var key = getKey(src, crossOrigin, color);
          return key in this.cache_ ? this.cache_[key] : null;
      };
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color} color Color.
       * @param {import("./IconImage.js").default} iconImage Icon image.
       */
      IconImageCache.prototype.set = function (src, crossOrigin, color, iconImage) {
          var key = getKey(src, crossOrigin, color);
          this.cache_[key] = iconImage;
          ++this.cacheSize_;
      };
      /**
       * Set the cache size of the icon cache. Default is `32`. Change this value when
       * your map uses more than 32 different icon images and you are not caching icon
       * styles on the application level.
       * @param {number} maxCacheSize Cache max size.
       * @api
       */
      IconImageCache.prototype.setSize = function (maxCacheSize) {
          this.maxCacheSize_ = maxCacheSize;
          this.expire();
      };
      return IconImageCache;
  }());
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @return {string} Cache key.
   */
  function getKey(src, crossOrigin, color) {
      var colorString = color ? asString(color) : 'null';
      return crossOrigin + ':' + src + ':' + colorString;
  }
  /**
   * The {@link module:ol/style/IconImageCache~IconImageCache} for
   * {@link module:ol/style/Icon~Icon} images.
   * @api
   */
  var shared = new IconImageCache();

  var __extends$A = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @abstract
   */
  var ImageBase = /** @class */ (function (_super) {
      __extends$A(ImageBase, _super);
      /**
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {number|undefined} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./ImageState.js").default} state State.
       */
      function ImageBase(extent, resolution, pixelRatio, state) {
          var _this = _super.call(this) || this;
          /**
           * @protected
           * @type {import("./extent.js").Extent}
           */
          _this.extent = extent;
          /**
           * @private
           * @type {number}
           */
          _this.pixelRatio_ = pixelRatio;
          /**
           * @protected
           * @type {number|undefined}
           */
          _this.resolution = resolution;
          /**
           * @protected
           * @type {import("./ImageState.js").default}
           */
          _this.state = state;
          return _this;
      }
      /**
       * @protected
       */
      ImageBase.prototype.changed = function () {
          this.dispatchEvent(EventType.CHANGE);
      };
      /**
       * @return {import("./extent.js").Extent} Extent.
       */
      ImageBase.prototype.getExtent = function () {
          return this.extent;
      };
      /**
       * @abstract
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       */
      ImageBase.prototype.getImage = function () {
          return abstract();
      };
      /**
       * @return {number} PixelRatio.
       */
      ImageBase.prototype.getPixelRatio = function () {
          return this.pixelRatio_;
      };
      /**
       * @return {number} Resolution.
       */
      ImageBase.prototype.getResolution = function () {
          return /** @type {number} */ (this.resolution);
      };
      /**
       * @return {import("./ImageState.js").default} State.
       */
      ImageBase.prototype.getState = function () {
          return this.state;
      };
      /**
       * Load not yet loaded URI.
       * @abstract
       */
      ImageBase.prototype.load = function () {
          abstract();
      };
      return ImageBase;
  }(Target));

  var __extends$B = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * A function that takes an {@link module:ol/Image~Image} for the image and a
   * `{string}` for the src as arguments. It is supposed to make it so the
   * underlying image {@link module:ol/Image~Image#getImage} is assigned the
   * content specified by the src. If not specified, the default is
   *
   *     function(image, src) {
   *       image.getImage().src = src;
   *     }
   *
   * Providing a custom `imageLoadFunction` can be useful to load images with
   * post requests or - in general - through XHR requests, where the src of the
   * image element would be set to a data URI when the content is loaded.
   *
   * @typedef {function(ImageWrapper, string): void} LoadFunction
   * @api
   */
  var ImageWrapper = /** @class */ (function (_super) {
      __extends$B(ImageWrapper, _super);
      /**
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {number|undefined} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {string} src Image source URI.
       * @param {?string} crossOrigin Cross origin.
       * @param {LoadFunction} imageLoadFunction Image load function.
       */
      function ImageWrapper(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
          var _this = _super.call(this, extent, resolution, pixelRatio, ImageState.IDLE) || this;
          /**
           * @private
           * @type {string}
           */
          _this.src_ = src;
          /**
           * @private
           * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
           */
          _this.image_ = new Image();
          if (crossOrigin !== null) {
              _this.image_.crossOrigin = crossOrigin;
          }
          /**
           * @private
           * @type {?function():void}
           */
          _this.unlisten_ = null;
          /**
           * @protected
           * @type {import("./ImageState.js").default}
           */
          _this.state = ImageState.IDLE;
          /**
           * @private
           * @type {LoadFunction}
           */
          _this.imageLoadFunction_ = imageLoadFunction;
          return _this;
      }
      /**
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       * @api
       */
      ImageWrapper.prototype.getImage = function () {
          return this.image_;
      };
      /**
       * Tracks loading or read errors.
       *
       * @private
       */
      ImageWrapper.prototype.handleImageError_ = function () {
          this.state = ImageState.ERROR;
          this.unlistenImage_();
          this.changed();
      };
      /**
       * Tracks successful image load.
       *
       * @private
       */
      ImageWrapper.prototype.handleImageLoad_ = function () {
          if (this.resolution === undefined) {
              this.resolution = getHeight(this.extent) / this.image_.height;
          }
          this.state = ImageState.LOADED;
          this.unlistenImage_();
          this.changed();
      };
      /**
       * Load the image or retry if loading previously failed.
       * Loading is taken care of by the tile queue, and calling this method is
       * only needed for preloading or for reloading in case of an error.
       * @api
       */
      ImageWrapper.prototype.load = function () {
          if (this.state == ImageState.IDLE || this.state == ImageState.ERROR) {
              this.state = ImageState.LOADING;
              this.changed();
              this.imageLoadFunction_(this, this.src_);
              this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
          }
      };
      /**
       * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
       */
      ImageWrapper.prototype.setImage = function (image) {
          this.image_ = image;
      };
      /**
       * Discards event handlers which listen for load completion or errors.
       *
       * @private
       */
      ImageWrapper.prototype.unlistenImage_ = function () {
          if (this.unlisten_) {
              this.unlisten_();
              this.unlisten_ = null;
          }
      };
      return ImageWrapper;
  }(ImageBase));
  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image element.
   * @param {function():any} loadHandler Load callback function.
   * @param {function():any} errorHandler Error callback function.
   * @return {function():void} Callback to stop listening.
   */
  function listenImage(image, loadHandler, errorHandler) {
      var img = /** @type {HTMLImageElement} */ (image);
      if (img.src && IMAGE_DECODE) {
          var promise = img.decode();
          var listening_1 = true;
          var unlisten = function () {
              listening_1 = false;
          };
          promise
              .then(function () {
              if (listening_1) {
                  loadHandler();
              }
          })
              .catch(function (error) {
              if (listening_1) {
                  // FIXME: Unconditionally call errorHandler() when this bug is fixed upstream:
                  //        https://bugs.webkit.org/show_bug.cgi?id=198527
                  if (error.name === 'EncodingError' &&
                      error.message === 'Invalid image type.') {
                      loadHandler();
                  }
                  else {
                      errorHandler();
                  }
              }
          });
          return unlisten;
      }
      var listenerKeys = [
          listenOnce(img, EventType.LOAD, loadHandler),
          listenOnce(img, EventType.ERROR, errorHandler),
      ];
      return function unlisten() {
          listenerKeys.forEach(unlistenByKey);
      };
  }

  /**
   * @module ol/style/IconImage
   */
  var __extends$C = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @type {CanvasRenderingContext2D}
   */
  var taintedTestContext = null;
  var IconImage = /** @class */ (function (_super) {
      __extends$C(IconImage, _super);
      /**
       * @param {HTMLImageElement|HTMLCanvasElement} image Image.
       * @param {string|undefined} src Src.
       * @param {import("../size.js").Size} size Size.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../ImageState.js").default} imageState Image state.
       * @param {import("../color.js").Color} color Color.
       */
      function IconImage(image, src, size, crossOrigin, imageState, color) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {HTMLImageElement|HTMLCanvasElement}
           */
          _this.hitDetectionImage_ = null;
          /**
           * @private
           * @type {HTMLImageElement|HTMLCanvasElement}
           */
          _this.image_ = !image ? new Image() : image;
          if (crossOrigin !== null) {
              /** @type {HTMLImageElement} */ (_this.image_).crossOrigin = crossOrigin;
          }
          /**
           * @private
           * @type {Object<number, HTMLCanvasElement>}
           */
          _this.canvas_ = {};
          /**
           * @private
           * @type {import("../color.js").Color}
           */
          _this.color_ = color;
          /**
           * @private
           * @type {?function():void}
           */
          _this.unlisten_ = null;
          /**
           * @private
           * @type {import("../ImageState.js").default}
           */
          _this.imageState_ = imageState;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          _this.size_ = size;
          /**
           * @private
           * @type {string|undefined}
           */
          _this.src_ = src;
          /**
           * @private
           */
          _this.tainted_;
          return _this;
      }
      /**
       * @private
       * @return {boolean} The image canvas is tainted.
       */
      IconImage.prototype.isTainted_ = function () {
          if (this.tainted_ === undefined && this.imageState_ === ImageState.LOADED) {
              if (!taintedTestContext) {
                  taintedTestContext = createCanvasContext2D(1, 1);
              }
              taintedTestContext.drawImage(this.image_, 0, 0);
              try {
                  taintedTestContext.getImageData(0, 0, 1, 1);
                  this.tainted_ = false;
              }
              catch (e) {
                  taintedTestContext = null;
                  this.tainted_ = true;
              }
          }
          return this.tainted_ === true;
      };
      /**
       * @private
       */
      IconImage.prototype.dispatchChangeEvent_ = function () {
          this.dispatchEvent(EventType.CHANGE);
      };
      /**
       * @private
       */
      IconImage.prototype.handleImageError_ = function () {
          this.imageState_ = ImageState.ERROR;
          this.unlistenImage_();
          this.dispatchChangeEvent_();
      };
      /**
       * @private
       */
      IconImage.prototype.handleImageLoad_ = function () {
          this.imageState_ = ImageState.LOADED;
          if (this.size_) {
              this.image_.width = this.size_[0];
              this.image_.height = this.size_[1];
          }
          else {
              this.size_ = [this.image_.width, this.image_.height];
          }
          this.unlistenImage_();
          this.dispatchChangeEvent_();
      };
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
       */
      IconImage.prototype.getImage = function (pixelRatio) {
          this.replaceColor_(pixelRatio);
          return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
      };
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Image or Canvas element.
       */
      IconImage.prototype.getPixelRatio = function (pixelRatio) {
          this.replaceColor_(pixelRatio);
          return this.canvas_[pixelRatio] ? pixelRatio : 1;
      };
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      IconImage.prototype.getImageState = function () {
          return this.imageState_;
      };
      /**
       * @return {HTMLImageElement|HTMLCanvasElement} Image element.
       */
      IconImage.prototype.getHitDetectionImage = function () {
          if (!this.hitDetectionImage_) {
              if (this.isTainted_()) {
                  var width = this.size_[0];
                  var height = this.size_[1];
                  var context = createCanvasContext2D(width, height);
                  context.fillRect(0, 0, width, height);
                  this.hitDetectionImage_ = context.canvas;
              }
              else {
                  this.hitDetectionImage_ = this.image_;
              }
          }
          return this.hitDetectionImage_;
      };
      /**
       * Get the size of the icon (in pixels).
       * @return {import("../size.js").Size} Image size.
       */
      IconImage.prototype.getSize = function () {
          return this.size_;
      };
      /**
       * @return {string|undefined} Image src.
       */
      IconImage.prototype.getSrc = function () {
          return this.src_;
      };
      /**
       * Load not yet loaded URI.
       */
      IconImage.prototype.load = function () {
          if (this.imageState_ == ImageState.IDLE) {
              this.imageState_ = ImageState.LOADING;
              try {
                  /** @type {HTMLImageElement} */ (this.image_).src = this.src_;
              }
              catch (e) {
                  this.handleImageError_();
              }
              this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
          }
      };
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @private
       */
      IconImage.prototype.replaceColor_ = function (pixelRatio) {
          if (!this.color_ || this.canvas_[pixelRatio]) {
              return;
          }
          var canvas = document.createElement('canvas');
          this.canvas_[pixelRatio] = canvas;
          canvas.width = Math.ceil(this.image_.width * pixelRatio);
          canvas.height = Math.ceil(this.image_.height * pixelRatio);
          var ctx = canvas.getContext('2d');
          ctx.scale(pixelRatio, pixelRatio);
          ctx.drawImage(this.image_, 0, 0);
          if (this.isTainted_()) {
              // If reading from the canvas throws a SecurityError the same effect can be
              // achieved with globalCompositeOperation.
              // This could be used as the default, but it is not fully supported by all
              // browsers. E. g. Internet Explorer 11 does not support the multiply
              // operation and the resulting image shape will be completelly filled with
              // the provided color.
              // So this is only used as a fallback. It is still better than having no icon
              // at all.
              var c = this.color_;
              ctx.globalCompositeOperation = 'multiply';
              ctx.fillStyle = 'rgb(' + c[0] + ',' + c[1] + ',' + c[2] + ')';
              ctx.fillRect(0, 0, canvas.width, canvas.height);
              ctx.globalCompositeOperation = 'destination-in';
              ctx.drawImage(this.image_, 0, 0);
              return;
          }
          var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          var data = imgData.data;
          var r = this.color_[0] / 255.0;
          var g = this.color_[1] / 255.0;
          var b = this.color_[2] / 255.0;
          for (var i = 0, ii = data.length; i < ii; i += 4) {
              data[i] *= r;
              data[i + 1] *= g;
              data[i + 2] *= b;
          }
          ctx.putImageData(imgData, 0, 0);
      };
      /**
       * Discards event handlers which listen for load completion or errors.
       *
       * @private
       */
      IconImage.prototype.unlistenImage_ = function () {
          if (this.unlisten_) {
              this.unlisten_();
              this.unlisten_ = null;
          }
      };
      return IconImage;
  }(Target));
  /**
   * @param {HTMLImageElement|HTMLCanvasElement} image Image.
   * @param {string} src Src.
   * @param {import("../size.js").Size} size Size.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default} imageState Image state.
   * @param {import("../color.js").Color} color Color.
   * @return {IconImage} Icon image.
   */
  function get$4(image, src, size, crossOrigin, imageState, color) {
      var iconImage = shared.get(src, crossOrigin, color);
      if (!iconImage) {
          iconImage = new IconImage(image, src, size, crossOrigin, imageState, color);
          shared.set(src, crossOrigin, color, iconImage);
      }
      return iconImage;
  }

  var __extends$D = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
   * @property {import("./IconOrigin.js").default} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
   * `top-left` or `top-right`.
   * @property {import("./IconAnchorUnits.js").default} [anchorXUnits='fraction'] Units in which the anchor x value is
   * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
   * the x value in pixels.
   * @property {import("./IconAnchorUnits.js").default} [anchorYUnits='fraction'] Units in which the anchor y value is
   * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
   * the y value in pixels.
   * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
   * the icon will be left as is.
   * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
   * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
   * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
   * @property {HTMLImageElement|HTMLCanvasElement} [img] Image object for the icon. If the `src` option is not provided then the
   * provided image must already be loaded. And in that case, it is required
   * to provide the size of the image, with the `imgSize` option.
   * @property {Array<number>} [offset=[0, 0]] Offset, which, together with the size and the offset origin, define the
   * sub-rectangle to use from the original icon image.
   * @property {Array<number>} [displacement=[0,0]] Displacement the icon
   * @property {import("./IconOrigin.js").default} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
   * `top-left` or `top-right`.
   * @property {number} [opacity=1] Opacity of the icon.
   * @property {number|import("../size.js").Size} [scale=1] Scale.
   * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
   * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
   * @property {import("../size.js").Size} [size] Icon size in pixel. Can be used together with `offset` to define the
   * sub-rectangle to use from the origin (sprite) icon image.
   * @property {import("../size.js").Size} [imgSize] Image size in pixels. Only required if `img` is set and `src` is not, and
   * for SVG images in Internet Explorer 11. The provided `imgSize` needs to match the actual size of the image.
   * @property {string} [src] Image source URI.
   */
  /**
   * @classdesc
   * Set icon style for vector features.
   * @api
   */
  var Icon = /** @class */ (function (_super) {
      __extends$D(Icon, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function Icon(opt_options) {
          var _this = this;
          var options = opt_options || {};
          /**
           * @type {number}
           */
          var opacity = options.opacity !== undefined ? options.opacity : 1;
          /**
           * @type {number}
           */
          var rotation = options.rotation !== undefined ? options.rotation : 0;
          /**
           * @type {number|import("../size.js").Size}
           */
          var scale = options.scale !== undefined ? options.scale : 1;
          /**
           * @type {boolean}
           */
          var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
          _this = _super.call(this, {
              opacity: opacity,
              rotation: rotation,
              scale: scale,
              displacement: options.displacement !== undefined ? options.displacement : [0, 0],
              rotateWithView: rotateWithView,
          }) || this;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];
          /**
           * @private
           * @type {Array<number>}
           */
          _this.normalizedAnchor_ = null;
          /**
           * @private
           * @type {import("./IconOrigin.js").default}
           */
          _this.anchorOrigin_ =
              options.anchorOrigin !== undefined
                  ? options.anchorOrigin
                  : IconOrigin.TOP_LEFT;
          /**
           * @private
           * @type {import("./IconAnchorUnits.js").default}
           */
          _this.anchorXUnits_ =
              options.anchorXUnits !== undefined
                  ? options.anchorXUnits
                  : IconAnchorUnits.FRACTION;
          /**
           * @private
           * @type {import("./IconAnchorUnits.js").default}
           */
          _this.anchorYUnits_ =
              options.anchorYUnits !== undefined
                  ? options.anchorYUnits
                  : IconAnchorUnits.FRACTION;
          /**
           * @private
           * @type {?string}
           */
          _this.crossOrigin_ =
              options.crossOrigin !== undefined ? options.crossOrigin : null;
          /**
           * @type {HTMLImageElement|HTMLCanvasElement}
           */
          var image = options.img !== undefined ? options.img : null;
          /**
           * @type {import("../size.js").Size}
           */
          var imgSize = options.imgSize !== undefined ? options.imgSize : null;
          /**
           * @type {string|undefined}
           */
          var src = options.src;
          assert(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time
          assert(!image || (image && imgSize), 5); // `imgSize` must be set when `image` is provided
          if ((src === undefined || src.length === 0) && image) {
              src = /** @type {HTMLImageElement} */ (image).src || getUid(image);
          }
          assert(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided
          /**
           * @type {import("../ImageState.js").default}
           */
          var imageState = options.src !== undefined ? ImageState.IDLE : ImageState.LOADED;
          /**
           * @private
           * @type {import("../color.js").Color}
           */
          _this.color_ = options.color !== undefined ? asArray(options.color) : null;
          /**
           * @private
           * @type {import("./IconImage.js").default}
           */
          _this.iconImage_ = get$4(image, 
          /** @type {string} */ (src), imgSize, _this.crossOrigin_, imageState, _this.color_);
          /**
           * @private
           * @type {Array<number>}
           */
          _this.offset_ = options.offset !== undefined ? options.offset : [0, 0];
          /**
           * @private
           * @type {import("./IconOrigin.js").default}
           */
          _this.offsetOrigin_ =
              options.offsetOrigin !== undefined
                  ? options.offsetOrigin
                  : IconOrigin.TOP_LEFT;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.origin_ = null;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          _this.size_ = options.size !== undefined ? options.size : null;
          return _this;
      }
      /**
       * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
       * @return {Icon} The cloned style.
       * @api
       */
      Icon.prototype.clone = function () {
          var scale = this.getScale();
          return new Icon({
              anchor: this.anchor_.slice(),
              anchorOrigin: this.anchorOrigin_,
              anchorXUnits: this.anchorXUnits_,
              anchorYUnits: this.anchorYUnits_,
              crossOrigin: this.crossOrigin_,
              color: this.color_ && this.color_.slice
                  ? this.color_.slice()
                  : this.color_ || undefined,
              src: this.getSrc(),
              offset: this.offset_.slice(),
              offsetOrigin: this.offsetOrigin_,
              size: this.size_ !== null ? this.size_.slice() : undefined,
              opacity: this.getOpacity(),
              scale: Array.isArray(scale) ? scale.slice() : scale,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
          });
      };
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @return {Array<number>} Anchor.
       * @api
       */
      Icon.prototype.getAnchor = function () {
          if (this.normalizedAnchor_) {
              return this.normalizedAnchor_;
          }
          var anchor = this.anchor_;
          var size = this.getSize();
          if (this.anchorXUnits_ == IconAnchorUnits.FRACTION ||
              this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
              if (!size) {
                  return null;
              }
              anchor = this.anchor_.slice();
              if (this.anchorXUnits_ == IconAnchorUnits.FRACTION) {
                  anchor[0] *= size[0];
              }
              if (this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
                  anchor[1] *= size[1];
              }
          }
          if (this.anchorOrigin_ != IconOrigin.TOP_LEFT) {
              if (!size) {
                  return null;
              }
              if (anchor === this.anchor_) {
                  anchor = this.anchor_.slice();
              }
              if (this.anchorOrigin_ == IconOrigin.TOP_RIGHT ||
                  this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                  anchor[0] = -anchor[0] + size[0];
              }
              if (this.anchorOrigin_ == IconOrigin.BOTTOM_LEFT ||
                  this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                  anchor[1] = -anchor[1] + size[1];
              }
          }
          this.normalizedAnchor_ = anchor;
          return this.normalizedAnchor_;
      };
      /**
       * Set the anchor point. The anchor determines the center point for the
       * symbolizer.
       *
       * @param {Array<number>} anchor Anchor.
       * @api
       */
      Icon.prototype.setAnchor = function (anchor) {
          this.anchor_ = anchor;
          this.normalizedAnchor_ = null;
      };
      /**
       * Get the icon color.
       * @return {import("../color.js").Color} Color.
       * @api
       */
      Icon.prototype.getColor = function () {
          return this.color_;
      };
      /**
       * Get the image icon.
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
       * @api
       */
      Icon.prototype.getImage = function (pixelRatio) {
          return this.iconImage_.getImage(pixelRatio);
      };
      /**
       * Get the pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} The pixel ration of the image.
       * @api
       */
      Icon.prototype.getPixelRatio = function (pixelRatio) {
          return this.iconImage_.getPixelRatio(pixelRatio);
      };
      /**
       * @return {import("../size.js").Size} Image size.
       */
      Icon.prototype.getImageSize = function () {
          return this.iconImage_.getSize();
      };
      /**
       * @return {import("../size.js").Size} Size of the hit-detection image.
       */
      Icon.prototype.getHitDetectionImageSize = function () {
          return this.getImageSize();
      };
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      Icon.prototype.getImageState = function () {
          return this.iconImage_.getImageState();
      };
      /**
       * @return {HTMLImageElement|HTMLCanvasElement} Image element.
       */
      Icon.prototype.getHitDetectionImage = function () {
          return this.iconImage_.getHitDetectionImage();
      };
      /**
       * Get the origin of the symbolizer.
       * @return {Array<number>} Origin.
       * @api
       */
      Icon.prototype.getOrigin = function () {
          if (this.origin_) {
              return this.origin_;
          }
          var offset = this.offset_;
          var displacement = this.getDisplacement();
          if (this.offsetOrigin_ != IconOrigin.TOP_LEFT) {
              var size = this.getSize();
              var iconImageSize = this.iconImage_.getSize();
              if (!size || !iconImageSize) {
                  return null;
              }
              offset = offset.slice();
              if (this.offsetOrigin_ == IconOrigin.TOP_RIGHT ||
                  this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                  offset[0] = iconImageSize[0] - size[0] - offset[0];
              }
              if (this.offsetOrigin_ == IconOrigin.BOTTOM_LEFT ||
                  this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                  offset[1] = iconImageSize[1] - size[1] - offset[1];
              }
          }
          offset[0] += displacement[0];
          offset[1] += displacement[1];
          this.origin_ = offset;
          return this.origin_;
      };
      /**
       * Get the image URL.
       * @return {string|undefined} Image src.
       * @api
       */
      Icon.prototype.getSrc = function () {
          return this.iconImage_.getSrc();
      };
      /**
       * Get the size of the icon (in pixels).
       * @return {import("../size.js").Size} Image size.
       * @api
       */
      Icon.prototype.getSize = function () {
          return !this.size_ ? this.iconImage_.getSize() : this.size_;
      };
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      Icon.prototype.listenImageChange = function (listener) {
          this.iconImage_.addEventListener(EventType.CHANGE, listener);
      };
      /**
       * Load not yet loaded URI.
       * When rendering a feature with an icon style, the vector renderer will
       * automatically call this method. However, you might want to call this
       * method yourself for preloading or other purposes.
       * @api
       */
      Icon.prototype.load = function () {
          this.iconImage_.load();
      };
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      Icon.prototype.unlistenImageChange = function (listener) {
          this.iconImage_.removeEventListener(EventType.CHANGE, listener);
      };
      return Icon;
  }(ImageStyle));

  /**
   * @module ol/style/Text
   */

  /**
   * @module ol/style
   */

  /**
   * @module ol/render/canvas/hitdetet
   */
  /**
   * @param {import("../../size.js").Size} size Canvas size in css pixels.
   * @param {Array<import("../../transform.js").Transform>} transforms Transforms
   * for rendering features to all worlds of the viewport, from coordinates to css
   * pixels.
   * @param {Array<import("../../Feature.js").FeatureLike>} features
   * Features to consider for hit detection.
   * @param {import("../../style/Style.js").StyleFunction|undefined} styleFunction
   * Layer style function.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @return {ImageData} Hit detection image data.
   */
  function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {
      var width = size[0] / 2;
      var height = size[1] / 2;
      var context = createCanvasContext2D(width, height);
      context.imageSmoothingEnabled = false;
      var canvas = context.canvas;
      var renderer = new CanvasImmediateRenderer(context, 0.5, extent, null, rotation);
      var featureCount = features.length;
      // Stretch hit detection index to use the whole available color range
      var indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
      var featuresByZIndex = {};
      for (var i = 1; i <= featureCount; ++i) {
          var feature = features[i - 1];
          var featureStyleFunction = feature.getStyleFunction() || styleFunction;
          if (!styleFunction) {
              continue;
          }
          var styles = featureStyleFunction(feature, resolution);
          if (!styles) {
              continue;
          }
          if (!Array.isArray(styles)) {
              styles = [styles];
          }
          var index = i * indexFactor;
          var color = '#' + ('000000' + index.toString(16)).slice(-6);
          for (var j = 0, jj = styles.length; j < jj; ++j) {
              var originalStyle = styles[j];
              var style = originalStyle.clone();
              var fill = style.getFill();
              if (fill) {
                  fill.setColor(color);
              }
              var stroke = style.getStroke();
              if (stroke) {
                  stroke.setColor(color);
              }
              style.setText(undefined);
              var image = originalStyle.getImage();
              if (image) {
                  var imgSize = image.getImageSize();
                  if (!imgSize) {
                      continue;
                  }
                  var canvas_1 = document.createElement('canvas');
                  canvas_1.width = imgSize[0];
                  canvas_1.height = imgSize[1];
                  var imgContext = canvas_1.getContext('2d', { alpha: false });
                  imgContext.fillStyle = color;
                  var img = imgContext.canvas;
                  imgContext.fillRect(0, 0, img.width, img.height);
                  var width_1 = imgSize ? imgSize[0] : img.width;
                  var height_1 = imgSize ? imgSize[1] : img.height;
                  var iconContext = createCanvasContext2D(width_1, height_1);
                  iconContext.drawImage(img, 0, 0);
                  style.setImage(new Icon({
                      img: img,
                      imgSize: imgSize,
                      anchor: image.getAnchor(),
                      anchorXUnits: IconAnchorUnits.PIXELS,
                      anchorYUnits: IconAnchorUnits.PIXELS,
                      offset: image.getOrigin(),
                      size: image.getSize(),
                      opacity: image.getOpacity(),
                      scale: image.getScale(),
                      rotation: image.getRotation(),
                      rotateWithView: image.getRotateWithView(),
                  }));
              }
              var zIndex = Number(style.getZIndex());
              var byGeometryType = featuresByZIndex[zIndex];
              if (!byGeometryType) {
                  byGeometryType = {};
                  featuresByZIndex[zIndex] = byGeometryType;
                  byGeometryType[GeometryType.POLYGON] = [];
                  byGeometryType[GeometryType.CIRCLE] = [];
                  byGeometryType[GeometryType.LINE_STRING] = [];
                  byGeometryType[GeometryType.POINT] = [];
              }
              var geometry = style.getGeometryFunction()(feature);
              if (geometry && intersects(extent, geometry.getExtent())) {
                  byGeometryType[geometry.getType().replace('Multi', '')].push(geometry, style);
              }
          }
      }
      var zIndexKeys = Object.keys(featuresByZIndex)
          .map(Number)
          .sort(numberSafeCompareFunction);
      for (var i = 0, ii = zIndexKeys.length; i < ii; ++i) {
          var byGeometryType = featuresByZIndex[zIndexKeys[i]];
          for (var type in byGeometryType) {
              var geomAndStyle = byGeometryType[type];
              for (var j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
                  renderer.setStyle(geomAndStyle[j + 1]);
                  for (var k = 0, kk = transforms.length; k < kk; ++k) {
                      renderer.setTransform(transforms[k]);
                      renderer.drawGeometry(geomAndStyle[j]);
                  }
              }
          }
      }
      return context.getImageData(0, 0, canvas.width, canvas.height);
  }
  /**
   * @param {import("../../pixel").Pixel} pixel Pixel coordinate on the hit
   * detection canvas in css pixels.
   * @param {Array<import("../../Feature").FeatureLike>} features Features. Has to
   * match the `features` array that was passed to `createHitDetectionImageData()`.
   * @param {ImageData} imageData Hit detection image data generated by
   * `createHitDetectionImageData()`.
   * @return {Array<import("../../Feature").FeatureLike>} features Features.
   */
  function hitDetect(pixel, features, imageData) {
      var resultFeatures = [];
      if (imageData) {
          var index = (Math.round(pixel[0] / 2) + Math.round(pixel[1] / 2) * imageData.width) *
              4;
          var r = imageData.data[index];
          var g = imageData.data[index + 1];
          var b = imageData.data[index + 2];
          var i = b + 256 * (g + 256 * r);
          var indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
          if (i && i % indexFactor === 0) {
              resultFeatures.push(features[i / indexFactor - 1]);
          }
      }
      return resultFeatures;
  }

  /**
   * @module ol/renderer/vector
   */
  /**
   * Tolerance for geometry simplification in device pixels.
   * @type {number}
   */
  var SIMPLIFY_TOLERANCE = 0.5;
  /**
   * @const
   * @type {Object<import("../geom/GeometryType.js").default,
   *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
   *                         import("../style/Style.js").default, Object): void>}
   */
  var GEOMETRY_RENDERERS = {
      'Point': renderPointGeometry,
      'LineString': renderLineStringGeometry,
      'Polygon': renderPolygonGeometry,
      'MultiPoint': renderMultiPointGeometry,
      'MultiLineString': renderMultiLineStringGeometry,
      'MultiPolygon': renderMultiPolygonGeometry,
      'GeometryCollection': renderGeometryCollectionGeometry,
      'Circle': renderCircleGeometry,
  };
  /**
   * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
   * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
   * @return {number} Order.
   */
  function defaultOrder(feature1, feature2) {
      return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Squared pixel tolerance.
   */
  function getSquaredTolerance(resolution, pixelRatio) {
      var tolerance = getTolerance(resolution, pixelRatio);
      return tolerance * tolerance;
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel tolerance.
   */
  function getTolerance(resolution, pixelRatio) {
      return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").default} feature Feature.
   */
  function renderCircleGeometry(builderGroup, geometry, style, feature) {
      var fillStyle = style.getFill();
      var strokeStyle = style.getStroke();
      if (fillStyle || strokeStyle) {
          var circleReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.CIRCLE);
          circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
          circleReplay.drawCircle(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @param {import("../proj.js").TransformFunction} [opt_transform] Transform from user to view projection.
   * @return {boolean} `true` if style is loading.
   * @template T
   */
  function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform) {
      var loading = false;
      var imageStyle = style.getImage();
      if (imageStyle) {
          var imageState = imageStyle.getImageState();
          if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {
              imageStyle.unlistenImageChange(listener);
          }
          else {
              if (imageState == ImageState.IDLE) {
                  imageStyle.load();
              }
              imageState = imageStyle.getImageState();
              imageStyle.listenImageChange(listener);
              loading = true;
          }
      }
      renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform);
      return loading;
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
   */
  function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform) {
      var geometry = style.getGeometryFunction()(feature);
      if (!geometry) {
          return;
      }
      var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);
      var renderer = style.getRenderer();
      if (renderer) {
          renderGeometry(replayGroup, simplifiedGeometry, style, feature);
      }
      else {
          var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
          geometryRenderer(replayGroup, simplifiedGeometry, style, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
   * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderGeometry(replayGroup, geometry, style, feature) {
      if (geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {
          var geometries = /** @type {import("../geom/GeometryCollection.js").default} */ (geometry).getGeometries();
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              renderGeometry(replayGroup, geometries[i], style, feature);
          }
          return;
      }
      var replay = replayGroup.getBuilder(style.getZIndex(), BuilderType.DEFAULT);
      replay.drawCustom(
      /** @type {import("../geom/SimpleGeometry.js").default} */ (geometry), feature, style.getRenderer());
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").default} feature Feature.
   */
  function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature) {
      var geometries = geometry.getGeometriesArray();
      var i, ii;
      for (i = 0, ii = geometries.length; i < ii; ++i) {
          var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
          geometryRenderer(replayGroup, geometries[i], style, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderLineStringGeometry(builderGroup, geometry, style, feature) {
      var strokeStyle = style.getStroke();
      if (strokeStyle) {
          var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);
          lineStringReplay.setFillStrokeStyle(null, strokeStyle);
          lineStringReplay.drawLineString(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderMultiLineStringGeometry(builderGroup, geometry, style, feature) {
      var strokeStyle = style.getStroke();
      if (strokeStyle) {
          var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);
          lineStringReplay.setFillStrokeStyle(null, strokeStyle);
          lineStringReplay.drawMultiLineString(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").default} feature Feature.
   */
  function renderMultiPolygonGeometry(builderGroup, geometry, style, feature) {
      var fillStyle = style.getFill();
      var strokeStyle = style.getStroke();
      if (strokeStyle || fillStyle) {
          var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);
          polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
          polygonReplay.drawMultiPolygon(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderPointGeometry(builderGroup, geometry, style, feature) {
      var imageStyle = style.getImage();
      if (imageStyle) {
          if (imageStyle.getImageState() != ImageState.LOADED) {
              return;
          }
          var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);
          imageReplay.setImageStyle(imageStyle, builderGroup.addDeclutter(false));
          imageReplay.drawPoint(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(!!imageStyle));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderMultiPointGeometry(builderGroup, geometry, style, feature) {
      var imageStyle = style.getImage();
      if (imageStyle) {
          if (imageStyle.getImageState() != ImageState.LOADED) {
              return;
          }
          var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);
          imageReplay.setImageStyle(imageStyle, builderGroup.addDeclutter(false));
          imageReplay.drawMultiPoint(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(!!imageStyle));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderPolygonGeometry(builderGroup, geometry, style, feature) {
      var fillStyle = style.getFill();
      var strokeStyle = style.getStroke();
      if (fillStyle || strokeStyle) {
          var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);
          polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
          polygonReplay.drawPolygon(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
          textReplay.drawText(geometry, feature);
      }
  }

  var __extends$E = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Canvas renderer for vector layers.
   * @api
   */
  var CanvasVectorLayerRenderer = /** @class */ (function (_super) {
      __extends$E(CanvasVectorLayerRenderer, _super);
      /**
       * @param {import("../../layer/Vector.js").default} vectorLayer Vector layer.
       */
      function CanvasVectorLayerRenderer(vectorLayer) {
          var _this = _super.call(this, vectorLayer) || this;
          /** @private */
          _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
          /**
           * @type {boolean}
           */
          _this.animatingOrInteracting_;
          /**
           * @private
           * @type {boolean}
           */
          _this.dirty_ = false;
          /**
           * @type {ImageData}
           */
          _this.hitDetectionImageData_ = null;
          /**
           * @type {Array<import("../../Feature.js").default>}
           */
          _this.renderedFeatures_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.renderedRevision_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.renderedResolution_ = NaN;
          /**
           * @private
           * @type {import("../../extent.js").Extent}
           */
          _this.renderedExtent_ = createEmpty();
          /**
           * @private
           * @type {number}
           */
          _this.renderedRotation_;
          /**
           * @private
           * @type {import("../../coordinate").Coordinate}
           */
          _this.renderedCenter_ = null;
          /**
           * @private
           * @type {import("../../proj/Projection").default}
           */
          _this.renderedProjection_ = null;
          /**
           * @private
           * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
           */
          _this.renderedRenderOrder_ = null;
          /**
           * @private
           * @type {import("../../render/canvas/ExecutorGroup").default}
           */
          _this.replayGroup_ = null;
          /**
           * A new replay group had to be created by `prepareFrame()`
           * @type {boolean}
           */
          _this.replayGroupChanged = true;
          /**
           * Clipping to be performed by `renderFrame()`
           * @type {boolean}
           */
          _this.clipping = true;
          return _this;
      }
      /**
       * Get a rendering container from an existing target, if compatible.
       * @param {HTMLElement} target Potential render target.
       * @param {string} transform CSS Transform.
       * @param {number} opacity Opacity.
       */
      CanvasVectorLayerRenderer.prototype.useContainer = function (target, transform$$1, opacity) {
          if (opacity < 1) {
              target = null;
          }
          _super.prototype.useContainer.call(this, target, transform$$1, opacity);
      };
      /**
       * Render the layer.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target that may be used to render content to.
       * @return {HTMLElement} The rendered element.
       */
      CanvasVectorLayerRenderer.prototype.renderFrame = function (frameState, target) {
          var pixelRatio = frameState.pixelRatio;
          var layerState = frameState.layerStatesArray[frameState.layerIndex];
          // set forward and inverse pixel transforms
          makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
          makeInverse(this.inversePixelTransform, this.pixelTransform);
          var canvasTransform = toString(this.pixelTransform);
          this.useContainer(target, canvasTransform, layerState.opacity);
          var context = this.context;
          var canvas = context.canvas;
          var replayGroup = this.replayGroup_;
          if (!replayGroup || replayGroup.isEmpty()) {
              if (!this.containerReused && canvas.width > 0) {
                  canvas.width = 0;
              }
              return this.container;
          }
          // resize and clear
          var width = Math.round(frameState.size[0] * pixelRatio);
          var height = Math.round(frameState.size[1] * pixelRatio);
          if (canvas.width != width || canvas.height != height) {
              canvas.width = width;
              canvas.height = height;
              if (canvas.style.transform !== canvasTransform) {
                  canvas.style.transform = canvasTransform;
              }
          }
          else if (!this.containerReused) {
              context.clearRect(0, 0, width, height);
          }
          this.preRender(context, frameState);
          var extent = frameState.extent;
          var viewState = frameState.viewState;
          var center = viewState.center;
          var resolution = viewState.resolution;
          var projection = viewState.projection;
          var rotation = viewState.rotation;
          var projectionExtent = projection.getExtent();
          var vectorSource = this.getLayer().getSource();
          // clipped rendering if layer extent is set
          var clipped = false;
          if (layerState.extent && this.clipping) {
              var layerExtent = fromUserExtent(layerState.extent, projection);
              clipped =
                  !containsExtent(layerExtent, frameState.extent) &&
                      intersects(layerExtent, frameState.extent);
              if (clipped) {
                  this.clipUnrotated(context, frameState, layerExtent);
              }
          }
          var viewHints = frameState.viewHints;
          var snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
          var transform$$1 = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, 0);
          var declutterReplays = this.getLayer().getDeclutter() ? {} : null;
          replayGroup.execute(context, 1, transform$$1, rotation, snapToPixel, undefined, declutterReplays);
          if (vectorSource.getWrapX() &&
              projection.canWrapX() &&
              !containsExtent(projectionExtent, extent)) {
              var startX = extent[0];
              var worldWidth = getWidth(projectionExtent);
              var world = 0;
              var offsetX = void 0;
              while (startX < projectionExtent[0]) {
                  --world;
                  offsetX = worldWidth * world;
                  var transform_1 = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX);
                  replayGroup.execute(context, 1, transform_1, rotation, snapToPixel, undefined, declutterReplays);
                  startX += worldWidth;
              }
              world = 0;
              startX = extent[2];
              while (startX > projectionExtent[2]) {
                  ++world;
                  offsetX = worldWidth * world;
                  var transform_2 = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX);
                  replayGroup.execute(context, 1, transform_2, rotation, snapToPixel, undefined, declutterReplays);
                  startX -= worldWidth;
              }
          }
          if (declutterReplays) {
              var viewHints_1 = frameState.viewHints;
              var hifi = !(viewHints_1[ViewHint.ANIMATING] || viewHints_1[ViewHint.INTERACTING]);
              replayDeclutter(declutterReplays, context, rotation, 1, hifi, frameState.declutterItems);
          }
          if (clipped) {
              context.restore();
          }
          this.postRender(context, frameState);
          var opacity = layerState.opacity;
          var container = this.container;
          if (opacity !== parseFloat(container.style.opacity)) {
              container.style.opacity = opacity === 1 ? '' : String(opacity);
          }
          if (this.renderedRotation_ !== viewState.rotation) {
              this.renderedRotation_ = viewState.rotation;
              this.hitDetectionImageData_ = null;
          }
          return this.container;
      };
      /**
       * Asynchronous layer level hit detection.
       * @param {import("../../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
       */
      CanvasVectorLayerRenderer.prototype.getFeatures = function (pixel) {
          return new Promise(function (resolve, reject) {
              if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
                  var size = [this.context.canvas.width, this.context.canvas.height];
                  apply$1(this.pixelTransform, size);
                  var center = this.renderedCenter_;
                  var resolution = this.renderedResolution_;
                  var rotation = this.renderedRotation_;
                  var projection = this.renderedProjection_;
                  var extent = this.renderedExtent_;
                  var layer = this.getLayer();
                  var transforms = [];
                  var width = size[0] / 2;
                  var height = size[1] / 2;
                  transforms.push(this.getRenderTransform(center, resolution, rotation, 0.5, width, height, 0).slice());
                  var source = layer.getSource();
                  var projectionExtent = projection.getExtent();
                  if (source.getWrapX() &&
                      projection.canWrapX() &&
                      !containsExtent(projectionExtent, extent)) {
                      var startX = extent[0];
                      var worldWidth = getWidth(projectionExtent);
                      var world = 0;
                      var offsetX = void 0;
                      while (startX < projectionExtent[0]) {
                          --world;
                          offsetX = worldWidth * world;
                          transforms.push(this.getRenderTransform(center, resolution, rotation, 0.5, width, height, offsetX).slice());
                          startX += worldWidth;
                      }
                      world = 0;
                      startX = extent[2];
                      while (startX > projectionExtent[2]) {
                          ++world;
                          offsetX = worldWidth * world;
                          transforms.push(this.getRenderTransform(center, resolution, rotation, 0.5, width, height, offsetX).slice());
                          startX -= worldWidth;
                      }
                  }
                  this.hitDetectionImageData_ = createHitDetectionImageData(size, transforms, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation);
              }
              resolve(hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
          }.bind(this));
      };
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../../Feature.js").FeatureLike, import("../../layer/Layer.js").default): T} callback Feature callback.
       * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
       * @return {T|void} Callback result.
       * @template T
       */
      CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, declutteredFeatures) {
          if (!this.replayGroup_) {
              return undefined;
          }
          else {
              var resolution = frameState.viewState.resolution;
              var rotation = frameState.viewState.rotation;
              var layer_1 = this.getLayer();
              /** @type {!Object<string, boolean>} */
              var features_1 = {};
              var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, 
              /**
               * @param {import("../../Feature.js").FeatureLike} feature Feature.
               * @return {?} Callback result.
               */
              function (feature) {
                  var key = getUid(feature);
                  if (!(key in features_1)) {
                      features_1[key] = true;
                      return callback(feature, layer_1);
                  }
              }, layer_1.getDeclutter() ? declutteredFeatures : null);
              return result;
          }
      };
      /**
       * Perform action necessary to get the layer rendered after new fonts have loaded
       */
      CanvasVectorLayerRenderer.prototype.handleFontsChanged = function () {
          var layer = this.getLayer();
          if (layer.getVisible() && this.replayGroup_) {
              layer.changed();
          }
      };
      /**
       * Handle changes in image style state.
       * @param {import("../../events/Event.js").default} event Image style change event.
       * @private
       */
      CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function (event) {
          this.renderIfReadyAndVisible();
      };
      /**
       * Determine whether render should be called.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      CanvasVectorLayerRenderer.prototype.prepareFrame = function (frameState) {
          var vectorLayer = this.getLayer();
          var vectorSource = vectorLayer.getSource();
          if (!vectorSource) {
              return false;
          }
          var animating = frameState.viewHints[ViewHint.ANIMATING];
          var interacting = frameState.viewHints[ViewHint.INTERACTING];
          var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
          var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
          if ((!this.dirty_ && !updateWhileAnimating && animating) ||
              (!updateWhileInteracting && interacting)) {
              this.animatingOrInteracting_ = true;
              return true;
          }
          this.animatingOrInteracting_ = false;
          var frameStateExtent = frameState.extent;
          var viewState = frameState.viewState;
          var projection = viewState.projection;
          var resolution = viewState.resolution;
          var pixelRatio = frameState.pixelRatio;
          var vectorLayerRevision = vectorLayer.getRevision();
          var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
          var vectorLayerRenderOrder = vectorLayer.getRenderOrder();
          if (vectorLayerRenderOrder === undefined) {
              vectorLayerRenderOrder = defaultOrder;
          }
          var center = viewState.center.slice();
          var extent = buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);
          var loadExtents = [extent.slice()];
          var projectionExtent = projection.getExtent();
          if (vectorSource.getWrapX() &&
              projection.canWrapX() &&
              !containsExtent(projectionExtent, frameState.extent)) {
              // For the replay group, we need an extent that intersects the real world
              // (-180 to +180). To support geometries in a coordinate range from -540
              // to +540, we add at least 1 world width on each side of the projection
              // extent. If the viewport is wider than the world, we need to add half of
              // the viewport width to make sure we cover the whole viewport.
              var worldWidth = getWidth(projectionExtent);
              var gutter = Math.max(getWidth(extent) / 2, worldWidth);
              extent[0] = projectionExtent[0] - gutter;
              extent[2] = projectionExtent[2] + gutter;
              wrapX$1(center, projection);
              var loadExtent = wrapX(loadExtents[0], projection);
              // If the extent crosses the date line, we load data for both edges of the worlds
              if (loadExtent[0] < projectionExtent[0] &&
                  loadExtent[2] < projectionExtent[2]) {
                  loadExtents.push([
                      loadExtent[0] + worldWidth,
                      loadExtent[1],
                      loadExtent[2] + worldWidth,
                      loadExtent[3],
                  ]);
              }
              else if (loadExtent[0] > projectionExtent[0] &&
                  loadExtent[2] > projectionExtent[2]) {
                  loadExtents.push([
                      loadExtent[0] - worldWidth,
                      loadExtent[1],
                      loadExtent[2] - worldWidth,
                      loadExtent[3],
                  ]);
              }
          }
          if (!this.dirty_ &&
              this.renderedResolution_ == resolution &&
              this.renderedRevision_ == vectorLayerRevision &&
              this.renderedRenderOrder_ == vectorLayerRenderOrder &&
              containsExtent(this.renderedExtent_, extent)) {
              this.replayGroupChanged = false;
              return true;
          }
          this.replayGroup_ = null;
          this.dirty_ = false;
          var replayGroup = new BuilderGroup(getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio, vectorLayer.getDeclutter());
          var userProjection = getUserProjection();
          var userTransform;
          if (userProjection) {
              for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
                  vectorSource.loadFeatures(toUserExtent(loadExtents[i], projection), resolution, userProjection);
              }
              userTransform = getTransformFromProjections(userProjection, projection);
          }
          else {
              for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
                  vectorSource.loadFeatures(loadExtents[i], resolution, projection);
              }
          }
          var squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
          /**
           * @param {import("../../Feature.js").default} feature Feature.
           * @this {CanvasVectorLayerRenderer}
           */
          var render = function (feature) {
              var styles;
              var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
              if (styleFunction) {
                  styles = styleFunction(feature, resolution);
              }
              if (styles) {
                  var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform);
                  this.dirty_ = this.dirty_ || dirty;
              }
          }.bind(this);
          var userExtent = toUserExtent(extent, projection);
          /** @type {Array<import("../../Feature.js").default>} */
          var features = vectorSource.getFeaturesInExtent(userExtent);
          if (vectorLayerRenderOrder) {
              features.sort(vectorLayerRenderOrder);
          }
          for (var i = 0, ii = features.length; i < ii; ++i) {
              render(features[i]);
          }
          this.renderedFeatures_ = features;
          var replayGroupInstructions = replayGroup.finish();
          var executorGroup = new ExecutorGroup(extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());
          this.renderedResolution_ = resolution;
          this.renderedRevision_ = vectorLayerRevision;
          this.renderedRenderOrder_ = vectorLayerRenderOrder;
          this.renderedExtent_ = extent;
          this.renderedCenter_ = center;
          this.renderedProjection_ = projection;
          this.replayGroup_ = executorGroup;
          this.hitDetectionImageData_ = null;
          this.replayGroupChanged = true;
          return true;
      };
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} squaredTolerance Squared render tolerance.
       * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
       * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
       * @param {import("../../proj.js").TransformFunction=} opt_transform Transform from user to view projection.
       * @return {boolean} `true` if an image is loading.
       */
      CanvasVectorLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, builderGroup, opt_transform) {
          if (!styles) {
              return false;
          }
          var loading = false;
          if (Array.isArray(styles)) {
              for (var i = 0, ii = styles.length; i < ii; ++i) {
                  loading =
                      renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, opt_transform) || loading;
              }
          }
          else {
              loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, opt_transform);
          }
          return loading;
      };
      return CanvasVectorLayerRenderer;
  }(CanvasLayerRenderer));

  var __extends$F = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Vector data that is rendered client-side.
   * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
   * property on the layer object; for example, setting `title: 'My Title'` in the
   * options means that `title` is observable, and has get/set accessors.
   *
   * @extends {BaseVectorLayer<import("../source/Vector.js").default>}
   * @api
   */
  var VectorLayer = /** @class */ (function (_super) {
      __extends$F(VectorLayer, _super);
      /**
       * @param {import("./BaseVector.js").Options=} opt_options Options.
       */
      function VectorLayer(opt_options) {
          return _super.call(this, opt_options) || this;
      }
      /**
       * Create a renderer for this layer.
       * @return {import("../renderer/Layer.js").default} A layer renderer.
       */
      VectorLayer.prototype.createRenderer = function () {
          return new CanvasVectorLayerRenderer(this);
      };
      return VectorLayer;
  }(BaseVectorLayer));

  /**
   * @module ol/structs/RBush
   */
  /**
   * @typedef {Object} Entry
   * @property {number} minX
   * @property {number} minY
   * @property {number} maxX
   * @property {number} maxY
   * @property {Object} [value]
   */
  /**
   * @classdesc
   * Wrapper around the RBush by Vladimir Agafonkin.
   * See https://github.com/mourner/rbush.
   *
   * @template T
   */
  var RBush = /** @class */ (function () {
      /**
       * @param {number=} opt_maxEntries Max entries.
       */
      function RBush(opt_maxEntries) {
          /**
           * @private
           */
          this.rbush_ = new rbush(opt_maxEntries);
          /**
           * A mapping between the objects added to this rbush wrapper
           * and the objects that are actually added to the internal rbush.
           * @private
           * @type {Object<string, Entry>}
           */
          this.items_ = {};
      }
      /**
       * Insert a value into the RBush.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {T} value Value.
       */
      RBush.prototype.insert = function (extent, value) {
          /** @type {Entry} */
          var item = {
              minX: extent[0],
              minY: extent[1],
              maxX: extent[2],
              maxY: extent[3],
              value: value,
          };
          this.rbush_.insert(item);
          this.items_[getUid(value)] = item;
      };
      /**
       * Bulk-insert values into the RBush.
       * @param {Array<import("../extent.js").Extent>} extents Extents.
       * @param {Array<T>} values Values.
       */
      RBush.prototype.load = function (extents, values) {
          var items = new Array(values.length);
          for (var i = 0, l = values.length; i < l; i++) {
              var extent = extents[i];
              var value = values[i];
              /** @type {Entry} */
              var item = {
                  minX: extent[0],
                  minY: extent[1],
                  maxX: extent[2],
                  maxY: extent[3],
                  value: value,
              };
              items[i] = item;
              this.items_[getUid(value)] = item;
          }
          this.rbush_.load(items);
      };
      /**
       * Remove a value from the RBush.
       * @param {T} value Value.
       * @return {boolean} Removed.
       */
      RBush.prototype.remove = function (value) {
          var uid = getUid(value);
          // get the object in which the value was wrapped when adding to the
          // internal rbush. then use that object to do the removal.
          var item = this.items_[uid];
          delete this.items_[uid];
          return this.rbush_.remove(item) !== null;
      };
      /**
       * Update the extent of a value in the RBush.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {T} value Value.
       */
      RBush.prototype.update = function (extent, value) {
          var item = this.items_[getUid(value)];
          var bbox = [item.minX, item.minY, item.maxX, item.maxY];
          if (!equals$1(bbox, extent)) {
              this.remove(value);
              this.insert(extent, value);
          }
      };
      /**
       * Return all values in the RBush.
       * @return {Array<T>} All.
       */
      RBush.prototype.getAll = function () {
          var items = this.rbush_.all();
          return items.map(function (item) {
              return item.value;
          });
      };
      /**
       * Return all values in the given extent.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {Array<T>} All in extent.
       */
      RBush.prototype.getInExtent = function (extent) {
          /** @type {Entry} */
          var bbox = {
              minX: extent[0],
              minY: extent[1],
              maxX: extent[2],
              maxY: extent[3],
          };
          var items = this.rbush_.search(bbox);
          return items.map(function (item) {
              return item.value;
          });
      };
      /**
       * Calls a callback function with each value in the tree.
       * If the callback returns a truthy value, this value is returned without
       * checking the rest of the tree.
       * @param {function(T): *} callback Callback.
       * @return {*} Callback return value.
       */
      RBush.prototype.forEach = function (callback) {
          return this.forEach_(this.getAll(), callback);
      };
      /**
       * Calls a callback function with each value in the provided extent.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(T): *} callback Callback.
       * @return {*} Callback return value.
       */
      RBush.prototype.forEachInExtent = function (extent, callback) {
          return this.forEach_(this.getInExtent(extent), callback);
      };
      /**
       * @param {Array<T>} values Values.
       * @param {function(T): *} callback Callback.
       * @private
       * @return {*} Callback return value.
       */
      RBush.prototype.forEach_ = function (values, callback) {
          var result;
          for (var i = 0, l = values.length; i < l; i++) {
              result = callback(values[i]);
              if (result) {
                  return result;
              }
          }
          return result;
      };
      /**
       * @return {boolean} Is empty.
       */
      RBush.prototype.isEmpty = function () {
          return isEmpty(this.items_);
      };
      /**
       * Remove all values from the RBush.
       */
      RBush.prototype.clear = function () {
          this.rbush_.clear();
          this.items_ = {};
      };
      /**
       * @param {import("../extent.js").Extent=} opt_extent Extent.
       * @return {import("../extent.js").Extent} Extent.
       */
      RBush.prototype.getExtent = function (opt_extent) {
          var data = this.rbush_.toJSON();
          return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
      };
      /**
       * @param {RBush} rbush R-Tree.
       */
      RBush.prototype.concat = function (rbush$$1) {
          this.rbush_.load(rbush$$1.rbush_.all());
          for (var i in rbush$$1.items_) {
              this.items_[i] = rbush$$1.items_[i];
          }
      };
      return RBush;
  }());

  var __extends$G = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * A function that returns a string or an array of strings representing source
   * attributions.
   *
   * @typedef {function(import("../PluggableMap.js").FrameState): (string|Array<string>)} Attribution
   */
  /**
   * A type that can be used to provide attribution information for data sources.
   *
   * It represents either
   * * a simple string (e.g. `' Acme Inc.'`)
   * * an array of simple strings (e.g. `[' Acme Inc.', ' Bacme Inc.']`)
   * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
   *
   * @typedef {string|Array<string>|Attribution} AttributionLike
   */
  /**
   * @typedef {Object} Options
   * @property {AttributionLike} [attributions]
   * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
   * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
   * @property {import("./State.js").default} [state='ready']
   * @property {boolean} [wrapX=false]
   */
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Base class for {@link module:ol/layer/Layer~Layer} sources.
   *
   * A generic `change` event is triggered when the state of the source changes.
   * @abstract
   * @api
   */
  var Source = /** @class */ (function (_super) {
      __extends$G(Source, _super);
      /**
       * @param {Options} options Source options.
       */
      function Source(options) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {import("../proj/Projection.js").default}
           */
          _this.projection_ = get$3(options.projection);
          /**
           * @private
           * @type {?Attribution}
           */
          _this.attributions_ = adaptAttributions(options.attributions);
          /**
           * @private
           * @type {boolean}
           */
          _this.attributionsCollapsible_ =
              options.attributionsCollapsible !== undefined
                  ? options.attributionsCollapsible
                  : true;
          /**
           * This source is currently loading data. Sources that defer loading to the
           * map's tile queue never set this to `true`.
           * @type {boolean}
           */
          _this.loading = false;
          /**
           * @private
           * @type {import("./State.js").default}
           */
          _this.state_ =
              options.state !== undefined ? options.state : SourceState.READY;
          /**
           * @private
           * @type {boolean}
           */
          _this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
          return _this;
      }
      /**
       * Get the attribution function for the source.
       * @return {?Attribution} Attribution function.
       */
      Source.prototype.getAttributions = function () {
          return this.attributions_;
      };
      /**
       * @return {boolean} Attributions are collapsible.
       */
      Source.prototype.getAttributionsCollapsible = function () {
          return this.attributionsCollapsible_;
      };
      /**
       * Get the projection of the source.
       * @return {import("../proj/Projection.js").default} Projection.
       * @api
       */
      Source.prototype.getProjection = function () {
          return this.projection_;
      };
      /**
       * @abstract
       * @return {Array<number>|undefined} Resolutions.
       */
      Source.prototype.getResolutions = function () {
          return abstract();
      };
      /**
       * Get the state of the source, see {@link module:ol/source/State~State} for possible states.
       * @return {import("./State.js").default} State.
       * @api
       */
      Source.prototype.getState = function () {
          return this.state_;
      };
      /**
       * @return {boolean|undefined} Wrap X.
       */
      Source.prototype.getWrapX = function () {
          return this.wrapX_;
      };
      /**
       * @return {Object|undefined} Context options.
       */
      Source.prototype.getContextOptions = function () {
          return undefined;
      };
      /**
       * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
       * @api
       */
      Source.prototype.refresh = function () {
          this.changed();
      };
      /**
       * Set the attributions of the source.
       * @param {AttributionLike|undefined} attributions Attributions.
       *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
       *     or `undefined`.
       * @api
       */
      Source.prototype.setAttributions = function (attributions) {
          this.attributions_ = adaptAttributions(attributions);
          this.changed();
      };
      /**
       * Set the state of the source.
       * @param {import("./State.js").default} state State.
       */
      Source.prototype.setState = function (state) {
          this.state_ = state;
          this.changed();
      };
      return Source;
  }(BaseObject));
  /**
   * Turns the attributions option into an attributions function.
   * @param {AttributionLike|undefined} attributionLike The attribution option.
   * @return {?Attribution} An attribution function (or null).
   */
  function adaptAttributions(attributionLike) {
      if (!attributionLike) {
          return null;
      }
      if (Array.isArray(attributionLike)) {
          return function (frameState) {
              return attributionLike;
          };
      }
      if (typeof attributionLike === 'function') {
          return attributionLike;
      }
      return function (frameState) {
          return [attributionLike];
      };
  }

  /**
   * @module ol/source/VectorEventType
   */
  /**
   * @enum {string}
   */
  var VectorEventType = {
      /**
       * Triggered when a feature is added to the source.
       * @event module:ol/source/Vector.VectorSourceEvent#addfeature
       * @api
       */
      ADDFEATURE: 'addfeature',
      /**
       * Triggered when a feature is updated.
       * @event module:ol/source/Vector.VectorSourceEvent#changefeature
       * @api
       */
      CHANGEFEATURE: 'changefeature',
      /**
       * Triggered when the clear method is called on the source.
       * @event module:ol/source/Vector.VectorSourceEvent#clear
       * @api
       */
      CLEAR: 'clear',
      /**
       * Triggered when a feature is removed from the source.
       * See {@link module:ol/source/Vector#clear source.clear()} for exceptions.
       * @event module:ol/source/Vector.VectorSourceEvent#removefeature
       * @api
       */
      REMOVEFEATURE: 'removefeature',
  };

  /**
   * @module ol/loadingstrategy
   */
  /**
   * Strategy function for loading all features with a single request.
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @return {Array<import("./extent.js").Extent>} Extents.
   * @api
   */
  function all$1(extent, resolution) {
      return [[-Infinity, -Infinity, Infinity, Infinity]];
  }

  /**
   * @module ol/format/FormatType
   */
  /**
   * @enum {string}
   */
  var FormatType = {
      ARRAY_BUFFER: 'arraybuffer',
      JSON: 'json',
      TEXT: 'text',
      XML: 'xml',
  };

  /**
   * @module ol/featureloader
   */
  /**
   *
   * @type {boolean}
   * @private
   */
  var withCredentials = false;
  /**
   * {@link module:ol/source/Vector} sources use a function of this type to
   * load features.
   *
   * This function takes an {@link module:ol/extent~Extent} representing the area to be loaded,
   * a `{number}` representing the resolution (map units per pixel) and an
   * {@link module:ol/proj/Projection} for the projection  as
   * arguments. `this` within the function is bound to the
   * {@link module:ol/source/Vector} it's called from.
   *
   * The function is responsible for loading the features and adding them to the
   * source.
   * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default), import("./extent.js").Extent, number,
   *                    import("./proj/Projection.js").default): void} FeatureLoader
   * @api
   */
  /**
   * {@link module:ol/source/Vector} sources use a function of this type to
   * get the url to load features from.
   *
   * This function takes an {@link module:ol/extent~Extent} representing the area
   * to be loaded, a `{number}` representing the resolution (map units per pixel)
   * and an {@link module:ol/proj/Projection} for the projection  as
   * arguments and returns a `{string}` representing the URL.
   * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
   * @api
   */
  /**
   * @param {string|FeatureUrlFunction} url Feature URL service.
   * @param {import("./format/Feature.js").default} format Feature format.
   * @param {function(this:import("./VectorTile.js").default, Array<import("./Feature.js").default>, import("./proj/Projection.js").default, import("./extent.js").Extent): void|function(this:import("./source/Vector").default, Array<import("./Feature.js").default>): void} success
   *     Function called with the loaded features and optionally with the data
   *     projection. Called with the vector tile or source as `this`.
   * @param {function(this:import("./VectorTile.js").default): void|function(this:import("./source/Vector").default): void} failure
   *     Function called when loading failed. Called with the vector tile or
   *     source as `this`.
   * @return {FeatureLoader} The feature loader.
   */
  function loadFeaturesXhr(url, format, success, failure) {
      return (
      /**
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {number} resolution Resolution.
       * @param {import("./proj/Projection.js").default} projection Projection.
       * @this {import("./source/Vector").default|import("./VectorTile.js").default}
       */
      function (extent, resolution, projection) {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);
          if (format.getType() == FormatType.ARRAY_BUFFER) {
              xhr.responseType = 'arraybuffer';
          }
          xhr.withCredentials = withCredentials;
          /**
           * @param {Event} event Event.
           * @private
           */
          xhr.onload = function (event) {
              // status will be 0 for file:// urls
              if (!xhr.status || (xhr.status >= 200 && xhr.status < 300)) {
                  var type = format.getType();
                  /** @type {Document|Node|Object|string|undefined} */
                  var source = void 0;
                  if (type == FormatType.JSON || type == FormatType.TEXT) {
                      source = xhr.responseText;
                  }
                  else if (type == FormatType.XML) {
                      source = xhr.responseXML;
                      if (!source) {
                          source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
                      }
                  }
                  else if (type == FormatType.ARRAY_BUFFER) {
                      source = /** @type {ArrayBuffer} */ (xhr.response);
                  }
                  if (source) {
                      success.call(this, format.readFeatures(source, {
                          extent: extent,
                          featureProjection: projection,
                      }), format.readProjection(source));
                  }
                  else {
                      failure.call(this);
                  }
              }
              else {
                  failure.call(this);
              }
          }.bind(this);
          /**
           * @private
           */
          xhr.onerror = function () {
              failure.call(this);
          }.bind(this);
          xhr.send();
      });
  }
  /**
   * Create an XHR feature loader for a `url` and `format`. The feature loader
   * loads features (with XHR), parses the features, and adds them to the
   * vector source.
   * @param {string|FeatureUrlFunction} url Feature URL service.
   * @param {import("./format/Feature.js").default} format Feature format.
   * @return {FeatureLoader} The feature loader.
   * @api
   */
  function xhr(url, format) {
      return loadFeaturesXhr(url, format, 
      /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       * @this {import("./source/Vector").default|import("./VectorTile.js").default}
       */
      function (features, dataProjection) {
          var sourceOrTile = /** @type {?} */ (this);
          if (typeof sourceOrTile.addFeatures === 'function') {
              /** @type {import("./source/Vector").default} */ (sourceOrTile).addFeatures(features);
          }
      }, 
      /* FIXME handle error */ VOID);
  }

  /**
   * @module ol/source/Vector
   */
  var __extends$H = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
   * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
   * is one of the standard {@link module:ol/loadingstrategy} strategies.
   *
   * @typedef {function(import("../extent.js").Extent, number): Array<import("../extent.js").Extent>} LoadingStrategy
   * @api
   */
  /**
   * @classdesc
   * Events emitted by {@link module:ol/source/Vector} instances are instances of this
   * type.
   * @template {import("../geom/Geometry.js").default} Geometry
   */
  var VectorSourceEvent = /** @class */ (function (_super) {
      __extends$H(VectorSourceEvent, _super);
      /**
       * @param {string} type Type.
       * @param {import("../Feature.js").default<Geometry>=} opt_feature Feature.
       */
      function VectorSourceEvent(type, opt_feature) {
          var _this = _super.call(this, type) || this;
          /**
           * The feature being added or removed.
           * @type {import("../Feature.js").default<Geometry>|undefined}
           * @api
           */
          _this.feature = opt_feature;
          return _this;
      }
      return VectorSourceEvent;
  }(BaseEvent));
  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
   * @property {Array<import("../Feature.js").default>|Collection<import("../Feature.js").default>} [features]
   * Features. If provided as {@link module:ol/Collection}, the features in the source
   * and the collection will stay in sync.
   * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
   * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
   * @property {import("../featureloader.js").FeatureLoader} [loader]
   * The loader function used to load features, from a remote source for example.
   * If this is not set and `url` is set, the source will create and use an XHR
   * feature loader.
   *
   * Example:
   *
   * ```js
   * import {Vector} from 'ol/source';
   * import {GeoJSON} from 'ol/format';
   * import {bbox} from 'ol/loadingstrategy';
   *
   * var vectorSource = new Vector({
   *   format: new GeoJSON(),
   *   loader: function(extent, resolution, projection) {
   *      var proj = projection.getCode();
   *      var url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
   *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
   *          'outputFormat=application/json&srsname=' + proj + '&' +
   *          'bbox=' + extent.join(',') + ',' + proj;
   *      var xhr = new XMLHttpRequest();
   *      xhr.open('GET', url);
   *      var onError = function() {
   *        vectorSource.removeLoadedExtent(extent);
   *      }
   *      xhr.onerror = onError;
   *      xhr.onload = function() {
   *        if (xhr.status == 200) {
   *          vectorSource.addFeatures(
   *              vectorSource.getFormat().readFeatures(xhr.responseText));
   *        } else {
   *          onError();
   *        }
   *      }
   *      xhr.send();
   *    },
   *    strategy: bbox
   *  });
   * ```
   * @property {boolean} [overlaps=true] This source may have overlapping geometries.
   * Setting this to `false` (e.g. for sources with polygons that represent administrative
   * boundaries or TopoJSON sources) allows the renderer to optimise fill and
   * stroke operations.
   * @property {LoadingStrategy} [strategy] The loading strategy to use.
   * By default an {@link module:ol/loadingstrategy~all}
   * strategy is used, a one-off strategy which loads all features at once.
   * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
   * Setting this option instructs the source to load features using an XHR loader
   * (see {@link module:ol/featureloader~xhr}). Use a `string` and an
   * {@link module:ol/loadingstrategy~all} for a one-off download of all features from
   * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
   * other loading strategies.
   * Requires `format` to be set as well.
   * When default XHR feature loader is provided, the features will
   * be transformed from the data projection to the view projection
   * during parsing. If your remote data source does not advertise its projection
   * properly, this transformation will be incorrect. For some formats, the
   * default projection (usually EPSG:4326) can be overridden by setting the
   * dataProjection constructor option on the format.
   * Note that if a source contains non-feature data, such as a GeoJSON geometry
   * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
   * @property {boolean} [useSpatialIndex=true]
   * By default, an RTree is used as spatial index. When features are removed and
   * added frequently, and the total number of features is low, setting this to
   * `false` may improve performance.
   *
   * Note that
   * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
   * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
   * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
   * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
   * through all features.
   *
   * When set to `false`, the features will be maintained in an
   * {@link module:ol/Collection}, which can be retrieved through
   * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
   * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
   * -180 and 180 meridians to work properly, this should be set to `false`. The
   * resulting geometry coordinates will then exceed the world bounds.
   */
  /**
   * @classdesc
   * Provides a source of features for vector layers. Vector features provided
   * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
   * vector data that is optimized for rendering.
   *
   * @fires VectorSourceEvent
   * @api
   * @template {import("../geom/Geometry.js").default} Geometry
   */
  var VectorSource = /** @class */ (function (_super) {
      __extends$H(VectorSource, _super);
      /**
       * @param {Options=} opt_options Vector source options.
       */
      function VectorSource(opt_options) {
          var _this = this;
          var options = opt_options || {};
          _this = _super.call(this, {
              attributions: options.attributions,
              projection: undefined,
              state: SourceState.READY,
              wrapX: options.wrapX !== undefined ? options.wrapX : true,
          }) || this;
          /**
           * @private
           * @type {import("../featureloader.js").FeatureLoader}
           */
          _this.loader_ = VOID;
          /**
           * @private
           * @type {import("../format/Feature.js").default|undefined}
           */
          _this.format_ = options.format;
          /**
           * @private
           * @type {boolean}
           */
          _this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;
          /**
           * @private
           * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
           */
          _this.url_ = options.url;
          if (options.loader !== undefined) {
              _this.loader_ = options.loader;
          }
          else if (_this.url_ !== undefined) {
              assert(_this.format_, 7); // `format` must be set when `url` is set
              // create a XHR feature loader for "url" and "format"
              _this.loader_ = xhr(_this.url_, 
              /** @type {import("../format/Feature.js").default} */ (_this.format_));
          }
          /**
           * @private
           * @type {LoadingStrategy}
           */
          _this.strategy_ =
              options.strategy !== undefined ? options.strategy : all$1;
          var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;
          /**
           * @private
           * @type {RBush<import("../Feature.js").default<Geometry>>}
           */
          _this.featuresRtree_ = useSpatialIndex ? new RBush() : null;
          /**
           * @private
           * @type {RBush<{extent: import("../extent.js").Extent}>}
           */
          _this.loadedExtentsRtree_ = new RBush();
          /**
           * @private
           * @type {!Object<string, import("../Feature.js").default<Geometry>>}
           */
          _this.nullGeometryFeatures_ = {};
          /**
           * A lookup of features by id (the return from feature.getId()).
           * @private
           * @type {!Object<string, import("../Feature.js").default<Geometry>>}
           */
          _this.idIndex_ = {};
          /**
           * A lookup of features by uid (using getUid(feature)).
           * @private
           * @type {!Object<string, import("../Feature.js").default<Geometry>>}
           */
          _this.uidIndex_ = {};
          /**
           * @private
           * @type {Object<string, Array<import("../events.js").EventsKey>>}
           */
          _this.featureChangeKeys_ = {};
          /**
           * @private
           * @type {Collection<import("../Feature.js").default<Geometry>>}
           */
          _this.featuresCollection_ = null;
          var collection, features;
          if (Array.isArray(options.features)) {
              features = options.features;
          }
          else if (options.features) {
              collection = options.features;
              features = collection.getArray();
          }
          if (!useSpatialIndex && collection === undefined) {
              collection = new Collection(features);
          }
          if (features !== undefined) {
              _this.addFeaturesInternal(features);
          }
          if (collection !== undefined) {
              _this.bindFeaturesCollection_(collection);
          }
          return _this;
      }
      /**
       * Add a single feature to the source.  If you want to add a batch of features
       * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
       * instead. A feature will not be added to the source if feature with
       * the same id is already there. The reason for this behavior is to avoid
       * feature duplication when using bbox or tile loading strategies.
       * Note: this also applies if an {@link module:ol/Collection} is used for features,
       * meaning that if a feature with a duplicate id is added in the collection, it will
       * be removed from it right away.
       * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
       * @api
       */
      VectorSource.prototype.addFeature = function (feature) {
          this.addFeatureInternal(feature);
          this.changed();
      };
      /**
       * Add a feature without firing a `change` event.
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       * @protected
       */
      VectorSource.prototype.addFeatureInternal = function (feature) {
          var featureKey = getUid(feature);
          if (!this.addToIndex_(featureKey, feature)) {
              if (this.featuresCollection_) {
                  this.featuresCollection_.remove(feature);
              }
              return;
          }
          this.setupChangeEvents_(featureKey, feature);
          var geometry = feature.getGeometry();
          if (geometry) {
              var extent = geometry.getExtent();
              if (this.featuresRtree_) {
                  this.featuresRtree_.insert(extent, feature);
              }
          }
          else {
              this.nullGeometryFeatures_[featureKey] = feature;
          }
          this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, feature));
      };
      /**
       * @param {string} featureKey Unique identifier for the feature.
       * @param {import("../Feature.js").default<Geometry>} feature The feature.
       * @private
       */
      VectorSource.prototype.setupChangeEvents_ = function (featureKey, feature) {
          this.featureChangeKeys_[featureKey] = [
              listen(feature, EventType.CHANGE, this.handleFeatureChange_, this),
              listen(feature, ObjectEventType.PROPERTYCHANGE, this.handleFeatureChange_, this),
          ];
      };
      /**
       * @param {string} featureKey Unique identifier for the feature.
       * @param {import("../Feature.js").default<Geometry>} feature The feature.
       * @return {boolean} The feature is "valid", in the sense that it is also a
       *     candidate for insertion into the Rtree.
       * @private
       */
      VectorSource.prototype.addToIndex_ = function (featureKey, feature) {
          var valid = true;
          var id = feature.getId();
          if (id !== undefined) {
              if (!(id.toString() in this.idIndex_)) {
                  this.idIndex_[id.toString()] = feature;
              }
              else {
                  valid = false;
              }
          }
          if (valid) {
              assert(!(featureKey in this.uidIndex_), 30); // The passed `feature` was already added to the source
              this.uidIndex_[featureKey] = feature;
          }
          return valid;
      };
      /**
       * Add a batch of features to the source.
       * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
       * @api
       */
      VectorSource.prototype.addFeatures = function (features) {
          this.addFeaturesInternal(features);
          this.changed();
      };
      /**
       * Add features without firing a `change` event.
       * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
       * @protected
       */
      VectorSource.prototype.addFeaturesInternal = function (features) {
          var extents = [];
          var newFeatures = [];
          var geometryFeatures = [];
          for (var i = 0, length_1 = features.length; i < length_1; i++) {
              var feature = features[i];
              var featureKey = getUid(feature);
              if (this.addToIndex_(featureKey, feature)) {
                  newFeatures.push(feature);
              }
          }
          for (var i = 0, length_2 = newFeatures.length; i < length_2; i++) {
              var feature = newFeatures[i];
              var featureKey = getUid(feature);
              this.setupChangeEvents_(featureKey, feature);
              var geometry = feature.getGeometry();
              if (geometry) {
                  var extent = geometry.getExtent();
                  extents.push(extent);
                  geometryFeatures.push(feature);
              }
              else {
                  this.nullGeometryFeatures_[featureKey] = feature;
              }
          }
          if (this.featuresRtree_) {
              this.featuresRtree_.load(extents, geometryFeatures);
          }
          for (var i = 0, length_3 = newFeatures.length; i < length_3; i++) {
              this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i]));
          }
      };
      /**
       * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
       * @private
       */
      VectorSource.prototype.bindFeaturesCollection_ = function (collection) {
          var modifyingCollection = false;
          this.addEventListener(VectorEventType.ADDFEATURE, 
          /**
           * @param {VectorSourceEvent<Geometry>} evt The vector source event
           */
          function (evt) {
              if (!modifyingCollection) {
                  modifyingCollection = true;
                  collection.push(evt.feature);
                  modifyingCollection = false;
              }
          });
          this.addEventListener(VectorEventType.REMOVEFEATURE, 
          /**
           * @param {VectorSourceEvent<Geometry>} evt The vector source event
           */
          function (evt) {
              if (!modifyingCollection) {
                  modifyingCollection = true;
                  collection.remove(evt.feature);
                  modifyingCollection = false;
              }
          });
          collection.addEventListener(CollectionEventType.ADD, 
          /**
           * @param {import("../Collection.js").CollectionEvent} evt The collection event
           */
          function (evt) {
              if (!modifyingCollection) {
                  modifyingCollection = true;
                  this.addFeature(
                  /** @type {import("../Feature.js").default<Geometry>} */ (evt.element));
                  modifyingCollection = false;
              }
          }.bind(this));
          collection.addEventListener(CollectionEventType.REMOVE, 
          /**
           * @param {import("../Collection.js").CollectionEvent} evt The collection event
           */
          function (evt) {
              if (!modifyingCollection) {
                  modifyingCollection = true;
                  this.removeFeature(
                  /** @type {import("../Feature.js").default<Geometry>} */ (evt.element));
                  modifyingCollection = false;
              }
          }.bind(this));
          this.featuresCollection_ = collection;
      };
      /**
       * Remove all features from the source.
       * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.
       * @api
       */
      VectorSource.prototype.clear = function (opt_fast) {
          if (opt_fast) {
              for (var featureId in this.featureChangeKeys_) {
                  var keys = this.featureChangeKeys_[featureId];
                  keys.forEach(unlistenByKey);
              }
              if (!this.featuresCollection_) {
                  this.featureChangeKeys_ = {};
                  this.idIndex_ = {};
                  this.uidIndex_ = {};
              }
          }
          else {
              if (this.featuresRtree_) {
                  this.featuresRtree_.forEach(this.removeFeatureInternal.bind(this));
                  for (var id in this.nullGeometryFeatures_) {
                      this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
                  }
              }
          }
          if (this.featuresCollection_) {
              this.featuresCollection_.clear();
          }
          if (this.featuresRtree_) {
              this.featuresRtree_.clear();
          }
          this.nullGeometryFeatures_ = {};
          var clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);
          this.dispatchEvent(clearEvent);
          this.changed();
      };
      /**
       * Iterate through all features on the source, calling the provided callback
       * with each one.  If the callback returns any "truthy" value, iteration will
       * stop and the function will return the same value.
       * Note: this function only iterate through the feature that have a defined geometry.
       *
       * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
       *     on the source.  Return a truthy value to stop iteration.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      VectorSource.prototype.forEachFeature = function (callback) {
          if (this.featuresRtree_) {
              return this.featuresRtree_.forEach(callback);
          }
          else if (this.featuresCollection_) {
              this.featuresCollection_.forEach(callback);
          }
      };
      /**
       * Iterate through all features whose geometries contain the provided
       * coordinate, calling the callback with each feature.  If the callback returns
       * a "truthy" value, iteration will stop and the function will return the same
       * value.
       *
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
       *     whose goemetry contains the provided coordinate.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       */
      VectorSource.prototype.forEachFeatureAtCoordinateDirect = function (coordinate, callback) {
          var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
          return this.forEachFeatureInExtent(extent, function (feature) {
              var geometry = feature.getGeometry();
              if (geometry.intersectsCoordinate(coordinate)) {
                  return callback(feature);
              }
              else {
                  return undefined;
              }
          });
      };
      /**
       * Iterate through all features whose bounding box intersects the provided
       * extent (note that the feature's geometry may not intersect the extent),
       * calling the callback with each feature.  If the callback returns a "truthy"
       * value, iteration will stop and the function will return the same value.
       *
       * If you are interested in features whose geometry intersects an extent, call
       * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
       *
       * When `useSpatialIndex` is set to false, this method will loop through all
       * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
       *     whose bounding box intersects the provided extent.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      VectorSource.prototype.forEachFeatureInExtent = function (extent, callback) {
          if (this.featuresRtree_) {
              return this.featuresRtree_.forEachInExtent(extent, callback);
          }
          else if (this.featuresCollection_) {
              this.featuresCollection_.forEach(callback);
          }
      };
      /**
       * Iterate through all features whose geometry intersects the provided extent,
       * calling the callback with each feature.  If the callback returns a "truthy"
       * value, iteration will stop and the function will return the same value.
       *
       * If you only want to test for bounding box intersection, call the
       * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
       *     whose geometry intersects the provided extent.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      VectorSource.prototype.forEachFeatureIntersectingExtent = function (extent, callback) {
          return this.forEachFeatureInExtent(extent, 
          /**
           * @param {import("../Feature.js").default<Geometry>} feature Feature.
           * @return {T|undefined} The return value from the last call to the callback.
           */
          function (feature) {
              var geometry = feature.getGeometry();
              if (geometry.intersectsExtent(extent)) {
                  var result = callback(feature);
                  if (result) {
                      return result;
                  }
              }
          });
      };
      /**
       * Get the features collection associated with this source. Will be `null`
       * unless the source was configured with `useSpatialIndex` set to `false`, or
       * with an {@link module:ol/Collection} as `features`.
       * @return {Collection<import("../Feature.js").default<Geometry>>} The collection of features.
       * @api
       */
      VectorSource.prototype.getFeaturesCollection = function () {
          return this.featuresCollection_;
      };
      /**
       * Get all features on the source in random order.
       * @return {Array<import("../Feature.js").default<Geometry>>} Features.
       * @api
       */
      VectorSource.prototype.getFeatures = function () {
          var features;
          if (this.featuresCollection_) {
              features = this.featuresCollection_.getArray();
          }
          else if (this.featuresRtree_) {
              features = this.featuresRtree_.getAll();
              if (!isEmpty(this.nullGeometryFeatures_)) {
                  extend$1(features, getValues(this.nullGeometryFeatures_));
              }
          }
          return /** @type {Array<import("../Feature.js").default<Geometry>>} */ (features);
      };
      /**
       * Get all features whose geometry intersects the provided coordinate.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {Array<import("../Feature.js").default<Geometry>>} Features.
       * @api
       */
      VectorSource.prototype.getFeaturesAtCoordinate = function (coordinate) {
          var features = [];
          this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {
              features.push(feature);
          });
          return features;
      };
      /**
       * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
       * all features intersecting the given extent in random order (so it may include
       * features whose geometries do not intersect the extent).
       *
       * When `useSpatialIndex` is set to false, this method will return all
       * features.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {Array<import("../Feature.js").default<Geometry>>} Features.
       * @api
       */
      VectorSource.prototype.getFeaturesInExtent = function (extent) {
          if (this.featuresRtree_) {
              return this.featuresRtree_.getInExtent(extent);
          }
          else if (this.featuresCollection_) {
              return this.featuresCollection_.getArray();
          }
          else {
              return [];
          }
      };
      /**
       * Get the closest feature to the provided coordinate.
       *
       * This method is not available when the source is configured with
       * `useSpatialIndex` set to `false`.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {function(import("../Feature.js").default<Geometry>):boolean=} opt_filter Feature filter function.
       *     The filter function will receive one argument, the {@link module:ol/Feature feature}
       *     and it should return a boolean value. By default, no filtering is made.
       * @return {import("../Feature.js").default<Geometry>} Closest feature.
       * @api
       */
      VectorSource.prototype.getClosestFeatureToCoordinate = function (coordinate, opt_filter) {
          // Find the closest feature using branch and bound.  We start searching an
          // infinite extent, and find the distance from the first feature found.  This
          // becomes the closest feature.  We then compute a smaller extent which any
          // closer feature must intersect.  We continue searching with this smaller
          // extent, trying to find a closer feature.  Every time we find a closer
          // feature, we update the extent being searched so that any even closer
          // feature must intersect it.  We continue until we run out of features.
          var x = coordinate[0];
          var y = coordinate[1];
          var closestFeature = null;
          var closestPoint = [NaN, NaN];
          var minSquaredDistance = Infinity;
          var extent = [-Infinity, -Infinity, Infinity, Infinity];
          var filter = opt_filter ? opt_filter : TRUE;
          this.featuresRtree_.forEachInExtent(extent, 
          /**
           * @param {import("../Feature.js").default<Geometry>} feature Feature.
           */
          function (feature) {
              if (filter(feature)) {
                  var geometry = feature.getGeometry();
                  var previousMinSquaredDistance = minSquaredDistance;
                  minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
                  if (minSquaredDistance < previousMinSquaredDistance) {
                      closestFeature = feature;
                      // This is sneaky.  Reduce the extent that it is currently being
                      // searched while the R-Tree traversal using this same extent object
                      // is still in progress.  This is safe because the new extent is
                      // strictly contained by the old extent.
                      var minDistance = Math.sqrt(minSquaredDistance);
                      extent[0] = x - minDistance;
                      extent[1] = y - minDistance;
                      extent[2] = x + minDistance;
                      extent[3] = y + minDistance;
                  }
              }
          });
          return closestFeature;
      };
      /**
       * Get the extent of the features currently in the source.
       *
       * This method is not available when the source is configured with
       * `useSpatialIndex` set to `false`.
       * @param {import("../extent.js").Extent=} opt_extent Destination extent. If provided, no new extent
       *     will be created. Instead, that extent's coordinates will be overwritten.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      VectorSource.prototype.getExtent = function (opt_extent) {
          return this.featuresRtree_.getExtent(opt_extent);
      };
      /**
       * Get a feature by its identifier (the value returned by feature.getId()).
       * Note that the index treats string and numeric identifiers as the same.  So
       * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
       *
       * @param {string|number} id Feature identifier.
       * @return {import("../Feature.js").default<Geometry>} The feature (or `null` if not found).
       * @api
       */
      VectorSource.prototype.getFeatureById = function (id) {
          var feature = this.idIndex_[id.toString()];
          return feature !== undefined ? feature : null;
      };
      /**
       * Get a feature by its internal unique identifier (using `getUid`).
       *
       * @param {string} uid Feature identifier.
       * @return {import("../Feature.js").default<Geometry>} The feature (or `null` if not found).
       */
      VectorSource.prototype.getFeatureByUid = function (uid) {
          var feature = this.uidIndex_[uid];
          return feature !== undefined ? feature : null;
      };
      /**
       * Get the format associated with this source.
       *
       * @return {import("../format/Feature.js").default|undefined} The feature format.
       * @api
       */
      VectorSource.prototype.getFormat = function () {
          return this.format_;
      };
      /**
       * @return {boolean} The source can have overlapping geometries.
       */
      VectorSource.prototype.getOverlaps = function () {
          return this.overlaps_;
      };
      /**
       * Get the url associated with this source.
       *
       * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
       * @api
       */
      VectorSource.prototype.getUrl = function () {
          return this.url_;
      };
      /**
       * @param {Event} event Event.
       * @private
       */
      VectorSource.prototype.handleFeatureChange_ = function (event) {
          var feature = /** @type {import("../Feature.js").default<Geometry>} */ (event.target);
          var featureKey = getUid(feature);
          var geometry = feature.getGeometry();
          if (!geometry) {
              if (!(featureKey in this.nullGeometryFeatures_)) {
                  if (this.featuresRtree_) {
                      this.featuresRtree_.remove(feature);
                  }
                  this.nullGeometryFeatures_[featureKey] = feature;
              }
          }
          else {
              var extent = geometry.getExtent();
              if (featureKey in this.nullGeometryFeatures_) {
                  delete this.nullGeometryFeatures_[featureKey];
                  if (this.featuresRtree_) {
                      this.featuresRtree_.insert(extent, feature);
                  }
              }
              else {
                  if (this.featuresRtree_) {
                      this.featuresRtree_.update(extent, feature);
                  }
              }
          }
          var id = feature.getId();
          if (id !== undefined) {
              var sid = id.toString();
              if (this.idIndex_[sid] !== feature) {
                  this.removeFromIdIndex_(feature);
                  this.idIndex_[sid] = feature;
              }
          }
          else {
              this.removeFromIdIndex_(feature);
              this.uidIndex_[featureKey] = feature;
          }
          this.changed();
          this.dispatchEvent(new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature));
      };
      /**
       * Returns true if the feature is contained within the source.
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       * @return {boolean} Has feature.
       * @api
       */
      VectorSource.prototype.hasFeature = function (feature) {
          var id = feature.getId();
          if (id !== undefined) {
              return id in this.idIndex_;
          }
          else {
              return getUid(feature) in this.uidIndex_;
          }
      };
      /**
       * @return {boolean} Is empty.
       */
      VectorSource.prototype.isEmpty = function () {
          return this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_);
      };
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} resolution Resolution.
       * @param {import("../proj/Projection.js").default} projection Projection.
       */
      VectorSource.prototype.loadFeatures = function (extent, resolution, projection) {
          var loadedExtentsRtree = this.loadedExtentsRtree_;
          var extentsToLoad = this.strategy_(extent, resolution);
          this.loading = false;
          var _loop_1 = function (i, ii) {
              var extentToLoad = extentsToLoad[i];
              var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad, 
              /**
               * @param {{extent: import("../extent.js").Extent}} object Object.
               * @return {boolean} Contains.
               */
              function (object) {
                  return containsExtent(object.extent, extentToLoad);
              });
              if (!alreadyLoaded) {
                  this_1.loader_.call(this_1, extentToLoad, resolution, projection);
                  loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
                  this_1.loading = this_1.loader_ !== VOID;
              }
          };
          var this_1 = this;
          for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) {
              _loop_1(i, ii);
          }
      };
      VectorSource.prototype.refresh = function () {
          this.clear(true);
          this.loadedExtentsRtree_.clear();
          _super.prototype.refresh.call(this);
      };
      /**
       * Remove an extent from the list of loaded extents.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */
      VectorSource.prototype.removeLoadedExtent = function (extent) {
          var loadedExtentsRtree = this.loadedExtentsRtree_;
          var obj;
          loadedExtentsRtree.forEachInExtent(extent, function (object) {
              if (equals$1(object.extent, extent)) {
                  obj = object;
                  return true;
              }
          });
          if (obj) {
              loadedExtentsRtree.remove(obj);
          }
      };
      /**
       * Remove a single feature from the source.  If you want to remove all features
       * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
       * instead.
       * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
       * @api
       */
      VectorSource.prototype.removeFeature = function (feature) {
          var featureKey = getUid(feature);
          if (featureKey in this.nullGeometryFeatures_) {
              delete this.nullGeometryFeatures_[featureKey];
          }
          else {
              if (this.featuresRtree_) {
                  this.featuresRtree_.remove(feature);
              }
          }
          this.removeFeatureInternal(feature);
          this.changed();
      };
      /**
       * Remove feature without firing a `change` event.
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       * @protected
       */
      VectorSource.prototype.removeFeatureInternal = function (feature) {
          var featureKey = getUid(feature);
          this.featureChangeKeys_[featureKey].forEach(unlistenByKey);
          delete this.featureChangeKeys_[featureKey];
          var id = feature.getId();
          if (id !== undefined) {
              delete this.idIndex_[id.toString()];
          }
          delete this.uidIndex_[featureKey];
          this.dispatchEvent(new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature));
      };
      /**
       * Remove a feature from the id index.  Called internally when the feature id
       * may have changed.
       * @param {import("../Feature.js").default<Geometry>} feature The feature.
       * @return {boolean} Removed the feature from the index.
       * @private
       */
      VectorSource.prototype.removeFromIdIndex_ = function (feature) {
          var removed = false;
          for (var id in this.idIndex_) {
              if (this.idIndex_[id] === feature) {
                  delete this.idIndex_[id];
                  removed = true;
                  break;
              }
          }
          return removed;
      };
      /**
       * Set the new loader of the source. The next render cycle will use the
       * new loader.
       * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
       * @api
       */
      VectorSource.prototype.setLoader = function (loader) {
          this.loader_ = loader;
      };
      /**
       * Points the source to a new url. The next render cycle will use the new url.
       * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
       * @api
       */
      VectorSource.prototype.setUrl = function (url) {
          assert(this.format_, 7); // `format` must be set when `url` is set
          this.setLoader(xhr(url, this.format_));
      };
      return VectorSource;
  }(Source));

  /**
   * @module ol/events/condition
   */
  /**
   * A function that takes an {@link module:ol/MapBrowserEvent} and returns a
   * `{boolean}`. If the condition is met, true should be returned.
   *
   * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
   */
  /**
   * Creates a condition function that passes when all provided conditions pass.
   * @param {...Condition} var_args Conditions to check.
   * @return {Condition} Condition function.
   */
  function all$2(var_args) {
      var conditions = arguments;
      /**
       * @param {import("../MapBrowserEvent.js").default} event Event.
       * @return {boolean} All conditions passed.
       */
      return function (event) {
          var pass = true;
          for (var i = 0, ii = conditions.length; i < ii; ++i) {
              pass = pass && conditions[i](event);
              if (!pass) {
                  break;
              }
          }
          return pass;
      };
  }
  /**
   * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
   * additionally the shift-key is pressed).
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if only the alt key is pressed.
   * @api
   */
  var altKeyOnly = function (mapBrowserEvent) {
      var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
      return (originalEvent.altKey &&
          !(originalEvent.metaKey || originalEvent.ctrlKey) &&
          !originalEvent.shiftKey);
  };
  /**
   * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
   * (e.g. when additionally the platform-modifier-key is pressed).
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if only the alt and shift keys are pressed.
   * @api
   */
  var altShiftKeysOnly = function (mapBrowserEvent) {
      var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
      return (originalEvent.altKey &&
          !(originalEvent.metaKey || originalEvent.ctrlKey) &&
          originalEvent.shiftKey);
  };
  /**
   * Return `true` if the map has the focus. This condition requires a map target
   * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.
   *
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} The map has the focus.
   * @api
   */
  var focus = function (event) {
      return event.target.getTargetElement().contains(document.activeElement);
  };
  /**
   * Return `true` if the map has the focus or no 'tabindex' attribute set.
   *
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} The map container has the focus or no 'tabindex' attribute.
   */
  var focusWithTabindex = function (event) {
      return event.map.getTargetElement().hasAttribute('tabindex')
          ? focus(event)
          : true;
  };
  /**
   * Return always true.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True.
   * @api
   */
  var always = TRUE;
  /**
   * Return `true` if the event has an "action"-producing mouse button.
   *
   * By definition, this includes left-click on windows/linux, and left-click
   * without the ctrl key on Macs.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} The result.
   */
  var mouseActionButton = function (mapBrowserEvent) {
      var originalEvent = /** @type {MouseEvent} */ (mapBrowserEvent.originalEvent);
      return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);
  };
  /**
   * Return always false.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} False.
   * @api
   */
  var never = FALSE;
  /**
   * Return `true` if the event is a map `singleclick` event, `false` otherwise.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if the event is a map `singleclick` event.
   * @api
   */
  var singleClick = function (mapBrowserEvent) {
      return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;
  };
  /**
   * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
   * pressed.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True only if there no modifier keys are pressed.
   * @api
   */
  var noModifierKeys = function (mapBrowserEvent) {
      var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
      return (!originalEvent.altKey &&
          !(originalEvent.metaKey || originalEvent.ctrlKey) &&
          !originalEvent.shiftKey);
  };
  /**
   * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
   * additionally the alt-key is pressed).
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if only the shift key is pressed.
   * @api
   */
  var shiftKeyOnly = function (mapBrowserEvent) {
      var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
      return (!originalEvent.altKey &&
          !(originalEvent.metaKey || originalEvent.ctrlKey) &&
          originalEvent.shiftKey);
  };
  /**
   * Return `true` if the target element is not editable, i.e. not a `<input>`-,
   * `<select>`- or `<textarea>`-element, `false` otherwise.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True only if the target element is not editable.
   * @api
   */
  var targetNotEditable = function (mapBrowserEvent) {
      var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
      var tagName = /** @type {Element} */ (originalEvent.target).tagName;
      return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA';
  };
  /**
   * Return `true` if the event originates from a mouse device.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if the event originates from a mouse device.
   * @api
   */
  var mouseOnly = function (mapBrowserEvent) {
      var pointerEvent = /** @type {import("../MapBrowserEvent").default} */ (mapBrowserEvent)
          .originalEvent;
      assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
      // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
      return pointerEvent.pointerType == 'mouse';
  };
  /**
   * Return `true` if the event originates from a primary pointer in
   * contact with the surface or if the left mouse button is pressed.
   * See http://www.w3.org/TR/pointerevents/#button-states.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if the event originates from a primary pointer.
   * @api
   */
  var primaryAction = function (mapBrowserEvent) {
      var pointerEvent = /** @type {import("../MapBrowserEvent").default} */ (mapBrowserEvent)
          .originalEvent;
      assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
      return pointerEvent.isPrimary && pointerEvent.button === 0;
  };

  var __extends$I = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("../geom/GeometryType.js").default} type Geometry type of
   * the geometries being drawn with this instance.
   * @property {number} [clickTolerance=6] The maximum distance in pixels between
   * "down" and "up" for a "up" event to be considered a "click" event and
   * actually add a point/vertex to the geometry being drawn.  The default of `6`
   * was chosen for the draw interaction to behave correctly on mouse as well as
   * on touch devices.
   * @property {import("../Collection.js").default<Feature>} [features]
   * Destination collection for the drawn features.
   * @property {VectorSource} [source] Destination source for
   * the drawn features.
   * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown
   * before the current vertex can be dragged to its exact position.
   * @property {number} [snapTolerance=12] Pixel distance for snapping to the
   * drawing finish.
   * @property {boolean} [stopClick=false] Stop click, singleclick, and
   * doubleclick events from firing during drawing.
   * @property {number} [maxPoints] The number of points that can be drawn before
   * a polygon ring or line string is finished. By default there is no
   * restriction.
   * @property {number} [minPoints] The number of points that must be drawn
   * before a polygon ring or line string can be finished. Default is `3` for
   * polygon rings and `2` for line strings.
   * @property {import("../events/condition.js").Condition} [finishCondition] A function
   * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether the drawing can be finished.
   * @property {import("../style/Style.js").StyleLike} [style]
   * Style for sketch features.
   * @property {GeometryFunction} [geometryFunction]
   * Function that is called when a geometry's coordinates are updated.
   * @property {string} [geometryName] Geometry name to use for features created
   * by the draw interaction.
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled.
   * By default {@link module:ol/events/condition~noModifierKeys}, i.e. a click,
   * adds a vertex or deactivates freehand drawing.
   * @property {boolean} [freehand=false] Operate in freehand mode for lines,
   * polygons, and circles.  This makes the interaction always operate in freehand
   * mode and takes precedence over any `freehandCondition` option.
   * @property {import("../events/condition.js").Condition} [freehandCondition]
   * Condition that activates freehand drawing for lines and polygons. This
   * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
   * returns a boolean to indicate whether that event should be handled. The
   * default is {@link module:ol/events/condition~shiftKeyOnly}, meaning that the
   * Shift key activates freehand drawing.
   * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
   * overlay.
   */
  /**
   * Coordinate type when drawing points.
   * @typedef {import("../coordinate.js").Coordinate} PointCoordType
   */
  /**
   * Coordinate type when drawing lines.
   * @typedef {Array<import("../coordinate.js").Coordinate>} LineCoordType
   */
  /**
   * Coordinate type when drawing polygons.
   * @typedef {Array<Array<import("../coordinate.js").Coordinate>>} PolyCoordType
   */
  /**
   * Types used for drawing coordinates.
   * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType
   */
  /**
   * Function that takes an array of coordinates and an optional existing geometry
   * and a projection as arguments, and returns a geometry. The optional existing
   * geometry is the geometry that is returned when the function is called without
   * a second argument.
   * @typedef {function(!SketchCoordType, import("../geom/SimpleGeometry.js").default=,
   *     import("../proj/Projection.js").default=):
   *     import("../geom/SimpleGeometry.js").default} GeometryFunction
   */
  /**
   * Draw mode.  This collapses multi-part geometry types with their single-part
   * cousins.
   * @enum {string}
   */
  var Mode = {
      POINT: 'Point',
      LINE_STRING: 'LineString',
      POLYGON: 'Polygon',
      CIRCLE: 'Circle',
  };
  /**
   * @enum {string}
   */
  var DrawEventType = {
      /**
       * Triggered upon feature draw start
       * @event DrawEvent#drawstart
       * @api
       */
      DRAWSTART: 'drawstart',
      /**
       * Triggered upon feature draw end
       * @event DrawEvent#drawend
       * @api
       */
      DRAWEND: 'drawend',
      /**
       * Triggered upon feature draw abortion
       * @event DrawEvent#drawabort
       * @api
       */
      DRAWABORT: 'drawabort',
  };
  /**
   * @classdesc
   * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are
   * instances of this type.
   */
  var DrawEvent = /** @class */ (function (_super) {
      __extends$I(DrawEvent, _super);
      /**
       * @param {DrawEventType} type Type.
       * @param {Feature} feature The feature drawn.
       */
      function DrawEvent(type, feature) {
          var _this = _super.call(this, type) || this;
          /**
           * The feature being drawn.
           * @type {Feature}
           * @api
           */
          _this.feature = feature;
          return _this;
      }
      return DrawEvent;
  }(BaseEvent));
  /**
   * @classdesc
   * Interaction for drawing feature geometries.
   *
   * @fires DrawEvent
   * @api
   */
  var Draw = /** @class */ (function (_super) {
      __extends$I(Draw, _super);
      /**
       * @param {Options} options Options.
       */
      function Draw(options) {
          var _this = this;
          var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);
          if (!pointerOptions.stopDown) {
              pointerOptions.stopDown = FALSE;
          }
          _this = _super.call(this, pointerOptions) || this;
          /**
           * @type {boolean}
           * @private
           */
          _this.shouldHandle_ = false;
          /**
           * @type {import("../pixel.js").Pixel}
           * @private
           */
          _this.downPx_ = null;
          /**
           * @type {?}
           * @private
           */
          _this.downTimeout_;
          /**
           * @type {number|undefined}
           * @private
           */
          _this.lastDragTime_;
          /**
           * @type {boolean}
           * @private
           */
          _this.freehand_ = false;
          /**
           * Target source for drawn features.
           * @type {VectorSource}
           * @private
           */
          _this.source_ = options.source ? options.source : null;
          /**
           * Target collection for drawn features.
           * @type {import("../Collection.js").default<Feature>}
           * @private
           */
          _this.features_ = options.features ? options.features : null;
          /**
           * Pixel distance for snapping.
           * @type {number}
           * @private
           */
          _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;
          /**
           * Geometry type.
           * @type {import("../geom/GeometryType.js").default}
           * @private
           */
          _this.type_ = /** @type {import("../geom/GeometryType.js").default} */ (options.type);
          /**
           * Drawing mode (derived from geometry type.
           * @type {Mode}
           * @private
           */
          _this.mode_ = getMode(_this.type_);
          /**
           * Stop click, singleclick, and doubleclick events from firing during drawing.
           * Default is `false`.
           * @type {boolean}
           * @private
           */
          _this.stopClick_ = !!options.stopClick;
          /**
           * The number of points that must be drawn before a polygon ring or line
           * string can be finished.  The default is 3 for polygon rings and 2 for
           * line strings.
           * @type {number}
           * @private
           */
          _this.minPoints_ = options.minPoints
              ? options.minPoints
              : _this.mode_ === Mode.POLYGON
                  ? 3
                  : 2;
          /**
           * The number of points that can be drawn before a polygon ring or line string
           * is finished. The default is no restriction.
           * @type {number}
           * @private
           */
          _this.maxPoints_ = options.maxPoints ? options.maxPoints : Infinity;
          /**
           * A function to decide if a potential finish coordinate is permissible
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.finishCondition_ = options.finishCondition
              ? options.finishCondition
              : TRUE;
          var geometryFunction = options.geometryFunction;
          if (!geometryFunction) {
              if (_this.type_ === GeometryType.CIRCLE) {
                  /**
                   * @param {!LineCoordType} coordinates The coordinates.
                   * @param {import("../geom/SimpleGeometry.js").default=} opt_geometry Optional geometry.
                   * @param {import("../proj/Projection.js").default} projection The view projection.
                   * @return {import("../geom/SimpleGeometry.js").default} A geometry.
                   */
                  geometryFunction = function (coordinates, opt_geometry, projection) {
                      var circle = opt_geometry
                          ? /** @type {Circle} */ (opt_geometry)
                          : new Circle([NaN, NaN]);
                      var center = fromUserCoordinate(coordinates[0], projection);
                      var squaredLength = squaredDistance$1(center, fromUserCoordinate(coordinates[1], projection));
                      circle.setCenterAndRadius(center, Math.sqrt(squaredLength));
                      var userProjection = getUserProjection();
                      if (userProjection) {
                          circle.transform(projection, userProjection);
                      }
                      return circle;
                  };
              }
              else {
                  var Constructor_1;
                  var mode_1 = _this.mode_;
                  if (mode_1 === Mode.POINT) {
                      Constructor_1 = Point$1;
                  }
                  else if (mode_1 === Mode.LINE_STRING) {
                      Constructor_1 = LineString;
                  }
                  else if (mode_1 === Mode.POLYGON) {
                      Constructor_1 = Polygon$1;
                  }
                  /**
                   * @param {!LineCoordType} coordinates The coordinates.
                   * @param {import("../geom/SimpleGeometry.js").default=} opt_geometry Optional geometry.
                   * @param {import("../proj/Projection.js").default} projection The view projection.
                   * @return {import("../geom/SimpleGeometry.js").default} A geometry.
                   */
                  geometryFunction = function (coordinates, opt_geometry, projection) {
                      var geometry = opt_geometry;
                      if (geometry) {
                          if (mode_1 === Mode.POLYGON) {
                              if (coordinates[0].length) {
                                  // Add a closing coordinate to match the first
                                  geometry.setCoordinates([
                                      coordinates[0].concat([coordinates[0][0]]),
                                  ]);
                              }
                              else {
                                  geometry.setCoordinates([]);
                              }
                          }
                          else {
                              geometry.setCoordinates(coordinates);
                          }
                      }
                      else {
                          geometry = new Constructor_1(coordinates);
                      }
                      return geometry;
                  };
              }
          }
          /**
           * @type {GeometryFunction}
           * @private
           */
          _this.geometryFunction_ = geometryFunction;
          /**
           * @type {number}
           * @private
           */
          _this.dragVertexDelay_ =
              options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;
          /**
           * Finish coordinate for the feature (first point for polygons, last point for
           * linestrings).
           * @type {import("../coordinate.js").Coordinate}
           * @private
           */
          _this.finishCoordinate_ = null;
          /**
           * Sketch feature.
           * @type {Feature}
           * @private
           */
          _this.sketchFeature_ = null;
          /**
           * Sketch point.
           * @type {Feature<Point>}
           * @private
           */
          _this.sketchPoint_ = null;
          /**
           * Sketch coordinates. Used when drawing a line or polygon.
           * @type {SketchCoordType}
           * @private
           */
          _this.sketchCoords_ = null;
          /**
           * Sketch line. Used when drawing polygon.
           * @type {Feature<LineString>}
           * @private
           */
          _this.sketchLine_ = null;
          /**
           * Sketch line coordinates. Used when drawing a polygon or circle.
           * @type {LineCoordType}
           * @private
           */
          _this.sketchLineCoords_ = null;
          /**
           * Squared tolerance for handling up events.  If the squared distance
           * between a down and up event is greater than this tolerance, up events
           * will not be handled.
           * @type {number}
           * @private
           */
          _this.squaredClickTolerance_ = options.clickTolerance
              ? options.clickTolerance * options.clickTolerance
              : 36;
          /**
           * Draw overlay where our sketch features are drawn.
           * @type {VectorLayer}
           * @private
           */
          _this.overlay_ = new VectorLayer({
              source: new VectorSource({
                  useSpatialIndex: false,
                  wrapX: options.wrapX ? options.wrapX : false,
              }),
              style: options.style ? options.style : getDefaultStyleFunction(),
              updateWhileInteracting: true,
          });
          /**
           * Name of the geometry attribute for newly created features.
           * @type {string|undefined}
           * @private
           */
          _this.geometryName_ = options.geometryName;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.condition ? options.condition : noModifierKeys;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.freehandCondition_;
          if (options.freehand) {
              _this.freehandCondition_ = always;
          }
          else {
              _this.freehandCondition_ = options.freehandCondition
                  ? options.freehandCondition
                  : shiftKeyOnly;
          }
          _this.addEventListener(getChangeEventType(InteractionProperty.ACTIVE), _this.updateState_);
          return _this;
      }
      /**
       * Remove the interaction from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       */
      Draw.prototype.setMap = function (map) {
          _super.prototype.setMap.call(this, map);
          this.updateState_();
      };
      /**
       * Get the overlay layer that this interaction renders sketch features to.
       * @return {VectorLayer} Overlay layer.
       * @api
       */
      Draw.prototype.getOverlay = function () {
          return this.overlay_;
      };
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} and may actually draw or finish the drawing.
       * @param {import("../MapBrowserEvent.js").default} event Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @api
       */
      Draw.prototype.handleEvent = function (event) {
          if (event.originalEvent.type === EventType.CONTEXTMENU) {
              // Avoid context menu for long taps when drawing on mobile
              event.preventDefault();
          }
          this.freehand_ =
              this.mode_ !== Mode.POINT && this.freehandCondition_(event);
          var move = event.type === MapBrowserEventType.POINTERMOVE;
          var pass = true;
          if (!this.freehand_ &&
              this.lastDragTime_ &&
              event.type === MapBrowserEventType.POINTERDRAG) {
              var now = Date.now();
              if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
                  this.downPx_ = event.pixel;
                  this.shouldHandle_ = !this.freehand_;
                  move = true;
              }
              else {
                  this.lastDragTime_ = undefined;
              }
              if (this.shouldHandle_ && this.downTimeout_ !== undefined) {
                  clearTimeout(this.downTimeout_);
                  this.downTimeout_ = undefined;
              }
          }
          if (this.freehand_ &&
              event.type === MapBrowserEventType.POINTERDRAG &&
              this.sketchFeature_ !== null) {
              this.addToDrawing_(event.coordinate);
              pass = false;
          }
          else if (this.freehand_ &&
              event.type === MapBrowserEventType.POINTERDOWN) {
              pass = false;
          }
          else if (move) {
              pass = event.type === MapBrowserEventType.POINTERMOVE;
              if (pass && this.freehand_) {
                  this.handlePointerMove_(event);
                  if (this.shouldHandle_) {
                      // Avoid page scrolling when freehand drawing on mobile
                      event.preventDefault();
                  }
              }
              else if (event.originalEvent.pointerType == 'mouse' ||
                  (event.type === MapBrowserEventType.POINTERDRAG &&
                      this.downTimeout_ === undefined)) {
                  this.handlePointerMove_(event);
              }
          }
          else if (event.type === MapBrowserEventType.DBLCLICK) {
              pass = false;
          }
          return _super.prototype.handleEvent.call(this, event) && pass;
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} event Event.
       * @return {boolean} If the event was consumed.
       */
      Draw.prototype.handleDownEvent = function (event) {
          this.shouldHandle_ = !this.freehand_;
          if (this.freehand_) {
              this.downPx_ = event.pixel;
              if (!this.finishCoordinate_) {
                  this.startDrawing_(event);
              }
              return true;
          }
          else if (this.condition_(event)) {
              this.lastDragTime_ = Date.now();
              this.downTimeout_ = setTimeout(function () {
                  this.handlePointerMove_(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, event.map, event.originalEvent, false, event.frameState));
              }.bind(this), this.dragVertexDelay_);
              this.downPx_ = event.pixel;
              return true;
          }
          else {
              this.lastDragTime_ = undefined;
              return false;
          }
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} event Event.
       * @return {boolean} If the event was consumed.
       */
      Draw.prototype.handleUpEvent = function (event) {
          var pass = true;
          if (this.downTimeout_) {
              clearTimeout(this.downTimeout_);
              this.downTimeout_ = undefined;
          }
          this.handlePointerMove_(event);
          var circleMode = this.mode_ === Mode.CIRCLE;
          if (this.shouldHandle_) {
              if (!this.finishCoordinate_) {
                  this.startDrawing_(event);
                  if (this.mode_ === Mode.POINT) {
                      this.finishDrawing();
                  }
              }
              else if (this.freehand_ || circleMode) {
                  this.finishDrawing();
              }
              else if (this.atFinish_(event)) {
                  if (this.finishCondition_(event)) {
                      this.finishDrawing();
                  }
              }
              else {
                  this.addToDrawing_(event.coordinate);
              }
              pass = false;
          }
          else if (this.freehand_) {
              this.abortDrawing();
          }
          if (!pass && this.stopClick_) {
              event.stopPropagation();
          }
          return pass;
      };
      /**
       * Handle move events.
       * @param {import("../MapBrowserEvent.js").default} event A move event.
       * @private
       */
      Draw.prototype.handlePointerMove_ = function (event) {
          if (this.downPx_ &&
              ((!this.freehand_ && this.shouldHandle_) ||
                  (this.freehand_ && !this.shouldHandle_))) {
              var downPx = this.downPx_;
              var clickPx = event.pixel;
              var dx = downPx[0] - clickPx[0];
              var dy = downPx[1] - clickPx[1];
              var squaredDistance$$1 = dx * dx + dy * dy;
              this.shouldHandle_ = this.freehand_
                  ? squaredDistance$$1 > this.squaredClickTolerance_
                  : squaredDistance$$1 <= this.squaredClickTolerance_;
              if (!this.shouldHandle_) {
                  return;
              }
          }
          if (this.finishCoordinate_) {
              this.modifyDrawing_(event);
          }
          else {
              this.createOrUpdateSketchPoint_(event);
          }
      };
      /**
       * Determine if an event is within the snapping tolerance of the start coord.
       * @param {import("../MapBrowserEvent.js").default} event Event.
       * @return {boolean} The event is within the snapping tolerance of the start.
       * @private
       */
      Draw.prototype.atFinish_ = function (event) {
          var at = false;
          if (this.sketchFeature_) {
              var potentiallyDone = false;
              var potentiallyFinishCoordinates = [this.finishCoordinate_];
              if (this.mode_ === Mode.LINE_STRING) {
                  potentiallyDone = this.sketchCoords_.length > this.minPoints_;
              }
              else if (this.mode_ === Mode.POLYGON) {
                  var sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);
                  potentiallyDone = sketchCoords[0].length > this.minPoints_;
                  potentiallyFinishCoordinates = [
                      sketchCoords[0][0],
                      sketchCoords[0][sketchCoords[0].length - 2],
                  ];
              }
              if (potentiallyDone) {
                  var map = event.map;
                  for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {
                      var finishCoordinate = potentiallyFinishCoordinates[i];
                      var finishPixel = map.getPixelFromCoordinate(finishCoordinate);
                      var pixel = event.pixel;
                      var dx = pixel[0] - finishPixel[0];
                      var dy = pixel[1] - finishPixel[1];
                      var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
                      at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
                      if (at) {
                          this.finishCoordinate_ = finishCoordinate;
                          break;
                      }
                  }
              }
          }
          return at;
      };
      /**
       * @param {import("../MapBrowserEvent.js").default} event Event.
       * @private
       */
      Draw.prototype.createOrUpdateSketchPoint_ = function (event) {
          var coordinates = event.coordinate.slice();
          if (!this.sketchPoint_) {
              this.sketchPoint_ = new Feature(new Point$1(coordinates));
              this.updateSketchFeatures_();
          }
          else {
              var sketchPointGeom = this.sketchPoint_.getGeometry();
              sketchPointGeom.setCoordinates(coordinates);
          }
      };
      /**
       * Start the drawing.
       * @param {import("../MapBrowserEvent.js").default} event Event.
       * @private
       */
      Draw.prototype.startDrawing_ = function (event) {
          var start = event.coordinate;
          var projection = event.map.getView().getProjection();
          this.finishCoordinate_ = start;
          if (this.mode_ === Mode.POINT) {
              this.sketchCoords_ = start.slice();
          }
          else if (this.mode_ === Mode.POLYGON) {
              this.sketchCoords_ = [[start.slice(), start.slice()]];
              this.sketchLineCoords_ = this.sketchCoords_[0];
          }
          else {
              this.sketchCoords_ = [start.slice(), start.slice()];
          }
          if (this.sketchLineCoords_) {
              this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));
          }
          var geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);
          this.sketchFeature_ = new Feature();
          if (this.geometryName_) {
              this.sketchFeature_.setGeometryName(this.geometryName_);
          }
          this.sketchFeature_.setGeometry(geometry);
          this.updateSketchFeatures_();
          this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
      };
      /**
       * Modify the drawing.
       * @param {import("../MapBrowserEvent.js").default} event Event.
       * @private
       */
      Draw.prototype.modifyDrawing_ = function (event) {
          var coordinate = event.coordinate;
          var geometry = this.sketchFeature_.getGeometry();
          var projection = event.map.getView().getProjection();
          var coordinates, last;
          if (this.mode_ === Mode.POINT) {
              last = this.sketchCoords_;
          }
          else if (this.mode_ === Mode.POLYGON) {
              coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
              last = coordinates[coordinates.length - 1];
              if (this.atFinish_(event)) {
                  // snap to finish
                  coordinate = this.finishCoordinate_.slice();
              }
          }
          else {
              coordinates = this.sketchCoords_;
              last = coordinates[coordinates.length - 1];
          }
          last[0] = coordinate[0];
          last[1] = coordinate[1];
          this.geometryFunction_(
          /** @type {!LineCoordType} */ (this.sketchCoords_), geometry, projection);
          if (this.sketchPoint_) {
              var sketchPointGeom = this.sketchPoint_.getGeometry();
              sketchPointGeom.setCoordinates(coordinate);
          }
          /** @type {LineString} */
          var sketchLineGeom;
          if (geometry.getType() == GeometryType.POLYGON &&
              this.mode_ !== Mode.POLYGON) {
              if (!this.sketchLine_) {
                  this.sketchLine_ = new Feature();
              }
              var ring = geometry.getLinearRing(0);
              sketchLineGeom = this.sketchLine_.getGeometry();
              if (!sketchLineGeom) {
                  sketchLineGeom = new LineString(ring.getFlatCoordinates(), ring.getLayout());
                  this.sketchLine_.setGeometry(sketchLineGeom);
              }
              else {
                  sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());
                  sketchLineGeom.changed();
              }
          }
          else if (this.sketchLineCoords_) {
              sketchLineGeom = this.sketchLine_.getGeometry();
              sketchLineGeom.setCoordinates(this.sketchLineCoords_);
          }
          this.updateSketchFeatures_();
      };
      /**
       * Add a new coordinate to the drawing.
       * @param {!PointCoordType} coordinate Coordinate
       * @private
       */
      Draw.prototype.addToDrawing_ = function (coordinate) {
          var geometry = this.sketchFeature_.getGeometry();
          var projection = this.getMap().getView().getProjection();
          var done;
          var coordinates;
          if (this.mode_ === Mode.LINE_STRING) {
              this.finishCoordinate_ = coordinate.slice();
              coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);
              if (coordinates.length >= this.maxPoints_) {
                  if (this.freehand_) {
                      coordinates.pop();
                  }
                  else {
                      done = true;
                  }
              }
              coordinates.push(coordinate.slice());
              this.geometryFunction_(coordinates, geometry, projection);
          }
          else if (this.mode_ === Mode.POLYGON) {
              coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
              if (coordinates.length >= this.maxPoints_) {
                  if (this.freehand_) {
                      coordinates.pop();
                  }
                  else {
                      done = true;
                  }
              }
              coordinates.push(coordinate.slice());
              if (done) {
                  this.finishCoordinate_ = coordinates[0];
              }
              this.geometryFunction_(this.sketchCoords_, geometry, projection);
          }
          this.updateSketchFeatures_();
          if (done) {
              this.finishDrawing();
          }
      };
      /**
       * Remove last point of the feature currently being drawn.
       * @api
       */
      Draw.prototype.removeLastPoint = function () {
          if (!this.sketchFeature_) {
              return;
          }
          var geometry = this.sketchFeature_.getGeometry();
          var projection = this.getMap().getView().getProjection();
          var coordinates;
          /** @type {LineString} */
          var sketchLineGeom;
          if (this.mode_ === Mode.LINE_STRING) {
              coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);
              coordinates.splice(-2, 1);
              this.geometryFunction_(coordinates, geometry, projection);
              if (coordinates.length >= 2) {
                  this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
              }
          }
          else if (this.mode_ === Mode.POLYGON) {
              coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
              coordinates.splice(-2, 1);
              sketchLineGeom = this.sketchLine_.getGeometry();
              sketchLineGeom.setCoordinates(coordinates);
              this.geometryFunction_(this.sketchCoords_, geometry, projection);
          }
          if (coordinates.length === 0) {
              this.abortDrawing();
          }
          this.updateSketchFeatures_();
      };
      /**
       * Stop drawing and add the sketch feature to the target layer.
       * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
       * dispatched before inserting the feature.
       * @api
       */
      Draw.prototype.finishDrawing = function () {
          var sketchFeature = this.abortDrawing_();
          if (!sketchFeature) {
              return;
          }
          var coordinates = this.sketchCoords_;
          var geometry = sketchFeature.getGeometry();
          var projection = this.getMap().getView().getProjection();
          if (this.mode_ === Mode.LINE_STRING) {
              // remove the redundant last point
              coordinates.pop();
              this.geometryFunction_(coordinates, geometry, projection);
          }
          else if (this.mode_ === Mode.POLYGON) {
              // remove the redundant last point in ring
              /** @type {PolyCoordType} */ (coordinates)[0].pop();
              this.geometryFunction_(coordinates, geometry, projection);
              coordinates = geometry.getCoordinates();
          }
          // cast multi-part geometries
          if (this.type_ === GeometryType.MULTI_POINT) {
              sketchFeature.setGeometry(new MultiPoint([/** @type {PointCoordType} */ (coordinates)]));
          }
          else if (this.type_ === GeometryType.MULTI_LINE_STRING) {
              sketchFeature.setGeometry(new MultiLineString([/** @type {LineCoordType} */ (coordinates)]));
          }
          else if (this.type_ === GeometryType.MULTI_POLYGON) {
              sketchFeature.setGeometry(new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)]));
          }
          // First dispatch event to allow full set up of feature
          this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));
          // Then insert feature
          if (this.features_) {
              this.features_.push(sketchFeature);
          }
          if (this.source_) {
              this.source_.addFeature(sketchFeature);
          }
      };
      /**
       * Stop drawing without adding the sketch feature to the target layer.
       * @return {Feature} The sketch feature (or null if none).
       * @private
       */
      Draw.prototype.abortDrawing_ = function () {
          this.finishCoordinate_ = null;
          var sketchFeature = this.sketchFeature_;
          this.sketchFeature_ = null;
          this.sketchPoint_ = null;
          this.sketchLine_ = null;
          this.overlay_.getSource().clear(true);
          return sketchFeature;
      };
      /**
       * Stop drawing without adding the sketch feature to the target layer.
       * @api
       */
      Draw.prototype.abortDrawing = function () {
          var sketchFeature = this.abortDrawing_();
          if (sketchFeature) {
              this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));
          }
      };
      /**
       * Append coordinates to the end of the geometry that is currently being drawn.
       * This can be used when drawing LineStrings or Polygons. Coordinates will
       * either be appended to the current LineString or the outer ring of the current
       * Polygon.
       * @param {!LineCoordType} coordinates Linear coordinates to be appended into
       * the coordinate array.
       * @api
       */
      Draw.prototype.appendCoordinates = function (coordinates) {
          var mode = this.mode_;
          var sketchCoords = [];
          if (mode === Mode.LINE_STRING) {
              sketchCoords = /** @type {LineCoordType} */ this.sketchCoords_;
          }
          else if (mode === Mode.POLYGON) {
              sketchCoords =
                  this.sketchCoords_ && this.sketchCoords_.length
                      ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]
                      : [];
          }
          // Remove last coordinate from sketch drawing (this coordinate follows cursor position)
          var ending = sketchCoords.pop();
          // Append coordinate list
          for (var i = 0; i < coordinates.length; i++) {
              this.addToDrawing_(coordinates[i]);
          }
          // Duplicate last coordinate for sketch drawing
          this.addToDrawing_(ending);
      };
      /**
       * Initiate draw mode by starting from an existing geometry which will
       * receive new additional points. This only works on features with
       * `LineString` geometries, where the interaction will extend lines by adding
       * points to the end of the coordinates array.
       * This will change the original feature, instead of drawing a copy.
       *
       * The function will dispatch a `drawstart` event.
       *
       * @param {!Feature<LineString>} feature Feature to be extended.
       * @api
       */
      Draw.prototype.extend = function (feature) {
          var geometry = feature.getGeometry();
          var lineString = geometry;
          this.sketchFeature_ = feature;
          this.sketchCoords_ = lineString.getCoordinates();
          var last = this.sketchCoords_[this.sketchCoords_.length - 1];
          this.finishCoordinate_ = last.slice();
          this.sketchCoords_.push(last.slice());
          this.updateSketchFeatures_();
          this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
      };
      /**
       * Redraw the sketch features.
       * @private
       */
      Draw.prototype.updateSketchFeatures_ = function () {
          var sketchFeatures = [];
          if (this.sketchFeature_) {
              sketchFeatures.push(this.sketchFeature_);
          }
          if (this.sketchLine_) {
              sketchFeatures.push(this.sketchLine_);
          }
          if (this.sketchPoint_) {
              sketchFeatures.push(this.sketchPoint_);
          }
          var overlaySource = this.overlay_.getSource();
          overlaySource.clear(true);
          overlaySource.addFeatures(sketchFeatures);
      };
      /**
       * @private
       */
      Draw.prototype.updateState_ = function () {
          var map = this.getMap();
          var active = this.getActive();
          if (!map || !active) {
              this.abortDrawing();
          }
          this.overlay_.setMap(active ? map : null);
      };
      return Draw;
  }(PointerInteraction));
  /**
   * @return {import("../style/Style.js").StyleFunction} Styles.
   */
  function getDefaultStyleFunction() {
      var styles = createEditingStyle();
      return function (feature, resolution) {
          return styles[feature.getGeometry().getType()];
      };
  }
  /**
   * Create a `geometryFunction` for `type: 'Circle'` that will create a regular
   * polygon with a user specified number of sides and start angle instead of an
   * `import("../geom/Circle.js").Circle` geometry.
   * @param {number=} opt_sides Number of sides of the regular polygon. Default is
   *     32.
   * @param {number=} opt_angle Angle of the first point in radians. 0 means East.
   *     Default is the angle defined by the heading from the center of the
   *     regular polygon to the current pointer position.
   * @return {GeometryFunction} Function that draws a
   *     polygon.
   * @api
   */
  function createRegularPolygon(opt_sides, opt_angle) {
      return function (coordinates, opt_geometry, projection) {
          var center = fromUserCoordinate(
          /** @type {LineCoordType} */ (coordinates)[0], projection);
          var end = fromUserCoordinate(
          /** @type {LineCoordType} */ (coordinates)[1], projection);
          var radius = Math.sqrt(squaredDistance$1(center, end));
          var geometry = opt_geometry
              ? /** @type {Polygon} */ (opt_geometry)
              : fromCircle(new Circle(center), opt_sides);
          var angle = opt_angle;
          if (!opt_angle) {
              var x = end[0] - center[0];
              var y = end[1] - center[1];
              angle = Math.atan(y / x) - (x < 0 ? Math.PI : 0);
          }
          makeRegular(geometry, center, radius, angle);
          var userProjection = getUserProjection();
          if (userProjection) {
              geometry.transform(projection, userProjection);
          }
          return geometry;
      };
  }
  /**
   * Get the drawing mode.  The mode for mult-part geometries is the same as for
   * their single-part cousins.
   * @param {import("../geom/GeometryType.js").default} type Geometry type.
   * @return {Mode} Drawing mode.
   */
  function getMode(type) {
      var mode;
      if (type === GeometryType.POINT || type === GeometryType.MULTI_POINT) {
          mode = Mode.POINT;
      }
      else if (type === GeometryType.LINE_STRING ||
          type === GeometryType.MULTI_LINE_STRING) {
          mode = Mode.LINE_STRING;
      }
      else if (type === GeometryType.POLYGON ||
          type === GeometryType.MULTI_POLYGON) {
          mode = Mode.POLYGON;
      }
      else if (type === GeometryType.CIRCLE) {
          mode = Mode.CIRCLE;
      }
      return /** @type {!Mode} */ (mode);
  }

  /**
   * @module ol/MapEventType
   */
  /**
   * @enum {string}
   */
  var MapEventType = {
      /**
       * Triggered after a map frame is rendered.
       * @event module:ol/MapEvent~MapEvent#postrender
       * @api
       */
      POSTRENDER: 'postrender',
      /**
       * Triggered when the map starts moving.
       * @event module:ol/MapEvent~MapEvent#movestart
       * @api
       */
      MOVESTART: 'movestart',
      /**
       * Triggered after the map is moved.
       * @event module:ol/MapEvent~MapEvent#moveend
       * @api
       */
      MOVEEND: 'moveend',
  };

  var __extends$J = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {HTMLElement} [element] The element is the control's
   * container element. This only needs to be specified if you're developing
   * a custom control.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when
   * the control should be re-rendered. This is called in a `requestAnimationFrame`
   * callback.
   * @property {HTMLElement|string} [target] Specify a target if you want
   * the control to be rendered outside of the map's viewport.
   */
  /**
   * @classdesc
   * A control is a visible widget with a DOM element in a fixed position on the
   * screen. They can involve user input (buttons), or be informational only;
   * the position is determined using CSS. By default these are placed in the
   * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
   * any outside DOM element.
   *
   * This is the base class for controls. You can use it for simple custom
   * controls by creating the element with listeners, creating an instance:
   * ```js
   * var myControl = new Control({element: myElement});
   * ```
   * and then adding this to the map.
   *
   * The main advantage of having this as a control rather than a simple separate
   * DOM element is that preventing propagation is handled for you. Controls
   * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
   *
   * You can also extend this base for your own control class. See
   * examples/custom-controls for an example of how to do this.
   *
   * @api
   */
  var Control = /** @class */ (function (_super) {
      __extends$J(Control, _super);
      /**
       * @param {Options} options Control options.
       */
      function Control(options) {
          var _this = _super.call(this) || this;
          var element = options.element;
          if (element && !options.target && !element.style.pointerEvents) {
              element.style.pointerEvents = 'auto';
          }
          /**
           * @protected
           * @type {HTMLElement}
           */
          _this.element = element ? element : null;
          /**
           * @private
           * @type {HTMLElement}
           */
          _this.target_ = null;
          /**
           * @private
           * @type {import("../PluggableMap.js").default}
           */
          _this.map_ = null;
          /**
           * @protected
           * @type {!Array<import("../events.js").EventsKey>}
           */
          _this.listenerKeys = [];
          if (options.render) {
              _this.render = options.render;
          }
          if (options.target) {
              _this.setTarget(options.target);
          }
          return _this;
      }
      /**
       * Clean up.
       */
      Control.prototype.disposeInternal = function () {
          removeNode(this.element);
          _super.prototype.disposeInternal.call(this);
      };
      /**
       * Get the map associated with this control.
       * @return {import("../PluggableMap.js").default} Map.
       * @api
       */
      Control.prototype.getMap = function () {
          return this.map_;
      };
      /**
       * Remove the control from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       * @api
       */
      Control.prototype.setMap = function (map) {
          if (this.map_) {
              removeNode(this.element);
          }
          for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
              unlistenByKey(this.listenerKeys[i]);
          }
          this.listenerKeys.length = 0;
          this.map_ = map;
          if (this.map_) {
              var target = this.target_
                  ? this.target_
                  : map.getOverlayContainerStopEvent();
              target.appendChild(this.element);
              if (this.render !== VOID) {
                  this.listenerKeys.push(listen(map, MapEventType.POSTRENDER, this.render, this));
              }
              map.render();
          }
      };
      /**
       * Renders the control.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @api
       */
      Control.prototype.render = function (mapEvent) { };
      /**
       * This function is used to set a target element for the control. It has no
       * effect if it is called after the control has been added to the map (i.e.
       * after `setMap` is called on the control). If no `target` is set in the
       * options passed to the control constructor and if `setTarget` is not called
       * then the control is added to the map's overlay container.
       * @param {HTMLElement|string} target Target.
       * @api
       */
      Control.prototype.setTarget = function (target) {
          this.target_ =
              typeof target === 'string' ? document.getElementById(target) : target;
      };
      return Control;
  }(BaseObject));

  var __extends$K = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var events = [
      'fullscreenchange',
      'webkitfullscreenchange',
      'MSFullscreenChange',
  ];
  /**
   * @enum {string}
   */
  var FullScreenEventType = {
      /**
       * Triggered after the map entered fullscreen.
       * @event FullScreenEventType#enterfullscreen
       * @api
       */
      ENTERFULLSCREEN: 'enterfullscreen',
      /**
       * Triggered after the map leave fullscreen.
       * @event FullScreenEventType#leavefullscreen
       * @api
       */
      LEAVEFULLSCREEN: 'leavefullscreen',
  };
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-full-screen'] CSS class name.
   * @property {string|Text} [label='\u2922'] Text label to use for the button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string|Text} [labelActive='\u00d7'] Text label to use for the
   * button when full-screen is active.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string} [tipLabel='Toggle full-screen'] Text label to use for the button tip.
   * @property {boolean} [keys=false] Full keyboard access.
   * @property {HTMLElement|string} [target] Specify a target if you want the
   * control to be rendered outside of the map's viewport.
   * @property {HTMLElement|string} [source] The element to be displayed
   * fullscreen. When not provided, the element containing the map viewport will
   * be displayed fullscreen.
   */
  /**
   * @classdesc
   * Provides a button that when clicked fills up the full screen with the map.
   * The full screen source element is by default the element containing the map viewport unless
   * overridden by providing the `source` option. In which case, the dom
   * element introduced using this parameter will be displayed in full screen.
   *
   * When in full screen mode, a close button is shown to exit full screen mode.
   * The [Fullscreen API](http://www.w3.org/TR/fullscreen/) is used to
   * toggle the map in full screen mode.
   *
   * @fires FullScreenEventType#enterfullscreen
   * @fires FullScreenEventType#leavefullscreen
   * @api
   */
  var FullScreen = /** @class */ (function (_super) {
      __extends$K(FullScreen, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function FullScreen(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              element: document.createElement('div'),
              target: options.target,
          }) || this;
          /**
           * @private
           * @type {string}
           */
          _this.cssClassName_ =
              options.className !== undefined ? options.className : 'ol-full-screen';
          var label = options.label !== undefined ? options.label : '\u2922';
          /**
           * @private
           * @type {Text}
           */
          _this.labelNode_ =
              typeof label === 'string' ? document.createTextNode(label) : label;
          var labelActive = options.labelActive !== undefined ? options.labelActive : '\u00d7';
          /**
           * @private
           * @type {Text}
           */
          _this.labelActiveNode_ =
              typeof labelActive === 'string'
                  ? document.createTextNode(labelActive)
                  : labelActive;
          /**
           * @private
           * @type {HTMLElement}
           */
          _this.button_ = document.createElement('button');
          var tipLabel = options.tipLabel ? options.tipLabel : 'Toggle full-screen';
          _this.setClassName_(_this.button_, isFullScreen());
          _this.button_.setAttribute('type', 'button');
          _this.button_.title = tipLabel;
          _this.button_.appendChild(_this.labelNode_);
          _this.button_.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
          var cssClasses = _this.cssClassName_ +
              ' ' +
              CLASS_UNSELECTABLE +
              ' ' +
              CLASS_CONTROL +
              ' ' +
              (!isFullScreenSupported() ? CLASS_UNSUPPORTED : '');
          var element = _this.element;
          element.className = cssClasses;
          element.appendChild(_this.button_);
          /**
           * @private
           * @type {boolean}
           */
          _this.keys_ = options.keys !== undefined ? options.keys : false;
          /**
           * @private
           * @type {HTMLElement|string|undefined}
           */
          _this.source_ = options.source;
          return _this;
      }
      /**
       * @param {MouseEvent} event The event to handle
       * @private
       */
      FullScreen.prototype.handleClick_ = function (event) {
          event.preventDefault();
          this.handleFullScreen_();
      };
      /**
       * @private
       */
      FullScreen.prototype.handleFullScreen_ = function () {
          if (!isFullScreenSupported()) {
              return;
          }
          var map = this.getMap();
          if (!map) {
              return;
          }
          if (isFullScreen()) {
              exitFullScreen();
          }
          else {
              var element = void 0;
              if (this.source_) {
                  element =
                      typeof this.source_ === 'string'
                          ? document.getElementById(this.source_)
                          : this.source_;
              }
              else {
                  element = map.getTargetElement();
              }
              if (this.keys_) {
                  requestFullScreenWithKeys(element);
              }
              else {
                  requestFullScreen(element);
              }
          }
      };
      /**
       * @private
       */
      FullScreen.prototype.handleFullScreenChange_ = function () {
          var map = this.getMap();
          if (isFullScreen()) {
              this.setClassName_(this.button_, true);
              replaceNode(this.labelActiveNode_, this.labelNode_);
              this.dispatchEvent(FullScreenEventType.ENTERFULLSCREEN);
          }
          else {
              this.setClassName_(this.button_, false);
              replaceNode(this.labelNode_, this.labelActiveNode_);
              this.dispatchEvent(FullScreenEventType.LEAVEFULLSCREEN);
          }
          if (map) {
              map.updateSize();
          }
      };
      /**
       * @param {HTMLElement} element Target element
       * @param {boolean} fullscreen True if fullscreen class name should be active
       * @private
       */
      FullScreen.prototype.setClassName_ = function (element, fullscreen) {
          var activeClassName = this.cssClassName_ + '-true';
          var inactiveClassName = this.cssClassName_ + '-false';
          var nextClassName = fullscreen ? activeClassName : inactiveClassName;
          element.classList.remove(activeClassName);
          element.classList.remove(inactiveClassName);
          element.classList.add(nextClassName);
      };
      /**
       * Remove the control from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       * @api
       */
      FullScreen.prototype.setMap = function (map) {
          _super.prototype.setMap.call(this, map);
          if (map) {
              for (var i = 0, ii = events.length; i < ii; ++i) {
                  this.listenerKeys.push(listen(document, events[i], this.handleFullScreenChange_, this));
              }
          }
      };
      return FullScreen;
  }(Control));
  /**
   * @return {boolean} Fullscreen is supported by the current platform.
   */
  function isFullScreenSupported() {
      var body = document.body;
      return !!(body['webkitRequestFullscreen'] ||
          (body['msRequestFullscreen'] && document['msFullscreenEnabled']) ||
          (body.requestFullscreen && document.fullscreenEnabled));
  }
  /**
   * @return {boolean} Element is currently in fullscreen.
   */
  function isFullScreen() {
      return !!(document['webkitIsFullScreen'] ||
          document['msFullscreenElement'] ||
          document.fullscreenElement);
  }
  /**
   * Request to fullscreen an element.
   * @param {HTMLElement} element Element to request fullscreen
   */
  function requestFullScreen(element) {
      if (element.requestFullscreen) {
          element.requestFullscreen();
      }
      else if (element['msRequestFullscreen']) {
          element['msRequestFullscreen']();
      }
      else if (element['webkitRequestFullscreen']) {
          element['webkitRequestFullscreen']();
      }
  }
  /**
   * Request to fullscreen an element with keyboard input.
   * @param {HTMLElement} element Element to request fullscreen
   */
  function requestFullScreenWithKeys(element) {
      if (element['webkitRequestFullscreen']) {
          element['webkitRequestFullscreen']();
      }
      else {
          requestFullScreen(element);
      }
  }
  /**
   * Exit fullscreen.
   */
  function exitFullScreen() {
      if (document.exitFullscreen) {
          document.exitFullscreen();
      }
      else if (document['msExitFullscreen']) {
          document['msExitFullscreen']();
      }
      else if (document['webkitExitFullscreen']) {
          document['webkitExitFullscreen']();
      }
  }

  var __extends$L = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
   * this layer in its layers collection, and the layer will be rendered on top. This is useful for
   * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
   * use {@link module:ol/Map#addLayer}.
   * @property {import("../source/Image.js").default} [source] Source for this layer.
   */
  /**
   * @classdesc
   * Server-rendered images that are available for arbitrary extents and
   * resolutions.
   * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
   * property on the layer object; for example, setting `title: 'My Title'` in the
   * options means that `title` is observable, and has get/set accessors.
   *
   * @extends {Layer<import("../source/Image.js").default>}
   * @api
   */
  var BaseImageLayer = /** @class */ (function (_super) {
      __extends$L(BaseImageLayer, _super);
      /**
       * @param {Options=} opt_options Layer options.
       */
      function BaseImageLayer(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, options) || this;
          return _this;
      }
      return BaseImageLayer;
  }(Layer));

  /**
   * @module ol/reproj/common
   */
  /**
   * Default maximum allowed threshold  (in pixels) for reprojection
   * triangulation.
   * @type {number}
   */
  var ERROR_THRESHOLD = 0.5;

  var __extends$M = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Canvas renderer for image layers.
   * @api
   */
  var CanvasImageLayerRenderer = /** @class */ (function (_super) {
      __extends$M(CanvasImageLayerRenderer, _super);
      /**
       * @param {import("../../layer/Image.js").default} imageLayer Image layer.
       */
      function CanvasImageLayerRenderer(imageLayer) {
          var _this = _super.call(this, imageLayer) || this;
          /**
           * @protected
           * @type {?import("../../ImageBase.js").default}
           */
          _this.image_ = null;
          return _this;
      }
      /**
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       */
      CanvasImageLayerRenderer.prototype.getImage = function () {
          return !this.image_ ? null : this.image_.getImage();
      };
      /**
       * Determine whether render should be called.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      CanvasImageLayerRenderer.prototype.prepareFrame = function (frameState) {
          var layerState = frameState.layerStatesArray[frameState.layerIndex];
          var pixelRatio = frameState.pixelRatio;
          var viewState = frameState.viewState;
          var viewResolution = viewState.resolution;
          var imageSource = this.getLayer().getSource();
          var hints = frameState.viewHints;
          var renderedExtent = frameState.extent;
          if (layerState.extent !== undefined) {
              renderedExtent = getIntersection(renderedExtent, fromUserExtent(layerState.extent, viewState.projection));
          }
          if (!hints[ViewHint.ANIMATING] &&
              !hints[ViewHint.INTERACTING] &&
              !isEmpty$1(renderedExtent)) {
              if (imageSource) {
                  var projection = viewState.projection;
                  var image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);
                  if (image && this.loadImage(image)) {
                      this.image_ = image;
                  }
              }
              else {
                  this.image_ = null;
              }
          }
          return !!this.image_;
      };
      /**
       * Render the layer.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target that may be used to render content to.
       * @return {HTMLElement} The rendered element.
       */
      CanvasImageLayerRenderer.prototype.renderFrame = function (frameState, target) {
          var image = this.image_;
          var imageExtent = image.getExtent();
          var imageResolution = image.getResolution();
          var imagePixelRatio = image.getPixelRatio();
          var layerState = frameState.layerStatesArray[frameState.layerIndex];
          var pixelRatio = frameState.pixelRatio;
          var viewState = frameState.viewState;
          var viewCenter = viewState.center;
          var viewResolution = viewState.resolution;
          var size = frameState.size;
          var scale$$1 = (pixelRatio * imageResolution) / (viewResolution * imagePixelRatio);
          var width = Math.round(size[0] * pixelRatio);
          var height = Math.round(size[1] * pixelRatio);
          var rotation = viewState.rotation;
          if (rotation) {
              var size_1 = Math.round(Math.sqrt(width * width + height * height));
              width = size_1;
              height = size_1;
          }
          // set forward and inverse pixel transforms
          compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
          makeInverse(this.inversePixelTransform, this.pixelTransform);
          var canvasTransform = createTransformString(this.pixelTransform);
          this.useContainer(target, canvasTransform, layerState.opacity);
          var context = this.context;
          var canvas = context.canvas;
          if (canvas.width != width || canvas.height != height) {
              canvas.width = width;
              canvas.height = height;
          }
          else if (!this.containerReused) {
              context.clearRect(0, 0, width, height);
          }
          // clipped rendering if layer extent is set
          var clipped = false;
          if (layerState.extent) {
              var layerExtent = fromUserExtent(layerState.extent, viewState.projection);
              clipped =
                  !containsExtent(layerExtent, frameState.extent) &&
                      intersects(layerExtent, frameState.extent);
              if (clipped) {
                  this.clipUnrotated(context, frameState, layerExtent);
              }
          }
          var img = image.getImage();
          var transform$$1 = compose(this.tempTransform, width / 2, height / 2, scale$$1, scale$$1, 0, (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolution, (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolution);
          this.renderedResolution = (imageResolution * pixelRatio) / imagePixelRatio;
          var dx = transform$$1[4];
          var dy = transform$$1[5];
          var dw = img.width * transform$$1[0];
          var dh = img.height * transform$$1[3];
          assign(context, this.getLayer().getSource().getContextOptions());
          this.preRender(context, frameState);
          if (dw >= 0.5 && dh >= 0.5) {
              var opacity = layerState.opacity;
              var previousAlpha = void 0;
              if (opacity !== 1) {
                  previousAlpha = this.context.globalAlpha;
                  this.context.globalAlpha = opacity;
              }
              this.context.drawImage(img, 0, 0, +img.width, +img.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
              if (opacity !== 1) {
                  this.context.globalAlpha = previousAlpha;
              }
          }
          this.postRender(context, frameState);
          if (clipped) {
              context.restore();
          }
          if (canvasTransform !== canvas.style.transform) {
              canvas.style.transform = canvasTransform;
          }
          return this.container;
      };
      return CanvasImageLayerRenderer;
  }(CanvasLayerRenderer));

  var __extends$N = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Server-rendered images that are available for arbitrary extents and
   * resolutions.
   * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
   * property on the layer object; for example, setting `title: 'My Title'` in the
   * options means that `title` is observable, and has get/set accessors.
   *
   * @api
   */
  var ImageLayer = /** @class */ (function (_super) {
      __extends$N(ImageLayer, _super);
      /**
       * @param {import("./BaseImage.js").Options=} opt_options Layer options.
       */
      function ImageLayer(opt_options) {
          return _super.call(this, opt_options) || this;
      }
      /**
       * Create a renderer for this layer.
       * @return {import("../renderer/Layer.js").default} A layer renderer.
       */
      ImageLayer.prototype.createRenderer = function () {
          return new CanvasImageLayerRenderer(this);
      };
      return ImageLayer;
  }(BaseImageLayer));

  /**
   * @module ol/render
   */
  /**
   * @param {import("./PluggableMap.js").FrameState} frameState Frame state.
   * @param {?} declutterTree Declutter tree.
   * @returns {?} Declutter tree.
   */
  function renderDeclutterItems(frameState, declutterTree) {
      if (declutterTree) {
          declutterTree.clear();
      }
      var items = frameState.declutterItems;
      for (var z = items.length - 1; z >= 0; --z) {
          var item = items[z];
          var zIndexItems = item.items;
          for (var i = 0, ii = zIndexItems.length; i < ii; i += 3) {
              declutterTree = zIndexItems[i].renderDeclutter(zIndexItems[i + 1], zIndexItems[i + 2], item.opacity, declutterTree);
          }
      }
      items.length = 0;
      return declutterTree;
  }

  var __extends$O = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @abstract
   */
  var MapRenderer = /** @class */ (function (_super) {
      __extends$O(MapRenderer, _super);
      /**
       * @param {import("../PluggableMap.js").default} map Map.
       */
      function MapRenderer(map) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {import("../PluggableMap.js").default}
           */
          _this.map_ = map;
          /**
           * @private
           */
          _this.declutterTree_ = null;
          return _this;
      }
      /**
       * @abstract
       * @param {import("../render/EventType.js").default} type Event type.
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      MapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {
          abstract();
      };
      /**
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @protected
       */
      MapRenderer.prototype.calculateMatrices2D = function (frameState) {
          var viewState = frameState.viewState;
          var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
          var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
          compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
          makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
      };
      /**
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {boolean} checkWrapped Check for wrapped geometries.
       * @param {function(this: S, import("../Feature.js").FeatureLike,
       *     import("../layer/Layer.js").default): T} callback Feature callback.
       * @param {S} thisArg Value to use as `this` when executing `callback`.
       * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
       * @return {T|undefined} Callback result.
       * @template S,T,U
       */
      MapRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
          var result;
          var viewState = frameState.viewState;
          /**
           * @param {boolean} managed Managed layer.
           * @param {import("../Feature.js").FeatureLike} feature Feature.
           * @param {import("../layer/Layer.js").default} layer Layer.
           * @return {?} Callback result.
           */
          function forEachFeatureAtCoordinate(managed, feature, layer) {
              return callback.call(thisArg, feature, managed ? layer : null);
          }
          var projection = viewState.projection;
          var translatedCoordinate = wrapX$1(coordinate.slice(), projection);
          var offsets = [[0, 0]];
          if (projection.canWrapX() && checkWrapped) {
              var projectionExtent = projection.getExtent();
              var worldWidth = getWidth(projectionExtent);
              offsets.push([-worldWidth, 0], [worldWidth, 0]);
          }
          var layerStates = frameState.layerStatesArray;
          var numLayers = layerStates.length;
          var declutteredFeatures;
          if (this.declutterTree_) {
              declutteredFeatures = this.declutterTree_.all().map(function (entry) {
                  return entry.value;
              });
          }
          var tmpCoord = [];
          for (var i = 0; i < offsets.length; i++) {
              for (var j = numLayers - 1; j >= 0; --j) {
                  var layerState = layerStates[j];
                  var layer = /** @type {import("../layer/Layer.js").default} */ (layerState.layer);
                  if (layer.hasRenderer() &&
                      inView(layerState, viewState) &&
                      layerFilter.call(thisArg2, layer)) {
                      var layerRenderer = layer.getRenderer();
                      var source = layer.getSource();
                      if (layerRenderer && source) {
                          var coordinates = source.getWrapX()
                              ? translatedCoordinate
                              : coordinate;
                          var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);
                          tmpCoord[0] = coordinates[0] + offsets[i][0];
                          tmpCoord[1] = coordinates[1] + offsets[i][1];
                          result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, declutteredFeatures);
                      }
                      if (result) {
                          return result;
                      }
                  }
              }
          }
          return undefined;
      };
      /**
       * @abstract
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
       *     callback.
       * @param {function(import("../layer/Layer.js").default): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @return {T|undefined} Callback result.
       * @template T
       */
      MapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {
          return abstract();
      };
      /**
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {boolean} checkWrapped Check for wrapped geometries.
       * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
       * @return {boolean} Is there a feature at the given coordinate?
       * @template U
       */
      MapRenderer.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
          var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);
          return hasFeature !== undefined;
      };
      /**
       * @return {import("../PluggableMap.js").default} Map.
       */
      MapRenderer.prototype.getMap = function () {
          return this.map_;
      };
      /**
       * Render.
       * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      MapRenderer.prototype.renderFrame = function (frameState) {
          this.declutterTree_ = renderDeclutterItems(frameState, this.declutterTree_);
      };
      /**
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       * @protected
       */
      MapRenderer.prototype.scheduleExpireIconCache = function (frameState) {
          if (shared.canExpireCache()) {
              frameState.postRenderFunctions.push(expireIconCache);
          }
      };
      return MapRenderer;
  }(Disposable));
  /**
   * @param {import("../PluggableMap.js").default} map Map.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   */
  function expireIconCache(map, frameState) {
      shared.expire();
  }

  var __extends$P = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Canvas map renderer.
   * @api
   */
  var CompositeMapRenderer = /** @class */ (function (_super) {
      __extends$P(CompositeMapRenderer, _super);
      /**
       * @param {import("../PluggableMap.js").default} map Map.
       */
      function CompositeMapRenderer(map) {
          var _this = _super.call(this, map) || this;
          /**
           * @type {import("../events.js").EventsKey}
           */
          _this.fontChangeListenerKey_ = listen(checkedFonts, ObjectEventType.PROPERTYCHANGE, map.redrawText.bind(map));
          /**
           * @private
           * @type {HTMLDivElement}
           */
          _this.element_ = document.createElement('div');
          var style = _this.element_.style;
          style.position = 'absolute';
          style.width = '100%';
          style.height = '100%';
          style.zIndex = '0';
          _this.element_.className = CLASS_UNSELECTABLE + ' ol-layers';
          var container = map.getViewport();
          container.insertBefore(_this.element_, container.firstChild || null);
          /**
           * @private
           * @type {Array<HTMLElement>}
           */
          _this.children_ = [];
          /**
           * @private
           * @type {boolean}
           */
          _this.renderedVisible_ = true;
          return _this;
      }
      /**
       * @param {import("../render/EventType.js").default} type Event type.
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      CompositeMapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {
          var map = this.getMap();
          if (map.hasListener(type)) {
              var event_1 = new RenderEvent(type, undefined, frameState);
              map.dispatchEvent(event_1);
          }
      };
      CompositeMapRenderer.prototype.disposeInternal = function () {
          unlistenByKey(this.fontChangeListenerKey_);
          this.element_.parentNode.removeChild(this.element_);
          _super.prototype.disposeInternal.call(this);
      };
      /**
       * Render.
       * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      CompositeMapRenderer.prototype.renderFrame = function (frameState) {
          if (!frameState) {
              if (this.renderedVisible_) {
                  this.element_.style.display = 'none';
                  this.renderedVisible_ = false;
              }
              return;
          }
          this.calculateMatrices2D(frameState);
          this.dispatchRenderEvent(RenderEventType.PRECOMPOSE, frameState);
          var layerStatesArray = frameState.layerStatesArray.sort(function (a, b) {
              return a.zIndex - b.zIndex;
          });
          var viewState = frameState.viewState;
          this.children_.length = 0;
          var previousElement = null;
          for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
              var layerState = layerStatesArray[i];
              frameState.layerIndex = i;
              if (!inView(layerState, viewState) ||
                  (layerState.sourceState != SourceState.READY &&
                      layerState.sourceState != SourceState.UNDEFINED)) {
                  continue;
              }
              var layer = layerState.layer;
              var element = layer.render(frameState, previousElement);
              if (!element) {
                  continue;
              }
              if (element !== previousElement) {
                  this.children_.push(element);
                  previousElement = element;
              }
          }
          _super.prototype.renderFrame.call(this, frameState);
          replaceChildren(this.element_, this.children_);
          this.dispatchRenderEvent(RenderEventType.POSTCOMPOSE, frameState);
          if (!this.renderedVisible_) {
              this.element_.style.display = '';
              this.renderedVisible_ = true;
          }
          this.scheduleExpireIconCache(frameState);
      };
      /**
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
       *     callback.
       * @param {function(import("../layer/Layer.js").default): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @return {T|undefined} Callback result.
       * @template T
       */
      CompositeMapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {
          var viewState = frameState.viewState;
          var layerStates = frameState.layerStatesArray;
          var numLayers = layerStates.length;
          for (var i = numLayers - 1; i >= 0; --i) {
              var layerState = layerStates[i];
              var layer = layerState.layer;
              if (layer.hasRenderer() &&
                  inView(layerState, viewState) &&
                  layerFilter(layer)) {
                  var layerRenderer = layer.getRenderer();
                  var data = layerRenderer.getDataAtPixel(pixel, frameState, hitTolerance);
                  if (data) {
                      var result = callback(layer, data);
                      if (result) {
                          return result;
                      }
                  }
              }
          }
          return undefined;
      };
      return CompositeMapRenderer;
  }(MapRenderer));

  var __extends$Q = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {Array<import("./Base.js").default>|import("../Collection.js").default<import("./Base.js").default>} [layers] Child layers.
   */
  /**
   * @enum {string}
   * @private
   */
  var Property$2 = {
      LAYERS: 'layers',
  };
  /**
   * @classdesc
   * A {@link module:ol/Collection~Collection} of layers that are handled together.
   *
   * A generic `change` event is triggered when the group/Collection changes.
   *
   * @api
   */
  var LayerGroup = /** @class */ (function (_super) {
      __extends$Q(LayerGroup, _super);
      /**
       * @param {Options=} opt_options Layer options.
       */
      function LayerGroup(opt_options) {
          var _this = this;
          var options = opt_options || {};
          var baseOptions = /** @type {Options} */ (assign({}, options));
          delete baseOptions.layers;
          var layers = options.layers;
          _this = _super.call(this, baseOptions) || this;
          /**
           * @private
           * @type {Array<import("../events.js").EventsKey>}
           */
          _this.layersListenerKeys_ = [];
          /**
           * @private
           * @type {Object<string, Array<import("../events.js").EventsKey>>}
           */
          _this.listenerKeys_ = {};
          _this.addEventListener(getChangeEventType(Property$2.LAYERS), _this.handleLayersChanged_);
          if (layers) {
              if (Array.isArray(layers)) {
                  layers = new Collection(layers.slice(), { unique: true });
              }
              else {
                  assert(typeof ( /** @type {?} */(layers).getArray) === 'function', 43); // Expected `layers` to be an array or a `Collection`
              }
          }
          else {
              layers = new Collection(undefined, { unique: true });
          }
          _this.setLayers(layers);
          return _this;
      }
      /**
       * @private
       */
      LayerGroup.prototype.handleLayerChange_ = function () {
          this.changed();
      };
      /**
       * @private
       */
      LayerGroup.prototype.handleLayersChanged_ = function () {
          this.layersListenerKeys_.forEach(unlistenByKey);
          this.layersListenerKeys_.length = 0;
          var layers = this.getLayers();
          this.layersListenerKeys_.push(listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this), listen(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this));
          for (var id in this.listenerKeys_) {
              this.listenerKeys_[id].forEach(unlistenByKey);
          }
          clear(this.listenerKeys_);
          var layersArray = layers.getArray();
          for (var i = 0, ii = layersArray.length; i < ii; i++) {
              var layer = layersArray[i];
              this.listenerKeys_[getUid(layer)] = [
                  listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this),
                  listen(layer, EventType.CHANGE, this.handleLayerChange_, this),
              ];
          }
          this.changed();
      };
      /**
       * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
       * @private
       */
      LayerGroup.prototype.handleLayersAdd_ = function (collectionEvent) {
          var layer = /** @type {import("./Base.js").default} */ (collectionEvent.element);
          this.listenerKeys_[getUid(layer)] = [
              listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this),
              listen(layer, EventType.CHANGE, this.handleLayerChange_, this),
          ];
          this.changed();
      };
      /**
       * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
       * @private
       */
      LayerGroup.prototype.handleLayersRemove_ = function (collectionEvent) {
          var layer = /** @type {import("./Base.js").default} */ (collectionEvent.element);
          var key = getUid(layer);
          this.listenerKeys_[key].forEach(unlistenByKey);
          delete this.listenerKeys_[key];
          this.changed();
      };
      /**
       * Returns the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
       * in this group.
       * @return {!import("../Collection.js").default<import("./Base.js").default>} Collection of
       *   {@link module:ol/layer/Base layers} that are part of this group.
       * @observable
       * @api
       */
      LayerGroup.prototype.getLayers = function () {
          return /** @type {!import("../Collection.js").default<import("./Base.js").default>} */ (this.get(Property$2.LAYERS));
      };
      /**
       * Set the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
       * in this group.
       * @param {!import("../Collection.js").default<import("./Base.js").default>} layers Collection of
       *   {@link module:ol/layer/Base layers} that are part of this group.
       * @observable
       * @api
       */
      LayerGroup.prototype.setLayers = function (layers) {
          this.set(Property$2.LAYERS, layers);
      };
      /**
       * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      LayerGroup.prototype.getLayersArray = function (opt_array) {
          var array = opt_array !== undefined ? opt_array : [];
          this.getLayers().forEach(function (layer) {
              layer.getLayersArray(array);
          });
          return array;
      };
      /**
       * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      LayerGroup.prototype.getLayerStatesArray = function (opt_states) {
          var states = opt_states !== undefined ? opt_states : [];
          var pos = states.length;
          this.getLayers().forEach(function (layer) {
              layer.getLayerStatesArray(states);
          });
          var ownLayerState = this.getLayerState();
          for (var i = pos, ii = states.length; i < ii; i++) {
              var layerState = states[i];
              layerState.opacity *= ownLayerState.opacity;
              layerState.visible = layerState.visible && ownLayerState.visible;
              layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
              layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
              layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
              layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
              if (ownLayerState.extent !== undefined) {
                  if (layerState.extent !== undefined) {
                      layerState.extent = getIntersection(layerState.extent, ownLayerState.extent);
                  }
                  else {
                      layerState.extent = ownLayerState.extent;
                  }
              }
          }
          return states;
      };
      /**
       * @return {import("../source/State.js").default} Source state.
       */
      LayerGroup.prototype.getSourceState = function () {
          return SourceState.READY;
      };
      return LayerGroup;
  }(BaseLayer));

  /**
   * @module ol/pointer/EventType
   */
  /**
   * Constants for event names.
   * @enum {string}
   */
  var PointerEventType = {
      POINTERMOVE: 'pointermove',
      POINTERDOWN: 'pointerdown',
      POINTERUP: 'pointerup',
      POINTEROVER: 'pointerover',
      POINTEROUT: 'pointerout',
      POINTERENTER: 'pointerenter',
      POINTERLEAVE: 'pointerleave',
      POINTERCANCEL: 'pointercancel',
  };

  /**
   * @module ol/MapBrowserEventHandler
   */
  var __extends$R = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var MapBrowserEventHandler = /** @class */ (function (_super) {
      __extends$R(MapBrowserEventHandler, _super);
      /**
       * @param {import("./PluggableMap.js").default} map The map with the viewport to listen to events on.
       * @param {number=} moveTolerance The minimal distance the pointer must travel to trigger a move.
       */
      function MapBrowserEventHandler(map, moveTolerance) {
          var _this = _super.call(this, map) || this;
          /**
           * This is the element that we will listen to the real events on.
           * @type {import("./PluggableMap.js").default}
           * @private
           */
          _this.map_ = map;
          /**
           * @type {any}
           * @private
           */
          _this.clickTimeoutId_;
          /**
           * @type {boolean}
           * @private
           */
          _this.dragging_ = false;
          /**
           * @type {!Array<import("./events.js").EventsKey>}
           * @private
           */
          _this.dragListenerKeys_ = [];
          /**
           * @type {number}
           * @private
           */
          _this.moveTolerance_ = moveTolerance
              ? moveTolerance * DEVICE_PIXEL_RATIO
              : DEVICE_PIXEL_RATIO;
          /**
           * The most recent "down" type event (or null if none have occurred).
           * Set on pointerdown.
           * @type {PointerEvent}
           * @private
           */
          _this.down_ = null;
          var element = _this.map_.getViewport();
          /**
           * @type {number}
           * @private
           */
          _this.activePointers_ = 0;
          /**
           * @type {!Object<number, boolean>}
           * @private
           */
          _this.trackedTouches_ = {};
          _this.element_ = element;
          /**
           * @type {?import("./events.js").EventsKey}
           * @private
           */
          _this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, _this.handlePointerDown_, _this);
          /**
           * @type {PointerEvent}
           * @private
           */
          _this.originalPointerMoveEvent_;
          /**
           * @type {?import("./events.js").EventsKey}
           * @private
           */
          _this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, _this.relayEvent_, _this);
          /**
           * @private
           */
          _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);
          _this.element_.addEventListener(EventType.TOUCHMOVE, _this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);
          return _this;
      }
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.emulateClick_ = function (pointerEvent) {
          var newEvent = new MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);
          this.dispatchEvent(newEvent);
          if (this.clickTimeoutId_ !== undefined) {
              // double-click
              clearTimeout(this.clickTimeoutId_);
              this.clickTimeoutId_ = undefined;
              newEvent = new MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);
              this.dispatchEvent(newEvent);
          }
          else {
              // click
              this.clickTimeoutId_ = setTimeout(function () {
                  this.clickTimeoutId_ = undefined;
                  var newEvent = new MapBrowserEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);
                  this.dispatchEvent(newEvent);
              }.bind(this), 250);
          }
      };
      /**
       * Keeps track on how many pointers are currently active.
       *
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.updateActivePointers_ = function (pointerEvent) {
          var event = pointerEvent;
          if (event.type == MapBrowserEventType.POINTERUP ||
              event.type == MapBrowserEventType.POINTERCANCEL) {
              delete this.trackedTouches_[event.pointerId];
          }
          else if (event.type == MapBrowserEventType.POINTERDOWN) {
              this.trackedTouches_[event.pointerId] = true;
          }
          this.activePointers_ = Object.keys(this.trackedTouches_).length;
      };
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.handlePointerUp_ = function (pointerEvent) {
          this.updateActivePointers_(pointerEvent);
          var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent);
          this.dispatchEvent(newEvent);
          // We emulate click events on left mouse button click, touch contact, and pen
          // contact. isMouseActionButton returns true in these cases (evt.button is set
          // to 0).
          // See http://www.w3.org/TR/pointerevents/#button-states
          // We only fire click, singleclick, and doubleclick if nobody has called
          // event.stopPropagation() or event.preventDefault().
          if (!newEvent.propagationStopped &&
              !this.dragging_ &&
              this.isMouseActionButton_(pointerEvent)) {
              this.emulateClick_(this.down_);
          }
          if (this.activePointers_ === 0) {
              this.dragListenerKeys_.forEach(unlistenByKey);
              this.dragListenerKeys_.length = 0;
              this.dragging_ = false;
              this.down_ = null;
          }
      };
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @return {boolean} If the left mouse button was pressed.
       * @private
       */
      MapBrowserEventHandler.prototype.isMouseActionButton_ = function (pointerEvent) {
          return pointerEvent.button === 0;
      };
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.handlePointerDown_ = function (pointerEvent) {
          this.updateActivePointers_(pointerEvent);
          var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);
          this.dispatchEvent(newEvent);
          this.down_ = pointerEvent;
          if (this.dragListenerKeys_.length === 0) {
              this.dragListenerKeys_.push(listen(document, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(document, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this), 
              /* Note that the listener for `pointercancel is set up on
               * `pointerEventHandler_` and not `documentPointerEventHandler_` like
               * the `pointerup` and `pointermove` listeners.
               *
               * The reason for this is the following: `TouchSource.vacuumTouches_()`
               * issues `pointercancel` events, when there was no `touchend` for a
               * `touchstart`. Now, let's say a first `touchstart` is registered on
               * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
               * But `documentPointerEventHandler_` doesn't know about the first
               * `touchstart`. If there is no `touchend` for the `touchstart`, we can
               * only receive a `touchcancel` from `pointerEventHandler_`, because it is
               * only registered there.
               */
              listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));
              if (this.element_.getRootNode &&
                  this.element_.getRootNode() !== document) {
                  this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));
              }
          }
      };
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.handlePointerMove_ = function (pointerEvent) {
          // Between pointerdown and pointerup, pointermove events are triggered.
          // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
          // moved a significant distance.
          if (this.isMoving_(pointerEvent)) {
              this.dragging_ = true;
              var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_);
              this.dispatchEvent(newEvent);
          }
      };
      /**
       * Wrap and relay a pointer event.  Note that this requires that the type
       * string for the MapBrowserEvent matches the PointerEvent type.
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.relayEvent_ = function (pointerEvent) {
          this.originalPointerMoveEvent_ = pointerEvent;
          var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
          this.dispatchEvent(new MapBrowserEvent(pointerEvent.type, this.map_, pointerEvent, dragging));
      };
      /**
       * Flexible handling of a `touch-action: none` css equivalent: because calling
       * `preventDefault()` on a `pointermove` event does not stop native page scrolling
       * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
       * when an interaction (currently `DragPan` handles the event.
       * @param {TouchEvent} event Event.
       * @private
       */
      MapBrowserEventHandler.prototype.handleTouchMove_ = function (event) {
          // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
          // may not be initialized yet when we get here on a platform without native pointer events.
          if (!this.originalPointerMoveEvent_ ||
              this.originalPointerMoveEvent_.defaultPrevented) {
              event.preventDefault();
          }
      };
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @return {boolean} Is moving.
       * @private
       */
      MapBrowserEventHandler.prototype.isMoving_ = function (pointerEvent) {
          return (this.dragging_ ||
              Math.abs(pointerEvent.clientX - this.down_.clientX) >
                  this.moveTolerance_ ||
              Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_);
      };
      /**
       * Clean up.
       */
      MapBrowserEventHandler.prototype.disposeInternal = function () {
          if (this.relayedListenerKey_) {
              unlistenByKey(this.relayedListenerKey_);
              this.relayedListenerKey_ = null;
          }
          this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);
          if (this.pointerdownListenerKey_) {
              unlistenByKey(this.pointerdownListenerKey_);
              this.pointerdownListenerKey_ = null;
          }
          this.dragListenerKeys_.forEach(unlistenByKey);
          this.dragListenerKeys_.length = 0;
          this.element_ = null;
          _super.prototype.disposeInternal.call(this);
      };
      return MapBrowserEventHandler;
  }(Target));

  /**
   * @module ol/MapProperty
   */
  /**
   * @enum {string}
   */
  var MapProperty = {
      LAYERGROUP: 'layergroup',
      SIZE: 'size',
      TARGET: 'target',
      VIEW: 'view',
  };

  /**
   * @module ol/structs/PriorityQueue
   */
  /**
   * @type {number}
   */
  var DROP = Infinity;
  /**
   * @classdesc
   * Priority queue.
   *
   * The implementation is inspired from the Closure Library's Heap class and
   * Python's heapq module.
   *
   * See http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html
   * and http://hg.python.org/cpython/file/2.7/Lib/heapq.py.
   *
   * @template T
   */
  var PriorityQueue = /** @class */ (function () {
      /**
       * @param {function(T): number} priorityFunction Priority function.
       * @param {function(T): string} keyFunction Key function.
       */
      function PriorityQueue(priorityFunction, keyFunction) {
          /**
           * @type {function(T): number}
           * @private
           */
          this.priorityFunction_ = priorityFunction;
          /**
           * @type {function(T): string}
           * @private
           */
          this.keyFunction_ = keyFunction;
          /**
           * @type {Array<T>}
           * @private
           */
          this.elements_ = [];
          /**
           * @type {Array<number>}
           * @private
           */
          this.priorities_ = [];
          /**
           * @type {!Object<string, boolean>}
           * @private
           */
          this.queuedElements_ = {};
      }
      /**
       * FIXME empty description for jsdoc
       */
      PriorityQueue.prototype.clear = function () {
          this.elements_.length = 0;
          this.priorities_.length = 0;
          clear(this.queuedElements_);
      };
      /**
       * Remove and return the highest-priority element. O(log N).
       * @return {T} Element.
       */
      PriorityQueue.prototype.dequeue = function () {
          var elements = this.elements_;
          var priorities = this.priorities_;
          var element = elements[0];
          if (elements.length == 1) {
              elements.length = 0;
              priorities.length = 0;
          }
          else {
              elements[0] = elements.pop();
              priorities[0] = priorities.pop();
              this.siftUp_(0);
          }
          var elementKey = this.keyFunction_(element);
          delete this.queuedElements_[elementKey];
          return element;
      };
      /**
       * Enqueue an element. O(log N).
       * @param {T} element Element.
       * @return {boolean} The element was added to the queue.
       */
      PriorityQueue.prototype.enqueue = function (element) {
          assert(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue
          var priority = this.priorityFunction_(element);
          if (priority != DROP) {
              this.elements_.push(element);
              this.priorities_.push(priority);
              this.queuedElements_[this.keyFunction_(element)] = true;
              this.siftDown_(0, this.elements_.length - 1);
              return true;
          }
          return false;
      };
      /**
       * @return {number} Count.
       */
      PriorityQueue.prototype.getCount = function () {
          return this.elements_.length;
      };
      /**
       * Gets the index of the left child of the node at the given index.
       * @param {number} index The index of the node to get the left child for.
       * @return {number} The index of the left child.
       * @private
       */
      PriorityQueue.prototype.getLeftChildIndex_ = function (index) {
          return index * 2 + 1;
      };
      /**
       * Gets the index of the right child of the node at the given index.
       * @param {number} index The index of the node to get the right child for.
       * @return {number} The index of the right child.
       * @private
       */
      PriorityQueue.prototype.getRightChildIndex_ = function (index) {
          return index * 2 + 2;
      };
      /**
       * Gets the index of the parent of the node at the given index.
       * @param {number} index The index of the node to get the parent for.
       * @return {number} The index of the parent.
       * @private
       */
      PriorityQueue.prototype.getParentIndex_ = function (index) {
          return (index - 1) >> 1;
      };
      /**
       * Make this a heap. O(N).
       * @private
       */
      PriorityQueue.prototype.heapify_ = function () {
          var i;
          for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
              this.siftUp_(i);
          }
      };
      /**
       * @return {boolean} Is empty.
       */
      PriorityQueue.prototype.isEmpty = function () {
          return this.elements_.length === 0;
      };
      /**
       * @param {string} key Key.
       * @return {boolean} Is key queued.
       */
      PriorityQueue.prototype.isKeyQueued = function (key) {
          return key in this.queuedElements_;
      };
      /**
       * @param {T} element Element.
       * @return {boolean} Is queued.
       */
      PriorityQueue.prototype.isQueued = function (element) {
          return this.isKeyQueued(this.keyFunction_(element));
      };
      /**
       * @param {number} index The index of the node to move down.
       * @private
       */
      PriorityQueue.prototype.siftUp_ = function (index) {
          var elements = this.elements_;
          var priorities = this.priorities_;
          var count = elements.length;
          var element = elements[index];
          var priority = priorities[index];
          var startIndex = index;
          while (index < count >> 1) {
              var lIndex = this.getLeftChildIndex_(index);
              var rIndex = this.getRightChildIndex_(index);
              var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex]
                  ? rIndex
                  : lIndex;
              elements[index] = elements[smallerChildIndex];
              priorities[index] = priorities[smallerChildIndex];
              index = smallerChildIndex;
          }
          elements[index] = element;
          priorities[index] = priority;
          this.siftDown_(startIndex, index);
      };
      /**
       * @param {number} startIndex The index of the root.
       * @param {number} index The index of the node to move up.
       * @private
       */
      PriorityQueue.prototype.siftDown_ = function (startIndex, index) {
          var elements = this.elements_;
          var priorities = this.priorities_;
          var element = elements[index];
          var priority = priorities[index];
          while (index > startIndex) {
              var parentIndex = this.getParentIndex_(index);
              if (priorities[parentIndex] > priority) {
                  elements[index] = elements[parentIndex];
                  priorities[index] = priorities[parentIndex];
                  index = parentIndex;
              }
              else {
                  break;
              }
          }
          elements[index] = element;
          priorities[index] = priority;
      };
      /**
       * FIXME empty description for jsdoc
       */
      PriorityQueue.prototype.reprioritize = function () {
          var priorityFunction = this.priorityFunction_;
          var elements = this.elements_;
          var priorities = this.priorities_;
          var index = 0;
          var n = elements.length;
          var element, i, priority;
          for (i = 0; i < n; ++i) {
              element = elements[i];
              priority = priorityFunction(element);
              if (priority == DROP) {
                  delete this.queuedElements_[this.keyFunction_(element)];
              }
              else {
                  priorities[index] = priority;
                  elements[index++] = element;
              }
          }
          elements.length = index;
          priorities.length = index;
          this.heapify_();
      };
      return PriorityQueue;
  }());

  /**
   * @module ol/TileState
   */
  /**
   * @enum {number}
   */
  var TileState = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      /**
       * Indicates that tile loading failed
       * @type {number}
       */
      ERROR: 3,
      EMPTY: 4,
  };

  var __extends$S = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
   */
  var TileQueue = /** @class */ (function (_super) {
      __extends$S(TileQueue, _super);
      /**
       * @param {PriorityFunction} tilePriorityFunction Tile priority function.
       * @param {function(): ?} tileChangeCallback Function called on each tile change event.
       */
      function TileQueue(tilePriorityFunction, tileChangeCallback) {
          var _this = _super.call(this, 
          /**
           * @param {Array} element Element.
           * @return {number} Priority.
           */
          function (element) {
              return tilePriorityFunction.apply(null, element);
          }, 
          /**
           * @param {Array} element Element.
           * @return {string} Key.
           */
          function (element) {
              return /** @type {import("./Tile.js").default} */ (element[0]).getKey();
          }) || this;
          /** @private */
          _this.boundHandleTileChange_ = _this.handleTileChange.bind(_this);
          /**
           * @private
           * @type {function(): ?}
           */
          _this.tileChangeCallback_ = tileChangeCallback;
          /**
           * @private
           * @type {number}
           */
          _this.tilesLoading_ = 0;
          /**
           * @private
           * @type {!Object<string,boolean>}
           */
          _this.tilesLoadingKeys_ = {};
          return _this;
      }
      /**
       * @param {Array} element Element.
       * @return {boolean} The element was added to the queue.
       */
      TileQueue.prototype.enqueue = function (element) {
          var added = _super.prototype.enqueue.call(this, element);
          if (added) {
              var tile = element[0];
              tile.addEventListener(EventType.CHANGE, this.boundHandleTileChange_);
          }
          return added;
      };
      /**
       * @return {number} Number of tiles loading.
       */
      TileQueue.prototype.getTilesLoading = function () {
          return this.tilesLoading_;
      };
      /**
       * @param {import("./events/Event.js").default} event Event.
       * @protected
       */
      TileQueue.prototype.handleTileChange = function (event) {
          var tile = /** @type {import("./Tile.js").default} */ (event.target);
          var state = tile.getState();
          if ((tile.hifi && state === TileState.LOADED) ||
              state === TileState.ERROR ||
              state === TileState.EMPTY) {
              tile.removeEventListener(EventType.CHANGE, this.boundHandleTileChange_);
              var tileKey = tile.getKey();
              if (tileKey in this.tilesLoadingKeys_) {
                  delete this.tilesLoadingKeys_[tileKey];
                  --this.tilesLoading_;
              }
              this.tileChangeCallback_();
          }
      };
      /**
       * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
       * @param {number} maxNewLoads Maximum number of new tiles to load.
       */
      TileQueue.prototype.loadMoreTiles = function (maxTotalLoading, maxNewLoads) {
          var newLoads = 0;
          var state, tile, tileKey;
          while (this.tilesLoading_ < maxTotalLoading &&
              newLoads < maxNewLoads &&
              this.getCount() > 0) {
              tile = /** @type {import("./Tile.js").default} */ (this.dequeue()[0]);
              tileKey = tile.getKey();
              state = tile.getState();
              if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
                  this.tilesLoadingKeys_[tileKey] = true;
                  ++this.tilesLoading_;
                  ++newLoads;
                  tile.load();
              }
          }
      };
      return TileQueue;
  }(PriorityQueue));
  /**
   * @param {import('./PluggableMap.js').FrameState} frameState Frame state.
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
      // Filter out tiles at higher zoom levels than the current zoom level, or that
      // are outside the visible extent.
      if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
          return DROP;
      }
      if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
          return DROP;
      }
      // Prioritize the highest zoom level tiles closest to the focus.
      // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
      // Within a zoom level, tiles are prioritized by the distance in pixels between
      // the center of the tile and the center of the viewport.  The factor of 65536
      // means that the prioritization should behave as desired for tiles up to
      // 65536 * Math.log(2) = 45426 pixels from the focus.
      var center = frameState.viewState.center;
      var deltaX = tileCenter[0] - center[0];
      var deltaY = tileCenter[1] - center[1];
      return (65536 * Math.log(tileResolution) +
          Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution);
  }

  /**
   * @module ol/ViewProperty
   */
  /**
   * @enum {string}
   */
  var ViewProperty = {
      CENTER: 'center',
      RESOLUTION: 'resolution',
      ROTATION: 'rotation',
  };

  /**
   * @module ol/tilegrid/common
   */
  /**
   * Default maximum zoom for default tile grids.
   * @type {number}
   */
  var DEFAULT_MAX_ZOOM = 42;
  /**
   * Default tile size.
   * @type {number}
   */
  var DEFAULT_TILE_SIZE = 256;

  /**
   * @module ol/centerconstraint
   */
  /**
   * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=): (import("./coordinate.js").Coordinate|undefined)} Type
   */
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
   * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
   * (only during interaction and animation).
   * @return {Type} The constraint.
   */
  function createExtent(extent, onlyCenter, smooth) {
      return (
      /**
       * @param {import("./coordinate.js").Coordinate|undefined} center Center.
       * @param {number} resolution Resolution.
       * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {import("./coordinate.js").Coordinate|undefined} Center.
       */
      function (center, resolution, size, opt_isMoving) {
          if (center) {
              var viewWidth = onlyCenter ? 0 : size[0] * resolution;
              var viewHeight = onlyCenter ? 0 : size[1] * resolution;
              var minX = extent[0] + viewWidth / 2;
              var maxX = extent[2] - viewWidth / 2;
              var minY = extent[1] + viewHeight / 2;
              var maxY = extent[3] - viewHeight / 2;
              // note: when zooming out of bounds, min and max values for x and y may
              // end up inverted (min > max); this has to be accounted for
              if (minX > maxX) {
                  minX = (maxX + minX) / 2;
                  maxX = minX;
              }
              if (minY > maxY) {
                  minY = (maxY + minY) / 2;
                  maxY = minY;
              }
              var x = clamp(center[0], minX, maxX);
              var y = clamp(center[1], minY, maxY);
              var ratio = 30 * resolution;
              // during an interaction, allow some overscroll
              if (opt_isMoving && smooth) {
                  x +=
                      -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) +
                          ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
                  y +=
                      -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) +
                          ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
              }
              return [x, y];
          }
          else {
              return undefined;
          }
      });
  }
  /**
   * @param {import("./coordinate.js").Coordinate=} center Center.
   * @return {import("./coordinate.js").Coordinate|undefined} Center.
   */
  function none(center) {
      return center;
  }

  /**
   * @module ol/resolutionconstraint
   */
  /**
   * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
   */
  /**
   * Returns a modified resolution taking into account the viewport size and maximum
   * allowed extent.
   * @param {number} resolution Resolution
   * @param {import("./extent.js").Extent=} maxExtent Maximum allowed extent.
   * @param {import("./size.js").Size} viewportSize Viewport size.
   * @param {boolean} showFullExtent Whether to show the full extent.
   * @return {number} Capped resolution.
   */
  function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
      var xResolution = getWidth(maxExtent) / viewportSize[0];
      var yResolution = getHeight(maxExtent) / viewportSize[1];
      if (showFullExtent) {
          return Math.min(resolution, Math.max(xResolution, yResolution));
      }
      return Math.min(resolution, Math.min(xResolution, yResolution));
  }
  /**
   * Returns a modified resolution to be between maxResolution and minResolution while
   * still allowing the value to be slightly out of bounds.
   * Note: the computation is based on the logarithm function (ln):
   *  - at 1, ln(x) is 0
   *  - above 1, ln(x) keeps increasing but at a much slower pace than x
   * The final result is clamped to prevent getting too far away from bounds.
   * @param {number} resolution Resolution.
   * @param {number} maxResolution Max resolution.
   * @param {number} minResolution Min resolution.
   * @return {number} Smoothed resolution.
   */
  function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
      var result = Math.min(resolution, maxResolution);
      var ratio = 50;
      result *=
          Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +
              1;
      if (minResolution) {
          result = Math.max(result, minResolution);
          result /=
              Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /
                  ratio +
                  1;
      }
      return clamp(result, minResolution / 2, maxResolution * 2);
  }
  /**
   * @param {Array<number>} resolutions Resolutions.
   * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
   * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
   * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
   * @return {Type} Zoom function.
   */
  function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {
      return (
      /**
       * @param {number|undefined} resolution Resolution.
       * @param {number} direction Direction.
       * @param {import("./size.js").Size} size Viewport size.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {number|undefined} Resolution.
       */
      function (resolution, direction, size, opt_isMoving) {
          if (resolution !== undefined) {
              var maxResolution = resolutions[0];
              var minResolution = resolutions[resolutions.length - 1];
              var cappedMaxRes = opt_maxExtent
                  ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)
                  : maxResolution;
              // during interacting or animating, allow intermediary values
              if (opt_isMoving) {
                  var smooth = opt_smooth !== undefined ? opt_smooth : true;
                  if (!smooth) {
                      return clamp(resolution, minResolution, cappedMaxRes);
                  }
                  return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
              }
              var capped = Math.min(cappedMaxRes, resolution);
              var z = Math.floor(linearFindNearest(resolutions, capped, direction));
              if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
                  return resolutions[z + 1];
              }
              return resolutions[z];
          }
          else {
              return undefined;
          }
      });
  }
  /**
   * @param {number} power Power.
   * @param {number} maxResolution Maximum resolution.
   * @param {number=} opt_minResolution Minimum resolution.
   * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
   * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
   * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
   * @return {Type} Zoom function.
   */
  function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
      return (
      /**
       * @param {number|undefined} resolution Resolution.
       * @param {number} direction Direction.
       * @param {import("./size.js").Size} size Viewport size.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {number|undefined} Resolution.
       */
      function (resolution, direction, size, opt_isMoving) {
          if (resolution !== undefined) {
              var cappedMaxRes = opt_maxExtent
                  ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)
                  : maxResolution;
              var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0;
              // during interacting or animating, allow intermediary values
              if (opt_isMoving) {
                  var smooth = opt_smooth !== undefined ? opt_smooth : true;
                  if (!smooth) {
                      return clamp(resolution, minResolution, cappedMaxRes);
                  }
                  return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
              }
              var tolerance = 1e-9;
              var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
              var offset = -direction * (0.5 - tolerance) + 0.5;
              var capped = Math.min(cappedMaxRes, resolution);
              var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
              var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
              var newResolution = maxResolution / Math.pow(power, zoomLevel);
              return clamp(newResolution, minResolution, cappedMaxRes);
          }
          else {
              return undefined;
          }
      });
  }
  /**
   * @param {number} maxResolution Max resolution.
   * @param {number} minResolution Min resolution.
   * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
   * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
   * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
   * @return {Type} Zoom function.
   */
  function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
      return (
      /**
       * @param {number|undefined} resolution Resolution.
       * @param {number} direction Direction.
       * @param {import("./size.js").Size} size Viewport size.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {number|undefined} Resolution.
       */
      function (resolution, direction, size, opt_isMoving) {
          if (resolution !== undefined) {
              var cappedMaxRes = opt_maxExtent
                  ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)
                  : maxResolution;
              var smooth = opt_smooth !== undefined ? opt_smooth : true;
              if (!smooth || !opt_isMoving) {
                  return clamp(resolution, minResolution, cappedMaxRes);
              }
              return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
          }
          else {
              return undefined;
          }
      });
  }

  /**
   * @module ol/rotationconstraint
   */
  /**
   * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
   */
  /**
   * @param {number|undefined} rotation Rotation.
   * @return {number|undefined} Rotation.
   */
  function disable(rotation) {
      if (rotation !== undefined) {
          return 0;
      }
      else {
          return undefined;
      }
  }
  /**
   * @param {number|undefined} rotation Rotation.
   * @return {number|undefined} Rotation.
   */
  function none$1(rotation) {
      if (rotation !== undefined) {
          return rotation;
      }
      else {
          return undefined;
      }
  }
  /**
   * @param {number} n N.
   * @return {Type} Rotation constraint.
   */
  function createSnapToN(n) {
      var theta = (2 * Math.PI) / n;
      return (
      /**
       * @param {number|undefined} rotation Rotation.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {number|undefined} Rotation.
       */
      function (rotation, opt_isMoving) {
          if (opt_isMoving) {
              return rotation;
          }
          if (rotation !== undefined) {
              rotation = Math.floor(rotation / theta + 0.5) * theta;
              return rotation;
          }
          else {
              return undefined;
          }
      });
  }
  /**
   * @param {number=} opt_tolerance Tolerance.
   * @return {Type} Rotation constraint.
   */
  function createSnapToZero(opt_tolerance) {
      var tolerance = opt_tolerance || toRadians(5);
      return (
      /**
       * @param {number|undefined} rotation Rotation.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {number|undefined} Rotation.
       */
      function (rotation, opt_isMoving) {
          if (opt_isMoving) {
              return rotation;
          }
          if (rotation !== undefined) {
              if (Math.abs(rotation) <= tolerance) {
                  return 0;
              }
              else {
                  return rotation;
              }
          }
          else {
              return undefined;
          }
      });
  }

  var __extends$T = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * An animation configuration
   *
   * @typedef {Object} Animation
   * @property {import("./coordinate.js").Coordinate} [sourceCenter]
   * @property {import("./coordinate.js").Coordinate} [targetCenter]
   * @property {number} [sourceResolution]
   * @property {number} [targetResolution]
   * @property {number} [sourceRotation]
   * @property {number} [targetRotation]
   * @property {import("./coordinate.js").Coordinate} [anchor]
   * @property {number} start
   * @property {number} duration
   * @property {boolean} complete
   * @property {function(number):number} easing
   * @property {function(boolean):void} callback
   */
  /**
   * @typedef {Object} Constraints
   * @property {import("./centerconstraint.js").Type} center
   * @property {import("./resolutionconstraint.js").Type} resolution
   * @property {import("./rotationconstraint.js").Type} rotation
   */
  /**
   * @typedef {Object} FitOptions
   * @property {import("./size.js").Size} [size] The size in pixels of the box to fit
   * the extent into. Default is the current size of the first map in the DOM that
   * uses this view, or `[100, 100]` if no such map is found.
   * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
   * cleared inside the view. Values in the array are top, right, bottom and left
   * padding.
   * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
   * get the nearest extent instead of the closest that actually fits the view.
   * @property {number} [minResolution=0] Minimum resolution that we zoom to.
   * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
   * `minResolution` is given, this property is ignored.
   * @property {number} [duration] The duration of the animation in milliseconds.
   * By default, there is no animation to the target extent.
   * @property {function(number):number} [easing] The easing function used during
   * the animation (defaults to {@link module:ol/easing~inAndOut}).
   * The function will be called for each frame with a number representing a
   * fraction of the animation's duration.  The function should return a number
   * between 0 and 1 representing the progress toward the destination state.
   * @property {function(boolean):void} [callback] Function called when the view is in
   * its final position. The callback will be called with `true` if the animation
   * series completed on its own or `false` if it was cancelled.
   */
  /**
   * @typedef {Object} ViewOptions
   * @property {import("./coordinate.js").Coordinate} [center] The initial center for
   * the view. If a user projection is not set, the coordinate system for the center is
   * specified with the `projection` option. Layer sources will not be fetched if this
   * is not set, but the center can be set later with {@link #setCenter}.
   * @property {boolean|number} [constrainRotation=true] Rotation constraint.
   * `false` means no constraint. `true` means no constraint, but snap to zero
   * near zero. A number constrains the rotation to that number of values. For
   * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
   * @property {boolean} [enableRotation=true] Enable rotation.
   * If `false`, a rotation constraint that always sets the rotation to zero is
   * used. The `constrainRotation` option has no effect if `enableRotation` is
   * `false`.
   * @property {import("./extent.js").Extent} [extent] The extent that constrains the
   * view, in other words, nothing outside of this extent can be visible on the map.
   * @property {boolean} [constrainOnlyCenter=false] If true, the extent
   * constraint will only apply to the view center and not the whole extent.
   * @property {boolean} [smoothExtentConstraint=true] If true, the extent
   * constraint will be applied smoothly, i.e. allow the view to go slightly outside
   * of the given `extent`.
   * @property {number} [maxResolution] The maximum resolution used to determine
   * the resolution constraint. It is used together with `minResolution` (or
   * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
   * that the projection's validity extent fits in a 256x256 px tile. If the
   * projection is Spherical Mercator (the default) then `maxResolution` defaults
   * to `40075016.68557849 / 256 = 156543.03392804097`.
   * @property {number} [minResolution] The minimum resolution used to determine
   * the resolution constraint.  It is used together with `maxResolution` (or
   * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
   * zoom levels (with a factor of 2). If the projection is Spherical Mercator
   * (the default) then `minResolution` defaults to
   * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
   * @property {number} [maxZoom=28] The maximum zoom level used to determine the
   * resolution constraint. It is used together with `minZoom` (or
   * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
   * provided, it is given precedence over `maxZoom`.
   * @property {number} [minZoom=0] The minimum zoom level used to determine the
   * resolution constraint. It is used together with `maxZoom` (or
   * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
   * provided, it is given precedence over `minZoom`.
   * @property {boolean} [multiWorld=false] If `false` the view is constrained so
   * only one world is visible, and you cannot pan off the edge.  If `true` the map
   * may show multiple worlds at low zoom levels.  Only used if the `projection` is
   * global.  Note that if `extent` is also provided it is given precedence.
   * @property {boolean} [constrainResolution=false] If true, the view will always
   * animate to the closest zoom level after an interaction; false means
   * intermediary zoom levels are allowed.
   * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
   * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
   * the given resolution or zoom bounds.
   * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
   * show the full configured extent. By default, when a view is configured with an
   * extent, users will not be able to zoom out so the viewport exceeds the extent in
   * either dimension. This means the full extent may not be visible if the viewport
   * is taller or wider than the aspect ratio of the configured extent. If
   * showFullExtent is true, the user will be able to zoom out so that the viewport
   * exceeds the height or width of the configured extent, but not both, allowing the
   * full extent to be shown.
   * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
   * projection. The default is Spherical Mercator.
   * @property {number} [resolution] The initial resolution for the view. The
   * units are `projection` units per pixel (e.g. meters per pixel). An
   * alternative to setting this is to set `zoom`. Layer sources will not be
   * fetched if neither this nor `zoom` are defined, but they can be set later
   * with {@link #setZoom} or {@link #setResolution}.
   * @property {Array<number>} [resolutions] Resolutions to determine the
   * resolution constraint. If set the `maxResolution`, `minResolution`,
   * `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
   * @property {number} [rotation=0] The initial rotation for the view in radians
   * (positive rotation clockwise, 0 means North).
   * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
   * level used to calculate the initial resolution for the view.
   * @property {number} [zoomFactor=2] The zoom factor used to compute the
   * corresponding resolution.
   */
  /**
   * @typedef {Object} AnimationOptions
   * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
   * the animation.
   * @property {number} [zoom] The zoom level of the view at the end of the
   * animation. This takes precedence over `resolution`.
   * @property {number} [resolution] The resolution of the view at the end
   * of the animation.  If `zoom` is also provided, this option will be ignored.
   * @property {number} [rotation] The rotation of the view at the end of
   * the animation.
   * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
   * during a rotation or resolution animation.
   * @property {number} [duration=1000] The duration of the animation in milliseconds.
   * @property {function(number):number} [easing] The easing function used
   * during the animation (defaults to {@link module:ol/easing~inAndOut}).
   * The function will be called for each frame with a number representing a
   * fraction of the animation's duration.  The function should return a number
   * between 0 and 1 representing the progress toward the destination state.
   */
  /**
   * @typedef {Object} State
   * @property {import("./coordinate.js").Coordinate} center
   * @property {import("./proj/Projection.js").default} projection
   * @property {number} resolution
   * @property {number} rotation
   * @property {number} zoom
   */
  /**
   * Default min zoom level for the map view.
   * @type {number}
   */
  var DEFAULT_MIN_ZOOM = 0;
  /**
   * @classdesc
   * A View object represents a simple 2D view of the map.
   *
   * This is the object to act upon to change the center, resolution,
   * and rotation of the map.
   *
   * A View has a `projection`. The projection determines the
   * coordinate system of the center, and its units determine the units of the
   * resolution (projection units per pixel). The default projection is
   * Spherical Mercator (EPSG:3857).
   *
   * ### The view states
   *
   * A View is determined by three states: `center`, `resolution`,
   * and `rotation`. Each state has a corresponding getter and setter, e.g.
   * `getCenter` and `setCenter` for the `center` state.
   *
   * The `zoom` state is actually not saved on the view: all computations
   * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
   * methods are available, as well as `getResolutionForZoom` and
   * `getZoomForResolution` to switch from one system to the other.
   *
   * ### The constraints
   *
   * `setCenter`, `setResolution` and `setRotation` can be used to change the
   * states of the view, but any constraint defined in the constructor will
   * be applied along the way.
   *
   * A View object can have a *resolution constraint*, a *rotation constraint*
   * and a *center constraint*.
   *
   * The *resolution constraint* typically restricts min/max values and
   * snaps to specific resolutions. It is determined by the following
   * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
   * If `resolutions` is set, the other three options are ignored. See
   * documentation for each option for more information. By default, the view
   * only has a min/max restriction and allow intermediary zoom levels when
   * pinch-zooming for example.
   *
   * The *rotation constraint* snaps to specific angles. It is determined
   * by the following options: `enableRotation` and `constrainRotation`.
   * By default rotation is allowed and its value is snapped to zero when approaching the
   * horizontal.
   *
   * The *center constraint* is determined by the `extent` option. By
   * default the view center is not constrained at all.
   *
   * ### Changing the view state
   *
   * It is important to note that `setZoom`, `setResolution`, `setCenter` and
   * `setRotation` are subject to the above mentioned constraints. As such, it
   * may sometimes not be possible to know in advance the resulting state of the
   * View. For example, calling `setResolution(10)` does not guarantee that
   * `getResolution()` will return `10`.
   *
   * A consequence of this is that, when applying a delta on the view state, one
   * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
   * rather than the corresponding setters. This will let view do its internal
   * computations. Besides, the `adjust*` methods also take an `opt_anchor`
   * argument which allows specifying an origin for the transformation.
   *
   * ### Interacting with the view
   *
   * View constraints are usually only applied when the view is *at rest*, meaning that
   * no interaction or animation is ongoing. As such, if the user puts the view in a
   * state that is not equivalent to a constrained one (e.g. rotating the view when
   * the snap angle is 0), an animation will be triggered at the interaction end to
   * put back the view to a stable state;
   *
   * @api
   */
  var View = /** @class */ (function (_super) {
      __extends$T(View, _super);
      /**
       * @param {ViewOptions=} opt_options View options.
       */
      function View(opt_options) {
          var _this = _super.call(this) || this;
          var options = assign({}, opt_options);
          /**
           * @private
           * @type {Array<number>}
           */
          _this.hints_ = [0, 0];
          /**
           * @private
           * @type {Array<Array<Animation>>}
           */
          _this.animations_ = [];
          /**
           * @private
           * @type {number|undefined}
           */
          _this.updateAnimationKey_;
          /**
           * @private
           * @const
           * @type {import("./proj/Projection.js").default}
           */
          _this.projection_ = createProjection(options.projection, 'EPSG:3857');
          /**
           * @private
           * @type {import("./size.js").Size}
           */
          _this.viewportSize_ = [100, 100];
          /**
           * @private
           * @type {import("./coordinate.js").Coordinate|undefined}
           */
          _this.targetCenter_ = null;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.targetResolution_;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.targetRotation_;
          /**
           * @private
           * @type {import("./coordinate.js").Coordinate|undefined}
           */
          _this.cancelAnchor_ = undefined;
          if (options.center) {
              options.center = fromUserCoordinate(options.center, _this.projection_);
          }
          if (options.extent) {
              options.extent = fromUserExtent(options.extent, _this.projection_);
          }
          _this.applyOptions_(options);
          return _this;
      }
      /**
       * Set up the view with the given options.
       * @param {ViewOptions} options View options.
       */
      View.prototype.applyOptions_ = function (options) {
          /**
           * @type {Object<string, *>}
           */
          var properties = {};
          var resolutionConstraintInfo = createResolutionConstraint(options);
          /**
           * @private
           * @type {number}
           */
          this.maxResolution_ = resolutionConstraintInfo.maxResolution;
          /**
           * @private
           * @type {number}
           */
          this.minResolution_ = resolutionConstraintInfo.minResolution;
          /**
           * @private
           * @type {number}
           */
          this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
          /**
           * @private
           * @type {Array<number>|undefined}
           */
          this.resolutions_ = options.resolutions;
          /**
           * @private
           * @type {number}
           */
          this.minZoom_ = resolutionConstraintInfo.minZoom;
          var centerConstraint = createCenterConstraint(options);
          var resolutionConstraint = resolutionConstraintInfo.constraint;
          var rotationConstraint = createRotationConstraint(options);
          /**
           * @private
           * @type {Constraints}
           */
          this.constraints_ = {
              center: centerConstraint,
              resolution: resolutionConstraint,
              rotation: rotationConstraint,
          };
          this.setRotation(options.rotation !== undefined ? options.rotation : 0);
          this.setCenterInternal(options.center !== undefined ? options.center : null);
          if (options.resolution !== undefined) {
              this.setResolution(options.resolution);
          }
          else if (options.zoom !== undefined) {
              this.setZoom(options.zoom);
          }
          this.setProperties(properties);
          /**
           * @private
           * @type {ViewOptions}
           */
          this.options_ = options;
      };
      /**
       * Get an updated version of the view options used to construct the view.  The
       * current resolution (or zoom), center, and rotation are applied to any stored
       * options.  The provided options can be used to apply new min/max zoom or
       * resolution limits.
       * @param {ViewOptions} newOptions New options to be applied.
       * @return {ViewOptions} New options updated with the current view state.
       */
      View.prototype.getUpdatedOptions_ = function (newOptions) {
          var options = assign({}, this.options_);
          // preserve resolution (or zoom)
          if (options.resolution !== undefined) {
              options.resolution = this.getResolution();
          }
          else {
              options.zoom = this.getZoom();
          }
          // preserve center
          options.center = this.getCenterInternal();
          // preserve rotation
          options.rotation = this.getRotation();
          return assign({}, options, newOptions);
      };
      /**
       * Animate the view.  The view's center, zoom (or resolution), and rotation
       * can be animated for smooth transitions between view states.  For example,
       * to animate the view to a new zoom level:
       *
       *     view.animate({zoom: view.getZoom() + 1});
       *
       * By default, the animation lasts one second and uses in-and-out easing.  You
       * can customize this behavior by including `duration` (in milliseconds) and
       * `easing` options (see {@link module:ol/easing}).
       *
       * To chain together multiple animations, call the method with multiple
       * animation objects.  For example, to first zoom and then pan:
       *
       *     view.animate({zoom: 10}, {center: [0, 0]});
       *
       * If you provide a function as the last argument to the animate method, it
       * will get called at the end of an animation series.  The callback will be
       * called with `true` if the animation series completed on its own or `false`
       * if it was cancelled.
       *
       * Animations are cancelled by user interactions (e.g. dragging the map) or by
       * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
       * (or another method that calls one of these).
       *
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
       *     options.  Multiple animations can be run in series by passing multiple
       *     options objects.  To run multiple animations in parallel, call the method
       *     multiple times.  An optional callback can be provided as a final
       *     argument.  The callback will be called with a boolean indicating whether
       *     the animation completed without being cancelled.
       * @api
       */
      View.prototype.animate = function (var_args) {
          if (this.isDef() && !this.getAnimating()) {
              this.resolveConstraints(0);
          }
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; ++i) {
              var options = arguments[i];
              if (options.center) {
                  options = assign({}, options);
                  options.center = fromUserCoordinate(options.center, this.getProjection());
              }
              if (options.anchor) {
                  options = assign({}, options);
                  options.anchor = fromUserCoordinate(options.anchor, this.getProjection());
              }
              args[i] = options;
          }
          this.animateInternal.apply(this, args);
      };
      /**
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
       */
      View.prototype.animateInternal = function (var_args) {
          var animationCount = arguments.length;
          var callback;
          if (animationCount > 1 &&
              typeof arguments[animationCount - 1] === 'function') {
              callback = arguments[animationCount - 1];
              --animationCount;
          }
          if (!this.isDef()) {
              // if view properties are not yet set, shortcut to the final state
              var state = arguments[animationCount - 1];
              if (state.center) {
                  this.setCenterInternal(state.center);
              }
              if (state.zoom !== undefined) {
                  this.setZoom(state.zoom);
              }
              if (state.rotation !== undefined) {
                  this.setRotation(state.rotation);
              }
              if (callback) {
                  animationCallback(callback, true);
              }
              return;
          }
          var start = Date.now();
          var center = this.targetCenter_.slice();
          var resolution = this.targetResolution_;
          var rotation = this.targetRotation_;
          var series = [];
          for (var i = 0; i < animationCount; ++i) {
              var options = /** @type {AnimationOptions} */ (arguments[i]);
              var animation = {
                  start: start,
                  complete: false,
                  anchor: options.anchor,
                  duration: options.duration !== undefined ? options.duration : 1000,
                  easing: options.easing || inAndOut,
                  callback: callback,
              };
              if (options.center) {
                  animation.sourceCenter = center;
                  animation.targetCenter = options.center.slice();
                  center = animation.targetCenter;
              }
              if (options.zoom !== undefined) {
                  animation.sourceResolution = resolution;
                  animation.targetResolution = this.getResolutionForZoom(options.zoom);
                  resolution = animation.targetResolution;
              }
              else if (options.resolution) {
                  animation.sourceResolution = resolution;
                  animation.targetResolution = options.resolution;
                  resolution = animation.targetResolution;
              }
              if (options.rotation !== undefined) {
                  animation.sourceRotation = rotation;
                  var delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
                  animation.targetRotation = rotation + delta;
                  rotation = animation.targetRotation;
              }
              // check if animation is a no-op
              if (isNoopAnimation(animation)) {
                  animation.complete = true;
                  // we still push it onto the series for callback handling
              }
              else {
                  start += animation.duration;
              }
              series.push(animation);
          }
          this.animations_.push(series);
          this.setHint(ViewHint.ANIMATING, 1);
          this.updateAnimations_();
      };
      /**
       * Determine if the view is being animated.
       * @return {boolean} The view is being animated.
       * @api
       */
      View.prototype.getAnimating = function () {
          return this.hints_[ViewHint.ANIMATING] > 0;
      };
      /**
       * Determine if the user is interacting with the view, such as panning or zooming.
       * @return {boolean} The view is being interacted with.
       * @api
       */
      View.prototype.getInteracting = function () {
          return this.hints_[ViewHint.INTERACTING] > 0;
      };
      /**
       * Cancel any ongoing animations.
       * @api
       */
      View.prototype.cancelAnimations = function () {
          this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);
          var anchor;
          for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
              var series = this.animations_[i];
              if (series[0].callback) {
                  animationCallback(series[0].callback, false);
              }
              if (!anchor) {
                  for (var j = 0, jj = series.length; j < jj; ++j) {
                      var animation = series[j];
                      if (!animation.complete) {
                          anchor = animation.anchor;
                          break;
                      }
                  }
              }
          }
          this.animations_.length = 0;
          this.cancelAnchor_ = anchor;
      };
      /**
       * Update all animations.
       */
      View.prototype.updateAnimations_ = function () {
          if (this.updateAnimationKey_ !== undefined) {
              cancelAnimationFrame(this.updateAnimationKey_);
              this.updateAnimationKey_ = undefined;
          }
          if (!this.getAnimating()) {
              return;
          }
          var now = Date.now();
          var more = false;
          for (var i = this.animations_.length - 1; i >= 0; --i) {
              var series = this.animations_[i];
              var seriesComplete = true;
              for (var j = 0, jj = series.length; j < jj; ++j) {
                  var animation = series[j];
                  if (animation.complete) {
                      continue;
                  }
                  var elapsed = now - animation.start;
                  var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
                  if (fraction >= 1) {
                      animation.complete = true;
                      fraction = 1;
                  }
                  else {
                      seriesComplete = false;
                  }
                  var progress = animation.easing(fraction);
                  if (animation.sourceCenter) {
                      var x0 = animation.sourceCenter[0];
                      var y0 = animation.sourceCenter[1];
                      var x1 = animation.targetCenter[0];
                      var y1 = animation.targetCenter[1];
                      var x = x0 + progress * (x1 - x0);
                      var y = y0 + progress * (y1 - y0);
                      this.targetCenter_ = [x, y];
                  }
                  if (animation.sourceResolution && animation.targetResolution) {
                      var resolution = progress === 1
                          ? animation.targetResolution
                          : animation.sourceResolution +
                              progress *
                                  (animation.targetResolution - animation.sourceResolution);
                      if (animation.anchor) {
                          var size = this.getViewportSize_(this.getRotation());
                          var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
                          this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
                      }
                      this.targetResolution_ = resolution;
                      this.applyTargetState_(true);
                  }
                  if (animation.sourceRotation !== undefined &&
                      animation.targetRotation !== undefined) {
                      var rotation = progress === 1
                          ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) -
                              Math.PI
                          : animation.sourceRotation +
                              progress *
                                  (animation.targetRotation - animation.sourceRotation);
                      if (animation.anchor) {
                          var constrainedRotation = this.constraints_.rotation(rotation, true);
                          this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
                      }
                      this.targetRotation_ = rotation;
                  }
                  this.applyTargetState_(true);
                  more = true;
                  if (!animation.complete) {
                      break;
                  }
              }
              if (seriesComplete) {
                  this.animations_[i] = null;
                  this.setHint(ViewHint.ANIMATING, -1);
                  var callback = series[0].callback;
                  if (callback) {
                      animationCallback(callback, true);
                  }
              }
          }
          // prune completed series
          this.animations_ = this.animations_.filter(Boolean);
          if (more && this.updateAnimationKey_ === undefined) {
              this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
          }
      };
      /**
       * @param {number} rotation Target rotation.
       * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
       */
      View.prototype.calculateCenterRotate = function (rotation, anchor) {
          var center;
          var currentCenter = this.getCenterInternal();
          if (currentCenter !== undefined) {
              center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
              rotate$1(center, rotation - this.getRotation());
              add$3(center, anchor);
          }
          return center;
      };
      /**
       * @param {number} resolution Target resolution.
       * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
       */
      View.prototype.calculateCenterZoom = function (resolution, anchor) {
          var center;
          var currentCenter = this.getCenterInternal();
          var currentResolution = this.getResolution();
          if (currentCenter !== undefined && currentResolution !== undefined) {
              var x = anchor[0] -
                  (resolution * (anchor[0] - currentCenter[0])) / currentResolution;
              var y = anchor[1] -
                  (resolution * (anchor[1] - currentCenter[1])) / currentResolution;
              center = [x, y];
          }
          return center;
      };
      /**
       * Returns the current viewport size.
       * @private
       * @param {number=} opt_rotation Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
       */
      View.prototype.getViewportSize_ = function (opt_rotation) {
          var size = this.viewportSize_;
          if (opt_rotation) {
              var w = size[0];
              var h = size[1];
              return [
                  Math.abs(w * Math.cos(opt_rotation)) +
                      Math.abs(h * Math.sin(opt_rotation)),
                  Math.abs(w * Math.sin(opt_rotation)) +
                      Math.abs(h * Math.cos(opt_rotation)),
              ];
          }
          else {
              return size;
          }
      };
      /**
       * Stores the viewport size on the view. The viewport size is not read every time from the DOM
       * to avoid performance hit and layout reflow.
       * This should be done on map size change.
       * Note: the constraints are not resolved during an animation to avoid stopping it
       * @param {import("./size.js").Size=} opt_size Viewport size; if undefined, [100, 100] is assumed
       */
      View.prototype.setViewportSize = function (opt_size) {
          this.viewportSize_ = Array.isArray(opt_size)
              ? opt_size.slice()
              : [100, 100];
          if (!this.getAnimating()) {
              this.resolveConstraints(0);
          }
      };
      /**
       * Get the view center.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       * @observable
       * @api
       */
      View.prototype.getCenter = function () {
          var center = this.getCenterInternal();
          if (!center) {
              return center;
          }
          return toUserCoordinate(center, this.getProjection());
      };
      /**
       * Get the view center without transforming to user projection.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       */
      View.prototype.getCenterInternal = function () {
          return /** @type {import("./coordinate.js").Coordinate|undefined} */ (this.get(ViewProperty.CENTER));
      };
      /**
       * @return {Constraints} Constraints.
       */
      View.prototype.getConstraints = function () {
          return this.constraints_;
      };
      /**
       * @return {boolean} Resolution constraint is set
       */
      View.prototype.getConstrainResolution = function () {
          return this.options_.constrainResolution;
      };
      /**
       * @param {Array<number>=} opt_hints Destination array.
       * @return {Array<number>} Hint.
       */
      View.prototype.getHints = function (opt_hints) {
          if (opt_hints !== undefined) {
              opt_hints[0] = this.hints_[0];
              opt_hints[1] = this.hints_[1];
              return opt_hints;
          }
          else {
              return this.hints_.slice();
          }
      };
      /**
       * Calculate the extent for the current view state and the passed size.
       * The size is the pixel dimensions of the box into which the calculated extent
       * should fit. In most cases you want to get the extent of the entire map,
       * that is `map.getSize()`.
       * @param {import("./size.js").Size=} opt_size Box pixel size. If not provided, the size
       * of the map that uses this view will be used.
       * @return {import("./extent.js").Extent} Extent.
       * @api
       */
      View.prototype.calculateExtent = function (opt_size) {
          var extent = this.calculateExtentInternal(opt_size);
          return toUserExtent(extent, this.getProjection());
      };
      /**
       * @param {import("./size.js").Size=} opt_size Box pixel size. If not provided, the size of the
       * first map that uses this view will be used.
       * @return {import("./extent.js").Extent} Extent.
       */
      View.prototype.calculateExtentInternal = function (opt_size) {
          var size = opt_size || this.getViewportSize_();
          var center = /** @type {!import("./coordinate.js").Coordinate} */ (this.getCenterInternal());
          assert(center, 1); // The view center is not defined
          var resolution = /** @type {!number} */ (this.getResolution());
          assert(resolution !== undefined, 2); // The view resolution is not defined
          var rotation = /** @type {!number} */ (this.getRotation());
          assert(rotation !== undefined, 3); // The view rotation is not defined
          return getForViewAndSize(center, resolution, rotation, size);
      };
      /**
       * Get the maximum resolution of the view.
       * @return {number} The maximum resolution of the view.
       * @api
       */
      View.prototype.getMaxResolution = function () {
          return this.maxResolution_;
      };
      /**
       * Get the minimum resolution of the view.
       * @return {number} The minimum resolution of the view.
       * @api
       */
      View.prototype.getMinResolution = function () {
          return this.minResolution_;
      };
      /**
       * Get the maximum zoom level for the view.
       * @return {number} The maximum zoom level.
       * @api
       */
      View.prototype.getMaxZoom = function () {
          return /** @type {number} */ (this.getZoomForResolution(this.minResolution_));
      };
      /**
       * Set a new maximum zoom level for the view.
       * @param {number} zoom The maximum zoom level.
       * @api
       */
      View.prototype.setMaxZoom = function (zoom) {
          this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
      };
      /**
       * Get the minimum zoom level for the view.
       * @return {number} The minimum zoom level.
       * @api
       */
      View.prototype.getMinZoom = function () {
          return /** @type {number} */ (this.getZoomForResolution(this.maxResolution_));
      };
      /**
       * Set a new minimum zoom level for the view.
       * @param {number} zoom The minimum zoom level.
       * @api
       */
      View.prototype.setMinZoom = function (zoom) {
          this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
      };
      /**
       * Set whether the view shoud allow intermediary zoom levels.
       * @param {boolean} enabled Whether the resolution is constrained.
       * @api
       */
      View.prototype.setConstrainResolution = function (enabled) {
          this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
      };
      /**
       * Get the view projection.
       * @return {import("./proj/Projection.js").default} The projection of the view.
       * @api
       */
      View.prototype.getProjection = function () {
          return this.projection_;
      };
      /**
       * Get the view resolution.
       * @return {number|undefined} The resolution of the view.
       * @observable
       * @api
       */
      View.prototype.getResolution = function () {
          return /** @type {number|undefined} */ (this.get(ViewProperty.RESOLUTION));
      };
      /**
       * Get the resolutions for the view. This returns the array of resolutions
       * passed to the constructor of the View, or undefined if none were given.
       * @return {Array<number>|undefined} The resolutions of the view.
       * @api
       */
      View.prototype.getResolutions = function () {
          return this.resolutions_;
      };
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size=} opt_size Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       * @api
       */
      View.prototype.getResolutionForExtent = function (extent, opt_size) {
          return this.getResolutionForExtentInternal(fromUserExtent(extent, this.getProjection()), opt_size);
      };
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size=} opt_size Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       */
      View.prototype.getResolutionForExtentInternal = function (extent, opt_size) {
          var size = opt_size || this.getViewportSize_();
          var xResolution = getWidth(extent) / size[0];
          var yResolution = getHeight(extent) / size[1];
          return Math.max(xResolution, yResolution);
      };
      /**
       * Return a function that returns a value between 0 and 1 for a
       * resolution. Exponential scaling is assumed.
       * @param {number=} opt_power Power.
       * @return {function(number): number} Resolution for value function.
       */
      View.prototype.getResolutionForValueFunction = function (opt_power) {
          var power = opt_power || 2;
          var maxResolution = this.getConstrainedResolution(this.maxResolution_);
          var minResolution = this.minResolution_;
          var max = Math.log(maxResolution / minResolution) / Math.log(power);
          return (
          /**
           * @param {number} value Value.
           * @return {number} Resolution.
           */
          function (value) {
              var resolution = maxResolution / Math.pow(power, value * max);
              return resolution;
          });
      };
      /**
       * Get the view rotation.
       * @return {number} The rotation of the view in radians.
       * @observable
       * @api
       */
      View.prototype.getRotation = function () {
          return /** @type {number} */ (this.get(ViewProperty.ROTATION));
      };
      /**
       * Return a function that returns a resolution for a value between
       * 0 and 1. Exponential scaling is assumed.
       * @param {number=} opt_power Power.
       * @return {function(number): number} Value for resolution function.
       */
      View.prototype.getValueForResolutionFunction = function (opt_power) {
          var logPower = Math.log(opt_power || 2);
          var maxResolution = this.getConstrainedResolution(this.maxResolution_);
          var minResolution = this.minResolution_;
          var max = Math.log(maxResolution / minResolution) / logPower;
          return (
          /**
           * @param {number} resolution Resolution.
           * @return {number} Value.
           */
          function (resolution) {
              var value = Math.log(maxResolution / resolution) / logPower / max;
              return value;
          });
      };
      /**
       * @return {State} View state.
       */
      View.prototype.getState = function () {
          var center = /** @type {import("./coordinate.js").Coordinate} */ (this.getCenterInternal());
          var projection = this.getProjection();
          var resolution = /** @type {number} */ (this.getResolution());
          var rotation = this.getRotation();
          return {
              center: center.slice(0),
              projection: projection !== undefined ? projection : null,
              resolution: resolution,
              rotation: rotation,
              zoom: this.getZoom(),
          };
      };
      /**
       * Get the current zoom level. This method may return non-integer zoom levels
       * if the view does not constrain the resolution, or if an interaction or
       * animation is underway.
       * @return {number|undefined} Zoom.
       * @api
       */
      View.prototype.getZoom = function () {
          var zoom;
          var resolution = this.getResolution();
          if (resolution !== undefined) {
              zoom = this.getZoomForResolution(resolution);
          }
          return zoom;
      };
      /**
       * Get the zoom level for a resolution.
       * @param {number} resolution The resolution.
       * @return {number|undefined} The zoom level for the provided resolution.
       * @api
       */
      View.prototype.getZoomForResolution = function (resolution) {
          var offset = this.minZoom_ || 0;
          var max, zoomFactor;
          if (this.resolutions_) {
              var nearest = linearFindNearest(this.resolutions_, resolution, 1);
              offset = nearest;
              max = this.resolutions_[nearest];
              if (nearest == this.resolutions_.length - 1) {
                  zoomFactor = 2;
              }
              else {
                  zoomFactor = max / this.resolutions_[nearest + 1];
              }
          }
          else {
              max = this.maxResolution_;
              zoomFactor = this.zoomFactor_;
          }
          return offset + Math.log(max / resolution) / Math.log(zoomFactor);
      };
      /**
       * Get the resolution for a zoom level.
       * @param {number} zoom Zoom level.
       * @return {number} The view resolution for the provided zoom level.
       * @api
       */
      View.prototype.getResolutionForZoom = function (zoom) {
          if (this.resolutions_) {
              if (this.resolutions_.length <= 1) {
                  return 0;
              }
              var baseLevel = clamp(Math.floor(zoom), 0, this.resolutions_.length - 2);
              var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
              return (this.resolutions_[baseLevel] /
                  Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1)));
          }
          else {
              return (this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_));
          }
      };
      /**
       * Fit the given geometry or extent based on the given map size and border.
       * The size is pixel dimensions of the box to fit the extent into.
       * In most cases you will want to use the map size, that is `map.getSize()`.
       * Takes care of the map angle.
       * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
       *     extent to fit the view to.
       * @param {FitOptions=} opt_options Options.
       * @api
       */
      View.prototype.fit = function (geometryOrExtent, opt_options) {
          var options = assign({ size: this.getViewportSize_() }, opt_options || {});
          /** @type {import("./geom/SimpleGeometry.js").default} */
          var geometry;
          assert(Array.isArray(geometryOrExtent) ||
              typeof ( /** @type {?} */(geometryOrExtent).getSimplifiedGeometry) ===
                  'function', 24); // Invalid extent or geometry provided as `geometry`
          if (Array.isArray(geometryOrExtent)) {
              assert(!isEmpty$1(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`
              var extent = fromUserExtent(geometryOrExtent, this.getProjection());
              geometry = fromExtent(extent);
          }
          else if (geometryOrExtent.getType() === GeometryType.CIRCLE) {
              var extent = fromUserExtent(geometryOrExtent.getExtent(), this.getProjection());
              geometry = fromExtent(extent);
              geometry.rotate(this.getRotation(), getCenter(extent));
          }
          else {
              var userProjection = getUserProjection();
              if (userProjection) {
                  geometry = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometryOrExtent
                      .clone()
                      .transform(userProjection, this.getProjection()));
              }
              else {
                  geometry = geometryOrExtent;
              }
          }
          this.fitInternal(geometry, options);
      };
      /**
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @param {FitOptions=} opt_options Options.
       */
      View.prototype.fitInternal = function (geometry, opt_options) {
          var options = opt_options || {};
          var size = options.size;
          if (!size) {
              size = this.getViewportSize_();
          }
          var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
          var nearest = options.nearest !== undefined ? options.nearest : false;
          var minResolution;
          if (options.minResolution !== undefined) {
              minResolution = options.minResolution;
          }
          else if (options.maxZoom !== undefined) {
              minResolution = this.getResolutionForZoom(options.maxZoom);
          }
          else {
              minResolution = 0;
          }
          var coords = geometry.getFlatCoordinates();
          // calculate rotated extent
          var rotation = this.getRotation();
          var cosAngle = Math.cos(-rotation);
          var sinAngle = Math.sin(-rotation);
          var minRotX = +Infinity;
          var minRotY = +Infinity;
          var maxRotX = -Infinity;
          var maxRotY = -Infinity;
          var stride = geometry.getStride();
          for (var i = 0, ii = coords.length; i < ii; i += stride) {
              var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
              var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
              minRotX = Math.min(minRotX, rotX);
              minRotY = Math.min(minRotY, rotY);
              maxRotX = Math.max(maxRotX, rotX);
              maxRotY = Math.max(maxRotY, rotY);
          }
          // calculate resolution
          var resolution = this.getResolutionForExtentInternal([minRotX, minRotY, maxRotX, maxRotY], [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
          resolution = isNaN(resolution)
              ? minResolution
              : Math.max(resolution, minResolution);
          resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
          // calculate center
          sinAngle = -sinAngle; // go back to original rotation
          var centerRotX = (minRotX + maxRotX) / 2;
          var centerRotY = (minRotY + maxRotY) / 2;
          centerRotX += ((padding[1] - padding[3]) / 2) * resolution;
          centerRotY += ((padding[0] - padding[2]) / 2) * resolution;
          var centerX = centerRotX * cosAngle - centerRotY * sinAngle;
          var centerY = centerRotY * cosAngle + centerRotX * sinAngle;
          var center = [centerX, centerY];
          var callback = options.callback ? options.callback : VOID;
          if (options.duration !== undefined) {
              this.animateInternal({
                  resolution: resolution,
                  center: this.getConstrainedCenter(center, resolution),
                  duration: options.duration,
                  easing: options.easing,
              }, callback);
          }
          else {
              this.targetResolution_ = resolution;
              this.targetCenter_ = center;
              this.applyTargetState_(false, true);
              animationCallback(callback, true);
          }
      };
      /**
       * Center on coordinate and view position.
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       * @api
       */
      View.prototype.centerOn = function (coordinate, size, position) {
          this.centerOnInternal(fromUserCoordinate(coordinate, this.getProjection()), size, position);
      };
      /**
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       */
      View.prototype.centerOnInternal = function (coordinate, size, position) {
          // calculate rotated position
          var rotation = this.getRotation();
          var cosAngle = Math.cos(-rotation);
          var sinAngle = Math.sin(-rotation);
          var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
          var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
          var resolution = this.getResolution();
          rotX += (size[0] / 2 - position[0]) * resolution;
          rotY += (position[1] - size[1] / 2) * resolution;
          // go back to original angle
          sinAngle = -sinAngle; // go back to original rotation
          var centerX = rotX * cosAngle - rotY * sinAngle;
          var centerY = rotY * cosAngle + rotX * sinAngle;
          this.setCenterInternal([centerX, centerY]);
      };
      /**
       * @return {boolean} Is defined.
       */
      View.prototype.isDef = function () {
          return !!this.getCenterInternal() && this.getResolution() !== undefined;
      };
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       * @api
       */
      View.prototype.adjustCenter = function (deltaCoordinates) {
          var center = toUserCoordinate(this.targetCenter_, this.getProjection());
          this.setCenter([
              center[0] + deltaCoordinates[0],
              center[1] + deltaCoordinates[1],
          ]);
      };
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       */
      View.prototype.adjustCenterInternal = function (deltaCoordinates) {
          var center = this.targetCenter_;
          this.setCenterInternal([
              center[0] + deltaCoordinates[0],
              center[1] + deltaCoordinates[1],
          ]);
      };
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       * @api
       */
      View.prototype.adjustResolution = function (ratio, opt_anchor) {
          var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
          this.adjustResolutionInternal(ratio, anchor);
      };
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       */
      View.prototype.adjustResolutionInternal = function (ratio, opt_anchor) {
          var isMoving = this.getAnimating() || this.getInteracting();
          var size = this.getViewportSize_(this.getRotation());
          var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
          if (opt_anchor) {
              this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);
          }
          this.targetResolution_ *= ratio;
          this.applyTargetState_();
      };
      /**
       * Adds a value to the view zoom level, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom level.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       * @api
       */
      View.prototype.adjustZoom = function (delta, opt_anchor) {
          this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);
      };
      /**
       * Adds a value to the view rotation, optionally using an anchor. Any rotation
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The rotation center.
       * @api
       */
      View.prototype.adjustRotation = function (delta, opt_anchor) {
          if (opt_anchor) {
              opt_anchor = fromUserCoordinate(opt_anchor, this.getProjection());
          }
          this.adjustRotationInternal(delta, opt_anchor);
      };
      /**
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The rotation center.
       */
      View.prototype.adjustRotationInternal = function (delta, opt_anchor) {
          var isMoving = this.getAnimating() || this.getInteracting();
          var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
          if (opt_anchor) {
              this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);
          }
          this.targetRotation_ += delta;
          this.applyTargetState_();
      };
      /**
       * Set the center of the current view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       * @observable
       * @api
       */
      View.prototype.setCenter = function (center) {
          this.setCenterInternal(fromUserCoordinate(center, this.getProjection()));
      };
      /**
       * Set the center using the view projection (not the user projection).
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       */
      View.prototype.setCenterInternal = function (center) {
          this.targetCenter_ = center;
          this.applyTargetState_();
      };
      /**
       * @param {import("./ViewHint.js").default} hint Hint.
       * @param {number} delta Delta.
       * @return {number} New value.
       */
      View.prototype.setHint = function (hint, delta) {
          this.hints_[hint] += delta;
          this.changed();
          return this.hints_[hint];
      };
      /**
       * Set the resolution for this view. Any resolution constraint will apply.
       * @param {number|undefined} resolution The resolution of the view.
       * @observable
       * @api
       */
      View.prototype.setResolution = function (resolution) {
          this.targetResolution_ = resolution;
          this.applyTargetState_();
      };
      /**
       * Set the rotation for this view. Any rotation constraint will apply.
       * @param {number} rotation The rotation of the view in radians.
       * @observable
       * @api
       */
      View.prototype.setRotation = function (rotation) {
          this.targetRotation_ = rotation;
          this.applyTargetState_();
      };
      /**
       * Zoom to a specific zoom level. Any resolution constrain will apply.
       * @param {number} zoom Zoom level.
       * @api
       */
      View.prototype.setZoom = function (zoom) {
          this.setResolution(this.getResolutionForZoom(zoom));
      };
      /**
       * Recompute rotation/resolution/center based on target values.
       * Note: we have to compute rotation first, then resolution and center considering that
       * parameters can influence one another in case a view extent constraint is present.
       * @param {boolean=} opt_doNotCancelAnims Do not cancel animations.
       * @param {boolean=} opt_forceMoving Apply constraints as if the view is moving.
       * @private
       */
      View.prototype.applyTargetState_ = function (opt_doNotCancelAnims, opt_forceMoving) {
          var isMoving = this.getAnimating() || this.getInteracting() || opt_forceMoving;
          // compute rotation
          var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
          var size = this.getViewportSize_(newRotation);
          var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
          var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving);
          if (this.get(ViewProperty.ROTATION) !== newRotation) {
              this.set(ViewProperty.ROTATION, newRotation);
          }
          if (this.get(ViewProperty.RESOLUTION) !== newResolution) {
              this.set(ViewProperty.RESOLUTION, newResolution);
          }
          if (!this.get(ViewProperty.CENTER) ||
              !equals$2(this.get(ViewProperty.CENTER), newCenter)) {
              this.set(ViewProperty.CENTER, newCenter);
          }
          if (this.getAnimating() && !opt_doNotCancelAnims) {
              this.cancelAnimations();
          }
          this.cancelAnchor_ = undefined;
      };
      /**
       * If any constraints need to be applied, an animation will be triggered.
       * This is typically done on interaction end.
       * Note: calling this with a duration of 0 will apply the constrained values straight away,
       * without animation.
       * @param {number=} opt_duration The animation duration in ms.
       * @param {number=} opt_resolutionDirection Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       */
      View.prototype.resolveConstraints = function (opt_duration, opt_resolutionDirection, opt_anchor) {
          var duration = opt_duration !== undefined ? opt_duration : 200;
          var direction = opt_resolutionDirection || 0;
          var newRotation = this.constraints_.rotation(this.targetRotation_);
          var size = this.getViewportSize_(newRotation);
          var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
          var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size);
          if (duration === 0 && !this.cancelAnchor_) {
              this.targetResolution_ = newResolution;
              this.targetRotation_ = newRotation;
              this.targetCenter_ = newCenter;
              this.applyTargetState_();
              return;
          }
          var anchor = opt_anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
          this.cancelAnchor_ = undefined;
          if (this.getResolution() !== newResolution ||
              this.getRotation() !== newRotation ||
              !this.getCenterInternal() ||
              !equals$2(this.getCenterInternal(), newCenter)) {
              if (this.getAnimating()) {
                  this.cancelAnimations();
              }
              this.animateInternal({
                  rotation: newRotation,
                  center: newCenter,
                  resolution: newResolution,
                  duration: duration,
                  easing: easeOut,
                  anchor: anchor,
              });
          }
      };
      /**
       * Notify the View that an interaction has started.
       * The view state will be resolved to a stable one if needed
       * (depending on its constraints).
       * @api
       */
      View.prototype.beginInteraction = function () {
          this.resolveConstraints(0);
          this.setHint(ViewHint.INTERACTING, 1);
      };
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number=} opt_duration Animation duration in ms.
       * @param {number=} opt_resolutionDirection Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       * @api
       */
      View.prototype.endInteraction = function (opt_duration, opt_resolutionDirection, opt_anchor) {
          var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
          this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);
      };
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number=} opt_duration Animation duration in ms.
       * @param {number=} opt_resolutionDirection Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       */
      View.prototype.endInteractionInternal = function (opt_duration, opt_resolutionDirection, opt_anchor) {
          this.setHint(ViewHint.INTERACTING, -1);
          this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);
      };
      /**
       * Get a valid position for the view center according to the current constraints.
       * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
       * @param {number=} opt_targetResolution Target resolution. If not supplied, the current one will be used.
       * This is useful to guess a valid center position at a different zoom level.
       * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
       */
      View.prototype.getConstrainedCenter = function (targetCenter, opt_targetResolution) {
          var size = this.getViewportSize_(this.getRotation());
          return this.constraints_.center(targetCenter, opt_targetResolution || this.getResolution(), size);
      };
      /**
       * Get a valid zoom level according to the current view constraints.
       * @param {number|undefined} targetZoom Target zoom.
       * @param {number=} [opt_direction=0] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid zoom level.
       */
      View.prototype.getConstrainedZoom = function (targetZoom, opt_direction) {
          var targetRes = this.getResolutionForZoom(targetZoom);
          return this.getZoomForResolution(this.getConstrainedResolution(targetRes, opt_direction));
      };
      /**
       * Get a valid resolution according to the current view constraints.
       * @param {number|undefined} targetResolution Target resolution.
       * @param {number=} [opt_direction=0] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid resolution.
       */
      View.prototype.getConstrainedResolution = function (targetResolution, opt_direction) {
          var direction = opt_direction || 0;
          var size = this.getViewportSize_(this.getRotation());
          return this.constraints_.resolution(targetResolution, direction, size);
      };
      return View;
  }(BaseObject));
  /**
   * @param {Function} callback Callback.
   * @param {*} returnValue Return value.
   */
  function animationCallback(callback, returnValue) {
      setTimeout(function () {
          callback(returnValue);
      }, 0);
  }
  /**
   * @param {ViewOptions} options View options.
   * @return {import("./centerconstraint.js").Type} The constraint.
   */
  function createCenterConstraint(options) {
      if (options.extent !== undefined) {
          var smooth = options.smoothExtentConstraint !== undefined
              ? options.smoothExtentConstraint
              : true;
          return createExtent(options.extent, options.constrainOnlyCenter, smooth);
      }
      var projection = createProjection(options.projection, 'EPSG:3857');
      if (options.multiWorld !== true && projection.isGlobal()) {
          var extent = projection.getExtent().slice();
          extent[0] = -Infinity;
          extent[2] = Infinity;
          return createExtent(extent, false, false);
      }
      return none;
  }
  /**
   * @param {ViewOptions} options View options.
   * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
   *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
   */
  function createResolutionConstraint(options) {
      var resolutionConstraint;
      var maxResolution;
      var minResolution;
      // TODO: move these to be ol constants
      // see https://github.com/openlayers/openlayers/issues/2076
      var defaultMaxZoom = 28;
      var defaultZoomFactor = 2;
      var minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;
      var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
      var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
      var multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;
      var smooth = options.smoothResolutionConstraint !== undefined
          ? options.smoothResolutionConstraint
          : true;
      var showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;
      var projection = createProjection(options.projection, 'EPSG:3857');
      var projExtent = projection.getExtent();
      var constrainOnlyCenter = options.constrainOnlyCenter;
      var extent = options.extent;
      if (!multiWorld && !extent && projection.isGlobal()) {
          constrainOnlyCenter = false;
          extent = projExtent;
      }
      if (options.resolutions !== undefined) {
          var resolutions = options.resolutions;
          maxResolution = resolutions[minZoom];
          minResolution =
              resolutions[maxZoom] !== undefined
                  ? resolutions[maxZoom]
                  : resolutions[resolutions.length - 1];
          if (options.constrainResolution) {
              resolutionConstraint = createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
          }
          else {
              resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
          }
      }
      else {
          // calculate the default min and max resolution
          var size = !projExtent
              ? // use an extent that can fit the whole world if need be
                  (360 * METERS_PER_UNIT[Units.DEGREES]) / projection.getMetersPerUnit()
              : Math.max(getWidth(projExtent), getHeight(projExtent));
          var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
          var defaultMinResolution = defaultMaxResolution /
              Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
          // user provided maxResolution takes precedence
          maxResolution = options.maxResolution;
          if (maxResolution !== undefined) {
              minZoom = 0;
          }
          else {
              maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
          }
          // user provided minResolution takes precedence
          minResolution = options.minResolution;
          if (minResolution === undefined) {
              if (options.maxZoom !== undefined) {
                  if (options.maxResolution !== undefined) {
                      minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
                  }
                  else {
                      minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
                  }
              }
              else {
                  minResolution = defaultMinResolution;
              }
          }
          // given discrete zoom levels, minResolution may be different than provided
          maxZoom =
              minZoom +
                  Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
          if (options.constrainResolution) {
              resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
          }
          else {
              resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
          }
      }
      return {
          constraint: resolutionConstraint,
          maxResolution: maxResolution,
          minResolution: minResolution,
          minZoom: minZoom,
          zoomFactor: zoomFactor,
      };
  }
  /**
   * @param {ViewOptions} options View options.
   * @return {import("./rotationconstraint.js").Type} Rotation constraint.
   */
  function createRotationConstraint(options) {
      var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;
      if (enableRotation) {
          var constrainRotation = options.constrainRotation;
          if (constrainRotation === undefined || constrainRotation === true) {
              return createSnapToZero();
          }
          else if (constrainRotation === false) {
              return none$1;
          }
          else if (typeof constrainRotation === 'number') {
              return createSnapToN(constrainRotation);
          }
          else {
              return none$1;
          }
      }
      else {
          return disable;
      }
  }
  /**
   * Determine if an animation involves no view change.
   * @param {Animation} animation The animation.
   * @return {boolean} The animation involves no view change.
   */
  function isNoopAnimation(animation) {
      if (animation.sourceCenter && animation.targetCenter) {
          if (!equals$2(animation.sourceCenter, animation.targetCenter)) {
              return false;
          }
      }
      if (animation.sourceResolution !== animation.targetResolution) {
          return false;
      }
      if (animation.sourceRotation !== animation.targetRotation) {
          return false;
      }
      return true;
  }

  var __extends$U = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
   * be used in applications.
   * @typedef {Object} FrameState
   * @property {number} pixelRatio The pixel ratio of the frame.
   * @property {number} time The time when rendering of the frame was requested.
   * @property {import("./View.js").State} viewState The state of the current view.
   * @property {boolean} animate
   * @property {import("./transform.js").Transform} coordinateToPixelTransform
   * @property {null|import("./extent.js").Extent} extent
   * @property {Array<DeclutterItems>} declutterItems
   * @property {number} index
   * @property {Array<import("./layer/Layer.js").State>} layerStatesArray
   * @property {number} layerIndex
   * @property {import("./transform.js").Transform} pixelToCoordinateTransform
   * @property {Array<PostRenderFunction>} postRenderFunctions
   * @property {import("./size.js").Size} size
   * @property {TileQueue} tileQueue
   * @property {!Object<string, Object<string, boolean>>} usedTiles
   * @property {Array<number>} viewHints
   * @property {!Object<string, Object<string, boolean>>} wantedTiles
   */
  /**
   * @typedef {Object} DeclutterItems
   * @property {Array<*>} items Declutter items of an executor.
   * @property {number} opacity Layer opacity.
   */
  /**
   * @typedef {function(PluggableMap, ?FrameState): any} PostRenderFunction
   */
  /**
   * @typedef {Object} AtPixelOptions
   * @property {undefined|function(import("./layer/Layer.js").default): boolean} [layerFilter] Layer filter
   * function. The filter function will receive one argument, the
   * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.
   * Only layers which are visible and for which this function returns `true`
   * will be tested for features. By default, all visible layers will be tested.
   * @property {number} [hitTolerance=0] Hit-detection tolerance in pixels. Pixels
   * inside the radius around the given position will be checked for features.
   * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for for wrapped geometries inside the range of
   *   +/- 1 world width. Works only if a projection is used that can be wrapped.
   */
  /**
   * @typedef {Object} MapOptionsInternal
   * @property {Collection<import("./control/Control.js").default>} [controls]
   * @property {Collection<import("./interaction/Interaction.js").default>} [interactions]
   * @property {HTMLElement|Document} keyboardEventTarget
   * @property {Collection<import("./Overlay.js").default>} overlays
   * @property {Object<string, *>} values
   */
  /**
   * Object literal with config options for the map.
   * @typedef {Object} MapOptions
   * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
   * Controls initially added to the map. If not specified,
   * {@link module:ol/control~defaults} is used.
   * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
   * physical pixels and device-independent pixels (dips) on the device.
   * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
   * Interactions that are initially added to the map. If not specified,
   * {@link module:ol/interaction~defaults} is used.
   * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
   * listen to keyboard events on. This determines when the `KeyboardPan` and
   * `KeyboardZoom` interactions trigger. For example, if this option is set to
   * `document` the keyboard interactions will always trigger. If this option is
   * not specified, the element the library listens to keyboard events on is the
   * map target (i.e. the user-provided div for the map). If this is not
   * `document`, the target element needs to be focused for key events to be
   * emitted, requiring that the target element has a `tabindex` attribute.
   * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
   * Layers. If this is not defined, a map with no layers will be rendered. Note
   * that layers are rendered in the order supplied, so if you want, for example,
   * a vector layer to appear on top of a tile layer, it must come after the tile
   * layer.
   * @property {number} [maxTilesLoading=16] Maximum number tiles to load
   * simultaneously.
   * @property {number} [moveTolerance=1] The minimum distance in pixels the
   * cursor must move to be detected as a map move event instead of a click.
   * Increasing this value can make it easier to click on the map.
   * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
   * Overlays initially added to the map. By default, no overlays are added.
   * @property {HTMLElement|string} [target] The container for the map, either the
   * element itself or the `id` of the element. If not specified at construction
   * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
   * rendered.
   * @property {View} [view] The map's view.  No layer sources will be
   * fetched unless this is specified at construction time or through
   * {@link module:ol/Map~Map#setView}.
   */
  /**
   * @fires import("./MapBrowserEvent.js").MapBrowserEvent
   * @fires import("./MapEvent.js").MapEvent
   * @fires import("./render/Event.js").default#precompose
   * @fires import("./render/Event.js").default#postcompose
   * @fires import("./render/Event.js").default#rendercomplete
   * @api
   */
  var PluggableMap = /** @class */ (function (_super) {
      __extends$U(PluggableMap, _super);
      /**
       * @param {MapOptions} options Map options.
       */
      function PluggableMap(options) {
          var _this = _super.call(this) || this;
          var optionsInternal = createOptionsInternal(options);
          /** @private */
          _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);
          /**
           * @type {number}
           * @private
           */
          _this.maxTilesLoading_ =
              options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;
          /**
           * @private
           * @type {number}
           */
          _this.pixelRatio_ =
              options.pixelRatio !== undefined
                  ? options.pixelRatio
                  : DEVICE_PIXEL_RATIO;
          /**
           * @private
           * @type {*}
           */
          _this.postRenderTimeoutHandle_;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.animationDelayKey_;
          /**
           * @private
           */
          _this.animationDelay_ = function () {
              this.animationDelayKey_ = undefined;
              this.renderFrame_(Date.now());
          }.bind(_this);
          /**
           * @private
           * @type {import("./transform.js").Transform}
           */
          _this.coordinateToPixelTransform_ = create$2();
          /**
           * @private
           * @type {import("./transform.js").Transform}
           */
          _this.pixelToCoordinateTransform_ = create$2();
          /**
           * @private
           * @type {number}
           */
          _this.frameIndex_ = 0;
          /**
           * @private
           * @type {?FrameState}
           */
          _this.frameState_ = null;
          /**
           * The extent at the previous 'moveend' event.
           * @private
           * @type {import("./extent.js").Extent}
           */
          _this.previousExtent_ = null;
          /**
           * @private
           * @type {?import("./events.js").EventsKey}
           */
          _this.viewPropertyListenerKey_ = null;
          /**
           * @private
           * @type {?import("./events.js").EventsKey}
           */
          _this.viewChangeListenerKey_ = null;
          /**
           * @private
           * @type {?Array<import("./events.js").EventsKey>}
           */
          _this.layerGroupPropertyListenerKeys_ = null;
          /**
           * @private
           * @type {!HTMLElement}
           */
          _this.viewport_ = document.createElement('div');
          _this.viewport_.className =
              'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');
          _this.viewport_.style.position = 'relative';
          _this.viewport_.style.overflow = 'hidden';
          _this.viewport_.style.width = '100%';
          _this.viewport_.style.height = '100%';
          /**
           * @private
           * @type {!HTMLElement}
           */
          _this.overlayContainer_ = document.createElement('div');
          _this.overlayContainer_.style.position = 'absolute';
          _this.overlayContainer_.style.zIndex = '0';
          _this.overlayContainer_.style.width = '100%';
          _this.overlayContainer_.style.height = '100%';
          _this.overlayContainer_.style.pointerEvents = 'none';
          _this.overlayContainer_.className = 'ol-overlaycontainer';
          _this.viewport_.appendChild(_this.overlayContainer_);
          /**
           * @private
           * @type {!HTMLElement}
           */
          _this.overlayContainerStopEvent_ = document.createElement('div');
          _this.overlayContainerStopEvent_.style.position = 'absolute';
          _this.overlayContainerStopEvent_.style.zIndex = '0';
          _this.overlayContainerStopEvent_.style.width = '100%';
          _this.overlayContainerStopEvent_.style.height = '100%';
          _this.overlayContainerStopEvent_.style.pointerEvents = 'none';
          _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
          _this.viewport_.appendChild(_this.overlayContainerStopEvent_);
          /**
           * @private
           * @type {MapBrowserEventHandler}
           */
          _this.mapBrowserEventHandler_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.moveTolerance_ = options.moveTolerance;
          /**
           * @private
           * @type {HTMLElement|Document}
           */
          _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
          /**
           * @private
           * @type {?Array<import("./events.js").EventsKey>}
           */
          _this.keyHandlerKeys_ = null;
          /**
           * @type {Collection<import("./control/Control.js").default>}
           * @protected
           */
          _this.controls = optionsInternal.controls || new Collection();
          /**
           * @type {Collection<import("./interaction/Interaction.js").default>}
           * @protected
           */
          _this.interactions = optionsInternal.interactions || new Collection();
          /**
           * @type {Collection<import("./Overlay.js").default>}
           * @private
           */
          _this.overlays_ = optionsInternal.overlays;
          /**
           * A lookup of overlays by id.
           * @private
           * @type {Object<string, import("./Overlay.js").default>}
           */
          _this.overlayIdIndex_ = {};
          /**
           * @type {import("./renderer/Map.js").default}
           * @private
           */
          _this.renderer_ = null;
          /**
           * @type {undefined|function(Event): void}
           * @private
           */
          _this.handleResize_;
          /**
           * @private
           * @type {!Array<PostRenderFunction>}
           */
          _this.postRenderFunctions_ = [];
          /**
           * @private
           * @type {TileQueue}
           */
          _this.tileQueue_ = new TileQueue(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));
          _this.addEventListener(getChangeEventType(MapProperty.LAYERGROUP), _this.handleLayerGroupChanged_);
          _this.addEventListener(getChangeEventType(MapProperty.VIEW), _this.handleViewChanged_);
          _this.addEventListener(getChangeEventType(MapProperty.SIZE), _this.handleSizeChanged_);
          _this.addEventListener(getChangeEventType(MapProperty.TARGET), _this.handleTargetChanged_);
          // setProperties will trigger the rendering of the map if the map
          // is "defined" already.
          _this.setProperties(optionsInternal.values);
          _this.controls.forEach(
          /**
           * @param {import("./control/Control.js").default} control Control.
           * @this {PluggableMap}
           */
          function (control) {
              control.setMap(this);
          }.bind(_this));
          _this.controls.addEventListener(CollectionEventType.ADD, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              event.element.setMap(this);
          }.bind(_this));
          _this.controls.addEventListener(CollectionEventType.REMOVE, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              event.element.setMap(null);
          }.bind(_this));
          _this.interactions.forEach(
          /**
           * @param {import("./interaction/Interaction.js").default} interaction Interaction.
           * @this {PluggableMap}
           */
          function (interaction) {
              interaction.setMap(this);
          }.bind(_this));
          _this.interactions.addEventListener(CollectionEventType.ADD, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              event.element.setMap(this);
          }.bind(_this));
          _this.interactions.addEventListener(CollectionEventType.REMOVE, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              event.element.setMap(null);
          }.bind(_this));
          _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));
          _this.overlays_.addEventListener(CollectionEventType.ADD, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              this.addOverlayInternal_(
              /** @type {import("./Overlay.js").default} */ (event.element));
          }.bind(_this));
          _this.overlays_.addEventListener(CollectionEventType.REMOVE, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              var overlay = /** @type {import("./Overlay.js").default} */ (event.element);
              var id = overlay.getId();
              if (id !== undefined) {
                  delete this.overlayIdIndex_[id.toString()];
              }
              event.element.setMap(null);
          }.bind(_this));
          return _this;
      }
      /**
       * @abstract
       * @return {import("./renderer/Map.js").default} The map renderer
       */
      PluggableMap.prototype.createRenderer = function () {
          throw new Error('Use a map type that has a createRenderer method');
      };
      /**
       * Add the given control to the map.
       * @param {import("./control/Control.js").default} control Control.
       * @api
       */
      PluggableMap.prototype.addControl = function (control) {
          this.getControls().push(control);
      };
      /**
       * Add the given interaction to the map. If you want to add an interaction
       * at another point of the collection use `getInteraction()` and the methods
       * available on {@link module:ol/Collection~Collection}. This can be used to
       * stop the event propagation from the handleEvent function. The interactions
       * get to handle the events in the reverse order of this collection.
       * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
       * @api
       */
      PluggableMap.prototype.addInteraction = function (interaction) {
          this.getInteractions().push(interaction);
      };
      /**
       * Adds the given layer to the top of this map. If you want to add a layer
       * elsewhere in the stack, use `getLayers()` and the methods available on
       * {@link module:ol/Collection~Collection}.
       * @param {import("./layer/Base.js").default} layer Layer.
       * @api
       */
      PluggableMap.prototype.addLayer = function (layer) {
          var layers = this.getLayerGroup().getLayers();
          layers.push(layer);
      };
      /**
       * Add the given overlay to the map.
       * @param {import("./Overlay.js").default} overlay Overlay.
       * @api
       */
      PluggableMap.prototype.addOverlay = function (overlay) {
          this.getOverlays().push(overlay);
      };
      /**
       * This deals with map's overlay collection changes.
       * @param {import("./Overlay.js").default} overlay Overlay.
       * @private
       */
      PluggableMap.prototype.addOverlayInternal_ = function (overlay) {
          var id = overlay.getId();
          if (id !== undefined) {
              this.overlayIdIndex_[id.toString()] = overlay;
          }
          overlay.setMap(this);
      };
      /**
       *
       * Clean up.
       */
      PluggableMap.prototype.disposeInternal = function () {
          this.setTarget(null);
          _super.prototype.disposeInternal.call(this);
      };
      /**
       * Detect features that intersect a pixel on the viewport, and execute a
       * callback with each intersecting feature. Layers included in the detection can
       * be configured through the `layerFilter` option in `opt_options`.
       * @param {import("./pixel.js").Pixel} pixel Pixel.
       * @param {function(this: S, import("./Feature.js").FeatureLike,
       *     import("./layer/Layer.js").default): T} callback Feature callback. The callback will be
       *     called with two arguments. The first argument is one
       *     {@link module:ol/Feature feature} or
       *     {@link module:ol/render/Feature render feature} at the pixel, the second is
       *     the {@link module:ol/layer/Layer layer} of the feature and will be null for
       *     unmanaged layers. To stop detection, callback functions can return a
       *     truthy value.
       * @param {AtPixelOptions=} opt_options Optional options.
       * @return {T|undefined} Callback result, i.e. the return value of last
       * callback execution, or the first truthy callback return value.
       * @template S,T
       * @api
       */
      PluggableMap.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {
          if (!this.frameState_) {
              return;
          }
          var coordinate = this.getCoordinateFromPixelInternal(pixel);
          opt_options = opt_options !== undefined ? opt_options : {};
          var hitTolerance = opt_options.hitTolerance !== undefined
              ? opt_options.hitTolerance * this.frameState_.pixelRatio
              : 0;
          var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;
          var checkWrapped = opt_options.checkWrapped !== false;
          return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
      };
      /**
       * Get all features that intersect a pixel on the viewport.
       * @param {import("./pixel.js").Pixel} pixel Pixel.
       * @param {AtPixelOptions=} opt_options Optional options.
       * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
       * an empty array if none were found.
       * @api
       */
      PluggableMap.prototype.getFeaturesAtPixel = function (pixel, opt_options) {
          var features = [];
          this.forEachFeatureAtPixel(pixel, function (feature) {
              features.push(feature);
          }, opt_options);
          return features;
      };
      /**
       * Detect layers that have a color value at a pixel on the viewport, and
       * execute a callback with each matching layer. Layers included in the
       * detection can be configured through `opt_layerFilter`.
       *
       * Note: this may give false positives unless the map layers have had different `className`
       * properties assigned to them.
       *
       * @param {import("./pixel.js").Pixel} pixel Pixel.
       * @param {function(this: S, import("./layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback
       *     Layer callback. This callback will receive two arguments: first is the
       *     {@link module:ol/layer/Layer layer}, second argument is an array representing
       *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
       *     that do not currently support this argument. To stop detection, callback
       *     functions can return a truthy value.
       * @param {AtPixelOptions=} opt_options Configuration options.
       * @return {T|undefined} Callback result, i.e. the return value of last
       * callback execution, or the first truthy callback return value.
       * @template S,T
       * @api
       */
      PluggableMap.prototype.forEachLayerAtPixel = function (pixel, callback, opt_options) {
          if (!this.frameState_) {
              return;
          }
          var options = opt_options || {};
          var hitTolerance = options.hitTolerance !== undefined
              ? options.hitTolerance * this.frameState_.pixelRatio
              : 0;
          var layerFilter = options.layerFilter || TRUE;
          return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);
      };
      /**
       * Detect if features intersect a pixel on the viewport. Layers included in the
       * detection can be configured through `opt_layerFilter`.
       * @param {import("./pixel.js").Pixel} pixel Pixel.
       * @param {AtPixelOptions=} opt_options Optional options.
       * @return {boolean} Is there a feature at the given pixel?
       * @api
       */
      PluggableMap.prototype.hasFeatureAtPixel = function (pixel, opt_options) {
          if (!this.frameState_) {
              return false;
          }
          var coordinate = this.getCoordinateFromPixelInternal(pixel);
          opt_options = opt_options !== undefined ? opt_options : {};
          var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;
          var hitTolerance = opt_options.hitTolerance !== undefined
              ? opt_options.hitTolerance * this.frameState_.pixelRatio
              : 0;
          var checkWrapped = opt_options.checkWrapped !== false;
          return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
      };
      /**
       * Returns the coordinate in user projection for a browser event.
       * @param {MouseEvent} event Event.
       * @return {import("./coordinate.js").Coordinate} Coordinate.
       * @api
       */
      PluggableMap.prototype.getEventCoordinate = function (event) {
          return this.getCoordinateFromPixel(this.getEventPixel(event));
      };
      /**
       * Returns the coordinate in view projection for a browser event.
       * @param {MouseEvent} event Event.
       * @return {import("./coordinate.js").Coordinate} Coordinate.
       */
      PluggableMap.prototype.getEventCoordinateInternal = function (event) {
          return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
      };
      /**
       * Returns the map pixel position for a browser event relative to the viewport.
       * @param {UIEvent} event Event.
       * @return {import("./pixel.js").Pixel} Pixel.
       * @api
       */
      PluggableMap.prototype.getEventPixel = function (event) {
          var viewportPosition = this.viewport_.getBoundingClientRect();
          var eventPosition = 
          //FIXME Are we really calling this with a TouchEvent anywhere?
          'changedTouches' in event
              ? /** @type {TouchEvent} */ (event).changedTouches[0]
              : /** @type {MouseEvent} */ (event);
          return [
              eventPosition.clientX - viewportPosition.left,
              eventPosition.clientY - viewportPosition.top,
          ];
      };
      /**
       * Get the target in which this map is rendered.
       * Note that this returns what is entered as an option or in setTarget:
       * if that was an element, it returns an element; if a string, it returns that.
       * @return {HTMLElement|string|undefined} The Element or id of the Element that the
       *     map is rendered in.
       * @observable
       * @api
       */
      PluggableMap.prototype.getTarget = function () {
          return /** @type {HTMLElement|string|undefined} */ (this.get(MapProperty.TARGET));
      };
      /**
       * Get the DOM element into which this map is rendered. In contrast to
       * `getTarget` this method always return an `Element`, or `null` if the
       * map has no target.
       * @return {HTMLElement} The element that the map is rendered in.
       * @api
       */
      PluggableMap.prototype.getTargetElement = function () {
          var target = this.getTarget();
          if (target !== undefined) {
              return typeof target === 'string'
                  ? document.getElementById(target)
                  : target;
          }
          else {
              return null;
          }
      };
      /**
       * Get the coordinate for a given pixel.  This returns a coordinate in the
       * user projection.
       * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
       * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
       * @api
       */
      PluggableMap.prototype.getCoordinateFromPixel = function (pixel) {
          return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
      };
      /**
       * Get the coordinate for a given pixel.  This returns a coordinate in the
       * map view projection.
       * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
       * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
       */
      PluggableMap.prototype.getCoordinateFromPixelInternal = function (pixel) {
          var frameState = this.frameState_;
          if (!frameState) {
              return null;
          }
          else {
              return apply$1(frameState.pixelToCoordinateTransform, pixel.slice());
          }
      };
      /**
       * Get the map controls. Modifying this collection changes the controls
       * associated with the map.
       * @return {Collection<import("./control/Control.js").default>} Controls.
       * @api
       */
      PluggableMap.prototype.getControls = function () {
          return this.controls;
      };
      /**
       * Get the map overlays. Modifying this collection changes the overlays
       * associated with the map.
       * @return {Collection<import("./Overlay.js").default>} Overlays.
       * @api
       */
      PluggableMap.prototype.getOverlays = function () {
          return this.overlays_;
      };
      /**
       * Get an overlay by its identifier (the value returned by overlay.getId()).
       * Note that the index treats string and numeric identifiers as the same. So
       * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
       * @param {string|number} id Overlay identifier.
       * @return {import("./Overlay.js").default} Overlay.
       * @api
       */
      PluggableMap.prototype.getOverlayById = function (id) {
          var overlay = this.overlayIdIndex_[id.toString()];
          return overlay !== undefined ? overlay : null;
      };
      /**
       * Get the map interactions. Modifying this collection changes the interactions
       * associated with the map.
       *
       * Interactions are used for e.g. pan, zoom and rotate.
       * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
       * @api
       */
      PluggableMap.prototype.getInteractions = function () {
          return this.interactions;
      };
      /**
       * Get the layergroup associated with this map.
       * @return {LayerGroup} A layer group containing the layers in this map.
       * @observable
       * @api
       */
      PluggableMap.prototype.getLayerGroup = function () {
          return /** @type {LayerGroup} */ (this.get(MapProperty.LAYERGROUP));
      };
      /**
       * Get the collection of layers associated with this map.
       * @return {!Collection<import("./layer/Base.js").default>} Layers.
       * @api
       */
      PluggableMap.prototype.getLayers = function () {
          var layers = this.getLayerGroup().getLayers();
          return layers;
      };
      /**
       * @return {boolean} Layers have sources that are still loading.
       */
      PluggableMap.prototype.getLoading = function () {
          var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
          for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
              var layer = layerStatesArray[i].layer;
              var source = /** @type {import("./layer/Layer.js").default} */ (layer).getSource();
              if (source && source.loading) {
                  return true;
              }
          }
          return false;
      };
      /**
       * Get the pixel for a coordinate.  This takes a coordinate in the user
       * projection and returns the corresponding pixel.
       * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
       * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
       * @api
       */
      PluggableMap.prototype.getPixelFromCoordinate = function (coordinate) {
          var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());
          return this.getPixelFromCoordinateInternal(viewCoordinate);
      };
      /**
       * Get the pixel for a coordinate.  This takes a coordinate in the map view
       * projection and returns the corresponding pixel.
       * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
       * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
       */
      PluggableMap.prototype.getPixelFromCoordinateInternal = function (coordinate) {
          var frameState = this.frameState_;
          if (!frameState) {
              return null;
          }
          else {
              return apply$1(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
          }
      };
      /**
       * Get the map renderer.
       * @return {import("./renderer/Map.js").default} Renderer
       */
      PluggableMap.prototype.getRenderer = function () {
          return this.renderer_;
      };
      /**
       * Get the size of this map.
       * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
       * @observable
       * @api
       */
      PluggableMap.prototype.getSize = function () {
          return /** @type {import("./size.js").Size|undefined} */ (this.get(MapProperty.SIZE));
      };
      /**
       * Get the view associated with this map. A view manages properties such as
       * center and resolution.
       * @return {View} The view that controls this map.
       * @observable
       * @api
       */
      PluggableMap.prototype.getView = function () {
          return /** @type {View} */ (this.get(MapProperty.VIEW));
      };
      /**
       * Get the element that serves as the map viewport.
       * @return {HTMLElement} Viewport.
       * @api
       */
      PluggableMap.prototype.getViewport = function () {
          return this.viewport_;
      };
      /**
       * Get the element that serves as the container for overlays.  Elements added to
       * this container will let mousedown and touchstart events through to the map,
       * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
       * events.
       * @return {!HTMLElement} The map's overlay container.
       */
      PluggableMap.prototype.getOverlayContainer = function () {
          return this.overlayContainer_;
      };
      /**
       * Get the element that serves as a container for overlays that don't allow
       * event propagation. Elements added to this container won't let mousedown and
       * touchstart events through to the map, so clicks and gestures on an overlay
       * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
       * @return {!HTMLElement} The map's overlay container that stops events.
       */
      PluggableMap.prototype.getOverlayContainerStopEvent = function () {
          return this.overlayContainerStopEvent_;
      };
      /**
       * @param {import("./Tile.js").default} tile Tile.
       * @param {string} tileSourceKey Tile source key.
       * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
       * @param {number} tileResolution Tile resolution.
       * @return {number} Tile priority.
       */
      PluggableMap.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {
          return getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
      };
      /**
       * @param {UIEvent} browserEvent Browser event.
       * @param {string=} opt_type Type.
       */
      PluggableMap.prototype.handleBrowserEvent = function (browserEvent, opt_type) {
          var type = opt_type || browserEvent.type;
          var mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);
          this.handleMapBrowserEvent(mapBrowserEvent);
      };
      /**
       * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
       */
      PluggableMap.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {
          if (!this.frameState_) {
              // With no view defined, we cannot translate pixels into geographical
              // coordinates so interactions cannot be used.
              return;
          }
          var originalEvent = /** @type {PointerEvent} */ (mapBrowserEvent.originalEvent);
          var eventType = originalEvent.type;
          if (eventType === PointerEventType.POINTERDOWN ||
              eventType === EventType.WHEEL ||
              eventType === EventType.KEYDOWN) {
              var rootNode = this.viewport_.getRootNode
                  ? this.viewport_.getRootNode()
                  : document;
              var target = rootNode === document
                  ? /** @type {Node} */ (originalEvent.target)
                  : /** @type {ShadowRoot} */ (rootNode).elementFromPoint(originalEvent.clientX, originalEvent.clientY);
              if (
              // Abort if the target is a child of the container for elements whose events are not meant
              // to be handled by map interactions.
              this.overlayContainerStopEvent_.contains(target) ||
                  // Abort if the event target is a child of the container that is no longer in the page.
                  // It's possible for the target to no longer be in the page if it has been removed in an
                  // event listener, this might happen in a Control that recreates it's content based on
                  // user interaction either manually or via a render in something like https://reactjs.org/
                  !(rootNode === document ? document.documentElement : rootNode).contains(target)) {
                  return;
              }
          }
          mapBrowserEvent.frameState = this.frameState_;
          var interactionsArray = this.getInteractions().getArray();
          if (this.dispatchEvent(mapBrowserEvent) !== false) {
              for (var i = interactionsArray.length - 1; i >= 0; i--) {
                  var interaction = interactionsArray[i];
                  if (!interaction.getActive()) {
                      continue;
                  }
                  var cont = interaction.handleEvent(mapBrowserEvent);
                  if (!cont) {
                      break;
                  }
              }
          }
      };
      /**
       * @protected
       */
      PluggableMap.prototype.handlePostRender = function () {
          var frameState = this.frameState_;
          // Manage the tile queue
          // Image loads are expensive and a limited resource, so try to use them
          // efficiently:
          // * When the view is static we allow a large number of parallel tile loads
          //   to complete the frame as quickly as possible.
          // * When animating or interacting, image loads can cause janks, so we reduce
          //   the maximum number of loads per frame and limit the number of parallel
          //   tile loads to remain reactive to view changes and to reduce the chance of
          //   loading tiles that will quickly disappear from view.
          var tileQueue = this.tileQueue_;
          if (!tileQueue.isEmpty()) {
              var maxTotalLoading = this.maxTilesLoading_;
              var maxNewLoads = maxTotalLoading;
              if (frameState) {
                  var hints = frameState.viewHints;
                  if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {
                      var lowOnFrameBudget = !IMAGE_DECODE && Date.now() - frameState.time > 8;
                      maxTotalLoading = lowOnFrameBudget ? 0 : 8;
                      maxNewLoads = lowOnFrameBudget ? 0 : 2;
                  }
              }
              if (tileQueue.getTilesLoading() < maxTotalLoading) {
                  tileQueue.reprioritize(); // FIXME only call if view has changed
                  tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
              }
          }
          if (frameState &&
              this.hasListener(RenderEventType.RENDERCOMPLETE) &&
              !frameState.animate &&
              !this.tileQueue_.getTilesLoading() &&
              !this.getLoading()) {
              this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, frameState);
          }
          var postRenderFunctions = this.postRenderFunctions_;
          for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
              postRenderFunctions[i](this, frameState);
          }
          postRenderFunctions.length = 0;
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleSizeChanged_ = function () {
          if (this.getView() && !this.getView().getAnimating()) {
              this.getView().resolveConstraints(0);
          }
          this.render();
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleTargetChanged_ = function () {
          // target may be undefined, null, a string or an Element.
          // If it's a string we convert it to an Element before proceeding.
          // If it's not now an Element we remove the viewport from the DOM.
          // If it's an Element we append the viewport element to it.
          var targetElement;
          if (this.getTarget()) {
              targetElement = this.getTargetElement();
          }
          if (this.mapBrowserEventHandler_) {
              for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {
                  unlistenByKey(this.keyHandlerKeys_[i]);
              }
              this.keyHandlerKeys_ = null;
              this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_);
              this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_);
              if (this.handleResize_ !== undefined) {
                  removeEventListener(EventType.RESIZE, this.handleResize_, false);
                  this.handleResize_ = undefined;
              }
              this.mapBrowserEventHandler_.dispose();
              this.mapBrowserEventHandler_ = null;
              removeNode(this.viewport_);
          }
          if (!targetElement) {
              if (this.renderer_) {
                  clearTimeout(this.postRenderTimeoutHandle_);
                  this.postRenderFunctions_.length = 0;
                  this.renderer_.dispose();
                  this.renderer_ = null;
              }
              if (this.animationDelayKey_) {
                  cancelAnimationFrame(this.animationDelayKey_);
                  this.animationDelayKey_ = undefined;
              }
          }
          else {
              targetElement.appendChild(this.viewport_);
              if (!this.renderer_) {
                  this.renderer_ = this.createRenderer();
              }
              this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, this.moveTolerance_);
              for (var key in MapBrowserEventType) {
                  this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));
              }
              this.viewport_.addEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_, false);
              this.viewport_.addEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);
              var keyboardEventTarget = !this.keyboardEventTarget_
                  ? targetElement
                  : this.keyboardEventTarget_;
              this.keyHandlerKeys_ = [
                  listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this),
                  listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this),
              ];
              if (!this.handleResize_) {
                  this.handleResize_ = this.updateSize.bind(this);
                  window.addEventListener(EventType.RESIZE, this.handleResize_, false);
              }
          }
          this.updateSize();
          // updateSize calls setSize, so no need to call this.render
          // ourselves here.
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleTileChange_ = function () {
          this.render();
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleViewPropertyChanged_ = function () {
          this.render();
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleViewChanged_ = function () {
          if (this.viewPropertyListenerKey_) {
              unlistenByKey(this.viewPropertyListenerKey_);
              this.viewPropertyListenerKey_ = null;
          }
          if (this.viewChangeListenerKey_) {
              unlistenByKey(this.viewChangeListenerKey_);
              this.viewChangeListenerKey_ = null;
          }
          var view = this.getView();
          if (view) {
              this.updateViewportSize_();
              this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
              this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);
              view.resolveConstraints(0);
          }
          this.render();
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleLayerGroupChanged_ = function () {
          if (this.layerGroupPropertyListenerKeys_) {
              this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
              this.layerGroupPropertyListenerKeys_ = null;
          }
          var layerGroup = this.getLayerGroup();
          if (layerGroup) {
              this.layerGroupPropertyListenerKeys_ = [
                  listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this),
                  listen(layerGroup, EventType.CHANGE, this.render, this),
              ];
          }
          this.render();
      };
      /**
       * @return {boolean} Is rendered.
       */
      PluggableMap.prototype.isRendered = function () {
          return !!this.frameState_;
      };
      /**
       * Requests an immediate render in a synchronous manner.
       * @api
       */
      PluggableMap.prototype.renderSync = function () {
          if (this.animationDelayKey_) {
              cancelAnimationFrame(this.animationDelayKey_);
          }
          this.animationDelay_();
      };
      /**
       * Redraws all text after new fonts have loaded
       */
      PluggableMap.prototype.redrawText = function () {
          var layerStates = this.getLayerGroup().getLayerStatesArray();
          for (var i = 0, ii = layerStates.length; i < ii; ++i) {
              var layer = layerStates[i].layer;
              if (layer.hasRenderer()) {
                  layer.getRenderer().handleFontsChanged();
              }
          }
      };
      /**
       * Request a map rendering (at the next animation frame).
       * @api
       */
      PluggableMap.prototype.render = function () {
          if (this.renderer_ && this.animationDelayKey_ === undefined) {
              this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
          }
      };
      /**
       * Remove the given control from the map.
       * @param {import("./control/Control.js").default} control Control.
       * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
       *     if the control was not found).
       * @api
       */
      PluggableMap.prototype.removeControl = function (control) {
          return this.getControls().remove(control);
      };
      /**
       * Remove the given interaction from the map.
       * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
       * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
       *     undefined if the interaction was not found).
       * @api
       */
      PluggableMap.prototype.removeInteraction = function (interaction) {
          return this.getInteractions().remove(interaction);
      };
      /**
       * Removes the given layer from the map.
       * @param {import("./layer/Base.js").default} layer Layer.
       * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
       *     layer was not found).
       * @api
       */
      PluggableMap.prototype.removeLayer = function (layer) {
          var layers = this.getLayerGroup().getLayers();
          return layers.remove(layer);
      };
      /**
       * Remove the given overlay from the map.
       * @param {import("./Overlay.js").default} overlay Overlay.
       * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
       *     if the overlay was not found).
       * @api
       */
      PluggableMap.prototype.removeOverlay = function (overlay) {
          return this.getOverlays().remove(overlay);
      };
      /**
       * @param {number} time Time.
       * @private
       */
      PluggableMap.prototype.renderFrame_ = function (time) {
          var size = this.getSize();
          var view = this.getView();
          var previousFrameState = this.frameState_;
          /** @type {?FrameState} */
          var frameState = null;
          if (size !== undefined && hasArea(size) && view && view.isDef()) {
              var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
              var viewState = view.getState();
              frameState = {
                  animate: false,
                  coordinateToPixelTransform: this.coordinateToPixelTransform_,
                  declutterItems: previousFrameState
                      ? previousFrameState.declutterItems
                      : [],
                  extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),
                  index: this.frameIndex_++,
                  layerIndex: 0,
                  layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
                  pixelRatio: this.pixelRatio_,
                  pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
                  postRenderFunctions: [],
                  size: size,
                  tileQueue: this.tileQueue_,
                  time: time,
                  usedTiles: {},
                  viewState: viewState,
                  viewHints: viewHints,
                  wantedTiles: {},
              };
          }
          this.frameState_ = frameState;
          this.renderer_.renderFrame(frameState);
          if (frameState) {
              if (frameState.animate) {
                  this.render();
              }
              Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);
              if (previousFrameState) {
                  var moveStart = !this.previousExtent_ ||
                      (!isEmpty$1(this.previousExtent_) &&
                          !equals$1(frameState.extent, this.previousExtent_));
                  if (moveStart) {
                      this.dispatchEvent(new MapEvent(MapEventType.MOVESTART, this, previousFrameState));
                      this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
                  }
              }
              var idle = this.previousExtent_ &&
                  !frameState.viewHints[ViewHint.ANIMATING] &&
                  !frameState.viewHints[ViewHint.INTERACTING] &&
                  !equals$1(frameState.extent, this.previousExtent_);
              if (idle) {
                  this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));
                  clone$2(frameState.extent, this.previousExtent_);
              }
          }
          this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));
          this.postRenderTimeoutHandle_ = setTimeout(this.handlePostRender.bind(this), 0);
      };
      /**
       * Sets the layergroup of this map.
       * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
       * @observable
       * @api
       */
      PluggableMap.prototype.setLayerGroup = function (layerGroup) {
          this.set(MapProperty.LAYERGROUP, layerGroup);
      };
      /**
       * Set the size of this map.
       * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
       * @observable
       * @api
       */
      PluggableMap.prototype.setSize = function (size) {
          this.set(MapProperty.SIZE, size);
      };
      /**
       * Set the target element to render this map into.
       * @param {HTMLElement|string|undefined} target The Element or id of the Element
       *     that the map is rendered in.
       * @observable
       * @api
       */
      PluggableMap.prototype.setTarget = function (target) {
          this.set(MapProperty.TARGET, target);
      };
      /**
       * Set the view for this map.
       * @param {View} view The view that controls this map.
       * @observable
       * @api
       */
      PluggableMap.prototype.setView = function (view) {
          this.set(MapProperty.VIEW, view);
      };
      /**
       * Force a recalculation of the map viewport size.  This should be called when
       * third-party code changes the size of the map viewport.
       * @api
       */
      PluggableMap.prototype.updateSize = function () {
          var targetElement = this.getTargetElement();
          if (!targetElement) {
              this.setSize(undefined);
          }
          else {
              var computedStyle = getComputedStyle(targetElement);
              this.setSize([
                  targetElement.offsetWidth -
                      parseFloat(computedStyle['borderLeftWidth']) -
                      parseFloat(computedStyle['paddingLeft']) -
                      parseFloat(computedStyle['paddingRight']) -
                      parseFloat(computedStyle['borderRightWidth']),
                  targetElement.offsetHeight -
                      parseFloat(computedStyle['borderTopWidth']) -
                      parseFloat(computedStyle['paddingTop']) -
                      parseFloat(computedStyle['paddingBottom']) -
                      parseFloat(computedStyle['borderBottomWidth']),
              ]);
          }
          this.updateViewportSize_();
      };
      /**
       * Recomputes the viewport size and save it on the view object (if any)
       * @private
       */
      PluggableMap.prototype.updateViewportSize_ = function () {
          var view = this.getView();
          if (view) {
              var size = undefined;
              var computedStyle = getComputedStyle(this.viewport_);
              if (computedStyle.width && computedStyle.height) {
                  size = [
                      parseInt(computedStyle.width, 10),
                      parseInt(computedStyle.height, 10),
                  ];
              }
              view.setViewportSize(size);
          }
      };
      return PluggableMap;
  }(BaseObject));
  /**
   * @param {MapOptions} options Map options.
   * @return {MapOptionsInternal} Internal map options.
   */
  function createOptionsInternal(options) {
      /**
       * @type {HTMLElement|Document}
       */
      var keyboardEventTarget = null;
      if (options.keyboardEventTarget !== undefined) {
          keyboardEventTarget =
              typeof options.keyboardEventTarget === 'string'
                  ? document.getElementById(options.keyboardEventTarget)
                  : options.keyboardEventTarget;
      }
      /**
       * @type {Object<string, *>}
       */
      var values = {};
      var layerGroup = options.layers &&
          typeof ( /** @type {?} */(options.layers).getLayers) === 'function'
          ? /** @type {LayerGroup} */ (options.layers)
          : new LayerGroup({ layers: /** @type {Collection} */ (options.layers) });
      values[MapProperty.LAYERGROUP] = layerGroup;
      values[MapProperty.TARGET] = options.target;
      values[MapProperty.VIEW] =
          options.view !== undefined ? options.view : new View();
      var controls;
      if (options.controls !== undefined) {
          if (Array.isArray(options.controls)) {
              controls = new Collection(options.controls.slice());
          }
          else {
              assert(typeof ( /** @type {?} */(options.controls).getArray) === 'function', 47); // Expected `controls` to be an array or an `import("./Collection.js").Collection`
              controls = /** @type {Collection} */ (options.controls);
          }
      }
      var interactions;
      if (options.interactions !== undefined) {
          if (Array.isArray(options.interactions)) {
              interactions = new Collection(options.interactions.slice());
          }
          else {
              assert(typeof ( /** @type {?} */(options.interactions).getArray) ===
                  'function', 48); // Expected `interactions` to be an array or an `import("./Collection.js").Collection`
              interactions = /** @type {Collection} */ (options.interactions);
          }
      }
      var overlays;
      if (options.overlays !== undefined) {
          if (Array.isArray(options.overlays)) {
              overlays = new Collection(options.overlays.slice());
          }
          else {
              assert(typeof ( /** @type {?} */(options.overlays).getArray) === 'function', 49); // Expected `overlays` to be an array or an `import("./Collection.js").Collection`
              overlays = options.overlays;
          }
      }
      else {
          overlays = new Collection();
      }
      return {
          controls: controls,
          interactions: interactions,
          keyboardEventTarget: keyboardEventTarget,
          overlays: overlays,
          values: values,
      };
  }

  var __extends$V = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-attribution'] CSS class name.
   * @property {HTMLElement|string} [target] Specify a target if you
   * want the control to be rendered outside of the map's
   * viewport.
   * @property {boolean} [collapsible] Specify if attributions can
   * be collapsed. If not specified, sources control this behavior with their
   * `attributionsCollapsible` setting.
   * @property {boolean} [collapsed=true] Specify if attributions should
   * be collapsed at startup.
   * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
   * @property {string} [label='i'] Text label to use for the
   * collapsed attributions button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string|HTMLElement} [collapseLabel=''] Text label to use
   * for the expanded attributions button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when
   * the control should be re-rendered. This is called in a `requestAnimationFrame`
   * callback.
   */
  /**
   * @classdesc
   * Control to show all the attributions associated with the layer sources
   * in the map. This control is one of the default controls included in maps.
   * By default it will show in the bottom right portion of the map, but this can
   * be changed by using a css selector for `.ol-attribution`.
   *
   * @api
   */
  var Attribution = /** @class */ (function (_super) {
      __extends$V(Attribution, _super);
      /**
       * @param {Options=} opt_options Attribution options.
       */
      function Attribution(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              element: document.createElement('div'),
              render: options.render,
              target: options.target,
          }) || this;
          /**
           * @private
           * @type {HTMLElement}
           */
          _this.ulElement_ = document.createElement('ul');
          /**
           * @private
           * @type {boolean}
           */
          _this.collapsed_ =
              options.collapsed !== undefined ? options.collapsed : true;
          /**
           * @private
           * @type {boolean}
           */
          _this.overrideCollapsible_ = options.collapsible !== undefined;
          /**
           * @private
           * @type {boolean}
           */
          _this.collapsible_ =
              options.collapsible !== undefined ? options.collapsible : true;
          if (!_this.collapsible_) {
              _this.collapsed_ = false;
          }
          var className = options.className !== undefined ? options.className : 'ol-attribution';
          var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';
          var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00BB';
          if (typeof collapseLabel === 'string') {
              /**
               * @private
               * @type {HTMLElement}
               */
              _this.collapseLabel_ = document.createElement('span');
              _this.collapseLabel_.textContent = collapseLabel;
          }
          else {
              _this.collapseLabel_ = collapseLabel;
          }
          var label = options.label !== undefined ? options.label : 'i';
          if (typeof label === 'string') {
              /**
               * @private
               * @type {HTMLElement}
               */
              _this.label_ = document.createElement('span');
              _this.label_.textContent = label;
          }
          else {
              _this.label_ = label;
          }
          var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
          var button = document.createElement('button');
          button.setAttribute('type', 'button');
          button.title = tipLabel;
          button.appendChild(activeLabel);
          button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
          var cssClasses = className +
              ' ' +
              CLASS_UNSELECTABLE +
              ' ' +
              CLASS_CONTROL +
              (_this.collapsed_ && _this.collapsible_ ? ' ' + CLASS_COLLAPSED : '') +
              (_this.collapsible_ ? '' : ' ol-uncollapsible');
          var element = _this.element;
          element.className = cssClasses;
          element.appendChild(_this.ulElement_);
          element.appendChild(button);
          /**
           * A list of currently rendered resolutions.
           * @type {Array<string>}
           * @private
           */
          _this.renderedAttributions_ = [];
          /**
           * @private
           * @type {boolean}
           */
          _this.renderedVisible_ = true;
          return _this;
      }
      /**
       * Collect a list of visible attributions and set the collapsible state.
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       * @return {Array<string>} Attributions.
       * @private
       */
      Attribution.prototype.collectSourceAttributions_ = function (frameState) {
          /**
           * Used to determine if an attribution already exists.
           * @type {!Object<string, boolean>}
           */
          var lookup = {};
          /**
           * A list of visible attributions.
           * @type {Array<string>}
           */
          var visibleAttributions = [];
          var layerStatesArray = frameState.layerStatesArray;
          for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
              var layerState = layerStatesArray[i];
              if (!inView(layerState, frameState.viewState)) {
                  continue;
              }
              var source = /** @type {import("../layer/Layer.js").default} */ (layerState.layer).getSource();
              if (!source) {
                  continue;
              }
              var attributionGetter = source.getAttributions();
              if (!attributionGetter) {
                  continue;
              }
              var attributions = attributionGetter(frameState);
              if (!attributions) {
                  continue;
              }
              if (!this.overrideCollapsible_ &&
                  source.getAttributionsCollapsible() === false) {
                  this.setCollapsible(false);
              }
              if (Array.isArray(attributions)) {
                  for (var j = 0, jj = attributions.length; j < jj; ++j) {
                      if (!(attributions[j] in lookup)) {
                          visibleAttributions.push(attributions[j]);
                          lookup[attributions[j]] = true;
                      }
                  }
              }
              else {
                  if (!(attributions in lookup)) {
                      visibleAttributions.push(attributions);
                      lookup[attributions] = true;
                  }
              }
          }
          return visibleAttributions;
      };
      /**
       * @private
       * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      Attribution.prototype.updateElement_ = function (frameState) {
          if (!frameState) {
              if (this.renderedVisible_) {
                  this.element.style.display = 'none';
                  this.renderedVisible_ = false;
              }
              return;
          }
          var attributions = this.collectSourceAttributions_(frameState);
          var visible = attributions.length > 0;
          if (this.renderedVisible_ != visible) {
              this.element.style.display = visible ? '' : 'none';
              this.renderedVisible_ = visible;
          }
          if (equals(attributions, this.renderedAttributions_)) {
              return;
          }
          removeChildren(this.ulElement_);
          // append the attributions
          for (var i = 0, ii = attributions.length; i < ii; ++i) {
              var element = document.createElement('li');
              element.innerHTML = attributions[i];
              this.ulElement_.appendChild(element);
          }
          this.renderedAttributions_ = attributions;
      };
      /**
       * @param {MouseEvent} event The event to handle
       * @private
       */
      Attribution.prototype.handleClick_ = function (event) {
          event.preventDefault();
          this.handleToggle_();
      };
      /**
       * @private
       */
      Attribution.prototype.handleToggle_ = function () {
          this.element.classList.toggle(CLASS_COLLAPSED);
          if (this.collapsed_) {
              replaceNode(this.collapseLabel_, this.label_);
          }
          else {
              replaceNode(this.label_, this.collapseLabel_);
          }
          this.collapsed_ = !this.collapsed_;
      };
      /**
       * Return `true` if the attribution is collapsible, `false` otherwise.
       * @return {boolean} True if the widget is collapsible.
       * @api
       */
      Attribution.prototype.getCollapsible = function () {
          return this.collapsible_;
      };
      /**
       * Set whether the attribution should be collapsible.
       * @param {boolean} collapsible True if the widget is collapsible.
       * @api
       */
      Attribution.prototype.setCollapsible = function (collapsible) {
          if (this.collapsible_ === collapsible) {
              return;
          }
          this.collapsible_ = collapsible;
          this.element.classList.toggle('ol-uncollapsible');
          if (!collapsible && this.collapsed_) {
              this.handleToggle_();
          }
      };
      /**
       * Collapse or expand the attribution according to the passed parameter. Will
       * not do anything if the attribution isn't collapsible or if the current
       * collapsed state is already the one requested.
       * @param {boolean} collapsed True if the widget is collapsed.
       * @api
       */
      Attribution.prototype.setCollapsed = function (collapsed) {
          if (!this.collapsible_ || this.collapsed_ === collapsed) {
              return;
          }
          this.handleToggle_();
      };
      /**
       * Return `true` when the attribution is currently collapsed or `false`
       * otherwise.
       * @return {boolean} True if the widget is collapsed.
       * @api
       */
      Attribution.prototype.getCollapsed = function () {
          return this.collapsed_;
      };
      /**
       * Update the attribution element.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @override
       */
      Attribution.prototype.render = function (mapEvent) {
          this.updateElement_(mapEvent.frameState);
      };
      return Attribution;
  }(Control));

  var __extends$W = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-rotate'] CSS class name.
   * @property {string|HTMLElement} [label=''] Text label to use for the rotate button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
   * @property {number} [duration=250] Animation duration in milliseconds.
   * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
   * be re-rendered. This is called in a `requestAnimationFrame` callback.
   * @property {function():void} [resetNorth] Function called when the control is clicked.
   * This will override the default `resetNorth`.
   * @property {HTMLElement|string} [target] Specify a target if you want the control to be
   * rendered outside of the map's viewport.
   */
  /**
   * @classdesc
   * A button control to reset rotation to 0.
   * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
   * selector is added to the button when the rotation is 0.
   *
   * @api
   */
  var Rotate = /** @class */ (function (_super) {
      __extends$W(Rotate, _super);
      /**
       * @param {Options=} opt_options Rotate options.
       */
      function Rotate(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              element: document.createElement('div'),
              render: options.render,
              target: options.target,
          }) || this;
          var className = options.className !== undefined ? options.className : 'ol-rotate';
          var label = options.label !== undefined ? options.label : '\u21E7';
          /**
           * @type {HTMLElement}
           * @private
           */
          _this.label_ = null;
          if (typeof label === 'string') {
              _this.label_ = document.createElement('span');
              _this.label_.className = 'ol-compass';
              _this.label_.textContent = label;
          }
          else {
              _this.label_ = label;
              _this.label_.classList.add('ol-compass');
          }
          var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';
          var button = document.createElement('button');
          button.className = className + '-reset';
          button.setAttribute('type', 'button');
          button.title = tipLabel;
          button.appendChild(_this.label_);
          button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
          var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;
          var element = _this.element;
          element.className = cssClasses;
          element.appendChild(button);
          _this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;
          /**
           * @type {number}
           * @private
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          /**
           * @type {boolean}
           * @private
           */
          _this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.rotation_ = undefined;
          if (_this.autoHide_) {
              _this.element.classList.add(CLASS_HIDDEN);
          }
          return _this;
      }
      /**
       * @param {MouseEvent} event The event to handle
       * @private
       */
      Rotate.prototype.handleClick_ = function (event) {
          event.preventDefault();
          if (this.callResetNorth_ !== undefined) {
              this.callResetNorth_();
          }
          else {
              this.resetNorth_();
          }
      };
      /**
       * @private
       */
      Rotate.prototype.resetNorth_ = function () {
          var map = this.getMap();
          var view = map.getView();
          if (!view) {
              // the map does not have a view, so we can't act
              // upon it
              return;
          }
          var rotation = view.getRotation();
          if (rotation !== undefined) {
              if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
                  view.animate({
                      rotation: 0,
                      duration: this.duration_,
                      easing: easeOut,
                  });
              }
              else {
                  view.setRotation(0);
              }
          }
      };
      /**
       * Update the rotate control element.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @override
       */
      Rotate.prototype.render = function (mapEvent) {
          var frameState = mapEvent.frameState;
          if (!frameState) {
              return;
          }
          var rotation = frameState.viewState.rotation;
          if (rotation != this.rotation_) {
              var transform = 'rotate(' + rotation + 'rad)';
              if (this.autoHide_) {
                  var contains = this.element.classList.contains(CLASS_HIDDEN);
                  if (!contains && rotation === 0) {
                      this.element.classList.add(CLASS_HIDDEN);
                  }
                  else if (contains && rotation !== 0) {
                      this.element.classList.remove(CLASS_HIDDEN);
                  }
              }
              this.label_.style.transform = transform;
          }
          this.rotation_ = rotation;
      };
      return Rotate;
  }(Control));

  var __extends$X = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [duration=250] Animation duration in milliseconds.
   * @property {string} [className='ol-zoom'] CSS class name.
   * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
   * button. Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string|HTMLElement} [zoomOutLabel='-'] Text label to use for the zoom-out button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
   * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
   * @property {number} [delta=1] The zoom delta applied on each click.
   * @property {HTMLElement|string} [target] Specify a target if you want the control to be
   * rendered outside of the map's viewport.
   */
  /**
   * @classdesc
   * A control with 2 buttons, one for zoom in and one for zoom out.
   * This control is one of the default controls of a map. To style this control
   * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
   *
   * @api
   */
  var Zoom = /** @class */ (function (_super) {
      __extends$X(Zoom, _super);
      /**
       * @param {Options=} opt_options Zoom options.
       */
      function Zoom(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              element: document.createElement('div'),
              target: options.target,
          }) || this;
          var className = options.className !== undefined ? options.className : 'ol-zoom';
          var delta = options.delta !== undefined ? options.delta : 1;
          var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
          var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2212';
          var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
          var zoomOutTipLabel = options.zoomOutTipLabel !== undefined
              ? options.zoomOutTipLabel
              : 'Zoom out';
          var inElement = document.createElement('button');
          inElement.className = className + '-in';
          inElement.setAttribute('type', 'button');
          inElement.title = zoomInTipLabel;
          inElement.appendChild(typeof zoomInLabel === 'string'
              ? document.createTextNode(zoomInLabel)
              : zoomInLabel);
          inElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this, delta), false);
          var outElement = document.createElement('button');
          outElement.className = className + '-out';
          outElement.setAttribute('type', 'button');
          outElement.title = zoomOutTipLabel;
          outElement.appendChild(typeof zoomOutLabel === 'string'
              ? document.createTextNode(zoomOutLabel)
              : zoomOutLabel);
          outElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this, -delta), false);
          var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;
          var element = _this.element;
          element.className = cssClasses;
          element.appendChild(inElement);
          element.appendChild(outElement);
          /**
           * @type {number}
           * @private
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          return _this;
      }
      /**
       * @param {number} delta Zoom delta.
       * @param {MouseEvent} event The event to handle
       * @private
       */
      Zoom.prototype.handleClick_ = function (delta, event) {
          event.preventDefault();
          this.zoomByDelta_(delta);
      };
      /**
       * @param {number} delta Zoom delta.
       * @private
       */
      Zoom.prototype.zoomByDelta_ = function (delta) {
          var map = this.getMap();
          var view = map.getView();
          if (!view) {
              // the map does not have a view, so we can't act
              // upon it
              return;
          }
          var currentZoom = view.getZoom();
          if (currentZoom !== undefined) {
              var newZoom = view.getConstrainedZoom(currentZoom + delta);
              if (this.duration_ > 0) {
                  if (view.getAnimating()) {
                      view.cancelAnimations();
                  }
                  view.animate({
                      zoom: newZoom,
                      duration: this.duration_,
                      easing: easeOut,
                  });
              }
              else {
                  view.setZoom(newZoom);
              }
          }
      };
      return Zoom;
  }(Control));

  /**
   * @module ol/control/MousePosition
   */
  var __extends$Y = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @type {string}
   */
  var PROJECTION = 'projection';
  /**
   * @type {string}
   */
  var COORDINATE_FORMAT = 'coordinateFormat';
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-mouse-position'] CSS class name.
   * @property {import("../coordinate.js").CoordinateFormat} [coordinateFormat] Coordinate format.
   * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when the
   * control should be re-rendered. This is called in a `requestAnimationFrame`
   * callback.
   * @property {HTMLElement|string} [target] Specify a target if you want the
   * control to be rendered outside of the map's viewport.
   * @property {string} [undefinedHTML='&#160;'] Markup to show when coordinates are not
   * available (e.g. when the pointer leaves the map viewport).  By default, the last position
   * will be replaced with `'&#160;'` (`&nbsp;`) when the pointer leaves the viewport.  To
   * retain the last rendered position, set this option to something falsey (like an empty
   * string `''`).
   */
  /**
   * @classdesc
   * A control to show the 2D coordinates of the mouse cursor. By default, these
   * are in the view projection, but can be in any supported projection.
   * By default the control is shown in the top right corner of the map, but this
   * can be changed by using the css selector `.ol-mouse-position`.
   *
   * On touch devices, which usually do not have a mouse cursor, the coordinates
   * of the currently touched position are shown.
   *
   * @api
   */
  var MousePosition = /** @class */ (function (_super) {
      __extends$Y(MousePosition, _super);
      /**
       * @param {Options=} opt_options Mouse position options.
       */
      function MousePosition(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var element = document.createElement('div');
          element.className =
              options.className !== undefined ? options.className : 'ol-mouse-position';
          _this = _super.call(this, {
              element: element,
              render: options.render,
              target: options.target,
          }) || this;
          _this.addEventListener(getChangeEventType(PROJECTION), _this.handleProjectionChanged_);
          if (options.coordinateFormat) {
              _this.setCoordinateFormat(options.coordinateFormat);
          }
          if (options.projection) {
              _this.setProjection(options.projection);
          }
          /**
           * @private
           * @type {string}
           */
          _this.undefinedHTML_ =
              options.undefinedHTML !== undefined ? options.undefinedHTML : '&#160;';
          /**
           * @private
           * @type {boolean}
           */
          _this.renderOnMouseOut_ = !!_this.undefinedHTML_;
          /**
           * @private
           * @type {string}
           */
          _this.renderedHTML_ = element.innerHTML;
          /**
           * @private
           * @type {?import("../proj/Projection.js").default}
           */
          _this.mapProjection_ = null;
          /**
           * @private
           * @type {?import("../proj.js").TransformFunction}
           */
          _this.transform_ = null;
          return _this;
      }
      /**
       * @private
       */
      MousePosition.prototype.handleProjectionChanged_ = function () {
          this.transform_ = null;
      };
      /**
       * Return the coordinate format type used to render the current position or
       * undefined.
       * @return {import("../coordinate.js").CoordinateFormat|undefined} The format to render the current
       *     position in.
       * @observable
       * @api
       */
      MousePosition.prototype.getCoordinateFormat = function () {
          return /** @type {import("../coordinate.js").CoordinateFormat|undefined} */ (this.get(COORDINATE_FORMAT));
      };
      /**
       * Return the projection that is used to report the mouse position.
       * @return {import("../proj/Projection.js").default|undefined} The projection to report mouse
       *     position in.
       * @observable
       * @api
       */
      MousePosition.prototype.getProjection = function () {
          return /** @type {import("../proj/Projection.js").default|undefined} */ (this.get(PROJECTION));
      };
      /**
       * @param {MouseEvent} event Browser event.
       * @protected
       */
      MousePosition.prototype.handleMouseMove = function (event) {
          var map = this.getMap();
          this.updateHTML_(map.getEventPixel(event));
      };
      /**
       * @param {Event} event Browser event.
       * @protected
       */
      MousePosition.prototype.handleMouseOut = function (event) {
          this.updateHTML_(null);
      };
      /**
       * Remove the control from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       * @api
       */
      MousePosition.prototype.setMap = function (map) {
          _super.prototype.setMap.call(this, map);
          if (map) {
              var viewport = map.getViewport();
              this.listenerKeys.push(listen(viewport, PointerEventType.POINTERMOVE, this.handleMouseMove, this));
              if (this.renderOnMouseOut_) {
                  this.listenerKeys.push(listen(viewport, PointerEventType.POINTEROUT, this.handleMouseOut, this));
              }
          }
      };
      /**
       * Set the coordinate format type used to render the current position.
       * @param {import("../coordinate.js").CoordinateFormat} format The format to render the current
       *     position in.
       * @observable
       * @api
       */
      MousePosition.prototype.setCoordinateFormat = function (format) {
          this.set(COORDINATE_FORMAT, format);
      };
      /**
       * Set the projection that is used to report the mouse position.
       * @param {import("../proj.js").ProjectionLike} projection The projection to report mouse
       *     position in.
       * @observable
       * @api
       */
      MousePosition.prototype.setProjection = function (projection) {
          this.set(PROJECTION, get$3(projection));
      };
      /**
       * @param {?import("../pixel.js").Pixel} pixel Pixel.
       * @private
       */
      MousePosition.prototype.updateHTML_ = function (pixel) {
          var html = this.undefinedHTML_;
          if (pixel && this.mapProjection_) {
              if (!this.transform_) {
                  var projection = this.getProjection();
                  if (projection) {
                      this.transform_ = getTransformFromProjections(this.mapProjection_, projection);
                  }
                  else {
                      this.transform_ = identityTransform;
                  }
              }
              var map = this.getMap();
              var coordinate = map.getCoordinateFromPixelInternal(pixel);
              if (coordinate) {
                  var userProjection = getUserProjection();
                  if (userProjection) {
                      this.transform_ = getTransformFromProjections(this.mapProjection_, userProjection);
                  }
                  this.transform_(coordinate, coordinate);
                  var coordinateFormat = this.getCoordinateFormat();
                  if (coordinateFormat) {
                      html = coordinateFormat(coordinate);
                  }
                  else {
                      html = coordinate.toString();
                  }
              }
          }
          if (!this.renderedHTML_ || html !== this.renderedHTML_) {
              this.element.innerHTML = html;
              this.renderedHTML_ = html;
          }
      };
      /**
       * Update the projection. Rendering of the coordinates is done in
       * `handleMouseMove` and `handleMouseUp`.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @override
       */
      MousePosition.prototype.render = function (mapEvent) {
          var frameState = mapEvent.frameState;
          if (!frameState) {
              this.mapProjection_ = null;
          }
          else {
              if (this.mapProjection_ != frameState.viewState.projection) {
                  this.mapProjection_ = frameState.viewState.projection;
                  this.transform_ = null;
              }
          }
      };
      return MousePosition;
  }(Control));

  /**
   * @module ol/OverlayPositioning
   */
  /**
   * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
   * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
   * `'top-center'`, `'top-right'`
   * @enum {string}
   */
  var OverlayPositioning = {
      BOTTOM_LEFT: 'bottom-left',
      BOTTOM_CENTER: 'bottom-center',
      BOTTOM_RIGHT: 'bottom-right',
      CENTER_LEFT: 'center-left',
      CENTER_CENTER: 'center-center',
      CENTER_RIGHT: 'center-right',
      TOP_LEFT: 'top-left',
      TOP_CENTER: 'top-center',
      TOP_RIGHT: 'top-right',
  };

  var __extends$Z = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number|string} [id] Set the overlay id. The overlay id can be used
   * with the {@link module:ol/Map~Map#getOverlayById} method.
   * @property {HTMLElement} [element] The overlay element.
   * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning
   * the overlay. The first element in the
   * array is the horizontal offset. A positive value shifts the overlay right.
   * The second element in the array is the vertical offset. A positive value
   * shifts the overlay down.
   * @property {import("./coordinate.js").Coordinate} [position] The overlay position
   * in map projection.
   * @property {import("./OverlayPositioning.js").default} [positioning='top-left'] Defines how
   * the overlay is actually positioned with respect to its `position` property.
   * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,
   * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
   * `'top-center'`, and `'top-right'`.
   * @property {boolean} [stopEvent=true] Whether event propagation to the map
   * viewport should be stopped. If `true` the overlay is placed in the same
   * container as that of the controls (CSS class name
   * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container
   * with CSS class name specified by the `className` property.
   * @property {boolean} [insertFirst=true] Whether the overlay is inserted first
   * in the overlay container, or appended. If the overlay is placed in the same
   * container as that of the controls (see the `stopEvent` option) you will
   * probably set `insertFirst` to `true` so the overlay is displayed below the
   * controls.
   * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling
   * `setPosition`, so that the overlay is entirely visible in the current viewport?
   * If `true` (deprecated), then `autoPanAnimation` and `autoPanMargin` will be
   * used to determine the panning parameters; if an object is supplied then other
   * parameters are ignored.
   * @property {PanOptions} [autoPanAnimation] The animation options used to pan
   * the overlay into view. This animation is only used when `autoPan` is enabled.
   * A `duration` and `easing` may be provided to customize the animation.
   * Deprecated and ignored if `autoPan` is supplied as an object.
   * @property {number} [autoPanMargin=20] The margin (in pixels) between the
   * overlay and the borders of the map when autopanning. Deprecated and ignored
   * if `autoPan` is supplied as an object.
   * @property {PanIntoViewOptions} [autoPanOptions] The options to use for the
   * autoPan. This is only used when `autoPan` is enabled and has preference over
   * the individual `autoPanMargin` and `autoPanOptions`.
   * @property {string} [className='ol-overlay-container ol-selectable'] CSS class
   * name.
   */
  /**
   * @typedef {Object} PanOptions
   * @property {number} [duration=1000] The duration of the animation in
   * milliseconds.
   * @property {function(number):number} [easing] The easing function to use. Can
   * be one from {@link module:ol/easing} or a custom function.
   * Default is {@link module:ol/easing~inAndOut}.
   */
  /**
   * @typedef {Object} PanIntoViewOptions
   * @property {PanOptions} [animation={}] The animation parameters for the pan
   * @property {number} [margin=20] The margin (in pixels) between the
   * overlay and the borders of the map when panning into view.
   */
  /**
   * @enum {string}
   * @protected
   */
  var Property$3 = {
      ELEMENT: 'element',
      MAP: 'map',
      OFFSET: 'offset',
      POSITION: 'position',
      POSITIONING: 'positioning',
  };
  /**
   * @classdesc
   * An element to be displayed over the map and attached to a single map
   * location.  Like {@link module:ol/control/Control~Control}, Overlays are
   * visible widgets. Unlike Controls, they are not in a fixed position on the
   * screen, but are tied to a geographical coordinate, so panning the map will
   * move an Overlay but not a Control.
   *
   * Example:
   *
   *     import Overlay from 'ol/Overlay';
   *
   *     var popup = new Overlay({
   *       element: document.getElementById('popup')
   *     });
   *     popup.setPosition(coordinate);
   *     map.addOverlay(popup);
   *
   * @api
   */
  var Overlay = /** @class */ (function (_super) {
      __extends$Z(Overlay, _super);
      /**
       * @param {Options} options Overlay options.
       */
      function Overlay(options) {
          var _this = _super.call(this) || this;
          /**
           * @protected
           * @type {Options}
           */
          _this.options = options;
          /**
           * @protected
           * @type {number|string|undefined}
           */
          _this.id = options.id;
          /**
           * @protected
           * @type {boolean}
           */
          _this.insertFirst =
              options.insertFirst !== undefined ? options.insertFirst : true;
          /**
           * @protected
           * @type {boolean}
           */
          _this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;
          /**
           * @protected
           * @type {HTMLElement}
           */
          _this.element = document.createElement('div');
          _this.element.className =
              options.className !== undefined
                  ? options.className
                  : 'ol-overlay-container ' + CLASS_SELECTABLE;
          _this.element.style.position = 'absolute';
          _this.element.style.pointerEvents = 'auto';
          var autoPan = options.autoPan;
          if (autoPan && 'object' !== typeof autoPan) {
              autoPan = {
                  animation: options.autoPanAnimation,
                  margin: options.autoPanMargin,
              };
          }
          /**
           * @protected
           * @type {PanIntoViewOptions|false}
           */
          _this.autoPan = /** @type {PanIntoViewOptions} */ (autoPan) || false;
          /**
           * @protected
           * @type {{transform_: string,
           *         visible: boolean}}
           */
          _this.rendered = {
              transform_: '',
              visible: true,
          };
          /**
           * @protected
           * @type {?import("./events.js").EventsKey}
           */
          _this.mapPostrenderListenerKey = null;
          _this.addEventListener(getChangeEventType(Property$3.ELEMENT), _this.handleElementChanged);
          _this.addEventListener(getChangeEventType(Property$3.MAP), _this.handleMapChanged);
          _this.addEventListener(getChangeEventType(Property$3.OFFSET), _this.handleOffsetChanged);
          _this.addEventListener(getChangeEventType(Property$3.POSITION), _this.handlePositionChanged);
          _this.addEventListener(getChangeEventType(Property$3.POSITIONING), _this.handlePositioningChanged);
          if (options.element !== undefined) {
              _this.setElement(options.element);
          }
          _this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);
          _this.setPositioning(options.positioning !== undefined
              ? /** @type {import("./OverlayPositioning.js").default} */ (options.positioning)
              : OverlayPositioning.TOP_LEFT);
          if (options.position !== undefined) {
              _this.setPosition(options.position);
          }
          return _this;
      }
      /**
       * Get the DOM element of this overlay.
       * @return {HTMLElement|undefined} The Element containing the overlay.
       * @observable
       * @api
       */
      Overlay.prototype.getElement = function () {
          return /** @type {HTMLElement|undefined} */ (this.get(Property$3.ELEMENT));
      };
      /**
       * Get the overlay identifier which is set on constructor.
       * @return {number|string|undefined} Id.
       * @api
       */
      Overlay.prototype.getId = function () {
          return this.id;
      };
      /**
       * Get the map associated with this overlay.
       * @return {import("./PluggableMap.js").default|undefined} The map that the
       * overlay is part of.
       * @observable
       * @api
       */
      Overlay.prototype.getMap = function () {
          return /** @type {import("./PluggableMap.js").default|undefined} */ (this.get(Property$3.MAP));
      };
      /**
       * Get the offset of this overlay.
       * @return {Array<number>} The offset.
       * @observable
       * @api
       */
      Overlay.prototype.getOffset = function () {
          return /** @type {Array<number>} */ (this.get(Property$3.OFFSET));
      };
      /**
       * Get the current position of this overlay.
       * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
       *     anchored at.
       * @observable
       * @api
       */
      Overlay.prototype.getPosition = function () {
          return /** @type {import("./coordinate.js").Coordinate|undefined} */ (this.get(Property$3.POSITION));
      };
      /**
       * Get the current positioning of this overlay.
       * @return {import("./OverlayPositioning.js").default} How the overlay is positioned
       *     relative to its point on the map.
       * @observable
       * @api
       */
      Overlay.prototype.getPositioning = function () {
          return /** @type {import("./OverlayPositioning.js").default} */ (this.get(Property$3.POSITIONING));
      };
      /**
       * @protected
       */
      Overlay.prototype.handleElementChanged = function () {
          removeChildren(this.element);
          var element = this.getElement();
          if (element) {
              this.element.appendChild(element);
          }
      };
      /**
       * @protected
       */
      Overlay.prototype.handleMapChanged = function () {
          if (this.mapPostrenderListenerKey) {
              removeNode(this.element);
              unlistenByKey(this.mapPostrenderListenerKey);
              this.mapPostrenderListenerKey = null;
          }
          var map = this.getMap();
          if (map) {
              this.mapPostrenderListenerKey = listen(map, MapEventType.POSTRENDER, this.render, this);
              this.updatePixelPosition();
              var container = this.stopEvent
                  ? map.getOverlayContainerStopEvent()
                  : map.getOverlayContainer();
              if (this.insertFirst) {
                  container.insertBefore(this.element, container.childNodes[0] || null);
              }
              else {
                  container.appendChild(this.element);
              }
              this.performAutoPan();
          }
      };
      /**
       * @protected
       */
      Overlay.prototype.render = function () {
          this.updatePixelPosition();
      };
      /**
       * @protected
       */
      Overlay.prototype.handleOffsetChanged = function () {
          this.updatePixelPosition();
      };
      /**
       * @protected
       */
      Overlay.prototype.handlePositionChanged = function () {
          this.updatePixelPosition();
          this.performAutoPan();
      };
      /**
       * @protected
       */
      Overlay.prototype.handlePositioningChanged = function () {
          this.updatePixelPosition();
      };
      /**
       * Set the DOM element to be associated with this overlay.
       * @param {HTMLElement|undefined} element The Element containing the overlay.
       * @observable
       * @api
       */
      Overlay.prototype.setElement = function (element) {
          this.set(Property$3.ELEMENT, element);
      };
      /**
       * Set the map to be associated with this overlay.
       * @param {import("./PluggableMap.js").default|undefined} map The map that the
       * overlay is part of.
       * @observable
       * @api
       */
      Overlay.prototype.setMap = function (map) {
          this.set(Property$3.MAP, map);
      };
      /**
       * Set the offset for this overlay.
       * @param {Array<number>} offset Offset.
       * @observable
       * @api
       */
      Overlay.prototype.setOffset = function (offset) {
          this.set(Property$3.OFFSET, offset);
      };
      /**
       * Set the position for this overlay. If the position is `undefined` the
       * overlay is hidden.
       * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
       *     is anchored at.
       * @observable
       * @api
       */
      Overlay.prototype.setPosition = function (position) {
          this.set(Property$3.POSITION, position);
      };
      /**
       * Pan the map so that the overlay is entirely visisble in the current viewport
       * (if necessary) using the configured autoPan parameters
       * @protected
       */
      Overlay.prototype.performAutoPan = function () {
          if (this.autoPan) {
              this.panIntoView(this.autoPan);
          }
      };
      /**
       * Pan the map so that the overlay is entirely visible in the current viewport
       * (if necessary).
       * @param {PanIntoViewOptions=} opt_panIntoViewOptions Options for the pan action
       * @api
       */
      Overlay.prototype.panIntoView = function (opt_panIntoViewOptions) {
          var map = this.getMap();
          if (!map || !map.getTargetElement() || !this.get(Property$3.POSITION)) {
              return;
          }
          var mapRect = this.getRect(map.getTargetElement(), map.getSize());
          var element = this.getElement();
          var overlayRect = this.getRect(element, [
              outerWidth(element),
              outerHeight(element),
          ]);
          var panIntoViewOptions = opt_panIntoViewOptions || {};
          var myMargin = panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;
          if (!containsExtent(mapRect, overlayRect)) {
              // the overlay is not completely inside the viewport, so pan the map
              var offsetLeft = overlayRect[0] - mapRect[0];
              var offsetRight = mapRect[2] - overlayRect[2];
              var offsetTop = overlayRect[1] - mapRect[1];
              var offsetBottom = mapRect[3] - overlayRect[3];
              var delta = [0, 0];
              if (offsetLeft < 0) {
                  // move map to the left
                  delta[0] = offsetLeft - myMargin;
              }
              else if (offsetRight < 0) {
                  // move map to the right
                  delta[0] = Math.abs(offsetRight) + myMargin;
              }
              if (offsetTop < 0) {
                  // move map up
                  delta[1] = offsetTop - myMargin;
              }
              else if (offsetBottom < 0) {
                  // move map down
                  delta[1] = Math.abs(offsetBottom) + myMargin;
              }
              if (delta[0] !== 0 || delta[1] !== 0) {
                  var center = /** @type {import("./coordinate.js").Coordinate} */ (map
                      .getView()
                      .getCenterInternal());
                  var centerPx = map.getPixelFromCoordinateInternal(center);
                  var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
                  var panOptions = panIntoViewOptions.animation || {};
                  map.getView().animateInternal({
                      center: map.getCoordinateFromPixelInternal(newCenterPx),
                      duration: panOptions.duration,
                      easing: panOptions.easing,
                  });
              }
          }
      };
      /**
       * Get the extent of an element relative to the document
       * @param {HTMLElement} element The element.
       * @param {import("./size.js").Size} size The size of the element.
       * @return {import("./extent.js").Extent} The extent.
       * @protected
       */
      Overlay.prototype.getRect = function (element, size) {
          var box = element.getBoundingClientRect();
          var offsetX = box.left + window.pageXOffset;
          var offsetY = box.top + window.pageYOffset;
          return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
      };
      /**
       * Set the positioning for this overlay.
       * @param {import("./OverlayPositioning.js").default} positioning how the overlay is
       *     positioned relative to its point on the map.
       * @observable
       * @api
       */
      Overlay.prototype.setPositioning = function (positioning) {
          this.set(Property$3.POSITIONING, positioning);
      };
      /**
       * Modify the visibility of the element.
       * @param {boolean} visible Element visibility.
       * @protected
       */
      Overlay.prototype.setVisible = function (visible) {
          if (this.rendered.visible !== visible) {
              this.element.style.display = visible ? '' : 'none';
              this.rendered.visible = visible;
          }
      };
      /**
       * Update pixel position.
       * @protected
       */
      Overlay.prototype.updatePixelPosition = function () {
          var map = this.getMap();
          var position = this.getPosition();
          if (!map || !map.isRendered() || !position) {
              this.setVisible(false);
              return;
          }
          var pixel = map.getPixelFromCoordinate(position);
          var mapSize = map.getSize();
          this.updateRenderedPosition(pixel, mapSize);
      };
      /**
       * @param {import("./pixel.js").Pixel} pixel The pixel location.
       * @param {import("./size.js").Size|undefined} mapSize The map size.
       * @protected
       */
      Overlay.prototype.updateRenderedPosition = function (pixel, mapSize) {
          var style = this.element.style;
          var offset = this.getOffset();
          var positioning = this.getPositioning();
          this.setVisible(true);
          var x = Math.round(pixel[0] + offset[0]) + 'px';
          var y = Math.round(pixel[1] + offset[1]) + 'px';
          var posX = '0%';
          var posY = '0%';
          if (positioning == OverlayPositioning.BOTTOM_RIGHT ||
              positioning == OverlayPositioning.CENTER_RIGHT ||
              positioning == OverlayPositioning.TOP_RIGHT) {
              posX = '-100%';
          }
          else if (positioning == OverlayPositioning.BOTTOM_CENTER ||
              positioning == OverlayPositioning.CENTER_CENTER ||
              positioning == OverlayPositioning.TOP_CENTER) {
              posX = '-50%';
          }
          if (positioning == OverlayPositioning.BOTTOM_LEFT ||
              positioning == OverlayPositioning.BOTTOM_CENTER ||
              positioning == OverlayPositioning.BOTTOM_RIGHT) {
              posY = '-100%';
          }
          else if (positioning == OverlayPositioning.CENTER_LEFT ||
              positioning == OverlayPositioning.CENTER_CENTER ||
              positioning == OverlayPositioning.CENTER_RIGHT) {
              posY = '-50%';
          }
          var transform = "translate(" + posX + ", " + posY + ") translate(" + x + ", " + y + ")";
          if (this.rendered.transform_ != transform) {
              this.rendered.transform_ = transform;
              style.transform = transform;
              // @ts-ignore IE9
              style.msTransform = transform;
          }
      };
      /**
       * returns the options this Overlay has been created with
       * @return {Options} overlay options
       */
      Overlay.prototype.getOptions = function () {
          return this.options;
      };
      return Overlay;
  }(BaseObject));

  var __extends$_ = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Maximum width and/or height extent ratio that determines when the overview
   * map should be zoomed out.
   * @type {number}
   */
  var MAX_RATIO = 0.75;
  /**
   * Minimum width and/or height extent ratio that determines when the overview
   * map should be zoomed in.
   * @type {number}
   */
  var MIN_RATIO = 0.1;
  var ControlledMap = /** @class */ (function (_super) {
      __extends$_(ControlledMap, _super);
      function ControlledMap() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      ControlledMap.prototype.createRenderer = function () {
          return new CompositeMapRenderer(this);
      };
      return ControlledMap;
  }(PluggableMap));
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-overviewmap'] CSS class name.
   * @property {boolean} [collapsed=true] Whether the control should start collapsed or not (expanded).
   * @property {string|HTMLElement} [collapseLabel=''] Text label to use for the
   * expanded overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {boolean} [collapsible=true] Whether the control can be collapsed or not.
   * @property {string|HTMLElement} [label=''] Text label to use for the collapsed
   * overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {Array<import("../layer/Layer.js").default>|import("../Collection.js").default<import("../layer/Layer.js").default>} [layers]
   * Layers for the overview map.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
   * should be re-rendered. This is called in a `requestAnimationFrame` callback.
   * @property {boolean} [rotateWithView=false] Whether the control view should rotate with the main map view.
   * @property {HTMLElement|string} [target] Specify a target if you want the control
   * to be rendered outside of the map's viewport.
   * @property {string} [tipLabel='Overview map'] Text label to use for the button tip.
   * @property {View} [view] Custom view for the overview map (should use same projection as main map). If not provided,
   * a default view with the same projection as the main map will be used.
   */
  /**
   * Create a new control with a map acting as an overview map for another
   * defined map.
   *
   * @api
   */
  var OverviewMap = /** @class */ (function (_super) {
      __extends$_(OverviewMap, _super);
      /**
       * @param {Options=} opt_options OverviewMap options.
       */
      function OverviewMap(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              element: document.createElement('div'),
              render: options.render,
              target: options.target,
          }) || this;
          /**
           * @private
           */
          _this.boundHandleRotationChanged_ = _this.handleRotationChanged_.bind(_this);
          /**
           * @type {boolean}
           * @private
           */
          _this.collapsed_ =
              options.collapsed !== undefined ? options.collapsed : true;
          /**
           * @private
           * @type {boolean}
           */
          _this.collapsible_ =
              options.collapsible !== undefined ? options.collapsible : true;
          if (!_this.collapsible_) {
              _this.collapsed_ = false;
          }
          /**
           * @private
           * @type {boolean}
           */
          _this.rotateWithView_ =
              options.rotateWithView !== undefined ? options.rotateWithView : false;
          /**
           * @private
           * @type {import("../extent.js").Extent|undefined}
           */
          _this.viewExtent_ = undefined;
          var className = options.className !== undefined ? options.className : 'ol-overviewmap';
          var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Overview map';
          var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00AB';
          if (typeof collapseLabel === 'string') {
              /**
               * @private
               * @type {HTMLElement}
               */
              _this.collapseLabel_ = document.createElement('span');
              _this.collapseLabel_.textContent = collapseLabel;
          }
          else {
              _this.collapseLabel_ = collapseLabel;
          }
          var label = options.label !== undefined ? options.label : '\u00BB';
          if (typeof label === 'string') {
              /**
               * @private
               * @type {HTMLElement}
               */
              _this.label_ = document.createElement('span');
              _this.label_.textContent = label;
          }
          else {
              _this.label_ = label;
          }
          var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
          var button = document.createElement('button');
          button.setAttribute('type', 'button');
          button.title = tipLabel;
          button.appendChild(activeLabel);
          button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
          /**
           * @type {HTMLElement}
           * @private
           */
          _this.ovmapDiv_ = document.createElement('div');
          _this.ovmapDiv_.className = 'ol-overviewmap-map';
          /**
           * Explicitly given view to be used instead of a view derived from the main map.
           * @type {View}
           * @private
           */
          _this.view_ = options.view;
          /**
           * @type {ControlledMap}
           * @private
           */
          _this.ovmap_ = new ControlledMap({
              view: options.view,
          });
          var ovmap = _this.ovmap_;
          if (options.layers) {
              options.layers.forEach(function (layer) {
                  ovmap.addLayer(layer);
              });
          }
          var box = document.createElement('div');
          box.className = 'ol-overviewmap-box';
          box.style.boxSizing = 'border-box';
          /**
           * @type {import("../Overlay.js").default}
           * @private
           */
          _this.boxOverlay_ = new Overlay({
              position: [0, 0],
              positioning: OverlayPositioning.CENTER_CENTER,
              element: box,
          });
          _this.ovmap_.addOverlay(_this.boxOverlay_);
          var cssClasses = className +
              ' ' +
              CLASS_UNSELECTABLE +
              ' ' +
              CLASS_CONTROL +
              (_this.collapsed_ && _this.collapsible_ ? ' ' + CLASS_COLLAPSED : '') +
              (_this.collapsible_ ? '' : ' ol-uncollapsible');
          var element = _this.element;
          element.className = cssClasses;
          element.appendChild(_this.ovmapDiv_);
          element.appendChild(button);
          /* Interactive map */
          var scope = _this;
          var overlay = _this.boxOverlay_;
          var overlayBox = _this.boxOverlay_.getElement();
          /* Functions definition */
          var computeDesiredMousePosition = function (mousePosition) {
              return {
                  clientX: mousePosition.clientX,
                  clientY: mousePosition.clientY,
              };
          };
          var move = function (event) {
              var position = /** @type {?} */ (computeDesiredMousePosition(event));
              var coordinates = ovmap.getEventCoordinateInternal(
              /** @type {MouseEvent} */ (position));
              overlay.setPosition(coordinates);
          };
          var endMoving = function (event) {
              var coordinates = ovmap.getEventCoordinateInternal(event);
              scope.getMap().getView().setCenterInternal(coordinates);
              window.removeEventListener('mousemove', move);
              window.removeEventListener('mouseup', endMoving);
          };
          /* Binding */
          overlayBox.addEventListener('mousedown', function () {
              window.addEventListener('mousemove', move);
              window.addEventListener('mouseup', endMoving);
          });
          return _this;
      }
      /**
       * Remove the control from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       * @api
       */
      OverviewMap.prototype.setMap = function (map) {
          var oldMap = this.getMap();
          if (map === oldMap) {
              return;
          }
          if (oldMap) {
              var oldView = oldMap.getView();
              if (oldView) {
                  this.unbindView_(oldView);
              }
              this.ovmap_.setTarget(null);
          }
          _super.prototype.setMap.call(this, map);
          if (map) {
              this.ovmap_.setTarget(this.ovmapDiv_);
              this.listenerKeys.push(listen(map, ObjectEventType.PROPERTYCHANGE, this.handleMapPropertyChange_, this));
              var view = map.getView();
              if (view) {
                  this.bindView_(view);
                  if (view.isDef()) {
                      this.ovmap_.updateSize();
                      this.resetExtent_();
                  }
              }
          }
      };
      /**
       * Handle map property changes.  This only deals with changes to the map's view.
       * @param {import("../Object.js").ObjectEvent} event The propertychange event.
       * @private
       */
      OverviewMap.prototype.handleMapPropertyChange_ = function (event) {
          if (event.key === MapProperty.VIEW) {
              var oldView = /** @type {import("../View.js").default} */ (event.oldValue);
              if (oldView) {
                  this.unbindView_(oldView);
              }
              var newView = this.getMap().getView();
              this.bindView_(newView);
          }
      };
      /**
       * Register listeners for view property changes.
       * @param {import("../View.js").default} view The view.
       * @private
       */
      OverviewMap.prototype.bindView_ = function (view) {
          if (!this.view_) {
              // Unless an explicit view definition was given, derive default from whatever main map uses.
              var newView = new View({
                  projection: view.getProjection(),
              });
              this.ovmap_.setView(newView);
          }
          view.addEventListener(getChangeEventType(ViewProperty.ROTATION), this.boundHandleRotationChanged_);
          // Sync once with the new view
          this.handleRotationChanged_();
      };
      /**
       * Unregister listeners for view property changes.
       * @param {import("../View.js").default} view The view.
       * @private
       */
      OverviewMap.prototype.unbindView_ = function (view) {
          view.removeEventListener(getChangeEventType(ViewProperty.ROTATION), this.boundHandleRotationChanged_);
      };
      /**
       * Handle rotation changes to the main map.
       * @private
       */
      OverviewMap.prototype.handleRotationChanged_ = function () {
          if (this.rotateWithView_) {
              this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
          }
      };
      /**
       * Reset the overview map extent if the box size (width or
       * height) is less than the size of the overview map size times minRatio
       * or is greater than the size of the overview size times maxRatio.
       *
       * If the map extent was not reset, the box size can fits in the defined
       * ratio sizes. This method then checks if is contained inside the overview
       * map current extent. If not, recenter the overview map to the current
       * main map center location.
       * @private
       */
      OverviewMap.prototype.validateExtent_ = function () {
          var map = this.getMap();
          var ovmap = this.ovmap_;
          if (!map.isRendered() || !ovmap.isRendered()) {
              return;
          }
          var mapSize = /** @type {import("../size.js").Size} */ (map.getSize());
          var view = map.getView();
          var extent = view.calculateExtentInternal(mapSize);
          if (this.viewExtent_ && equals$1(extent, this.viewExtent_)) {
              // repeats of the same extent may indicate constraint conflicts leading to an endless cycle
              return;
          }
          this.viewExtent_ = extent;
          var ovmapSize = /** @type {import("../size.js").Size} */ (ovmap.getSize());
          var ovview = ovmap.getView();
          var ovextent = ovview.calculateExtentInternal(ovmapSize);
          var topLeftPixel = ovmap.getPixelFromCoordinateInternal(getTopLeft(extent));
          var bottomRightPixel = ovmap.getPixelFromCoordinateInternal(getBottomRight(extent));
          var boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);
          var boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);
          var ovmapWidth = ovmapSize[0];
          var ovmapHeight = ovmapSize[1];
          if (boxWidth < ovmapWidth * MIN_RATIO ||
              boxHeight < ovmapHeight * MIN_RATIO ||
              boxWidth > ovmapWidth * MAX_RATIO ||
              boxHeight > ovmapHeight * MAX_RATIO) {
              this.resetExtent_();
          }
          else if (!containsExtent(ovextent, extent)) {
              this.recenter_();
          }
      };
      /**
       * Reset the overview map extent to half calculated min and max ratio times
       * the extent of the main map.
       * @private
       */
      OverviewMap.prototype.resetExtent_ = function () {
          var map = this.getMap();
          var ovmap = this.ovmap_;
          var mapSize = /** @type {import("../size.js").Size} */ (map.getSize());
          var view = map.getView();
          var extent = view.calculateExtentInternal(mapSize);
          var ovview = ovmap.getView();
          // get how many times the current map overview could hold different
          // box sizes using the min and max ratio, pick the step in the middle used
          // to calculate the extent from the main map to set it to the overview map,
          var steps = Math.log(MAX_RATIO / MIN_RATIO) / Math.LN2;
          var ratio = 1 / (Math.pow(2, steps / 2) * MIN_RATIO);
          scaleFromCenter(extent, ratio);
          ovview.fitInternal(fromExtent(extent));
      };
      /**
       * Set the center of the overview map to the map center without changing its
       * resolution.
       * @private
       */
      OverviewMap.prototype.recenter_ = function () {
          var map = this.getMap();
          var ovmap = this.ovmap_;
          var view = map.getView();
          var ovview = ovmap.getView();
          ovview.setCenterInternal(view.getCenterInternal());
      };
      /**
       * Update the box using the main map extent
       * @private
       */
      OverviewMap.prototype.updateBox_ = function () {
          var map = this.getMap();
          var ovmap = this.ovmap_;
          if (!map.isRendered() || !ovmap.isRendered()) {
              return;
          }
          var mapSize = /** @type {import("../size.js").Size} */ (map.getSize());
          var view = map.getView();
          var ovview = ovmap.getView();
          var rotation = this.rotateWithView_ ? 0 : -view.getRotation();
          var overlay = this.boxOverlay_;
          var box = this.boxOverlay_.getElement();
          var center = view.getCenterInternal();
          var resolution = view.getResolution();
          var ovresolution = ovview.getResolution();
          var width = (mapSize[0] * resolution) / ovresolution;
          var height = (mapSize[1] * resolution) / ovresolution;
          // set position using center coordinates
          overlay.setPosition(center);
          // set box size calculated from map extent size and overview map resolution
          if (box) {
              box.style.width = width + 'px';
              box.style.height = height + 'px';
              var transform = 'rotate(' + rotation + 'rad)';
              box.style.transform = transform;
          }
      };
      /**
       * @param {MouseEvent} event The event to handle
       * @private
       */
      OverviewMap.prototype.handleClick_ = function (event) {
          event.preventDefault();
          this.handleToggle_();
      };
      /**
       * @private
       */
      OverviewMap.prototype.handleToggle_ = function () {
          this.element.classList.toggle(CLASS_COLLAPSED);
          if (this.collapsed_) {
              replaceNode(this.collapseLabel_, this.label_);
          }
          else {
              replaceNode(this.label_, this.collapseLabel_);
          }
          this.collapsed_ = !this.collapsed_;
          // manage overview map if it had not been rendered before and control
          // is expanded
          var ovmap = this.ovmap_;
          if (!this.collapsed_) {
              if (ovmap.isRendered()) {
                  this.viewExtent_ = undefined;
                  ovmap.render();
                  return;
              }
              ovmap.updateSize();
              this.resetExtent_();
              listenOnce(ovmap, MapEventType.POSTRENDER, function (event) {
                  this.updateBox_();
              }, this);
          }
      };
      /**
       * Return `true` if the overview map is collapsible, `false` otherwise.
       * @return {boolean} True if the widget is collapsible.
       * @api
       */
      OverviewMap.prototype.getCollapsible = function () {
          return this.collapsible_;
      };
      /**
       * Set whether the overview map should be collapsible.
       * @param {boolean} collapsible True if the widget is collapsible.
       * @api
       */
      OverviewMap.prototype.setCollapsible = function (collapsible) {
          if (this.collapsible_ === collapsible) {
              return;
          }
          this.collapsible_ = collapsible;
          this.element.classList.toggle('ol-uncollapsible');
          if (!collapsible && this.collapsed_) {
              this.handleToggle_();
          }
      };
      /**
       * Collapse or expand the overview map according to the passed parameter. Will
       * not do anything if the overview map isn't collapsible or if the current
       * collapsed state is already the one requested.
       * @param {boolean} collapsed True if the widget is collapsed.
       * @api
       */
      OverviewMap.prototype.setCollapsed = function (collapsed) {
          if (!this.collapsible_ || this.collapsed_ === collapsed) {
              return;
          }
          this.handleToggle_();
      };
      /**
       * Determine if the overview map is collapsed.
       * @return {boolean} The overview map is collapsed.
       * @api
       */
      OverviewMap.prototype.getCollapsed = function () {
          return this.collapsed_;
      };
      /**
       * Return `true` if the overview map view can rotate, `false` otherwise.
       * @return {boolean} True if the control view can rotate.
       * @api
       */
      OverviewMap.prototype.getRotateWithView = function () {
          return this.rotateWithView_;
      };
      /**
       * Set whether the overview map view should rotate with the main map view.
       * @param {boolean} rotateWithView True if the control view should rotate.
       * @api
       */
      OverviewMap.prototype.setRotateWithView = function (rotateWithView) {
          if (this.rotateWithView_ === rotateWithView) {
              return;
          }
          this.rotateWithView_ = rotateWithView;
          if (this.getMap().getView().getRotation() !== 0) {
              if (this.rotateWithView_) {
                  this.handleRotationChanged_();
              }
              else {
                  this.ovmap_.getView().setRotation(0);
              }
              this.viewExtent_ = undefined;
              this.validateExtent_();
              this.updateBox_();
          }
      };
      /**
       * Return the overview map.
       * @return {import("../PluggableMap.js").default} Overview map.
       * @api
       */
      OverviewMap.prototype.getOverviewMap = function () {
          return this.ovmap_;
      };
      /**
       * Update the overview map element.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @override
       */
      OverviewMap.prototype.render = function (mapEvent) {
          this.validateExtent_();
          this.updateBox_();
      };
      return OverviewMap;
  }(Control));

  var __extends$10 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @type {string}
   */
  var UNITS_PROP = 'units';
  /**
   * Units for the scale line. Supported values are `'degrees'`, `'imperial'`,
   * `'nautical'`, `'metric'`, `'us'`.
   * @enum {string}
   */
  var Units$1 = {
      DEGREES: 'degrees',
      IMPERIAL: 'imperial',
      NAUTICAL: 'nautical',
      METRIC: 'metric',
      US: 'us',
  };
  /**
   * @const
   * @type {Array<number>}
   */
  var LEADING_DIGITS = [1, 2, 5];
  /**
   * @const
   * @type {number}
   */
  var DEFAULT_DPI = 25.4 / 0.28;
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-scale-line'] CSS Class name.
   * @property {number} [minWidth=64] Minimum width in pixels at the OGC default dpi. The width will be
   * adjusted to match the dpi used.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
   * should be re-rendered. This is called in a `requestAnimationFrame` callback.
   * @property {HTMLElement|string} [target] Specify a target if you want the control
   * to be rendered outside of the map's viewport.
   * @property {import("./ScaleLine.js").Units|string} [units='metric'] Units.
   * @property {boolean} [bar=false] Render scalebars instead of a line.
   * @property {number} [steps=4] Number of steps the scalebar should use. Use even numbers
   * for best results. Only applies when `bar` is `true`.
   * @property {boolean} [text=false] Render the text scale above of the scalebar. Only applies
   * when `bar` is `true`.
   * @property {number|undefined} [dpi=undefined] dpi of output device such as printer. Only applies
   * when `bar` is `true`. If undefined the OGC default screen pixel size of 0.28mm will be assumed.
   */
  /**
   * @classdesc
   * A control displaying rough y-axis distances, calculated for the center of the
   * viewport. For conformal projections (e.g. EPSG:3857, the default view
   * projection in OpenLayers), the scale is valid for all directions.
   * No scale line will be shown when the y-axis distance of a pixel at the
   * viewport center cannot be calculated in the view projection.
   * By default the scale line will show in the bottom left portion of the map,
   * but this can be changed by using the css selector `.ol-scale-line`.
   * When specifying `bar` as `true`, a scalebar will be rendered instead
   * of a scaleline.
   *
   * @api
   */
  var ScaleLine = /** @class */ (function (_super) {
      __extends$10(ScaleLine, _super);
      /**
       * @param {Options=} opt_options Scale line options.
       */
      function ScaleLine(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var className = options.className !== undefined
              ? options.className
              : options.bar
                  ? 'ol-scale-bar'
                  : 'ol-scale-line';
          _this = _super.call(this, {
              element: document.createElement('div'),
              render: options.render,
              target: options.target,
          }) || this;
          /**
           * @private
           * @type {HTMLElement}
           */
          _this.innerElement_ = document.createElement('div');
          _this.innerElement_.className = className + '-inner';
          _this.element.className = className + ' ' + CLASS_UNSELECTABLE;
          _this.element.appendChild(_this.innerElement_);
          /**
           * @private
           * @type {?import("../View.js").State}
           */
          _this.viewState_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.minWidth_ = options.minWidth !== undefined ? options.minWidth : 64;
          /**
           * @private
           * @type {boolean}
           */
          _this.renderedVisible_ = false;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.renderedWidth_ = undefined;
          /**
           * @private
           * @type {string}
           */
          _this.renderedHTML_ = '';
          _this.addEventListener(getChangeEventType(UNITS_PROP), _this.handleUnitsChanged_);
          _this.setUnits(options.units || Units$1.METRIC);
          /**
           * @private
           * @type {boolean}
           */
          _this.scaleBar_ = options.bar || false;
          /**
           * @private
           * @type {number}
           */
          _this.scaleBarSteps_ = options.steps || 4;
          /**
           * @private
           * @type {boolean}
           */
          _this.scaleBarText_ = options.text || false;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.dpi_ = options.dpi || undefined;
          return _this;
      }
      /**
       * Return the units to use in the scale line.
       * @return {import("./ScaleLine.js").Units} The units
       * to use in the scale line.
       * @observable
       * @api
       */
      ScaleLine.prototype.getUnits = function () {
          return this.get(UNITS_PROP);
      };
      /**
       * @private
       */
      ScaleLine.prototype.handleUnitsChanged_ = function () {
          this.updateElement_();
      };
      /**
       * Set the units to use in the scale line.
       * @param {import("./ScaleLine.js").Units} units The units to use in the scale line.
       * @observable
       * @api
       */
      ScaleLine.prototype.setUnits = function (units) {
          this.set(UNITS_PROP, units);
      };
      /**
       * Specify the dpi of output device such as printer.
       * @param {number|undefined} dpi The dpi of output device.
       * @api
       */
      ScaleLine.prototype.setDpi = function (dpi) {
          this.dpi_ = dpi;
      };
      /**
       * @private
       */
      ScaleLine.prototype.updateElement_ = function () {
          var viewState = this.viewState_;
          if (!viewState) {
              if (this.renderedVisible_) {
                  this.element.style.display = 'none';
                  this.renderedVisible_ = false;
              }
              return;
          }
          var center = viewState.center;
          var projection = viewState.projection;
          var units = this.getUnits();
          var pointResolutionUnits = units == Units$1.DEGREES ? Units.DEGREES : Units.METERS;
          var pointResolution = getPointResolution(projection, viewState.resolution, center, pointResolutionUnits);
          var minWidth = (this.minWidth_ * (this.dpi_ || DEFAULT_DPI)) / DEFAULT_DPI;
          var nominalCount = minWidth * pointResolution;
          var suffix = '';
          if (units == Units$1.DEGREES) {
              var metersPerDegree = METERS_PER_UNIT[Units.DEGREES];
              nominalCount *= metersPerDegree;
              if (nominalCount < metersPerDegree / 60) {
                  suffix = '\u2033'; // seconds
                  pointResolution *= 3600;
              }
              else if (nominalCount < metersPerDegree) {
                  suffix = '\u2032'; // minutes
                  pointResolution *= 60;
              }
              else {
                  suffix = '\u00b0'; // degrees
              }
          }
          else if (units == Units$1.IMPERIAL) {
              if (nominalCount < 0.9144) {
                  suffix = 'in';
                  pointResolution /= 0.0254;
              }
              else if (nominalCount < 1609.344) {
                  suffix = 'ft';
                  pointResolution /= 0.3048;
              }
              else {
                  suffix = 'mi';
                  pointResolution /= 1609.344;
              }
          }
          else if (units == Units$1.NAUTICAL) {
              pointResolution /= 1852;
              suffix = 'nm';
          }
          else if (units == Units$1.METRIC) {
              if (nominalCount < 0.001) {
                  suffix = 'm';
                  pointResolution *= 1000000;
              }
              else if (nominalCount < 1) {
                  suffix = 'mm';
                  pointResolution *= 1000;
              }
              else if (nominalCount < 1000) {
                  suffix = 'm';
              }
              else {
                  suffix = 'km';
                  pointResolution /= 1000;
              }
          }
          else if (units == Units$1.US) {
              if (nominalCount < 0.9144) {
                  suffix = 'in';
                  pointResolution *= 39.37;
              }
              else if (nominalCount < 1609.344) {
                  suffix = 'ft';
                  pointResolution /= 0.30480061;
              }
              else {
                  suffix = 'mi';
                  pointResolution /= 1609.3472;
              }
          }
          else {
              assert(false, 33); // Invalid units
          }
          var i = 3 * Math.floor(Math.log(minWidth * pointResolution) / Math.log(10));
          var count, width, decimalCount;
          while (true) {
              decimalCount = Math.floor(i / 3);
              var decimal = Math.pow(10, decimalCount);
              count = LEADING_DIGITS[((i % 3) + 3) % 3] * decimal;
              width = Math.round(count / pointResolution);
              if (isNaN(width)) {
                  this.element.style.display = 'none';
                  this.renderedVisible_ = false;
                  return;
              }
              else if (width >= minWidth) {
                  break;
              }
              ++i;
          }
          var html;
          if (this.scaleBar_) {
              html = this.createScaleBar(width, count, suffix);
          }
          else {
              html = count.toFixed(decimalCount < 0 ? -decimalCount : 0) + ' ' + suffix;
          }
          if (this.renderedHTML_ != html) {
              this.innerElement_.innerHTML = html;
              this.renderedHTML_ = html;
          }
          if (this.renderedWidth_ != width) {
              this.innerElement_.style.width = width + 'px';
              this.renderedWidth_ = width;
          }
          if (!this.renderedVisible_) {
              this.element.style.display = '';
              this.renderedVisible_ = true;
          }
      };
      /**
       * @private
       * @param {number} width The current width of the scalebar.
       * @param {number} scale The current scale.
       * @param {string} suffix The suffix to append to the scale text.
       * @returns {string} The stringified HTML of the scalebar.
       */
      ScaleLine.prototype.createScaleBar = function (width, scale, suffix) {
          var mapScale = '1 : ' + Math.round(this.getScaleForResolution()).toLocaleString();
          var scaleSteps = [];
          var stepWidth = width / this.scaleBarSteps_;
          var backgroundColor = '#ffffff';
          for (var i = 0; i < this.scaleBarSteps_; i++) {
              if (i === 0) {
                  // create the first marker at position 0
                  scaleSteps.push(this.createMarker('absolute', i));
              }
              scaleSteps.push('<div>' +
                  '<div ' +
                  'class="ol-scale-singlebar" ' +
                  'style=' +
                  '"width: ' +
                  stepWidth +
                  'px;' +
                  'background-color: ' +
                  backgroundColor +
                  ';"' +
                  '>' +
                  '</div>' +
                  this.createMarker('relative', i) +
                  /*render text every second step, except when only 2 steps */
                  (i % 2 === 0 || this.scaleBarSteps_ === 2
                      ? this.createStepText(i, width, false, scale, suffix)
                      : '') +
                  '</div>');
              if (i === this.scaleBarSteps_ - 1) {
                  scaleSteps.push(this.createStepText(i + 1, width, true, scale, suffix));
              }
              // switch colors of steps between black and white
              if (backgroundColor === '#ffffff') {
                  backgroundColor = '#000000';
              }
              else {
                  backgroundColor = '#ffffff';
              }
          }
          var scaleBarText;
          if (this.scaleBarText_) {
              scaleBarText =
                  '<div ' +
                      'class="ol-scale-text" ' +
                      'style="width: ' +
                      width +
                      'px;">' +
                      mapScale +
                      '</div>';
          }
          else {
              scaleBarText = '';
          }
          var container = '<div ' +
              'style="display: flex;">' +
              scaleBarText +
              scaleSteps.join('') +
              '</div>';
          return container;
      };
      /**
       * Creates a marker at given position
       * @param {string} position - The position, absolute or relative
       * @param {number} i - The iterator
       * @returns {string} The stringified div containing the marker
       */
      ScaleLine.prototype.createMarker = function (position, i) {
          var top = position === 'absolute' ? 3 : -10;
          return ('<div ' +
              'class="ol-scale-step-marker" ' +
              'style="position: ' +
              position +
              ';' +
              'top: ' +
              top +
              'px;"' +
              '></div>');
      };
      /**
       * Creates the label for a marker marker at given position
       * @param {number} i - The iterator
       * @param {number} width - The width the scalebar will currently use
       * @param {boolean} isLast - Flag indicating if we add the last step text
       * @param {number} scale - The current scale for the whole scalebar
       * @param {string} suffix - The suffix for the scale
       * @returns {string} The stringified div containing the step text
       */
      ScaleLine.prototype.createStepText = function (i, width, isLast, scale, suffix) {
          var length = i === 0 ? 0 : Math.round((scale / this.scaleBarSteps_) * i * 100) / 100;
          var lengthString = length + (i === 0 ? '' : ' ' + suffix);
          var margin = i === 0 ? -3 : (width / this.scaleBarSteps_) * -1;
          var minWidth = i === 0 ? 0 : (width / this.scaleBarSteps_) * 2;
          return ('<div ' +
              'class="ol-scale-step-text" ' +
              'style="' +
              'margin-left: ' +
              margin +
              'px;' +
              'text-align: ' +
              (i === 0 ? 'left' : 'center') +
              '; ' +
              'min-width: ' +
              minWidth +
              'px;' +
              'left: ' +
              (isLast ? width + 'px' : 'unset') +
              ';"' +
              '>' +
              lengthString +
              '</div>');
      };
      /**
       * Returns the appropriate scale for the given resolution and units.
       * @return {number} The appropriate scale.
       */
      ScaleLine.prototype.getScaleForResolution = function () {
          var resolution = getPointResolution(this.viewState_.projection, this.viewState_.resolution, this.viewState_.center);
          var dpi = this.dpi_ || DEFAULT_DPI;
          var mpu = this.viewState_.projection.getMetersPerUnit();
          var inchesPerMeter = 39.37;
          return parseFloat(resolution.toString()) * mpu * inchesPerMeter * dpi;
      };
      /**
       * Update the scale line element.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @override
       */
      ScaleLine.prototype.render = function (mapEvent) {
          var frameState = mapEvent.frameState;
          if (!frameState) {
              this.viewState_ = null;
          }
          else {
              this.viewState_ = frameState.viewState;
          }
          this.updateElement_();
      };
      return ScaleLine;
  }(Control));

  /**
   * @module ol/control/ZoomSlider
   */
  var __extends$11 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * The enum for available directions.
   *
   * @enum {number}
   */
  var Direction = {
      VERTICAL: 0,
      HORIZONTAL: 1,
  };
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-zoomslider'] CSS class name.
   * @property {number} [duration=200] Animation duration in milliseconds.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
   * should be re-rendered. This is called in a `requestAnimationFrame` callback.
   */
  /**
   * @classdesc
   * A slider type of control for zooming.
   *
   * Example:
   *
   *     map.addControl(new ZoomSlider());
   *
   * @api
   */
  var ZoomSlider = /** @class */ (function (_super) {
      __extends$11(ZoomSlider, _super);
      /**
       * @param {Options=} opt_options Zoom slider options.
       */
      function ZoomSlider(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              element: document.createElement('div'),
              render: options.render,
          }) || this;
          /**
           * @type {!Array.<import("../events.js").EventsKey>}
           * @private
           */
          _this.dragListenerKeys_ = [];
          /**
           * Will hold the current resolution of the view.
           *
           * @type {number|undefined}
           * @private
           */
          _this.currentResolution_ = undefined;
          /**
           * The direction of the slider. Will be determined from actual display of the
           * container and defaults to Direction.VERTICAL.
           *
           * @type {Direction}
           * @private
           */
          _this.direction_ = Direction.VERTICAL;
          /**
           * @type {boolean}
           * @private
           */
          _this.dragging_;
          /**
           * @type {number}
           * @private
           */
          _this.heightLimit_ = 0;
          /**
           * @type {number}
           * @private
           */
          _this.widthLimit_ = 0;
          /**
           * @type {number|undefined}
           * @private
           */
          _this.startX_;
          /**
           * @type {number|undefined}
           * @private
           */
          _this.startY_;
          /**
           * The calculated thumb size (border box plus margins).  Set when initSlider_
           * is called.
           * @type {import("../size.js").Size}
           * @private
           */
          _this.thumbSize_ = null;
          /**
           * Whether the slider is initialized.
           * @type {boolean}
           * @private
           */
          _this.sliderInitialized_ = false;
          /**
           * @type {number}
           * @private
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 200;
          var className = options.className !== undefined ? options.className : 'ol-zoomslider';
          var thumbElement = document.createElement('button');
          thumbElement.setAttribute('type', 'button');
          thumbElement.className = className + '-thumb ' + CLASS_UNSELECTABLE;
          var containerElement = _this.element;
          containerElement.className =
              className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;
          containerElement.appendChild(thumbElement);
          containerElement.addEventListener(PointerEventType.POINTERDOWN, _this.handleDraggerStart_.bind(_this), false);
          containerElement.addEventListener(PointerEventType.POINTERMOVE, _this.handleDraggerDrag_.bind(_this), false);
          containerElement.addEventListener(PointerEventType.POINTERUP, _this.handleDraggerEnd_.bind(_this), false);
          containerElement.addEventListener(EventType.CLICK, _this.handleContainerClick_.bind(_this), false);
          thumbElement.addEventListener(EventType.CLICK, stopPropagation, false);
          return _this;
      }
      /**
       * Remove the control from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       * @api
       */
      ZoomSlider.prototype.setMap = function (map) {
          _super.prototype.setMap.call(this, map);
          if (map) {
              map.render();
          }
      };
      /**
       * Initializes the slider element. This will determine and set this controls
       * direction_ and also constrain the dragging of the thumb to always be within
       * the bounds of the container.
       *
       * @return {boolean} Initialization successful
       * @private
       */
      ZoomSlider.prototype.initSlider_ = function () {
          var container = this.element;
          var containerWidth = container.offsetWidth;
          var containerHeight = container.offsetHeight;
          if (containerWidth === 0 && containerHeight === 0) {
              return (this.sliderInitialized_ = false);
          }
          var thumb = /** @type {HTMLElement} */ (container.firstElementChild);
          var computedStyle = getComputedStyle(thumb);
          var thumbWidth = thumb.offsetWidth +
              parseFloat(computedStyle['marginRight']) +
              parseFloat(computedStyle['marginLeft']);
          var thumbHeight = thumb.offsetHeight +
              parseFloat(computedStyle['marginTop']) +
              parseFloat(computedStyle['marginBottom']);
          this.thumbSize_ = [thumbWidth, thumbHeight];
          if (containerWidth > containerHeight) {
              this.direction_ = Direction.HORIZONTAL;
              this.widthLimit_ = containerWidth - thumbWidth;
          }
          else {
              this.direction_ = Direction.VERTICAL;
              this.heightLimit_ = containerHeight - thumbHeight;
          }
          return (this.sliderInitialized_ = true);
      };
      /**
       * @param {PointerEvent} event The browser event to handle.
       * @private
       */
      ZoomSlider.prototype.handleContainerClick_ = function (event) {
          var view = this.getMap().getView();
          var relativePosition = this.getRelativePosition_(event.offsetX - this.thumbSize_[0] / 2, event.offsetY - this.thumbSize_[1] / 2);
          var resolution = this.getResolutionForPosition_(relativePosition);
          var zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));
          view.animateInternal({
              zoom: zoom,
              duration: this.duration_,
              easing: easeOut,
          });
      };
      /**
       * Handle dragger start events.
       * @param {PointerEvent} event The drag event.
       * @private
       */
      ZoomSlider.prototype.handleDraggerStart_ = function (event) {
          if (!this.dragging_ && event.target === this.element.firstElementChild) {
              var element = /** @type {HTMLElement} */ (this.element
                  .firstElementChild);
              this.getMap().getView().beginInteraction();
              this.startX_ = event.clientX - parseFloat(element.style.left);
              this.startY_ = event.clientY - parseFloat(element.style.top);
              this.dragging_ = true;
              if (this.dragListenerKeys_.length === 0) {
                  var drag = this.handleDraggerDrag_;
                  var end = this.handleDraggerEnd_;
                  this.dragListenerKeys_.push(listen(document, PointerEventType.POINTERMOVE, drag, this), listen(document, PointerEventType.POINTERUP, end, this));
              }
          }
      };
      /**
       * Handle dragger drag events.
       *
       * @param {PointerEvent} event The drag event.
       * @private
       */
      ZoomSlider.prototype.handleDraggerDrag_ = function (event) {
          if (this.dragging_) {
              var deltaX = event.clientX - this.startX_;
              var deltaY = event.clientY - this.startY_;
              var relativePosition = this.getRelativePosition_(deltaX, deltaY);
              this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
              this.getMap().getView().setResolution(this.currentResolution_);
          }
      };
      /**
       * Handle dragger end events.
       * @param {PointerEvent} event The drag event.
       * @private
       */
      ZoomSlider.prototype.handleDraggerEnd_ = function (event) {
          if (this.dragging_) {
              var view = this.getMap().getView();
              view.endInteraction();
              this.dragging_ = false;
              this.startX_ = undefined;
              this.startY_ = undefined;
              this.dragListenerKeys_.forEach(unlistenByKey);
              this.dragListenerKeys_.length = 0;
          }
      };
      /**
       * Positions the thumb inside its container according to the given resolution.
       *
       * @param {number} res The res.
       * @private
       */
      ZoomSlider.prototype.setThumbPosition_ = function (res) {
          var position = this.getPositionForResolution_(res);
          var thumb = /** @type {HTMLElement} */ (this.element.firstElementChild);
          if (this.direction_ == Direction.HORIZONTAL) {
              thumb.style.left = this.widthLimit_ * position + 'px';
          }
          else {
              thumb.style.top = this.heightLimit_ * position + 'px';
          }
      };
      /**
       * Calculates the relative position of the thumb given x and y offsets.  The
       * relative position scales from 0 to 1.  The x and y offsets are assumed to be
       * in pixel units within the dragger limits.
       *
       * @param {number} x Pixel position relative to the left of the slider.
       * @param {number} y Pixel position relative to the top of the slider.
       * @return {number} The relative position of the thumb.
       * @private
       */
      ZoomSlider.prototype.getRelativePosition_ = function (x, y) {
          var amount;
          if (this.direction_ === Direction.HORIZONTAL) {
              amount = x / this.widthLimit_;
          }
          else {
              amount = y / this.heightLimit_;
          }
          return clamp(amount, 0, 1);
      };
      /**
       * Calculates the corresponding resolution of the thumb given its relative
       * position (where 0 is the minimum and 1 is the maximum).
       *
       * @param {number} position The relative position of the thumb.
       * @return {number} The corresponding resolution.
       * @private
       */
      ZoomSlider.prototype.getResolutionForPosition_ = function (position) {
          var fn = this.getMap().getView().getResolutionForValueFunction();
          return fn(1 - position);
      };
      /**
       * Determines the relative position of the slider for the given resolution.  A
       * relative position of 0 corresponds to the minimum view resolution.  A
       * relative position of 1 corresponds to the maximum view resolution.
       *
       * @param {number} res The resolution.
       * @return {number} The relative position value (between 0 and 1).
       * @private
       */
      ZoomSlider.prototype.getPositionForResolution_ = function (res) {
          var fn = this.getMap().getView().getValueForResolutionFunction();
          return clamp(1 - fn(res), 0, 1);
      };
      /**
       * Update the zoomslider element.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @override
       */
      ZoomSlider.prototype.render = function (mapEvent) {
          if (!mapEvent.frameState) {
              return;
          }
          if (!this.sliderInitialized_ && !this.initSlider_()) {
              return;
          }
          var res = mapEvent.frameState.viewState.resolution;
          this.currentResolution_ = res;
          this.setThumbPosition_(res);
      };
      return ZoomSlider;
  }(Control));

  var __extends$12 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-zoom-extent'] Class name.
   * @property {HTMLElement|string} [target] Specify a target if you want the control
   * to be rendered outside of the map's viewport.
   * @property {string|HTMLElement} [label='E'] Text label to use for the button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string} [tipLabel='Fit to extent'] Text label to use for the button tip.
   * @property {import("../extent.js").Extent} [extent] The extent to zoom to. If undefined the validity
   * extent of the view projection is used.
   */
  /**
   * @classdesc
   * A button control which, when pressed, changes the map view to a specific
   * extent. To style this control use the css selector `.ol-zoom-extent`.
   *
   * @api
   */
  var ZoomToExtent = /** @class */ (function (_super) {
      __extends$12(ZoomToExtent, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function ZoomToExtent(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              element: document.createElement('div'),
              target: options.target,
          }) || this;
          /**
           * @type {?import("../extent.js").Extent}
           * @protected
           */
          _this.extent = options.extent ? options.extent : null;
          var className = options.className !== undefined ? options.className : 'ol-zoom-extent';
          var label = options.label !== undefined ? options.label : 'E';
          var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Fit to extent';
          var button = document.createElement('button');
          button.setAttribute('type', 'button');
          button.title = tipLabel;
          button.appendChild(typeof label === 'string' ? document.createTextNode(label) : label);
          button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
          var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;
          var element = _this.element;
          element.className = cssClasses;
          element.appendChild(button);
          return _this;
      }
      /**
       * @param {MouseEvent} event The event to handle
       * @private
       */
      ZoomToExtent.prototype.handleClick_ = function (event) {
          event.preventDefault();
          this.handleZoomToExtent();
      };
      /**
       * @protected
       */
      ZoomToExtent.prototype.handleZoomToExtent = function () {
          var map = this.getMap();
          var view = map.getView();
          var extent = !this.extent
              ? view.getProjection().getExtent()
              : this.extent;
          view.fitInternal(fromExtent(extent));
      };
      return ZoomToExtent;
  }(Control));

  /**
   * @module ol/control
   */
  /**
   * @typedef {Object} DefaultsOptions
   * @property {boolean} [attribution=true] Include
   * {@link module:ol/control/Attribution~Attribution}.
   * @property {import("./control/Attribution.js").Options} [attributionOptions]
   * Options for {@link module:ol/control/Attribution~Attribution}.
   * @property {boolean} [rotate=true] Include
   * {@link module:ol/control/Rotate~Rotate}.
   * @property {import("./control/Rotate.js").Options} [rotateOptions] Options
   * for {@link module:ol/control/Rotate~Rotate}.
   * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
   * @property {import("./control/Zoom.js").Options} [zoomOptions] Options for
   * {@link module:ol/control/Zoom~Zoom}.
   * @api
   */
  /**
   * Set of controls included in maps by default. Unless configured otherwise,
   * this returns a collection containing an instance of each of the following
   * controls:
   * * {@link module:ol/control/Zoom~Zoom}
   * * {@link module:ol/control/Rotate~Rotate}
   * * {@link module:ol/control/Attribution~Attribution}
   *
   * @param {DefaultsOptions=} opt_options
   * Defaults options.
   * @return {Collection<import("./control/Control.js").default>}
   * Controls.
   * @api
   */
  function defaults(opt_options) {
      var options = opt_options ? opt_options : {};
      var controls = new Collection();
      var zoomControl = options.zoom !== undefined ? options.zoom : true;
      if (zoomControl) {
          controls.push(new Zoom(options.zoomOptions));
      }
      var rotateControl = options.rotate !== undefined ? options.rotate : true;
      if (rotateControl) {
          controls.push(new Rotate(options.rotateOptions));
      }
      var attributionControl = options.attribution !== undefined ? options.attribution : true;
      if (attributionControl) {
          controls.push(new Attribution(options.attributionOptions));
      }
      return controls;
  }

  var __extends$13 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [duration=250] Animation duration in milliseconds.
   * @property {number} [delta=1] The zoom delta applied on each double click.
   */
  /**
   * @classdesc
   * Allows the user to zoom by double-clicking on the map.
   * @api
   */
  var DoubleClickZoom = /** @class */ (function (_super) {
      __extends$13(DoubleClickZoom, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DoubleClickZoom(opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @private
           * @type {number}
           */
          _this.delta_ = options.delta ? options.delta : 1;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          return _this;
      }
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a
       * doubleclick) and eventually zooms the map.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       */
      DoubleClickZoom.prototype.handleEvent = function (mapBrowserEvent) {
          var stopEvent = false;
          if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {
              var browserEvent = /** @type {MouseEvent} */ (mapBrowserEvent.originalEvent);
              var map = mapBrowserEvent.map;
              var anchor = mapBrowserEvent.coordinate;
              var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
              var view = map.getView();
              zoomByDelta(view, delta, anchor, this.duration_);
              mapBrowserEvent.preventDefault();
              stopEvent = true;
          }
          return !stopEvent;
      };
      return DoubleClickZoom;
  }(Interaction));

  var __extends$14 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
   * to indicate whether that event should be handled.
   * Default is {@link module:ol/events/condition~noModifierKeys} and {@link module:ol/events/condition~primaryAction}.
   * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
   * the interaction will only handle events when the map has the focus.
   * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
   */
  /**
   * @classdesc
   * Allows the user to pan the map by dragging the map.
   * @api
   */
  var DragPan = /** @class */ (function (_super) {
      __extends$14(DragPan, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DragPan(opt_options) {
          var _this = _super.call(this, {
              stopDown: FALSE,
          }) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @private
           * @type {import("../Kinetic.js").default|undefined}
           */
          _this.kinetic_ = options.kinetic;
          /**
           * @type {import("../pixel.js").Pixel}
           */
          _this.lastCentroid = null;
          /**
           * @type {number}
           */
          _this.lastPointersCount_;
          /**
           * @type {boolean}
           */
          _this.panning_ = false;
          var condition = options.condition
              ? options.condition
              : all$2(noModifierKeys, primaryAction);
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.onFocusOnly
              ? all$2(focusWithTabindex, condition)
              : condition;
          /**
           * @private
           * @type {boolean}
           */
          _this.noKinetic_ = false;
          return _this;
      }
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      DragPan.prototype.handleDragEvent = function (mapBrowserEvent) {
          if (!this.panning_) {
              this.panning_ = true;
              this.getMap().getView().beginInteraction();
          }
          var targetPointers = this.targetPointers;
          var centroid$$1 = centroid(targetPointers);
          if (targetPointers.length == this.lastPointersCount_) {
              if (this.kinetic_) {
                  this.kinetic_.update(centroid$$1[0], centroid$$1[1]);
              }
              if (this.lastCentroid) {
                  var delta = [
                      this.lastCentroid[0] - centroid$$1[0],
                      centroid$$1[1] - this.lastCentroid[1],
                  ];
                  var map = mapBrowserEvent.map;
                  var view = map.getView();
                  scale$1(delta, view.getResolution());
                  rotate$1(delta, view.getRotation());
                  view.adjustCenterInternal(delta);
              }
          }
          else if (this.kinetic_) {
              // reset so we don't overestimate the kinetic energy after
              // after one finger down, tiny drag, second finger down
              this.kinetic_.begin();
          }
          this.lastCentroid = centroid$$1;
          this.lastPointersCount_ = targetPointers.length;
          mapBrowserEvent.originalEvent.preventDefault();
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragPan.prototype.handleUpEvent = function (mapBrowserEvent) {
          var map = mapBrowserEvent.map;
          var view = map.getView();
          if (this.targetPointers.length === 0) {
              if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
                  var distance = this.kinetic_.getDistance();
                  var angle = this.kinetic_.getAngle();
                  var center = view.getCenterInternal();
                  var centerpx = map.getPixelFromCoordinateInternal(center);
                  var dest = map.getCoordinateFromPixelInternal([
                      centerpx[0] - distance * Math.cos(angle),
                      centerpx[1] - distance * Math.sin(angle),
                  ]);
                  view.animateInternal({
                      center: view.getConstrainedCenter(dest),
                      duration: 500,
                      easing: easeOut,
                  });
              }
              if (this.panning_) {
                  this.panning_ = false;
                  view.endInteraction();
              }
              return false;
          }
          else {
              if (this.kinetic_) {
                  // reset so we don't overestimate the kinetic energy after
                  // after one finger up, tiny drag, second finger up
                  this.kinetic_.begin();
              }
              this.lastCentroid = null;
              return true;
          }
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragPan.prototype.handleDownEvent = function (mapBrowserEvent) {
          if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
              var map = mapBrowserEvent.map;
              var view = map.getView();
              this.lastCentroid = null;
              // stop any current animation
              if (view.getAnimating()) {
                  view.cancelAnimations();
              }
              if (this.kinetic_) {
                  this.kinetic_.begin();
              }
              // No kinetic as soon as more than one pointer on the screen is
              // detected. This is to prevent nasty pans after pinch.
              this.noKinetic_ = this.targetPointers.length > 1;
              return true;
          }
          else {
              return false;
          }
      };
      return DragPan;
  }(PointerInteraction));

  var __extends$15 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that takes an
   * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
   * to indicate whether that event should be handled.
   * Default is {@link module:ol/events/condition~altShiftKeysOnly}.
   * @property {number} [duration=250] Animation duration in milliseconds.
   */
  /**
   * @classdesc
   * Allows the user to rotate the map by clicking and dragging on the map,
   * normally combined with an {@link module:ol/events/condition} that limits
   * it to when the alt and shift keys are held down.
   *
   * This interaction is only supported for mouse devices.
   * @api
   */
  var DragRotate = /** @class */ (function (_super) {
      __extends$15(DragRotate, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DragRotate(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              stopDown: FALSE,
          }) || this;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.lastAngle_ = undefined;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          return _this;
      }
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      DragRotate.prototype.handleDragEvent = function (mapBrowserEvent) {
          if (!mouseOnly(mapBrowserEvent)) {
              return;
          }
          var map = mapBrowserEvent.map;
          var view = map.getView();
          if (view.getConstraints().rotation === disable) {
              return;
          }
          var size = map.getSize();
          var offset = mapBrowserEvent.pixel;
          var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
          if (this.lastAngle_ !== undefined) {
              var delta = theta - this.lastAngle_;
              view.adjustRotationInternal(-delta);
          }
          this.lastAngle_ = theta;
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragRotate.prototype.handleUpEvent = function (mapBrowserEvent) {
          if (!mouseOnly(mapBrowserEvent)) {
              return true;
          }
          var map = mapBrowserEvent.map;
          var view = map.getView();
          view.endInteraction(this.duration_);
          return false;
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragRotate.prototype.handleDownEvent = function (mapBrowserEvent) {
          if (!mouseOnly(mapBrowserEvent)) {
              return false;
          }
          if (mouseActionButton(mapBrowserEvent) &&
              this.condition_(mapBrowserEvent)) {
              var map = mapBrowserEvent.map;
              map.getView().beginInteraction();
              this.lastAngle_ = undefined;
              return true;
          }
          else {
              return false;
          }
      };
      return DragRotate;
  }(PointerInteraction));

  /**
   * @module ol/render/Box
   */
  var __extends$16 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var RenderBox = /** @class */ (function (_super) {
      __extends$16(RenderBox, _super);
      /**
       * @param {string} className CSS class name.
       */
      function RenderBox(className) {
          var _this = _super.call(this) || this;
          /**
           * @type {import("../geom/Polygon.js").default}
           * @private
           */
          _this.geometry_ = null;
          /**
           * @type {HTMLDivElement}
           * @private
           */
          _this.element_ = document.createElement('div');
          _this.element_.style.position = 'absolute';
          _this.element_.style.pointerEvents = 'auto';
          _this.element_.className = 'ol-box ' + className;
          /**
           * @private
           * @type {import("../PluggableMap.js").default}
           */
          _this.map_ = null;
          /**
           * @private
           * @type {import("../pixel.js").Pixel}
           */
          _this.startPixel_ = null;
          /**
           * @private
           * @type {import("../pixel.js").Pixel}
           */
          _this.endPixel_ = null;
          return _this;
      }
      /**
       * Clean up.
       */
      RenderBox.prototype.disposeInternal = function () {
          this.setMap(null);
      };
      /**
       * @private
       */
      RenderBox.prototype.render_ = function () {
          var startPixel = this.startPixel_;
          var endPixel = this.endPixel_;
          var px = 'px';
          var style = this.element_.style;
          style.left = Math.min(startPixel[0], endPixel[0]) + px;
          style.top = Math.min(startPixel[1], endPixel[1]) + px;
          style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
          style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
      };
      /**
       * @param {import("../PluggableMap.js").default} map Map.
       */
      RenderBox.prototype.setMap = function (map) {
          if (this.map_) {
              this.map_.getOverlayContainer().removeChild(this.element_);
              var style = this.element_.style;
              style.left = 'inherit';
              style.top = 'inherit';
              style.width = 'inherit';
              style.height = 'inherit';
          }
          this.map_ = map;
          if (this.map_) {
              this.map_.getOverlayContainer().appendChild(this.element_);
          }
      };
      /**
       * @param {import("../pixel.js").Pixel} startPixel Start pixel.
       * @param {import("../pixel.js").Pixel} endPixel End pixel.
       */
      RenderBox.prototype.setPixels = function (startPixel, endPixel) {
          this.startPixel_ = startPixel;
          this.endPixel_ = endPixel;
          this.createOrUpdateGeometry();
          this.render_();
      };
      /**
       * Creates or updates the cached geometry.
       */
      RenderBox.prototype.createOrUpdateGeometry = function () {
          var startPixel = this.startPixel_;
          var endPixel = this.endPixel_;
          var pixels = [
              startPixel,
              [startPixel[0], endPixel[1]],
              endPixel,
              [endPixel[0], startPixel[1]],
          ];
          var coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_);
          // close the polygon
          coordinates[4] = coordinates[0].slice();
          if (!this.geometry_) {
              this.geometry_ = new Polygon$1([coordinates]);
          }
          else {
              this.geometry_.setCoordinates([coordinates]);
          }
      };
      /**
       * @return {import("../geom/Polygon.js").default} Geometry.
       */
      RenderBox.prototype.getGeometry = function () {
          return this.geometry_;
      };
      return RenderBox;
  }(Disposable));

  var __extends$17 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * A function that takes a {@link module:ol/MapBrowserEvent} and two
   * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
   * true should be returned.
   * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
   */
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
   * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
   * to indicate whether that event should be handled.
   * Default is {@link ol/events/condition~mouseActionButton}.
   * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
   * `boxEndCondition` function.
   * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
   * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
   * Default is `true` if the area of the box is bigger than the `minArea` option.
   * @property {function(this:DragBox, import("../MapBrowserEvent.js").default):void} [onBoxEnd] Code to execute just
   * before `boxend` is fired.
   */
  /**
   * @enum {string}
   */
  var DragBoxEventType = {
      /**
       * Triggered upon drag box start.
       * @event DragBoxEvent#boxstart
       * @api
       */
      BOXSTART: 'boxstart',
      /**
       * Triggered on drag when box is active.
       * @event DragBoxEvent#boxdrag
       * @api
       */
      BOXDRAG: 'boxdrag',
      /**
       * Triggered upon drag box end.
       * @event DragBoxEvent#boxend
       * @api
       */
      BOXEND: 'boxend',
  };
  /**
   * @classdesc
   * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
   * this type.
   */
  var DragBoxEvent = /** @class */ (function (_super) {
      __extends$17(DragBoxEvent, _super);
      /**
       * @param {string} type The event type.
       * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
       */
      function DragBoxEvent(type, coordinate, mapBrowserEvent) {
          var _this = _super.call(this, type) || this;
          /**
           * The coordinate of the drag event.
           * @const
           * @type {import("../coordinate.js").Coordinate}
           * @api
           */
          _this.coordinate = coordinate;
          /**
           * @const
           * @type {import("../MapBrowserEvent.js").default}
           * @api
           */
          _this.mapBrowserEvent = mapBrowserEvent;
          return _this;
      }
      return DragBoxEvent;
  }(BaseEvent));
  /**
   * @classdesc
   * Allows the user to draw a vector box by clicking and dragging on the map,
   * normally combined with an {@link module:ol/events/condition} that limits
   * it to when the shift or other key is held down. This is used, for example,
   * for zooming to a specific area of the map
   * (see {@link module:ol/interaction/DragZoom~DragZoom} and
   * {@link module:ol/interaction/DragRotateAndZoom}).
   *
   * @fires DragBoxEvent
   * @api
   */
  var DragBox = /** @class */ (function (_super) {
      __extends$17(DragBox, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DragBox(opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @type {import("../render/Box.js").default}
           * @private
           */
          _this.box_ = new RenderBox(options.className || 'ol-dragbox');
          /**
           * @type {number}
           * @private
           */
          _this.minArea_ = options.minArea !== undefined ? options.minArea : 64;
          if (options.onBoxEnd) {
              _this.onBoxEnd = options.onBoxEnd;
          }
          /**
           * @type {import("../pixel.js").Pixel}
           * @private
           */
          _this.startPixel_ = null;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.condition ? options.condition : mouseActionButton;
          /**
           * @private
           * @type {EndCondition}
           */
          _this.boxEndCondition_ = options.boxEndCondition
              ? options.boxEndCondition
              : _this.defaultBoxEndCondition;
          return _this;
      }
      /**
       * The default condition for determining whether the boxend event
       * should fire.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
       *     leading to the box end.
       * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
       * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
       * @return {boolean} Whether or not the boxend condition should be fired.
       */
      DragBox.prototype.defaultBoxEndCondition = function (mapBrowserEvent, startPixel, endPixel) {
          var width = endPixel[0] - startPixel[0];
          var height = endPixel[1] - startPixel[1];
          return width * width + height * height >= this.minArea_;
      };
      /**
       * Returns geometry of last drawn box.
       * @return {import("../geom/Polygon.js").default} Geometry.
       * @api
       */
      DragBox.prototype.getGeometry = function () {
          return this.box_.getGeometry();
      };
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      DragBox.prototype.handleDragEvent = function (mapBrowserEvent) {
          this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
          this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragBox.prototype.handleUpEvent = function (mapBrowserEvent) {
          this.box_.setMap(null);
          if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {
              this.onBoxEnd(mapBrowserEvent);
              this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXEND, mapBrowserEvent.coordinate, mapBrowserEvent));
          }
          return false;
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragBox.prototype.handleDownEvent = function (mapBrowserEvent) {
          if (this.condition_(mapBrowserEvent)) {
              this.startPixel_ = mapBrowserEvent.pixel;
              this.box_.setMap(mapBrowserEvent.map);
              this.box_.setPixels(this.startPixel_, this.startPixel_);
              this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
              return true;
          }
          else {
              return false;
          }
      };
      /**
       * Function to execute just before `onboxend` is fired
       * @param {import("../MapBrowserEvent.js").default} event Event.
       */
      DragBox.prototype.onBoxEnd = function (event) { };
      return DragBox;
  }(PointerInteraction));

  var __extends$18 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-dragzoom'] CSS class name for styling the
   * box.
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled.
   * Default is {@link module:ol/events/condition~shiftKeyOnly}.
   * @property {number} [duration=200] Animation duration in milliseconds.
   * @property {boolean} [out=false] Use interaction for zooming out.
   * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
   * `boxEndCondition` function.
   */
  /**
   * @classdesc
   * Allows the user to zoom the map by clicking and dragging on the map,
   * normally combined with an {@link module:ol/events/condition} that limits
   * it to when a key, shift by default, is held down.
   *
   * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
   * your custom one configured with `className`.
   * @api
   */
  var DragZoom = /** @class */ (function (_super) {
      __extends$18(DragZoom, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DragZoom(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var condition = options.condition ? options.condition : shiftKeyOnly;
          _this = _super.call(this, {
              condition: condition,
              className: options.className || 'ol-dragzoom',
              minArea: options.minArea,
          }) || this;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 200;
          /**
           * @private
           * @type {boolean}
           */
          _this.out_ = options.out !== undefined ? options.out : false;
          return _this;
      }
      /**
       * Function to execute just before `onboxend` is fired
       * @param {import("../MapBrowserEvent.js").default} event Event.
       */
      DragZoom.prototype.onBoxEnd = function (event) {
          var map = this.getMap();
          var view = /** @type {!import("../View.js").default} */ (map.getView());
          var size = /** @type {!import("../size.js").Size} */ (map.getSize());
          var extent = this.getGeometry().getExtent();
          if (this.out_) {
              var mapExtent = view.calculateExtentInternal(size);
              var boxPixelExtent = createOrUpdateFromCoordinates([
                  map.getPixelFromCoordinateInternal(getBottomLeft(extent)),
                  map.getPixelFromCoordinateInternal(getTopRight(extent)),
              ]);
              var factor = view.getResolutionForExtentInternal(boxPixelExtent, size);
              scaleFromCenter(mapExtent, 1 / factor);
              extent = mapExtent;
          }
          var resolution = view.getConstrainedResolution(view.getResolutionForExtentInternal(extent, size));
          var center = view.getConstrainedCenter(getCenter(extent), resolution);
          view.animateInternal({
              resolution: resolution,
              center: center,
              duration: this.duration_,
              easing: easeOut,
          });
      };
      return DragZoom;
  }(DragBox));

  /**
   * @module ol/events/KeyCode
   */
  /**
   * @enum {number}
   * @const
   */
  var KeyCode = {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
  };

  var __extends$19 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. Default is
   * {@link module:ol/events/condition~noModifierKeys} and
   * {@link module:ol/events/condition~targetNotEditable}.
   * @property {number} [duration=100] Animation duration in milliseconds.
   * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
   * press.
   */
  /**
   * @classdesc
   * Allows the user to pan the map using keyboard arrows.
   * Note that, although this interaction is by default included in maps,
   * the keys can only be used when browser focus is on the element to which
   * the keyboard events are attached. By default, this is the map div,
   * though you can change this with the `keyboardEventTarget` in
   * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
   * element, focus will have to be on, and returned to, this element if the keys
   * are to function.
   * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
   * @api
   */
  var KeyboardPan = /** @class */ (function (_super) {
      __extends$19(KeyboardPan, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function KeyboardPan(opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options || {};
          /**
           * @private
           * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
           * @return {boolean} Combined condition result.
           */
          _this.defaultCondition_ = function (mapBrowserEvent) {
              return (noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent));
          };
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ =
              options.condition !== undefined
                  ? options.condition
                  : _this.defaultCondition_;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 100;
          /**
           * @private
           * @type {number}
           */
          _this.pixelDelta_ =
              options.pixelDelta !== undefined ? options.pixelDelta : 128;
          return _this;
      }
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
       * `KeyEvent`, and decides the direction to pan to (if an arrow key was
       * pressed).
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @this {KeyboardPan}
       */
      KeyboardPan.prototype.handleEvent = function (mapBrowserEvent) {
          var stopEvent = false;
          if (mapBrowserEvent.type == EventType.KEYDOWN) {
              var keyEvent = /** @type {KeyboardEvent} */ (mapBrowserEvent.originalEvent);
              var keyCode = keyEvent.keyCode;
              if (this.condition_(mapBrowserEvent) &&
                  (keyCode == KeyCode.DOWN ||
                      keyCode == KeyCode.LEFT ||
                      keyCode == KeyCode.RIGHT ||
                      keyCode == KeyCode.UP)) {
                  var map = mapBrowserEvent.map;
                  var view = map.getView();
                  var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
                  var deltaX = 0, deltaY = 0;
                  if (keyCode == KeyCode.DOWN) {
                      deltaY = -mapUnitsDelta;
                  }
                  else if (keyCode == KeyCode.LEFT) {
                      deltaX = -mapUnitsDelta;
                  }
                  else if (keyCode == KeyCode.RIGHT) {
                      deltaX = mapUnitsDelta;
                  }
                  else {
                      deltaY = mapUnitsDelta;
                  }
                  var delta = [deltaX, deltaY];
                  rotate$1(delta, view.getRotation());
                  pan(view, delta, this.duration_);
                  mapBrowserEvent.preventDefault();
                  stopEvent = true;
              }
          }
          return !stopEvent;
      };
      return KeyboardPan;
  }(Interaction));

  var __extends$1a = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [duration=100] Animation duration in milliseconds.
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. Default is
   * {@link module:ol/events/condition~targetNotEditable}.
   * @property {number} [delta=1] The zoom level delta on each key press.
   */
  /**
   * @classdesc
   * Allows the user to zoom the map using keyboard + and -.
   * Note that, although this interaction is by default included in maps,
   * the keys can only be used when browser focus is on the element to which
   * the keyboard events are attached. By default, this is the map div,
   * though you can change this with the `keyboardEventTarget` in
   * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
   * element, focus will have to be on, and returned to, this element if the keys
   * are to function.
   * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
   * @api
   */
  var KeyboardZoom = /** @class */ (function (_super) {
      __extends$1a(KeyboardZoom, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function KeyboardZoom(opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.condition ? options.condition : targetNotEditable;
          /**
           * @private
           * @type {number}
           */
          _this.delta_ = options.delta ? options.delta : 1;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 100;
          return _this;
      }
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
       * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
       * key pressed was '+' or '-').
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @this {KeyboardZoom}
       */
      KeyboardZoom.prototype.handleEvent = function (mapBrowserEvent) {
          var stopEvent = false;
          if (mapBrowserEvent.type == EventType.KEYDOWN ||
              mapBrowserEvent.type == EventType.KEYPRESS) {
              var keyEvent = /** @type {KeyboardEvent} */ (mapBrowserEvent.originalEvent);
              var charCode = keyEvent.charCode;
              if (this.condition_(mapBrowserEvent) &&
                  (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
                  var map = mapBrowserEvent.map;
                  var delta = charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;
                  var view = map.getView();
                  zoomByDelta(view, delta, undefined, this.duration_);
                  mapBrowserEvent.preventDefault();
                  stopEvent = true;
              }
          }
          return !stopEvent;
      };
      return KeyboardZoom;
  }(Interaction));

  /**
   * @module ol/Kinetic
   */
  /**
   * @classdesc
   * Implementation of inertial deceleration for map movement.
   *
   * @api
   */
  var Kinetic = /** @class */ (function () {
      /**
       * @param {number} decay Rate of decay (must be negative).
       * @param {number} minVelocity Minimum velocity (pixels/millisecond).
       * @param {number} delay Delay to consider to calculate the kinetic
       *     initial values (milliseconds).
       */
      function Kinetic(decay, minVelocity, delay) {
          /**
           * @private
           * @type {number}
           */
          this.decay_ = decay;
          /**
           * @private
           * @type {number}
           */
          this.minVelocity_ = minVelocity;
          /**
           * @private
           * @type {number}
           */
          this.delay_ = delay;
          /**
           * @private
           * @type {Array<number>}
           */
          this.points_ = [];
          /**
           * @private
           * @type {number}
           */
          this.angle_ = 0;
          /**
           * @private
           * @type {number}
           */
          this.initialVelocity_ = 0;
      }
      /**
       * FIXME empty description for jsdoc
       */
      Kinetic.prototype.begin = function () {
          this.points_.length = 0;
          this.angle_ = 0;
          this.initialVelocity_ = 0;
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       */
      Kinetic.prototype.update = function (x, y) {
          this.points_.push(x, y, Date.now());
      };
      /**
       * @return {boolean} Whether we should do kinetic animation.
       */
      Kinetic.prototype.end = function () {
          if (this.points_.length < 6) {
              // at least 2 points are required (i.e. there must be at least 6 elements
              // in the array)
              return false;
          }
          var delay = Date.now() - this.delay_;
          var lastIndex = this.points_.length - 3;
          if (this.points_[lastIndex + 2] < delay) {
              // the last tracked point is too old, which means that the user stopped
              // panning before releasing the map
              return false;
          }
          // get the first point which still falls into the delay time
          var firstIndex = lastIndex - 3;
          while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
              firstIndex -= 3;
          }
          var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
          // we don't want a duration of 0 (divide by zero)
          // we also make sure the user panned for a duration of at least one frame
          // (1/60s) to compute sane displacement values
          if (duration < 1000 / 60) {
              return false;
          }
          var dx = this.points_[lastIndex] - this.points_[firstIndex];
          var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
          this.angle_ = Math.atan2(dy, dx);
          this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
          return this.initialVelocity_ > this.minVelocity_;
      };
      /**
       * @return {number} Total distance travelled (pixels).
       */
      Kinetic.prototype.getDistance = function () {
          return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
      };
      /**
       * @return {number} Angle of the kinetic panning animation (radians).
       */
      Kinetic.prototype.getAngle = function () {
          return this.angle_;
      };
      return Kinetic;
  }());

  var __extends$1b = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @enum {string}
   */
  var Mode$1 = {
      TRACKPAD: 'trackpad',
      WHEEL: 'wheel',
  };
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. Default is
   * {@link module:ol/events/condition~always}.
   * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
   * the interaction will only handle events when the map has the focus.
   * @property {number} [maxDelta=1] Maximum mouse wheel delta.
   * @property {number} [duration=250] Animation duration in milliseconds.
   * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
   * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
   * location as the anchor. When set to `false`, zooming in and out will zoom to
   * the center of the screen instead of zooming on the mouse's location.
   * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
   * event will always animate to the closest zoom level after an interaction;
   * false means intermediary zoom levels are allowed.
   */
  /**
   * @classdesc
   * Allows the user to zoom the map by scrolling the mouse wheel.
   * @api
   */
  var MouseWheelZoom = /** @class */ (function (_super) {
      __extends$1b(MouseWheelZoom, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function MouseWheelZoom(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, 
          /** @type {import("./Interaction.js").InteractionOptions} */ (options)) || this;
          /**
           * @private
           * @type {number}
           */
          _this.totalDelta_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.lastDelta_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          /**
           * @private
           * @type {number}
           */
          _this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
          /**
           * @private
           * @type {boolean}
           */
          _this.useAnchor_ =
              options.useAnchor !== undefined ? options.useAnchor : true;
          /**
           * @private
           * @type {boolean}
           */
          _this.constrainResolution_ =
              options.constrainResolution !== undefined
                  ? options.constrainResolution
                  : false;
          var condition = options.condition ? options.condition : always;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.onFocusOnly
              ? all$2(focusWithTabindex, condition)
              : condition;
          /**
           * @private
           * @type {?import("../coordinate.js").Coordinate}
           */
          _this.lastAnchor_ = null;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.startTime_ = undefined;
          /**
           * @private
           * @type {?}
           */
          _this.timeoutId_;
          /**
           * @private
           * @type {Mode|undefined}
           */
          _this.mode_ = undefined;
          /**
           * Trackpad events separated by this delay will be considered separate
           * interactions.
           * @type {number}
           */
          _this.trackpadEventGap_ = 400;
          /**
           * @type {?}
           */
          _this.trackpadTimeoutId_;
          /**
           * The number of delta values per zoom level
           * @private
           * @type {number}
           */
          _this.deltaPerZoom_ = 300;
          return _this;
      }
      /**
       * @private
       */
      MouseWheelZoom.prototype.endInteraction_ = function () {
          this.trackpadTimeoutId_ = undefined;
          var view = this.getMap().getView();
          view.endInteraction(undefined, this.lastDelta_ ? (this.lastDelta_ > 0 ? 1 : -1) : 0, this.lastAnchor_);
      };
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
       * zooms the map.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       */
      MouseWheelZoom.prototype.handleEvent = function (mapBrowserEvent) {
          if (!this.condition_(mapBrowserEvent)) {
              return true;
          }
          var type = mapBrowserEvent.type;
          if (type !== EventType.WHEEL) {
              return true;
          }
          mapBrowserEvent.preventDefault();
          var map = mapBrowserEvent.map;
          var wheelEvent = /** @type {WheelEvent} */ (mapBrowserEvent.originalEvent);
          if (this.useAnchor_) {
              this.lastAnchor_ = mapBrowserEvent.coordinate;
          }
          // Delta normalisation inspired by
          // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
          var delta;
          if (mapBrowserEvent.type == EventType.WHEEL) {
              delta = wheelEvent.deltaY;
              if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
                  delta /= DEVICE_PIXEL_RATIO;
              }
              if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
                  delta *= 40;
              }
          }
          if (delta === 0) {
              return false;
          }
          else {
              this.lastDelta_ = delta;
          }
          var now = Date.now();
          if (this.startTime_ === undefined) {
              this.startTime_ = now;
          }
          if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
              this.mode_ = Math.abs(delta) < 4 ? Mode$1.TRACKPAD : Mode$1.WHEEL;
          }
          var view = map.getView();
          if (this.mode_ === Mode$1.TRACKPAD &&
              !(view.getConstrainResolution() || this.constrainResolution_)) {
              if (this.trackpadTimeoutId_) {
                  clearTimeout(this.trackpadTimeoutId_);
              }
              else {
                  if (view.getAnimating()) {
                      view.cancelAnimations();
                  }
                  view.beginInteraction();
              }
              this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
              view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
              this.startTime_ = now;
              return false;
          }
          this.totalDelta_ += delta;
          var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
          clearTimeout(this.timeoutId_);
          this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
          return false;
      };
      /**
       * @private
       * @param {import("../PluggableMap.js").default} map Map.
       */
      MouseWheelZoom.prototype.handleWheelZoom_ = function (map) {
          var view = map.getView();
          if (view.getAnimating()) {
              view.cancelAnimations();
          }
          var delta = -clamp(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
          if (view.getConstrainResolution() || this.constrainResolution_) {
              // view has a zoom constraint, zoom by 1
              delta = delta ? (delta > 0 ? 1 : -1) : 0;
          }
          zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
          this.mode_ = undefined;
          this.totalDelta_ = 0;
          this.lastAnchor_ = null;
          this.startTime_ = undefined;
          this.timeoutId_ = undefined;
      };
      /**
       * Enable or disable using the mouse's location as an anchor when zooming
       * @param {boolean} useAnchor true to zoom to the mouse's location, false
       * to zoom to the center of the map
       * @api
       */
      MouseWheelZoom.prototype.setMouseAnchor = function (useAnchor) {
          this.useAnchor_ = useAnchor;
          if (!useAnchor) {
              this.lastAnchor_ = null;
          }
      };
      return MouseWheelZoom;
  }(Interaction));

  var __extends$1c = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [duration=250] The duration of the animation in
   * milliseconds.
   * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
   */
  /**
   * @classdesc
   * Allows the user to rotate the map by twisting with two fingers
   * on a touch screen.
   * @api
   */
  var PinchRotate = /** @class */ (function (_super) {
      __extends$1c(PinchRotate, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function PinchRotate(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);
          if (!pointerOptions.stopDown) {
              pointerOptions.stopDown = FALSE;
          }
          _this = _super.call(this, pointerOptions) || this;
          /**
           * @private
           * @type {import("../coordinate.js").Coordinate}
           */
          _this.anchor_ = null;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.lastAngle_ = undefined;
          /**
           * @private
           * @type {boolean}
           */
          _this.rotating_ = false;
          /**
           * @private
           * @type {number}
           */
          _this.rotationDelta_ = 0.0;
          /**
           * @private
           * @type {number}
           */
          _this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          return _this;
      }
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      PinchRotate.prototype.handleDragEvent = function (mapBrowserEvent) {
          var rotationDelta = 0.0;
          var touch0 = this.targetPointers[0];
          var touch1 = this.targetPointers[1];
          // angle between touches
          var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);
          if (this.lastAngle_ !== undefined) {
              var delta = angle - this.lastAngle_;
              this.rotationDelta_ += delta;
              if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
                  this.rotating_ = true;
              }
              rotationDelta = delta;
          }
          this.lastAngle_ = angle;
          var map = mapBrowserEvent.map;
          var view = map.getView();
          if (view.getConstraints().rotation === disable) {
              return;
          }
          // rotate anchor point.
          // FIXME: should be the intersection point between the lines:
          //     touch0,touch1 and previousTouch0,previousTouch1
          var viewportPosition = map.getViewport().getBoundingClientRect();
          var centroid$$1 = centroid(this.targetPointers);
          centroid$$1[0] -= viewportPosition.left;
          centroid$$1[1] -= viewportPosition.top;
          this.anchor_ = map.getCoordinateFromPixelInternal(centroid$$1);
          // rotate
          if (this.rotating_) {
              map.render();
              view.adjustRotationInternal(rotationDelta, this.anchor_);
          }
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      PinchRotate.prototype.handleUpEvent = function (mapBrowserEvent) {
          if (this.targetPointers.length < 2) {
              var map = mapBrowserEvent.map;
              var view = map.getView();
              view.endInteraction(this.duration_);
              return false;
          }
          else {
              return true;
          }
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      PinchRotate.prototype.handleDownEvent = function (mapBrowserEvent) {
          if (this.targetPointers.length >= 2) {
              var map = mapBrowserEvent.map;
              this.anchor_ = null;
              this.lastAngle_ = undefined;
              this.rotating_ = false;
              this.rotationDelta_ = 0.0;
              if (!this.handlingDownUpSequence) {
                  map.getView().beginInteraction();
              }
              return true;
          }
          else {
              return false;
          }
      };
      return PinchRotate;
  }(PointerInteraction));

  var __extends$1d = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [duration=400] Animation duration in milliseconds.
   */
  /**
   * @classdesc
   * Allows the user to zoom the map by pinching with two fingers
   * on a touch screen.
   * @api
   */
  var PinchZoom = /** @class */ (function (_super) {
      __extends$1d(PinchZoom, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function PinchZoom(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);
          if (!pointerOptions.stopDown) {
              pointerOptions.stopDown = FALSE;
          }
          _this = _super.call(this, pointerOptions) || this;
          /**
           * @private
           * @type {import("../coordinate.js").Coordinate}
           */
          _this.anchor_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 400;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.lastDistance_ = undefined;
          /**
           * @private
           * @type {number}
           */
          _this.lastScaleDelta_ = 1;
          return _this;
      }
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      PinchZoom.prototype.handleDragEvent = function (mapBrowserEvent) {
          var scaleDelta = 1.0;
          var touch0 = this.targetPointers[0];
          var touch1 = this.targetPointers[1];
          var dx = touch0.clientX - touch1.clientX;
          var dy = touch0.clientY - touch1.clientY;
          // distance between touches
          var distance = Math.sqrt(dx * dx + dy * dy);
          if (this.lastDistance_ !== undefined) {
              scaleDelta = this.lastDistance_ / distance;
          }
          this.lastDistance_ = distance;
          var map = mapBrowserEvent.map;
          var view = map.getView();
          if (scaleDelta != 1.0) {
              this.lastScaleDelta_ = scaleDelta;
          }
          // scale anchor point.
          var viewportPosition = map.getViewport().getBoundingClientRect();
          var centroid$$1 = centroid(this.targetPointers);
          centroid$$1[0] -= viewportPosition.left;
          centroid$$1[1] -= viewportPosition.top;
          this.anchor_ = map.getCoordinateFromPixelInternal(centroid$$1);
          // scale, bypass the resolution constraint
          map.render();
          view.adjustResolutionInternal(scaleDelta, this.anchor_);
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      PinchZoom.prototype.handleUpEvent = function (mapBrowserEvent) {
          if (this.targetPointers.length < 2) {
              var map = mapBrowserEvent.map;
              var view = map.getView();
              var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
              view.endInteraction(this.duration_, direction);
              return false;
          }
          else {
              return true;
          }
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      PinchZoom.prototype.handleDownEvent = function (mapBrowserEvent) {
          if (this.targetPointers.length >= 2) {
              var map = mapBrowserEvent.map;
              this.anchor_ = null;
              this.lastDistance_ = undefined;
              this.lastScaleDelta_ = 1;
              if (!this.handlingDownUpSequence) {
                  map.getView().beginInteraction();
              }
              return true;
          }
          else {
              return false;
          }
      };
      return PinchZoom;
  }(PointerInteraction));

  /**
   * @module ol/interaction/DragAndDrop
   */
  // FIXME should handle all geo-referenced data, not just vector data
  var __extends$1e = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {Array<typeof import("../format/Feature.js").default>} [formatConstructors] Format constructors.
   * @property {import("../source/Vector.js").default} [source] Optional vector source where features will be added.  If a source is provided
   * all existing features will be removed and new features will be added when
   * they are dropped on the target.  If you want to add features to a vector
   * source without removing the existing features (append only), instead of
   * providing the source option listen for the "addfeatures" event.
   * @property {import("../proj.js").ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.
   * @property {HTMLElement} [target] The element that is used as the drop target, default is the viewport element.
   */
  /**
   * @enum {string}
   */
  var DragAndDropEventType = {
      /**
       * Triggered when features are added
       * @event DragAndDropEvent#addfeatures
       * @api
       */
      ADD_FEATURES: 'addfeatures',
  };
  /**
   * @classdesc
   * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances
   * of this type.
   */
  var DragAndDropEvent = /** @class */ (function (_super) {
      __extends$1e(DragAndDropEvent, _super);
      /**
       * @param {DragAndDropEventType} type Type.
       * @param {File} file File.
       * @param {Array<import("../Feature.js").default>=} opt_features Features.
       * @param {import("../proj/Projection.js").default=} opt_projection Projection.
       */
      function DragAndDropEvent(type, file, opt_features, opt_projection) {
          var _this = _super.call(this, type) || this;
          /**
           * The features parsed from dropped data.
           * @type {Array<import("../Feature.js").FeatureLike>|undefined}
           * @api
           */
          _this.features = opt_features;
          /**
           * The dropped file.
           * @type {File}
           * @api
           */
          _this.file = file;
          /**
           * The feature projection.
           * @type {import("../proj/Projection.js").default|undefined}
           * @api
           */
          _this.projection = opt_projection;
          return _this;
      }
      return DragAndDropEvent;
  }(BaseEvent));
  /**
   * @classdesc
   * Handles input of vector data by drag and drop.
   * @api
   *
   * @fires DragAndDropEvent
   */
  var DragAndDrop = /** @class */ (function (_super) {
      __extends$1e(DragAndDrop, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DragAndDrop(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              handleEvent: TRUE,
          }) || this;
          /**
           * @private
           * @type {Array<typeof import("../format/Feature.js").default>}
           */
          _this.formatConstructors_ = options.formatConstructors
              ? options.formatConstructors
              : [];
          /**
           * @private
           * @type {import("../proj/Projection.js").default}
           */
          _this.projection_ = options.projection
              ? get$3(options.projection)
              : null;
          /**
           * @private
           * @type {?Array<import("../events.js").EventsKey>}
           */
          _this.dropListenKeys_ = null;
          /**
           * @private
           * @type {import("../source/Vector.js").default}
           */
          _this.source_ = options.source || null;
          /**
           * @private
           * @type {HTMLElement}
           */
          _this.target = options.target ? options.target : null;
          return _this;
      }
      /**
       * @param {File} file File.
       * @param {Event} event Load event.
       * @private
       */
      DragAndDrop.prototype.handleResult_ = function (file, event) {
          var result = event.target.result;
          var map = this.getMap();
          var projection = this.projection_;
          if (!projection) {
              var view = map.getView();
              projection = view.getProjection();
          }
          var formatConstructors = this.formatConstructors_;
          for (var i = 0, ii = formatConstructors.length; i < ii; ++i) {
              var format = new formatConstructors[i]();
              var features = this.tryReadFeatures_(format, result, {
                  featureProjection: projection,
              });
              if (features && features.length > 0) {
                  if (this.source_) {
                      this.source_.clear();
                      this.source_.addFeatures(features);
                  }
                  this.dispatchEvent(new DragAndDropEvent(DragAndDropEventType.ADD_FEATURES, file, features, projection));
                  break;
              }
          }
      };
      /**
       * @private
       */
      DragAndDrop.prototype.registerListeners_ = function () {
          var map = this.getMap();
          if (map) {
              var dropArea = this.target ? this.target : map.getViewport();
              this.dropListenKeys_ = [
                  listen(dropArea, EventType.DROP, this.handleDrop, this),
                  listen(dropArea, EventType.DRAGENTER, this.handleStop, this),
                  listen(dropArea, EventType.DRAGOVER, this.handleStop, this),
                  listen(dropArea, EventType.DROP, this.handleStop, this),
              ];
          }
      };
      /**
       * Activate or deactivate the interaction.
       * @param {boolean} active Active.
       * @observable
       * @api
       */
      DragAndDrop.prototype.setActive = function (active) {
          if (!this.getActive() && active) {
              this.registerListeners_();
          }
          if (this.getActive() && !active) {
              this.unregisterListeners_();
          }
          _super.prototype.setActive.call(this, active);
      };
      /**
       * Remove the interaction from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       */
      DragAndDrop.prototype.setMap = function (map) {
          this.unregisterListeners_();
          _super.prototype.setMap.call(this, map);
          if (this.getActive()) {
              this.registerListeners_();
          }
      };
      /**
       * @param {import("../format/Feature.js").default} format Format.
       * @param {string} text Text.
       * @param {import("../format/Feature.js").ReadOptions} options Read options.
       * @private
       * @return {Array<import("../Feature.js").default>} Features.
       */
      DragAndDrop.prototype.tryReadFeatures_ = function (format, text, options) {
          try {
              return (
              /** @type {Array<import("../Feature.js").default>} */
              (format.readFeatures(text, options)));
          }
          catch (e) {
              return null;
          }
      };
      /**
       * @private
       */
      DragAndDrop.prototype.unregisterListeners_ = function () {
          if (this.dropListenKeys_) {
              this.dropListenKeys_.forEach(unlistenByKey);
              this.dropListenKeys_ = null;
          }
      };
      /**
       * @param {DragEvent} event Event.
       */
      DragAndDrop.prototype.handleDrop = function (event) {
          var files = event.dataTransfer.files;
          for (var i = 0, ii = files.length; i < ii; ++i) {
              var file = files.item(i);
              var reader = new FileReader();
              reader.addEventListener(EventType.LOAD, this.handleResult_.bind(this, file));
              reader.readAsText(file);
          }
      };
      /**
       * @param {DragEvent} event Event.
       */
      DragAndDrop.prototype.handleStop = function (event) {
          event.stopPropagation();
          event.preventDefault();
          event.dataTransfer.dropEffect = 'copy';
      };
      return DragAndDrop;
  }(Interaction));

  var __extends$1f = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled.
   * Default is {@link module:ol/events/condition~shiftKeyOnly}.
   * @property {number} [duration=400] Animation duration in milliseconds.
   */
  /**
   * @classdesc
   * Allows the user to zoom and rotate the map by clicking and dragging
   * on the map.  By default, this interaction is limited to when the shift
   * key is held down.
   *
   * This interaction is only supported for mouse devices.
   *
   * And this interaction is not included in the default interactions.
   * @api
   */
  var DragRotateAndZoom = /** @class */ (function (_super) {
      __extends$1f(DragRotateAndZoom, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DragRotateAndZoom(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, /** @type {import("./Pointer.js").Options} */ (options)) || this;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.condition ? options.condition : shiftKeyOnly;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.lastAngle_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.lastMagnitude_ = undefined;
          /**
           * @private
           * @type {number}
           */
          _this.lastScaleDelta_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 400;
          return _this;
      }
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      DragRotateAndZoom.prototype.handleDragEvent = function (mapBrowserEvent) {
          if (!mouseOnly(mapBrowserEvent)) {
              return;
          }
          var map = mapBrowserEvent.map;
          var size = map.getSize();
          var offset = mapBrowserEvent.pixel;
          var deltaX = offset[0] - size[0] / 2;
          var deltaY = size[1] / 2 - offset[1];
          var theta = Math.atan2(deltaY, deltaX);
          var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          var view = map.getView();
          if (this.lastAngle_ !== undefined) {
              var angleDelta = this.lastAngle_ - theta;
              view.adjustRotationInternal(angleDelta);
          }
          this.lastAngle_ = theta;
          if (this.lastMagnitude_ !== undefined) {
              view.adjustResolutionInternal(this.lastMagnitude_ / magnitude);
          }
          if (this.lastMagnitude_ !== undefined) {
              this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;
          }
          this.lastMagnitude_ = magnitude;
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragRotateAndZoom.prototype.handleUpEvent = function (mapBrowserEvent) {
          if (!mouseOnly(mapBrowserEvent)) {
              return true;
          }
          var map = mapBrowserEvent.map;
          var view = map.getView();
          var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
          view.endInteraction(this.duration_, direction);
          this.lastScaleDelta_ = 0;
          return false;
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragRotateAndZoom.prototype.handleDownEvent = function (mapBrowserEvent) {
          if (!mouseOnly(mapBrowserEvent)) {
              return false;
          }
          if (this.condition_(mapBrowserEvent)) {
              mapBrowserEvent.map.getView().beginInteraction();
              this.lastAngle_ = undefined;
              this.lastMagnitude_ = undefined;
              return true;
          }
          else {
              return false;
          }
      };
      return DragRotateAndZoom;
  }(PointerInteraction));

  var __extends$1g = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled.
   * Default is {@link module:ol/events/condition~always}.
   * @property {import("../extent.js").Extent} [extent] Initial extent. Defaults to no
   * initial extent.
   * @property {import("../style/Style.js").StyleLike} [boxStyle]
   * Style for the drawn extent box. Defaults to
   * {@link module:ol/style/Style~createEditing()['Polygon']}
   * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
   * pointer close enough to a segment or vertex for editing.
   * @property {import("../style/Style.js").StyleLike} [pointerStyle]
   * Style for the cursor used to draw the extent. Defaults to
   * {@link module:ol/style/Style~createEditing()['Point']}
   * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps
   * in the X direction? Only affects visuals, not functionality.
   */
  /**
   * @enum {string}
   */
  var ExtentEventType = {
      /**
       * Triggered after the extent is changed
       * @event ExtentEvent#extentchanged
       * @api
       */
      EXTENTCHANGED: 'extentchanged',
  };
  /**
   * @classdesc
   * Events emitted by {@link module:ol/interaction/Extent~Extent} instances are
   * instances of this type.
   */
  var ExtentEvent = /** @class */ (function (_super) {
      __extends$1g(ExtentEvent, _super);
      /**
       * @param {import("../extent.js").Extent} extent the new extent
       */
      function ExtentEvent(extent) {
          var _this = _super.call(this, ExtentEventType.EXTENTCHANGED) || this;
          /**
           * The current extent.
           * @type {import("../extent.js").Extent}
           * @api
           */
          _this.extent = extent;
          return _this;
      }
      return ExtentEvent;
  }(BaseEvent));
  /**
   * @classdesc
   * Allows the user to draw a vector box by clicking and dragging on the map.
   * Once drawn, the vector box can be modified by dragging its vertices or edges.
   * This interaction is only supported for mouse devices.
   *
   * @fires ExtentEvent
   * @api
   */
  var Extent = /** @class */ (function (_super) {
      __extends$1g(Extent, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function Extent(opt_options) {
          var _this = this;
          var options = opt_options || {};
          _this = _super.call(this, /** @type {import("./Pointer.js").Options} */ (options)) || this;
          /**
           * Condition
           * @type {import("../events/condition.js").Condition}
           * @private
           */
          _this.condition_ = options.condition ? options.condition : always;
          /**
           * Extent of the drawn box
           * @type {import("../extent.js").Extent}
           * @private
           */
          _this.extent_ = null;
          /**
           * Handler for pointer move events
           * @type {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null}
           * @private
           */
          _this.pointerHandler_ = null;
          /**
           * Pixel threshold to snap to extent
           * @type {number}
           * @private
           */
          _this.pixelTolerance_ =
              options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
          /**
           * Is the pointer snapped to an extent vertex
           * @type {boolean}
           * @private
           */
          _this.snappedToVertex_ = false;
          /**
           * Feature for displaying the visible extent
           * @type {Feature}
           * @private
           */
          _this.extentFeature_ = null;
          /**
           * Feature for displaying the visible pointer
           * @type {Feature<Point>}
           * @private
           */
          _this.vertexFeature_ = null;
          if (!opt_options) {
              opt_options = {};
          }
          /**
           * Layer for the extentFeature
           * @type {VectorLayer}
           * @private
           */
          _this.extentOverlay_ = new VectorLayer({
              source: new VectorSource({
                  useSpatialIndex: false,
                  wrapX: !!opt_options.wrapX,
              }),
              style: opt_options.boxStyle
                  ? opt_options.boxStyle
                  : getDefaultExtentStyleFunction(),
              updateWhileAnimating: true,
              updateWhileInteracting: true,
          });
          /**
           * Layer for the vertexFeature
           * @type {VectorLayer}
           * @private
           */
          _this.vertexOverlay_ = new VectorLayer({
              source: new VectorSource({
                  useSpatialIndex: false,
                  wrapX: !!opt_options.wrapX,
              }),
              style: opt_options.pointerStyle
                  ? opt_options.pointerStyle
                  : getDefaultPointerStyleFunction(),
              updateWhileAnimating: true,
              updateWhileInteracting: true,
          });
          if (opt_options.extent) {
              _this.setExtent(opt_options.extent);
          }
          return _this;
      }
      /**
       * @param {import("../pixel.js").Pixel} pixel cursor location
       * @param {import("../PluggableMap.js").default} map map
       * @returns {import("../coordinate.js").Coordinate|null} snapped vertex on extent
       * @private
       */
      Extent.prototype.snapToVertex_ = function (pixel, map) {
          var pixelCoordinate = map.getCoordinateFromPixelInternal(pixel);
          var sortByDistance = function (a, b) {
              return (squaredDistanceToSegment(pixelCoordinate, a) -
                  squaredDistanceToSegment(pixelCoordinate, b));
          };
          var extent = this.getExtentInternal();
          if (extent) {
              //convert extents to line segments and find the segment closest to pixelCoordinate
              var segments = getSegments(extent);
              segments.sort(sortByDistance);
              var closestSegment = segments[0];
              var vertex = closestOnSegment(pixelCoordinate, closestSegment);
              var vertexPixel = map.getPixelFromCoordinateInternal(vertex);
              //if the distance is within tolerance, snap to the segment
              if (distance$1(pixel, vertexPixel) <= this.pixelTolerance_) {
                  //test if we should further snap to a vertex
                  var pixel1 = map.getPixelFromCoordinateInternal(closestSegment[0]);
                  var pixel2 = map.getPixelFromCoordinateInternal(closestSegment[1]);
                  var squaredDist1 = squaredDistance$1(vertexPixel, pixel1);
                  var squaredDist2 = squaredDistance$1(vertexPixel, pixel2);
                  var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
                  this.snappedToVertex_ = dist <= this.pixelTolerance_;
                  if (this.snappedToVertex_) {
                      vertex =
                          squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
                  }
                  return vertex;
              }
          }
          return null;
      };
      /**
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent pointer move event
       * @private
       */
      Extent.prototype.handlePointerMove_ = function (mapBrowserEvent) {
          var pixel = mapBrowserEvent.pixel;
          var map = mapBrowserEvent.map;
          var vertex = this.snapToVertex_(pixel, map);
          if (!vertex) {
              vertex = map.getCoordinateFromPixelInternal(pixel);
          }
          this.createOrUpdatePointerFeature_(vertex);
      };
      /**
       * @param {import("../extent.js").Extent} extent extent
       * @returns {Feature} extent as featrue
       * @private
       */
      Extent.prototype.createOrUpdateExtentFeature_ = function (extent) {
          var extentFeature = this.extentFeature_;
          if (!extentFeature) {
              if (!extent) {
                  extentFeature = new Feature({});
              }
              else {
                  extentFeature = new Feature(fromExtent(extent));
              }
              this.extentFeature_ = extentFeature;
              this.extentOverlay_.getSource().addFeature(extentFeature);
          }
          else {
              if (!extent) {
                  extentFeature.setGeometry(undefined);
              }
              else {
                  extentFeature.setGeometry(fromExtent(extent));
              }
          }
          return extentFeature;
      };
      /**
       * @param {import("../coordinate.js").Coordinate} vertex location of feature
       * @returns {Feature} vertex as feature
       * @private
       */
      Extent.prototype.createOrUpdatePointerFeature_ = function (vertex) {
          var vertexFeature = this.vertexFeature_;
          if (!vertexFeature) {
              vertexFeature = new Feature(new Point$1(vertex));
              this.vertexFeature_ = vertexFeature;
              this.vertexOverlay_.getSource().addFeature(vertexFeature);
          }
          else {
              var geometry = vertexFeature.getGeometry();
              geometry.setCoordinates(vertex);
          }
          return vertexFeature;
      };
      /**
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       */
      Extent.prototype.handleEvent = function (mapBrowserEvent) {
          if (!mapBrowserEvent.originalEvent || !this.condition_(mapBrowserEvent)) {
              return true;
          }
          //display pointer (if not dragging)
          if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&
              !this.handlingDownUpSequence) {
              this.handlePointerMove_(mapBrowserEvent);
          }
          //call pointer to determine up/down/drag
          _super.prototype.handleEvent.call(this, mapBrowserEvent);
          //return false to stop propagation
          return false;
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      Extent.prototype.handleDownEvent = function (mapBrowserEvent) {
          var pixel = mapBrowserEvent.pixel;
          var map = mapBrowserEvent.map;
          var extent = this.getExtentInternal();
          var vertex = this.snapToVertex_(pixel, map);
          //find the extent corner opposite the passed corner
          var getOpposingPoint = function (point) {
              var x_ = null;
              var y_ = null;
              if (point[0] == extent[0]) {
                  x_ = extent[2];
              }
              else if (point[0] == extent[2]) {
                  x_ = extent[0];
              }
              if (point[1] == extent[1]) {
                  y_ = extent[3];
              }
              else if (point[1] == extent[3]) {
                  y_ = extent[1];
              }
              if (x_ !== null && y_ !== null) {
                  return [x_, y_];
              }
              return null;
          };
          if (vertex && extent) {
              var x = vertex[0] == extent[0] || vertex[0] == extent[2] ? vertex[0] : null;
              var y = vertex[1] == extent[1] || vertex[1] == extent[3] ? vertex[1] : null;
              //snap to point
              if (x !== null && y !== null) {
                  this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex));
                  //snap to edge
              }
              else if (x !== null) {
                  this.pointerHandler_ = getEdgeHandler(getOpposingPoint([x, extent[1]]), getOpposingPoint([x, extent[3]]));
              }
              else if (y !== null) {
                  this.pointerHandler_ = getEdgeHandler(getOpposingPoint([extent[0], y]), getOpposingPoint([extent[2], y]));
              }
              //no snap - new bbox
          }
          else {
              vertex = map.getCoordinateFromPixelInternal(pixel);
              this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);
              this.pointerHandler_ = getPointHandler(vertex);
          }
          return true; //event handled; start downup sequence
      };
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      Extent.prototype.handleDragEvent = function (mapBrowserEvent) {
          if (this.pointerHandler_) {
              var pixelCoordinate = mapBrowserEvent.coordinate;
              this.setExtent(this.pointerHandler_(pixelCoordinate));
              this.createOrUpdatePointerFeature_(pixelCoordinate);
          }
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      Extent.prototype.handleUpEvent = function (mapBrowserEvent) {
          this.pointerHandler_ = null;
          //If bbox is zero area, set to null;
          var extent = this.getExtentInternal();
          if (!extent || getArea(extent) === 0) {
              this.setExtent(null);
          }
          return false; //Stop handling downup sequence
      };
      /**
       * Remove the interaction from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       */
      Extent.prototype.setMap = function (map) {
          this.extentOverlay_.setMap(map);
          this.vertexOverlay_.setMap(map);
          _super.prototype.setMap.call(this, map);
      };
      /**
       * Returns the current drawn extent in the view projection (or user projection if set)
       *
       * @return {import("../extent.js").Extent} Drawn extent in the view projection.
       * @api
       */
      Extent.prototype.getExtent = function () {
          return toUserExtent(this.getExtentInternal(), this.getMap().getView().getProjection());
      };
      /**
       * Returns the current drawn extent in the view projection
       *
       * @return {import("../extent.js").Extent} Drawn extent in the view projection.
       * @api
       */
      Extent.prototype.getExtentInternal = function () {
          return this.extent_;
      };
      /**
       * Manually sets the drawn extent, using the view projection.
       *
       * @param {import("../extent.js").Extent} extent Extent
       * @api
       */
      Extent.prototype.setExtent = function (extent) {
          //Null extent means no bbox
          this.extent_ = extent ? extent : null;
          this.createOrUpdateExtentFeature_(extent);
          this.dispatchEvent(new ExtentEvent(this.extent_));
      };
      return Extent;
  }(PointerInteraction));
  /**
   * Returns the default style for the drawn bbox
   *
   * @return {import("../style/Style.js").StyleFunction} Default Extent style
   */
  function getDefaultExtentStyleFunction() {
      var style = createEditingStyle();
      return function (feature, resolution) {
          return style[GeometryType.POLYGON];
      };
  }
  /**
   * Returns the default style for the pointer
   *
   * @return {import("../style/Style.js").StyleFunction} Default pointer style
   */
  function getDefaultPointerStyleFunction() {
      var style = createEditingStyle();
      return function (feature, resolution) {
          return style[GeometryType.POINT];
      };
  }
  /**
   * @param {import("../coordinate.js").Coordinate} fixedPoint corner that will be unchanged in the new extent
   * @returns {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent} event handler
   */
  function getPointHandler(fixedPoint) {
      return function (point) {
          return boundingExtent([fixedPoint, point]);
      };
  }
  /**
   * @param {import("../coordinate.js").Coordinate} fixedP1 first corner that will be unchanged in the new extent
   * @param {import("../coordinate.js").Coordinate} fixedP2 second corner that will be unchanged in the new extent
   * @returns {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null} event handler
   */
  function getEdgeHandler(fixedP1, fixedP2) {
      if (fixedP1[0] == fixedP2[0]) {
          return function (point) {
              return boundingExtent([fixedP1, [point[0], fixedP2[1]]]);
          };
      }
      else if (fixedP1[1] == fixedP2[1]) {
          return function (point) {
              return boundingExtent([fixedP1, [fixedP2[0], point[1]]]);
          };
      }
      else {
          return null;
      }
  }
  /**
   * @param {import("../extent.js").Extent} extent extent
   * @returns {Array<Array<import("../coordinate.js").Coordinate>>} extent line segments
   */
  function getSegments(extent) {
      return [
          [
              [extent[0], extent[1]],
              [extent[0], extent[3]],
          ],
          [
              [extent[0], extent[3]],
              [extent[2], extent[3]],
          ],
          [
              [extent[2], extent[3]],
              [extent[2], extent[1]],
          ],
          [
              [extent[2], extent[1]],
              [extent[0], extent[1]],
          ],
      ];
  }

  var __extends$1h = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * The segment index assigned to a circle's center when
   * breaking up a circle into ModifySegmentDataType segments.
   * @type {number}
   */
  var CIRCLE_CENTER_INDEX = 0;
  /**
   * The segment index assigned to a circle's circumference when
   * breaking up a circle into ModifySegmentDataType segments.
   * @type {number}
   */
  var CIRCLE_CIRCUMFERENCE_INDEX = 1;
  var tempExtent = [0, 0, 0, 0];
  var tempSegment = [];
  /**
   * @enum {string}
   */
  var ModifyEventType = {
      /**
       * Triggered upon feature modification start
       * @event ModifyEvent#modifystart
       * @api
       */
      MODIFYSTART: 'modifystart',
      /**
       * Triggered upon feature modification end
       * @event ModifyEvent#modifyend
       * @api
       */
      MODIFYEND: 'modifyend',
  };
  /**
   * @typedef {Object} SegmentData
   * @property {Array<number>} [depth]
   * @property {Feature} feature
   * @property {import("../geom/SimpleGeometry.js").default} geometry
   * @property {number} [index]
   * @property {Array<import("../extent.js").Extent>} segment
   * @property {Array<SegmentData>} [featureSegments]
   */
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event will be considered to add or move a
   * vertex to the sketch. Default is
   * {@link module:ol/events/condition~primaryAction}.
   * @property {import("../events/condition.js").Condition} [deleteCondition] A function
   * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. By default,
   * {@link module:ol/events/condition~singleClick} with
   * {@link module:ol/events/condition~altKeyOnly} results in a vertex deletion.
   * @property {import("../events/condition.js").Condition} [insertVertexCondition] A
   * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
   * returns a boolean to indicate whether a new vertex should be added to the sketch
   * features. Default is {@link module:ol/events/condition~always}.
   * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
   * pointer close enough to a segment or vertex for editing.
   * @property {import("../style/Style.js").StyleLike} [style]
   * Style used for the features being modified. By default the default edit
   * style is used (see {@link module:ol/style}).
   * @property {VectorSource} [source] The vector source with
   * features to modify.  If a vector source is not provided, a feature collection
   * must be provided with the features option.
   * @property {Collection<Feature>} [features]
   * The features the interaction works on.  If a feature collection is not
   * provided, a vector source must be provided with the source option.
   * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
   * overlay.
   */
  /**
   * @classdesc
   * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are
   * instances of this type.
   */
  var ModifyEvent = /** @class */ (function (_super) {
      __extends$1h(ModifyEvent, _super);
      /**
       * @param {ModifyEventType} type Type.
       * @param {Collection<Feature>} features
       * The features modified.
       * @param {import("../MapBrowserEvent.js").default} MapBrowserEvent
       * Associated {@link module:ol/MapBrowserEvent}.
       */
      function ModifyEvent(type, features, MapBrowserEvent) {
          var _this = _super.call(this, type) || this;
          /**
           * The features being modified.
           * @type {Collection<Feature>}
           * @api
           */
          _this.features = features;
          /**
           * Associated {@link module:ol/MapBrowserEvent}.
           * @type {import("../MapBrowserEvent.js").default}
           * @api
           */
          _this.mapBrowserEvent = MapBrowserEvent;
          return _this;
      }
      return ModifyEvent;
  }(BaseEvent));
  /**
   * @classdesc
   * Interaction for modifying feature geometries.  To modify features that have
   * been added to an existing source, construct the modify interaction with the
   * `source` option.  If you want to modify features in a collection (for example,
   * the collection used by a select interaction), construct the interaction with
   * the `features` option.  The interaction must be constructed with either a
   * `source` or `features` option.
   *
   * By default, the interaction will allow deletion of vertices when the `alt`
   * key is pressed.  To configure the interaction with a different condition
   * for deletion, use the `deleteCondition` option.
   * @fires ModifyEvent
   * @api
   */
  var Modify = /** @class */ (function (_super) {
      __extends$1h(Modify, _super);
      /**
       * @param {Options} options Options.
       */
      function Modify(options) {
          var _this = _super.call(this, /** @type {import("./Pointer.js").Options} */ (options)) || this;
          /** @private */
          _this.boundHandleFeatureChange_ = _this.handleFeatureChange_.bind(_this);
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.condition ? options.condition : primaryAction;
          /**
           * @private
           * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
           * @return {boolean} Combined condition result.
           */
          _this.defaultDeleteCondition_ = function (mapBrowserEvent) {
              return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);
          };
          /**
           * @type {import("../events/condition.js").Condition}
           * @private
           */
          _this.deleteCondition_ = options.deleteCondition
              ? options.deleteCondition
              : _this.defaultDeleteCondition_;
          /**
           * @type {import("../events/condition.js").Condition}
           * @private
           */
          _this.insertVertexCondition_ = options.insertVertexCondition
              ? options.insertVertexCondition
              : always;
          /**
           * Editing vertex.
           * @type {Feature}
           * @private
           */
          _this.vertexFeature_ = null;
          /**
           * Segments intersecting {@link this.vertexFeature_} by segment uid.
           * @type {Object<string, boolean>}
           * @private
           */
          _this.vertexSegments_ = null;
          /**
           * @type {import("../pixel.js").Pixel}
           * @private
           */
          _this.lastPixel_ = [0, 0];
          /**
           * Tracks if the next `singleclick` event should be ignored to prevent
           * accidental deletion right after vertex creation.
           * @type {boolean}
           * @private
           */
          _this.ignoreNextSingleClick_ = false;
          /**
           * @type {boolean}
           * @private
           */
          _this.modified_ = false;
          /**
           * Segment RTree for each layer
           * @type {RBush<SegmentData>}
           * @private
           */
          _this.rBush_ = new RBush();
          /**
           * @type {number}
           * @private
           */
          _this.pixelTolerance_ =
              options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
          /**
           * @type {boolean}
           * @private
           */
          _this.snappedToVertex_ = false;
          /**
           * Indicate whether the interaction is currently changing a feature's
           * coordinates.
           * @type {boolean}
           * @private
           */
          _this.changingFeature_ = false;
          /**
           * @type {Array}
           * @private
           */
          _this.dragSegments_ = [];
          /**
           * Draw overlay where sketch features are drawn.
           * @type {VectorLayer}
           * @private
           */
          _this.overlay_ = new VectorLayer({
              source: new VectorSource({
                  useSpatialIndex: false,
                  wrapX: !!options.wrapX,
              }),
              style: options.style ? options.style : getDefaultStyleFunction$1(),
              updateWhileAnimating: true,
              updateWhileInteracting: true,
          });
          /**
           * @const
           * @private
           * @type {!Object<string, function(Feature, import("../geom/Geometry.js").default): void>}
           */
          _this.SEGMENT_WRITERS_ = {
              'Point': _this.writePointGeometry_.bind(_this),
              'LineString': _this.writeLineStringGeometry_.bind(_this),
              'LinearRing': _this.writeLineStringGeometry_.bind(_this),
              'Polygon': _this.writePolygonGeometry_.bind(_this),
              'MultiPoint': _this.writeMultiPointGeometry_.bind(_this),
              'MultiLineString': _this.writeMultiLineStringGeometry_.bind(_this),
              'MultiPolygon': _this.writeMultiPolygonGeometry_.bind(_this),
              'Circle': _this.writeCircleGeometry_.bind(_this),
              'GeometryCollection': _this.writeGeometryCollectionGeometry_.bind(_this),
          };
          /**
           * @type {VectorSource}
           * @private
           */
          _this.source_ = null;
          var features;
          if (options.source) {
              _this.source_ = options.source;
              features = new Collection(_this.source_.getFeatures());
              _this.source_.addEventListener(VectorEventType.ADDFEATURE, _this.handleSourceAdd_.bind(_this));
              _this.source_.addEventListener(VectorEventType.REMOVEFEATURE, _this.handleSourceRemove_.bind(_this));
          }
          else {
              features = options.features;
          }
          if (!features) {
              throw new Error('The modify interaction requires features or a source');
          }
          /**
           * @type {Collection<Feature>}
           * @private
           */
          _this.features_ = features;
          _this.features_.forEach(_this.addFeature_.bind(_this));
          _this.features_.addEventListener(CollectionEventType.ADD, _this.handleFeatureAdd_.bind(_this));
          _this.features_.addEventListener(CollectionEventType.REMOVE, _this.handleFeatureRemove_.bind(_this));
          /**
           * @type {import("../MapBrowserEvent.js").default}
           * @private
           */
          _this.lastPointerEvent_ = null;
          return _this;
      }
      /**
       * @param {Feature} feature Feature.
       * @private
       */
      Modify.prototype.addFeature_ = function (feature) {
          var geometry = feature.getGeometry();
          if (geometry) {
              var writer = this.SEGMENT_WRITERS_[geometry.getType()];
              if (writer) {
                  writer(feature, geometry);
              }
          }
          var map = this.getMap();
          if (map && map.isRendered() && this.getActive()) {
              this.handlePointerAtPixel_(this.lastPixel_, map);
          }
          feature.addEventListener(EventType.CHANGE, this.boundHandleFeatureChange_);
      };
      /**
       * @param {import("../MapBrowserEvent.js").default} evt Map browser event
       * @private
       */
      Modify.prototype.willModifyFeatures_ = function (evt) {
          if (!this.modified_) {
              this.modified_ = true;
              this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART, this.features_, evt));
          }
      };
      /**
       * @param {Feature} feature Feature.
       * @private
       */
      Modify.prototype.removeFeature_ = function (feature) {
          this.removeFeatureSegmentData_(feature);
          // Remove the vertex feature if the collection of canditate features is empty.
          if (this.vertexFeature_ && this.features_.getLength() === 0) {
              this.overlay_.getSource().removeFeature(this.vertexFeature_);
              this.vertexFeature_ = null;
          }
          feature.removeEventListener(EventType.CHANGE, this.boundHandleFeatureChange_);
      };
      /**
       * @param {Feature} feature Feature.
       * @private
       */
      Modify.prototype.removeFeatureSegmentData_ = function (feature) {
          var rBush = this.rBush_;
          /** @type {Array<SegmentData>} */
          var nodesToRemove = [];
          rBush.forEach(
          /**
           * @param {SegmentData} node RTree node.
           */
          function (node) {
              if (feature === node.feature) {
                  nodesToRemove.push(node);
              }
          });
          for (var i = nodesToRemove.length - 1; i >= 0; --i) {
              var nodeToRemove = nodesToRemove[i];
              for (var j = this.dragSegments_.length - 1; j >= 0; --j) {
                  if (this.dragSegments_[j][0] === nodeToRemove) {
                      this.dragSegments_.splice(j, 1);
                  }
              }
              rBush.remove(nodeToRemove);
          }
      };
      /**
       * Activate or deactivate the interaction.
       * @param {boolean} active Active.
       * @observable
       * @api
       */
      Modify.prototype.setActive = function (active) {
          if (this.vertexFeature_ && !active) {
              this.overlay_.getSource().removeFeature(this.vertexFeature_);
              this.vertexFeature_ = null;
          }
          _super.prototype.setActive.call(this, active);
      };
      /**
       * Remove the interaction from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       */
      Modify.prototype.setMap = function (map) {
          this.overlay_.setMap(map);
          _super.prototype.setMap.call(this, map);
      };
      /**
       * Get the overlay layer that this interaction renders sketch features to.
       * @return {VectorLayer} Overlay layer.
       * @api
       */
      Modify.prototype.getOverlay = function () {
          return this.overlay_;
      };
      /**
       * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
       * @private
       */
      Modify.prototype.handleSourceAdd_ = function (event) {
          if (event.feature) {
              this.features_.push(event.feature);
          }
      };
      /**
       * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
       * @private
       */
      Modify.prototype.handleSourceRemove_ = function (event) {
          if (event.feature) {
              this.features_.remove(event.feature);
          }
      };
      /**
       * @param {import("../Collection.js").CollectionEvent} evt Event.
       * @private
       */
      Modify.prototype.handleFeatureAdd_ = function (evt) {
          this.addFeature_(/** @type {Feature} */ (evt.element));
      };
      /**
       * @param {import("../events/Event.js").default} evt Event.
       * @private
       */
      Modify.prototype.handleFeatureChange_ = function (evt) {
          if (!this.changingFeature_) {
              var feature = /** @type {Feature} */ (evt.target);
              this.removeFeature_(feature);
              this.addFeature_(feature);
          }
      };
      /**
       * @param {import("../Collection.js").CollectionEvent} evt Event.
       * @private
       */
      Modify.prototype.handleFeatureRemove_ = function (evt) {
          var feature = /** @type {Feature} */ (evt.element);
          this.removeFeature_(feature);
      };
      /**
       * @param {Feature} feature Feature
       * @param {Point} geometry Geometry.
       * @private
       */
      Modify.prototype.writePointGeometry_ = function (feature, geometry) {
          var coordinates = geometry.getCoordinates();
          /** @type {SegmentData} */
          var segmentData = {
              feature: feature,
              geometry: geometry,
              segment: [coordinates, coordinates],
          };
          this.rBush_.insert(geometry.getExtent(), segmentData);
      };
      /**
       * @param {Feature} feature Feature
       * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
       * @private
       */
      Modify.prototype.writeMultiPointGeometry_ = function (feature, geometry) {
          var points = geometry.getCoordinates();
          for (var i = 0, ii = points.length; i < ii; ++i) {
              var coordinates = points[i];
              /** @type {SegmentData} */
              var segmentData = {
                  feature: feature,
                  geometry: geometry,
                  depth: [i],
                  index: i,
                  segment: [coordinates, coordinates],
              };
              this.rBush_.insert(geometry.getExtent(), segmentData);
          }
      };
      /**
       * @param {Feature} feature Feature
       * @param {import("../geom/LineString.js").default} geometry Geometry.
       * @private
       */
      Modify.prototype.writeLineStringGeometry_ = function (feature, geometry) {
          var coordinates = geometry.getCoordinates();
          for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
              var segment = coordinates.slice(i, i + 2);
              /** @type {SegmentData} */
              var segmentData = {
                  feature: feature,
                  geometry: geometry,
                  index: i,
                  segment: segment,
              };
              this.rBush_.insert(boundingExtent(segment), segmentData);
          }
      };
      /**
       * @param {Feature} feature Feature
       * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
       * @private
       */
      Modify.prototype.writeMultiLineStringGeometry_ = function (feature, geometry) {
          var lines = geometry.getCoordinates();
          for (var j = 0, jj = lines.length; j < jj; ++j) {
              var coordinates = lines[j];
              for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                  var segment = coordinates.slice(i, i + 2);
                  /** @type {SegmentData} */
                  var segmentData = {
                      feature: feature,
                      geometry: geometry,
                      depth: [j],
                      index: i,
                      segment: segment,
                  };
                  this.rBush_.insert(boundingExtent(segment), segmentData);
              }
          }
      };
      /**
       * @param {Feature} feature Feature
       * @param {import("../geom/Polygon.js").default} geometry Geometry.
       * @private
       */
      Modify.prototype.writePolygonGeometry_ = function (feature, geometry) {
          var rings = geometry.getCoordinates();
          for (var j = 0, jj = rings.length; j < jj; ++j) {
              var coordinates = rings[j];
              for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                  var segment = coordinates.slice(i, i + 2);
                  /** @type {SegmentData} */
                  var segmentData = {
                      feature: feature,
                      geometry: geometry,
                      depth: [j],
                      index: i,
                      segment: segment,
                  };
                  this.rBush_.insert(boundingExtent(segment), segmentData);
              }
          }
      };
      /**
       * @param {Feature} feature Feature
       * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
       * @private
       */
      Modify.prototype.writeMultiPolygonGeometry_ = function (feature, geometry) {
          var polygons = geometry.getCoordinates();
          for (var k = 0, kk = polygons.length; k < kk; ++k) {
              var rings = polygons[k];
              for (var j = 0, jj = rings.length; j < jj; ++j) {
                  var coordinates = rings[j];
                  for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                      var segment = coordinates.slice(i, i + 2);
                      /** @type {SegmentData} */
                      var segmentData = {
                          feature: feature,
                          geometry: geometry,
                          depth: [j, k],
                          index: i,
                          segment: segment,
                      };
                      this.rBush_.insert(boundingExtent(segment), segmentData);
                  }
              }
          }
      };
      /**
       * We convert a circle into two segments.  The segment at index
       * {@link CIRCLE_CENTER_INDEX} is the
       * circle's center (a point).  The segment at index
       * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
       * the circumference, and is not a line segment.
       *
       * @param {Feature} feature Feature.
       * @param {import("../geom/Circle.js").default} geometry Geometry.
       * @private
       */
      Modify.prototype.writeCircleGeometry_ = function (feature, geometry) {
          var coordinates = geometry.getCenter();
          /** @type {SegmentData} */
          var centerSegmentData = {
              feature: feature,
              geometry: geometry,
              index: CIRCLE_CENTER_INDEX,
              segment: [coordinates, coordinates],
          };
          /** @type {SegmentData} */
          var circumferenceSegmentData = {
              feature: feature,
              geometry: geometry,
              index: CIRCLE_CIRCUMFERENCE_INDEX,
              segment: [coordinates, coordinates],
          };
          var featureSegments = [centerSegmentData, circumferenceSegmentData];
          centerSegmentData.featureSegments = featureSegments;
          circumferenceSegmentData.featureSegments = featureSegments;
          this.rBush_.insert(createOrUpdateFromCoordinate(coordinates), centerSegmentData);
          var circleGeometry = /** @type {import("../geom/Geometry.js").default} */ (geometry);
          var userProjection = getUserProjection();
          if (userProjection && this.getMap()) {
              var projection = this.getMap().getView().getProjection();
              circleGeometry = circleGeometry
                  .clone()
                  .transform(userProjection, projection);
              circleGeometry = fromCircle(
              /** @type {import("../geom/Circle.js").default} */ (circleGeometry)).transform(projection, userProjection);
          }
          this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);
      };
      /**
       * @param {Feature} feature Feature
       * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
       * @private
       */
      Modify.prototype.writeGeometryCollectionGeometry_ = function (feature, geometry) {
          var geometries = geometry.getGeometriesArray();
          for (var i = 0; i < geometries.length; ++i) {
              var geometry_1 = geometries[i];
              var writer = this.SEGMENT_WRITERS_[geometry_1.getType()];
              writer(feature, geometry_1);
          }
      };
      /**
       * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
       * @return {Feature} Vertex feature.
       * @private
       */
      Modify.prototype.createOrUpdateVertexFeature_ = function (coordinates) {
          var vertexFeature = this.vertexFeature_;
          if (!vertexFeature) {
              vertexFeature = new Feature(new Point$1(coordinates));
              this.vertexFeature_ = vertexFeature;
              this.overlay_.getSource().addFeature(vertexFeature);
          }
          else {
              var geometry = vertexFeature.getGeometry();
              geometry.setCoordinates(coordinates);
          }
          return vertexFeature;
      };
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} and may modify the geometry.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       */
      Modify.prototype.handleEvent = function (mapBrowserEvent) {
          if (!mapBrowserEvent.originalEvent) {
              return true;
          }
          this.lastPointerEvent_ = mapBrowserEvent;
          var handled;
          if (!mapBrowserEvent.map.getView().getInteracting() &&
              mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&
              !this.handlingDownUpSequence) {
              this.handlePointerMove_(mapBrowserEvent);
          }
          if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
              if (mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK ||
                  !this.ignoreNextSingleClick_) {
                  handled = this.removePoint();
              }
              else {
                  handled = true;
              }
          }
          if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {
              this.ignoreNextSingleClick_ = false;
          }
          return _super.prototype.handleEvent.call(this, mapBrowserEvent) && !handled;
      };
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} evt Event.
       */
      Modify.prototype.handleDragEvent = function (evt) {
          this.ignoreNextSingleClick_ = false;
          this.willModifyFeatures_(evt);
          var vertex = evt.coordinate;
          for (var i = 0, ii = this.dragSegments_.length; i < ii; ++i) {
              var dragSegment = this.dragSegments_[i];
              var segmentData = dragSegment[0];
              var depth = segmentData.depth;
              var geometry = segmentData.geometry;
              var coordinates = void 0;
              var segment = segmentData.segment;
              var index = dragSegment[1];
              while (vertex.length < geometry.getStride()) {
                  vertex.push(segment[index][vertex.length]);
              }
              switch (geometry.getType()) {
                  case GeometryType.POINT:
                      coordinates = vertex;
                      segment[0] = vertex;
                      segment[1] = vertex;
                      break;
                  case GeometryType.MULTI_POINT:
                      coordinates = geometry.getCoordinates();
                      coordinates[segmentData.index] = vertex;
                      segment[0] = vertex;
                      segment[1] = vertex;
                      break;
                  case GeometryType.LINE_STRING:
                      coordinates = geometry.getCoordinates();
                      coordinates[segmentData.index + index] = vertex;
                      segment[index] = vertex;
                      break;
                  case GeometryType.MULTI_LINE_STRING:
                      coordinates = geometry.getCoordinates();
                      coordinates[depth[0]][segmentData.index + index] = vertex;
                      segment[index] = vertex;
                      break;
                  case GeometryType.POLYGON:
                      coordinates = geometry.getCoordinates();
                      coordinates[depth[0]][segmentData.index + index] = vertex;
                      segment[index] = vertex;
                      break;
                  case GeometryType.MULTI_POLYGON:
                      coordinates = geometry.getCoordinates();
                      coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
                      segment[index] = vertex;
                      break;
                  case GeometryType.CIRCLE:
                      segment[0] = vertex;
                      segment[1] = vertex;
                      if (segmentData.index === CIRCLE_CENTER_INDEX) {
                          this.changingFeature_ = true;
                          geometry.setCenter(vertex);
                          this.changingFeature_ = false;
                      }
                      else {
                          // We're dragging the circle's circumference:
                          this.changingFeature_ = true;
                          var projection = evt.map.getView().getProjection();
                          var radius = distance$1(fromUserCoordinate(geometry.getCenter(), projection), fromUserCoordinate(vertex, projection));
                          var userProjection = getUserProjection();
                          if (userProjection) {
                              var circleGeometry = geometry
                                  .clone()
                                  .transform(userProjection, projection);
                              circleGeometry.setRadius(radius);
                              radius = circleGeometry
                                  .transform(projection, userProjection)
                                  .getRadius();
                          }
                          geometry.setRadius(radius);
                          this.changingFeature_ = false;
                      }
                      break;
                  default:
                  // pass
              }
              if (coordinates) {
                  this.setGeometryCoordinates_(geometry, coordinates);
              }
          }
          this.createOrUpdateVertexFeature_(vertex);
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} evt Event.
       * @return {boolean} If the event was consumed.
       */
      Modify.prototype.handleDownEvent = function (evt) {
          if (!this.condition_(evt)) {
              return false;
          }
          var pixelCoordinate = evt.coordinate;
          this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);
          this.dragSegments_.length = 0;
          this.modified_ = false;
          var vertexFeature = this.vertexFeature_;
          if (vertexFeature) {
              var projection = evt.map.getView().getProjection();
              var insertVertices = [];
              var vertex = vertexFeature.getGeometry().getCoordinates();
              var vertexExtent = boundingExtent([vertex]);
              var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
              var componentSegments = {};
              segmentDataMatches.sort(compareIndexes);
              for (var i = 0, ii = segmentDataMatches.length; i < ii; ++i) {
                  var segmentDataMatch = segmentDataMatches[i];
                  var segment = segmentDataMatch.segment;
                  var uid = getUid(segmentDataMatch.geometry);
                  var depth = segmentDataMatch.depth;
                  if (depth) {
                      uid += '-' + depth.join('-'); // separate feature components
                  }
                  if (!componentSegments[uid]) {
                      componentSegments[uid] = new Array(2);
                  }
                  if (segmentDataMatch.geometry.getType() === GeometryType.CIRCLE &&
                      segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                      var closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch, projection);
                      if (equals$2(closestVertex, vertex) &&
                          !componentSegments[uid][0]) {
                          this.dragSegments_.push([segmentDataMatch, 0]);
                          componentSegments[uid][0] = segmentDataMatch;
                      }
                      continue;
                  }
                  if (equals$2(segment[0], vertex) &&
                      !componentSegments[uid][0]) {
                      this.dragSegments_.push([segmentDataMatch, 0]);
                      componentSegments[uid][0] = segmentDataMatch;
                      continue;
                  }
                  if (equals$2(segment[1], vertex) &&
                      !componentSegments[uid][1]) {
                      // prevent dragging closed linestrings by the connecting node
                      if ((segmentDataMatch.geometry.getType() === GeometryType.LINE_STRING ||
                          segmentDataMatch.geometry.getType() ===
                              GeometryType.MULTI_LINE_STRING) &&
                          componentSegments[uid][0] &&
                          componentSegments[uid][0].index === 0) {
                          continue;
                      }
                      this.dragSegments_.push([segmentDataMatch, 1]);
                      componentSegments[uid][1] = segmentDataMatch;
                      continue;
                  }
                  if (getUid(segment) in this.vertexSegments_ &&
                      !componentSegments[uid][0] &&
                      !componentSegments[uid][1] &&
                      this.insertVertexCondition_(evt)) {
                      insertVertices.push([segmentDataMatch, vertex]);
                  }
              }
              if (insertVertices.length) {
                  this.willModifyFeatures_(evt);
              }
              for (var j = insertVertices.length - 1; j >= 0; --j) {
                  this.insertVertex_.apply(this, insertVertices[j]);
              }
          }
          return !!this.vertexFeature_;
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} evt Event.
       * @return {boolean} If the event was consumed.
       */
      Modify.prototype.handleUpEvent = function (evt) {
          for (var i = this.dragSegments_.length - 1; i >= 0; --i) {
              var segmentData = this.dragSegments_[i][0];
              var geometry = segmentData.geometry;
              if (geometry.getType() === GeometryType.CIRCLE) {
                  // Update a circle object in the R* bush:
                  var coordinates = geometry.getCenter();
                  var centerSegmentData = segmentData.featureSegments[0];
                  var circumferenceSegmentData = segmentData.featureSegments[1];
                  centerSegmentData.segment[0] = coordinates;
                  centerSegmentData.segment[1] = coordinates;
                  circumferenceSegmentData.segment[0] = coordinates;
                  circumferenceSegmentData.segment[1] = coordinates;
                  this.rBush_.update(createOrUpdateFromCoordinate(coordinates), centerSegmentData);
                  var circleGeometry = geometry;
                  var userProjection = getUserProjection();
                  if (userProjection) {
                      var projection = evt.map.getView().getProjection();
                      circleGeometry = circleGeometry
                          .clone()
                          .transform(userProjection, projection);
                      circleGeometry = fromCircle(circleGeometry).transform(projection, userProjection);
                  }
                  this.rBush_.update(circleGeometry.getExtent(), circumferenceSegmentData);
              }
              else {
                  this.rBush_.update(boundingExtent(segmentData.segment), segmentData);
              }
          }
          if (this.modified_) {
              this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.features_, evt));
              this.modified_ = false;
          }
          return false;
      };
      /**
       * @param {import("../MapBrowserEvent.js").default} evt Event.
       * @private
       */
      Modify.prototype.handlePointerMove_ = function (evt) {
          this.lastPixel_ = evt.pixel;
          this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);
      };
      /**
       * @param {import("../pixel.js").Pixel} pixel Pixel
       * @param {import("../PluggableMap.js").default} map Map.
       * @param {import("../coordinate.js").Coordinate=} opt_coordinate The pixel Coordinate.
       * @private
       */
      Modify.prototype.handlePointerAtPixel_ = function (pixel, map, opt_coordinate) {
          var pixelCoordinate = opt_coordinate || map.getCoordinateFromPixel(pixel);
          var projection = map.getView().getProjection();
          var sortByDistance = function (a, b) {
              return (projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) -
                  projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection));
          };
          var viewExtent = fromUserExtent(createOrUpdateFromCoordinate(pixelCoordinate, tempExtent), projection);
          var buffer$$1 = map.getView().getResolution() * this.pixelTolerance_;
          var box = toUserExtent(buffer(viewExtent, buffer$$1, tempExtent), projection);
          var rBush = this.rBush_;
          var nodes = rBush.getInExtent(box);
          if (nodes.length > 0) {
              nodes.sort(sortByDistance);
              var node = nodes[0];
              var closestSegment = node.segment;
              var vertex = closestOnSegmentData(pixelCoordinate, node, projection);
              var vertexPixel = map.getPixelFromCoordinate(vertex);
              var dist = distance$1(pixel, vertexPixel);
              if (dist <= this.pixelTolerance_) {
                  /** @type {Object<string, boolean>} */
                  var vertexSegments = {};
                  if (node.geometry.getType() === GeometryType.CIRCLE &&
                      node.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                      this.snappedToVertex_ = true;
                      this.createOrUpdateVertexFeature_(vertex);
                  }
                  else {
                      var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
                      var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
                      var squaredDist1 = squaredDistance$1(vertexPixel, pixel1);
                      var squaredDist2 = squaredDistance$1(vertexPixel, pixel2);
                      dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
                      this.snappedToVertex_ = dist <= this.pixelTolerance_;
                      if (this.snappedToVertex_) {
                          vertex =
                              squaredDist1 > squaredDist2
                                  ? closestSegment[1]
                                  : closestSegment[0];
                      }
                      this.createOrUpdateVertexFeature_(vertex);
                      for (var i = 1, ii = nodes.length; i < ii; ++i) {
                          var segment = nodes[i].segment;
                          if ((equals$2(closestSegment[0], segment[0]) &&
                              equals$2(closestSegment[1], segment[1])) ||
                              (equals$2(closestSegment[0], segment[1]) &&
                                  equals$2(closestSegment[1], segment[0]))) {
                              vertexSegments[getUid(segment)] = true;
                          }
                          else {
                              break;
                          }
                      }
                  }
                  vertexSegments[getUid(closestSegment)] = true;
                  this.vertexSegments_ = vertexSegments;
                  return;
              }
          }
          if (this.vertexFeature_) {
              this.overlay_.getSource().removeFeature(this.vertexFeature_);
              this.vertexFeature_ = null;
          }
      };
      /**
       * @param {SegmentData} segmentData Segment data.
       * @param {import("../coordinate.js").Coordinate} vertex Vertex.
       * @private
       */
      Modify.prototype.insertVertex_ = function (segmentData, vertex) {
          var segment = segmentData.segment;
          var feature = segmentData.feature;
          var geometry = segmentData.geometry;
          var depth = segmentData.depth;
          var index = segmentData.index;
          var coordinates;
          while (vertex.length < geometry.getStride()) {
              vertex.push(0);
          }
          switch (geometry.getType()) {
              case GeometryType.MULTI_LINE_STRING:
                  coordinates = geometry.getCoordinates();
                  coordinates[depth[0]].splice(index + 1, 0, vertex);
                  break;
              case GeometryType.POLYGON:
                  coordinates = geometry.getCoordinates();
                  coordinates[depth[0]].splice(index + 1, 0, vertex);
                  break;
              case GeometryType.MULTI_POLYGON:
                  coordinates = geometry.getCoordinates();
                  coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
                  break;
              case GeometryType.LINE_STRING:
                  coordinates = geometry.getCoordinates();
                  coordinates.splice(index + 1, 0, vertex);
                  break;
              default:
                  return;
          }
          this.setGeometryCoordinates_(geometry, coordinates);
          var rTree = this.rBush_;
          rTree.remove(segmentData);
          this.updateSegmentIndices_(geometry, index, depth, 1);
          /** @type {SegmentData} */
          var newSegmentData = {
              segment: [segment[0], vertex],
              feature: feature,
              geometry: geometry,
              depth: depth,
              index: index,
          };
          rTree.insert(boundingExtent(newSegmentData.segment), newSegmentData);
          this.dragSegments_.push([newSegmentData, 1]);
          /** @type {SegmentData} */
          var newSegmentData2 = {
              segment: [vertex, segment[1]],
              feature: feature,
              geometry: geometry,
              depth: depth,
              index: index + 1,
          };
          rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);
          this.dragSegments_.push([newSegmentData2, 0]);
          this.ignoreNextSingleClick_ = true;
      };
      /**
       * Removes the vertex currently being pointed.
       * @return {boolean} True when a vertex was removed.
       * @api
       */
      Modify.prototype.removePoint = function () {
          if (this.lastPointerEvent_ &&
              this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG) {
              var evt = this.lastPointerEvent_;
              this.willModifyFeatures_(evt);
              var removed = this.removeVertex_();
              this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.features_, evt));
              this.modified_ = false;
              return removed;
          }
          return false;
      };
      /**
       * Removes a vertex from all matching features.
       * @return {boolean} True when a vertex was removed.
       * @private
       */
      Modify.prototype.removeVertex_ = function () {
          var dragSegments = this.dragSegments_;
          var segmentsByFeature = {};
          var deleted = false;
          var component, coordinates, dragSegment, geometry, i, index, left;
          var newIndex, right, segmentData, uid;
          for (i = dragSegments.length - 1; i >= 0; --i) {
              dragSegment = dragSegments[i];
              segmentData = dragSegment[0];
              uid = getUid(segmentData.feature);
              if (segmentData.depth) {
                  // separate feature components
                  uid += '-' + segmentData.depth.join('-');
              }
              if (!(uid in segmentsByFeature)) {
                  segmentsByFeature[uid] = {};
              }
              if (dragSegment[1] === 0) {
                  segmentsByFeature[uid].right = segmentData;
                  segmentsByFeature[uid].index = segmentData.index;
              }
              else if (dragSegment[1] == 1) {
                  segmentsByFeature[uid].left = segmentData;
                  segmentsByFeature[uid].index = segmentData.index + 1;
              }
          }
          for (uid in segmentsByFeature) {
              right = segmentsByFeature[uid].right;
              left = segmentsByFeature[uid].left;
              index = segmentsByFeature[uid].index;
              newIndex = index - 1;
              if (left !== undefined) {
                  segmentData = left;
              }
              else {
                  segmentData = right;
              }
              if (newIndex < 0) {
                  newIndex = 0;
              }
              geometry = segmentData.geometry;
              coordinates = geometry.getCoordinates();
              component = coordinates;
              deleted = false;
              switch (geometry.getType()) {
                  case GeometryType.MULTI_LINE_STRING:
                      if (coordinates[segmentData.depth[0]].length > 2) {
                          coordinates[segmentData.depth[0]].splice(index, 1);
                          deleted = true;
                      }
                      break;
                  case GeometryType.LINE_STRING:
                      if (coordinates.length > 2) {
                          coordinates.splice(index, 1);
                          deleted = true;
                      }
                      break;
                  case GeometryType.MULTI_POLYGON:
                      component = component[segmentData.depth[1]];
                  /* falls through */
                  case GeometryType.POLYGON:
                      component = component[segmentData.depth[0]];
                      if (component.length > 4) {
                          if (index == component.length - 1) {
                              index = 0;
                          }
                          component.splice(index, 1);
                          deleted = true;
                          if (index === 0) {
                              // close the ring again
                              component.pop();
                              component.push(component[0]);
                              newIndex = component.length - 1;
                          }
                      }
                      break;
                  default:
                  // pass
              }
              if (deleted) {
                  this.setGeometryCoordinates_(geometry, coordinates);
                  var segments = [];
                  if (left !== undefined) {
                      this.rBush_.remove(left);
                      segments.push(left.segment[0]);
                  }
                  if (right !== undefined) {
                      this.rBush_.remove(right);
                      segments.push(right.segment[1]);
                  }
                  if (left !== undefined && right !== undefined) {
                      /** @type {SegmentData} */
                      var newSegmentData = {
                          depth: segmentData.depth,
                          feature: segmentData.feature,
                          geometry: segmentData.geometry,
                          index: newIndex,
                          segment: segments,
                      };
                      this.rBush_.insert(boundingExtent(newSegmentData.segment), newSegmentData);
                  }
                  this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);
                  if (this.vertexFeature_) {
                      this.overlay_.getSource().removeFeature(this.vertexFeature_);
                      this.vertexFeature_ = null;
                  }
                  dragSegments.length = 0;
              }
          }
          return deleted;
      };
      /**
       * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {Array} coordinates Coordinates.
       * @private
       */
      Modify.prototype.setGeometryCoordinates_ = function (geometry, coordinates) {
          this.changingFeature_ = true;
          geometry.setCoordinates(coordinates);
          this.changingFeature_ = false;
      };
      /**
       * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {number} index Index.
       * @param {Array<number>|undefined} depth Depth.
       * @param {number} delta Delta (1 or -1).
       * @private
       */
      Modify.prototype.updateSegmentIndices_ = function (geometry, index, depth, delta) {
          this.rBush_.forEachInExtent(geometry.getExtent(), function (segmentDataMatch) {
              if (segmentDataMatch.geometry === geometry &&
                  (depth === undefined ||
                      segmentDataMatch.depth === undefined ||
                      equals(segmentDataMatch.depth, depth)) &&
                  segmentDataMatch.index > index) {
                  segmentDataMatch.index += delta;
              }
          });
      };
      return Modify;
  }(PointerInteraction));
  /**
   * @param {SegmentData} a The first segment data.
   * @param {SegmentData} b The second segment data.
   * @return {number} The difference in indexes.
   */
  function compareIndexes(a, b) {
      return a.index - b.index;
  }
  /**
   * Returns the distance from a point to a line segment.
   *
   * @param {import("../coordinate.js").Coordinate} pointCoordinates The coordinates of the point from
   *        which to calculate the distance.
   * @param {SegmentData} segmentData The object describing the line
   *        segment we are calculating the distance to.
   * @param {import("../proj/Projection.js").default} projection The view projection.
   * @return {number} The square of the distance between a point and a line segment.
   */
  function projectedDistanceToSegmentDataSquared(pointCoordinates, segmentData, projection) {
      var geometry = segmentData.geometry;
      if (geometry.getType() === GeometryType.CIRCLE) {
          var circleGeometry = /** @type {import("../geom/Circle.js").default} */ (geometry);
          if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
              var userProjection = getUserProjection();
              if (userProjection) {
                  circleGeometry = /** @type {import("../geom/Circle.js").default} */ (circleGeometry
                      .clone()
                      .transform(userProjection, projection));
              }
              var distanceToCenterSquared = squaredDistance$1(circleGeometry.getCenter(), fromUserCoordinate(pointCoordinates, projection));
              var distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
              return distanceToCircumference * distanceToCircumference;
          }
      }
      var coordinate = fromUserCoordinate(pointCoordinates, projection);
      tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);
      tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);
      return squaredDistanceToSegment(coordinate, tempSegment);
  }
  /**
   * Returns the point closest to a given line segment.
   *
   * @param {import("../coordinate.js").Coordinate} pointCoordinates The point to which a closest point
   *        should be found.
   * @param {SegmentData} segmentData The object describing the line
   *        segment which should contain the closest point.
   * @param {import("../proj/Projection.js").default} projection The view projection.
   * @return {import("../coordinate.js").Coordinate} The point closest to the specified line segment.
   */
  function closestOnSegmentData(pointCoordinates, segmentData, projection) {
      var geometry = segmentData.geometry;
      if (geometry.getType() === GeometryType.CIRCLE &&
          segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
          var circleGeometry = /** @type {import("../geom/Circle.js").default} */ (geometry);
          var userProjection = getUserProjection();
          if (userProjection) {
              circleGeometry = /** @type {import("../geom/Circle.js").default} */ (circleGeometry
                  .clone()
                  .transform(userProjection, projection));
          }
          return toUserCoordinate(circleGeometry.getClosestPoint(fromUserCoordinate(pointCoordinates, projection)), projection);
      }
      var coordinate = fromUserCoordinate(pointCoordinates, projection);
      tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);
      tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);
      return toUserCoordinate(closestOnSegment(coordinate, tempSegment), projection);
  }
  /**
   * @return {import("../style/Style.js").StyleFunction} Styles.
   */
  function getDefaultStyleFunction$1() {
      var style = createEditingStyle();
      return function (feature, resolution) {
          return style[GeometryType.POINT];
      };
  }

  var __extends$1i = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @enum {string}
   */
  var SelectEventType = {
      /**
       * Triggered when feature(s) has been (de)selected.
       * @event SelectEvent#select
       * @api
       */
      SELECT: 'select',
  };
  /**
   * A function that takes an {@link module:ol/Feature} or
   * {@link module:ol/render/Feature} and an
   * {@link module:ol/layer/Layer} and returns `true` if the feature may be
   * selected or `false` otherwise.
   * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default):boolean} FilterFunction
   */
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [addCondition] A function
   * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled.
   * By default, this is {@link module:ol/events/condition~never}. Use this if you
   * want to use different events for add and remove instead of `toggle`.
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. This is the event
   * for the selected features as a whole. By default, this is
   * {@link module:ol/events/condition~singleClick}. Clicking on a feature selects that
   * feature and removes any that were in the selection. Clicking outside any
   * feature removes all from the selection.
   * See `toggle`, `add`, `remove` options for adding/removing extra features to/
   * from the selection.
   * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default): boolean} [layers]
   * A list of layers from which features should be selected. Alternatively, a
   * filter function can be provided. The function will be called for each layer
   * in the map and should return `true` for layers that you want to be
   * selectable. If the option is absent, all visible layers will be considered
   * selectable.
   * @property {import("../style/Style.js").StyleLike|null} [style]
   * Style for the selected features. By default the default edit style is used
   * (see {@link module:ol/style}). Set to `null` if this interaction should not apply
   * any style changes for selected features.
   * If set to a falsey value, the selected feature's style will not change.
   * @property {import("../events/condition.js").Condition} [removeCondition] A function
   * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled.
   * By default, this is {@link module:ol/events/condition~never}. Use this if you
   * want to use different events for add and remove instead of `toggle`.
   * @property {import("../events/condition.js").Condition} [toggleCondition] A function
   * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. This is in addition
   * to the `condition` event. By default,
   * {@link module:ol/events/condition~shiftKeyOnly}, i.e. pressing `shift` as
   * well as the `condition` event, adds that feature to the current selection if
   * it is not currently selected, and removes it if it is. See `add` and `remove`
   * if you want to use different events instead of a toggle.
   * @property {boolean} [multi=false] A boolean that determines if the default
   * behaviour should select only single features or all (overlapping) features at
   * the clicked map position. The default of `false` means single select.
   * @property {import("../Collection.js").default<import("../Feature.js").default>} [features]
   * Collection where the interaction will place selected features. Optional. If
   * not set the interaction will create a collection. In any case the collection
   * used by the interaction is returned by
   * {@link module:ol/interaction/Select~Select#getFeatures}.
   * @property {FilterFunction} [filter] A function
   * that takes an {@link module:ol/Feature} and an
   * {@link module:ol/layer/Layer} and returns `true` if the feature may be
   * selected or `false` otherwise.
   * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside
   * the radius around the given position will be checked for features.
   */
  /**
   * @classdesc
   * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of
   * this type.
   */
  var SelectEvent = /** @class */ (function (_super) {
      __extends$1i(SelectEvent, _super);
      /**
       * @param {SelectEventType} type The event type.
       * @param {Array<import("../Feature.js").default>} selected Selected features.
       * @param {Array<import("../Feature.js").default>} deselected Deselected features.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
       *     {@link module:ol/MapBrowserEvent}.
       */
      function SelectEvent(type, selected, deselected, mapBrowserEvent) {
          var _this = _super.call(this, type) || this;
          /**
           * Selected features array.
           * @type {Array<import("../Feature.js").default>}
           * @api
           */
          _this.selected = selected;
          /**
           * Deselected features array.
           * @type {Array<import("../Feature.js").default>}
           * @api
           */
          _this.deselected = deselected;
          /**
           * Associated {@link module:ol/MapBrowserEvent}.
           * @type {import("../MapBrowserEvent.js").default}
           * @api
           */
          _this.mapBrowserEvent = mapBrowserEvent;
          return _this;
      }
      return SelectEvent;
  }(BaseEvent));
  /**
   * Original feature styles to reset to when features are no longer selected.
   * @type {Object.<number, import("../style/Style.js").default|Array.<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction>}
   */
  var originalFeatureStyles = {};
  /**
   * @classdesc
   * Interaction for selecting vector features. By default, selected features are
   * styled differently, so this interaction can be used for visual highlighting,
   * as well as selecting features for other actions, such as modification or
   * output. There are three ways of controlling which features are selected:
   * using the browser event as defined by the `condition` and optionally the
   * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
   * further feature filter using the `filter` option.
   *
   * Selected features are added to an internal unmanaged layer.
   *
   * @fires SelectEvent
   * @api
   */
  var Select = /** @class */ (function (_super) {
      __extends$1i(Select, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function Select(opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @private
           */
          _this.boundAddFeature_ = _this.addFeature_.bind(_this);
          /**
           * @private
           */
          _this.boundRemoveFeature_ = _this.removeFeature_.bind(_this);
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.condition ? options.condition : singleClick;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.addCondition_ = options.addCondition ? options.addCondition : never;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.removeCondition_ = options.removeCondition
              ? options.removeCondition
              : never;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.toggleCondition_ = options.toggleCondition
              ? options.toggleCondition
              : shiftKeyOnly;
          /**
           * @private
           * @type {boolean}
           */
          _this.multi_ = options.multi ? options.multi : false;
          /**
           * @private
           * @type {FilterFunction}
           */
          _this.filter_ = options.filter ? options.filter : TRUE;
          /**
           * @private
           * @type {number}
           */
          _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
          /**
           * @private
           * @type {import("../style/Style.js").default|Array.<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction|null}
           */
          _this.style_ =
              options.style !== undefined ? options.style : getDefaultStyleFunction$2();
          /**
           * @private
           * @type {import("../Collection.js").default}
           */
          _this.features_ = options.features || new Collection();
          /** @type {function(import("../layer/Layer.js").default): boolean} */
          var layerFilter;
          if (options.layers) {
              if (typeof options.layers === 'function') {
                  layerFilter = options.layers;
              }
              else {
                  var layers_1 = options.layers;
                  layerFilter = function (layer) {
                      return includes(layers_1, layer);
                  };
              }
          }
          else {
              layerFilter = TRUE;
          }
          /**
           * @private
           * @type {function(import("../layer/Layer.js").default): boolean}
           */
          _this.layerFilter_ = layerFilter;
          /**
           * An association between selected feature (key)
           * and layer (value)
           * @private
           * @type {Object<string, import("../layer/Layer.js").default>}
           */
          _this.featureLayerAssociation_ = {};
          return _this;
      }
      /**
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {import("../layer/Layer.js").default} layer Layer.
       * @private
       */
      Select.prototype.addFeatureLayerAssociation_ = function (feature, layer) {
          this.featureLayerAssociation_[getUid(feature)] = layer;
      };
      /**
       * Get the selected features.
       * @return {import("../Collection.js").default<import("../Feature.js").default>} Features collection.
       * @api
       */
      Select.prototype.getFeatures = function () {
          return this.features_;
      };
      /**
       * Returns the Hit-detection tolerance.
       * @returns {number} Hit tolerance in pixels.
       * @api
       */
      Select.prototype.getHitTolerance = function () {
          return this.hitTolerance_;
      };
      /**
       * Returns the associated {@link module:ol/layer/Vector~Vector vectorlayer} of
       * the (last) selected feature. Note that this will not work with any
       * programmatic method like pushing features to
       * {@link module:ol/interaction/Select~Select#getFeatures collection}.
       * @param {import("../Feature.js").FeatureLike} feature Feature
       * @return {import('../layer/Vector.js').default} Layer.
       * @api
       */
      Select.prototype.getLayer = function (feature) {
          return /** @type {import('../layer/Vector.js').default} */ (this
              .featureLayerAssociation_[getUid(feature)]);
      };
      /**
       * Hit-detection tolerance. Pixels inside the radius around the given position
       * will be checked for features.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @api
       */
      Select.prototype.setHitTolerance = function (hitTolerance) {
          this.hitTolerance_ = hitTolerance;
      };
      /**
       * Remove the interaction from its current map, if any,  and attach it to a new
       * map, if any. Pass `null` to just remove the interaction from the current map.
       * @param {import("../PluggableMap.js").default} map Map.
       * @api
       */
      Select.prototype.setMap = function (map) {
          var currentMap = this.getMap();
          if (currentMap && this.style_) {
              this.features_.forEach(this.restorePreviousStyle_.bind(this));
          }
          _super.prototype.setMap.call(this, map);
          if (map) {
              this.features_.addEventListener(CollectionEventType.ADD, this.boundAddFeature_);
              this.features_.addEventListener(CollectionEventType.REMOVE, this.boundRemoveFeature_);
              if (this.style_) {
                  this.features_.forEach(this.applySelectedStyle_.bind(this));
              }
          }
          else {
              this.features_.removeEventListener(CollectionEventType.ADD, this.boundAddFeature_);
              this.features_.removeEventListener(CollectionEventType.REMOVE, this.boundRemoveFeature_);
          }
      };
      /**
       * @param {import("../Collection.js").CollectionEvent} evt Event.
       * @private
       */
      Select.prototype.addFeature_ = function (evt) {
          var feature = evt.element;
          if (this.style_) {
              this.applySelectedStyle_(feature);
          }
      };
      /**
       * @param {import("../Collection.js").CollectionEvent} evt Event.
       * @private
       */
      Select.prototype.removeFeature_ = function (evt) {
          var feature = evt.element;
          if (this.style_) {
              this.restorePreviousStyle_(feature);
          }
      };
      /**
       * @return {import("../style/Style.js").StyleLike|null} Select style.
       */
      Select.prototype.getStyle = function () {
          return this.style_;
      };
      /**
       * @param {import("../Feature.js").default} feature Feature
       * @private
       */
      Select.prototype.applySelectedStyle_ = function (feature) {
          var key = getUid(feature);
          if (!(key in originalFeatureStyles)) {
              originalFeatureStyles[key] = feature.getStyle();
          }
          feature.setStyle(this.style_);
      };
      /**
       * @param {import("../Feature.js").default} feature Feature
       * @private
       */
      Select.prototype.restorePreviousStyle_ = function (feature) {
          var key = getUid(feature);
          var selectInteractions = /** @type {Array<Select>} */ (this.getMap()
              .getInteractions()
              .getArray()
              .filter(function (interaction) {
              return (interaction instanceof Select &&
                  interaction.getStyle() &&
                  interaction.getFeatures().getArray().indexOf(feature) !== -1);
          }));
          if (selectInteractions.length > 0) {
              feature.setStyle(selectInteractions[selectInteractions.length - 1].getStyle());
          }
          else {
              feature.setStyle(originalFeatureStyles[key]);
              delete originalFeatureStyles[key];
          }
      };
      /**
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @private
       */
      Select.prototype.removeFeatureLayerAssociation_ = function (feature) {
          delete this.featureLayerAssociation_[getUid(feature)];
      };
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} and may change the
       * selected state of features.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @this {Select}
       */
      Select.prototype.handleEvent = function (mapBrowserEvent) {
          if (!this.condition_(mapBrowserEvent)) {
              return true;
          }
          var add = this.addCondition_(mapBrowserEvent);
          var remove$$1 = this.removeCondition_(mapBrowserEvent);
          var toggle = this.toggleCondition_(mapBrowserEvent);
          var set = !add && !remove$$1 && !toggle;
          var map = mapBrowserEvent.map;
          var features = this.getFeatures();
          var deselected = [];
          var selected = [];
          if (set) {
              // Replace the currently selected feature(s) with the feature(s) at the
              // pixel, or clear the selected feature(s) if there is no feature at
              // the pixel.
              clear(this.featureLayerAssociation_);
              map.forEachFeatureAtPixel(mapBrowserEvent.pixel, 
              /**
               * @param {import("../Feature.js").FeatureLike} feature Feature.
               * @param {import("../layer/Layer.js").default} layer Layer.
               * @return {boolean|undefined} Continue to iterate over the features.
               */
              function (feature, layer) {
                  if (this.filter_(feature, layer)) {
                      selected.push(feature);
                      this.addFeatureLayerAssociation_(feature, layer);
                      return !this.multi_;
                  }
              }.bind(this), {
                  layerFilter: this.layerFilter_,
                  hitTolerance: this.hitTolerance_,
              });
              for (var i = features.getLength() - 1; i >= 0; --i) {
                  var feature = features.item(i);
                  var index = selected.indexOf(feature);
                  if (index > -1) {
                      // feature is already selected
                      selected.splice(index, 1);
                  }
                  else {
                      features.remove(feature);
                      deselected.push(feature);
                  }
              }
              if (selected.length !== 0) {
                  features.extend(selected);
              }
          }
          else {
              // Modify the currently selected feature(s).
              map.forEachFeatureAtPixel(mapBrowserEvent.pixel, 
              /**
               * @param {import("../Feature.js").FeatureLike} feature Feature.
               * @param {import("../layer/Layer.js").default} layer Layer.
               * @return {boolean|undefined} Continue to iterate over the features.
               */
              function (feature, layer) {
                  if (this.filter_(feature, layer)) {
                      if ((add || toggle) && !includes(features.getArray(), feature)) {
                          selected.push(feature);
                          this.addFeatureLayerAssociation_(feature, layer);
                      }
                      else if ((remove$$1 || toggle) &&
                          includes(features.getArray(), feature)) {
                          deselected.push(feature);
                          this.removeFeatureLayerAssociation_(feature);
                      }
                      return !this.multi_;
                  }
              }.bind(this), {
                  layerFilter: this.layerFilter_,
                  hitTolerance: this.hitTolerance_,
              });
              for (var j = deselected.length - 1; j >= 0; --j) {
                  features.remove(deselected[j]);
              }
              features.extend(selected);
          }
          if (selected.length > 0 || deselected.length > 0) {
              this.dispatchEvent(new SelectEvent(SelectEventType.SELECT, selected, deselected, mapBrowserEvent));
          }
          return true;
      };
      return Select;
  }(Interaction));
  /**
   * @return {import("../style/Style.js").StyleFunction} Styles.
   */
  function getDefaultStyleFunction$2() {
      var styles = createEditingStyle();
      extend$1(styles[GeometryType.POLYGON], styles[GeometryType.LINE_STRING]);
      extend$1(styles[GeometryType.GEOMETRY_COLLECTION], styles[GeometryType.LINE_STRING]);
      return function (feature) {
          if (!feature.getGeometry()) {
              return null;
          }
          return styles[feature.getGeometry().getType()];
      };
  }

  var __extends$1j = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Result
   * @property {boolean} snapped
   * @property {import("../coordinate.js").Coordinate|null} vertex
   * @property {import("../pixel.js").Pixel|null} vertexPixel
   */
  /**
   * @typedef {Object} SegmentData
   * @property {import("../Feature.js").default} feature
   * @property {Array<import("../coordinate.js").Coordinate>} segment
   */
  /**
   * @typedef {Object} Options
   * @property {import("../Collection.js").default<import("../Feature.js").default>} [features] Snap to these features. Either this option or source should be provided.
   * @property {boolean} [edge=true] Snap to edges.
   * @property {boolean} [vertex=true] Snap to vertices.
   * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or
   * vertex for snapping.
   * @property {import("../source/Vector.js").default} [source] Snap to features from this source. Either this option or features should be provided
   */
  /**
   * @param  {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
   * @return {import("../Feature.js").default} Feature.
   */
  function getFeatureFromEvent(evt) {
      if (
      /** @type {import("../source/Vector.js").VectorSourceEvent} */ (evt).feature) {
          return /** @type {import("../source/Vector.js").VectorSourceEvent} */ (evt)
              .feature;
      }
      else if (
      /** @type {import("../Collection.js").CollectionEvent} */ (evt).element) {
          return /** @type {import("../Feature.js").default} */ (
          /** @type {import("../Collection.js").CollectionEvent} */ (evt).element);
      }
  }
  var tempSegment$1 = [];
  /**
   * @classdesc
   * Handles snapping of vector features while modifying or drawing them.  The
   * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}
   * Any interaction object that allows the user to interact
   * with the features using the mouse can benefit from the snapping, as long
   * as it is added before.
   *
   * The snap interaction modifies map browser event `coordinate` and `pixel`
   * properties to force the snap to occur to any interaction that them.
   *
   * Example:
   *
   *     import Snap from 'ol/interaction/Snap';
   *
   *     const snap = new Snap({
   *       source: source
   *     });
   *
   *     map.addInteraction(snap);
   *
   * @api
   */
  var Snap = /** @class */ (function (_super) {
      __extends$1j(Snap, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function Snap(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);
          if (!pointerOptions.handleDownEvent) {
              pointerOptions.handleDownEvent = TRUE;
          }
          if (!pointerOptions.stopDown) {
              pointerOptions.stopDown = FALSE;
          }
          _this = _super.call(this, pointerOptions) || this;
          /**
           * @type {import("../source/Vector.js").default}
           * @private
           */
          _this.source_ = options.source ? options.source : null;
          /**
           * @private
           * @type {boolean}
           */
          _this.vertex_ = options.vertex !== undefined ? options.vertex : true;
          /**
           * @private
           * @type {boolean}
           */
          _this.edge_ = options.edge !== undefined ? options.edge : true;
          /**
           * @type {import("../Collection.js").default<import("../Feature.js").default>}
           * @private
           */
          _this.features_ = options.features ? options.features : null;
          /**
           * @type {Array<import("../events.js").EventsKey>}
           * @private
           */
          _this.featuresListenerKeys_ = [];
          /**
           * @type {Object<string, import("../events.js").EventsKey>}
           * @private
           */
          _this.featureChangeListenerKeys_ = {};
          /**
           * Extents are preserved so indexed segment can be quickly removed
           * when its feature geometry changes
           * @type {Object<string, import("../extent.js").Extent>}
           * @private
           */
          _this.indexedFeaturesExtents_ = {};
          /**
           * If a feature geometry changes while a pointer drag|move event occurs, the
           * feature doesn't get updated right away.  It will be at the next 'pointerup'
           * event fired.
           * @type {!Object<string, import("../Feature.js").default>}
           * @private
           */
          _this.pendingFeatures_ = {};
          /**
           * @type {number}
           * @private
           */
          _this.pixelTolerance_ =
              options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
          /**
           * Segment RTree for each layer
           * @type {import("../structs/RBush.js").default<SegmentData>}
           * @private
           */
          _this.rBush_ = new RBush();
          /**
           * @const
           * @private
           * @type {Object<string, function(import("../Feature.js").default, import("../geom/Geometry.js").default): void>}
           */
          _this.SEGMENT_WRITERS_ = {
              'Point': _this.writePointGeometry_.bind(_this),
              'LineString': _this.writeLineStringGeometry_.bind(_this),
              'LinearRing': _this.writeLineStringGeometry_.bind(_this),
              'Polygon': _this.writePolygonGeometry_.bind(_this),
              'MultiPoint': _this.writeMultiPointGeometry_.bind(_this),
              'MultiLineString': _this.writeMultiLineStringGeometry_.bind(_this),
              'MultiPolygon': _this.writeMultiPolygonGeometry_.bind(_this),
              'GeometryCollection': _this.writeGeometryCollectionGeometry_.bind(_this),
              'Circle': _this.writeCircleGeometry_.bind(_this),
          };
          return _this;
      }
      /**
       * Add a feature to the collection of features that we may snap to.
       * @param {import("../Feature.js").default} feature Feature.
       * @param {boolean=} opt_listen Whether to listen to the feature change or not
       *     Defaults to `true`.
       * @api
       */
      Snap.prototype.addFeature = function (feature, opt_listen) {
          var register = opt_listen !== undefined ? opt_listen : true;
          var feature_uid = getUid(feature);
          var geometry = feature.getGeometry();
          if (geometry) {
              var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];
              if (segmentWriter) {
                  this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());
                  segmentWriter(feature, geometry);
              }
          }
          if (register) {
              this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);
          }
      };
      /**
       * @param {import("../Feature.js").default} feature Feature.
       * @private
       */
      Snap.prototype.forEachFeatureAdd_ = function (feature) {
          this.addFeature(feature);
      };
      /**
       * @param {import("../Feature.js").default} feature Feature.
       * @private
       */
      Snap.prototype.forEachFeatureRemove_ = function (feature) {
          this.removeFeature(feature);
      };
      /**
       * @return {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} Features.
       * @private
       */
      Snap.prototype.getFeatures_ = function () {
          var features;
          if (this.features_) {
              features = this.features_;
          }
          else if (this.source_) {
              features = this.source_.getFeatures();
          }
          return features;
      };
      /**
       * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
       * @return {boolean} `false` to stop event propagation.
       */
      Snap.prototype.handleEvent = function (evt) {
          var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);
          if (result.snapped) {
              evt.coordinate = result.vertex.slice(0, 2);
              evt.pixel = result.vertexPixel;
          }
          return _super.prototype.handleEvent.call(this, evt);
      };
      /**
       * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
       * @private
       */
      Snap.prototype.handleFeatureAdd_ = function (evt) {
          var feature = getFeatureFromEvent(evt);
          this.addFeature(feature);
      };
      /**
       * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
       * @private
       */
      Snap.prototype.handleFeatureRemove_ = function (evt) {
          var feature = getFeatureFromEvent(evt);
          this.removeFeature(feature);
      };
      /**
       * @param {import("../events/Event.js").default} evt Event.
       * @private
       */
      Snap.prototype.handleFeatureChange_ = function (evt) {
          var feature = /** @type {import("../Feature.js").default} */ (evt.target);
          if (this.handlingDownUpSequence) {
              var uid = getUid(feature);
              if (!(uid in this.pendingFeatures_)) {
                  this.pendingFeatures_[uid] = feature;
              }
          }
          else {
              this.updateFeature_(feature);
          }
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} evt Event.
       * @return {boolean} If the event was consumed.
       */
      Snap.prototype.handleUpEvent = function (evt) {
          var featuresToUpdate = getValues(this.pendingFeatures_);
          if (featuresToUpdate.length) {
              featuresToUpdate.forEach(this.updateFeature_.bind(this));
              this.pendingFeatures_ = {};
          }
          return false;
      };
      /**
       * Remove a feature from the collection of features that we may snap to.
       * @param {import("../Feature.js").default} feature Feature
       * @param {boolean=} opt_unlisten Whether to unlisten to the feature change
       *     or not. Defaults to `true`.
       * @api
       */
      Snap.prototype.removeFeature = function (feature, opt_unlisten) {
          var unregister = opt_unlisten !== undefined ? opt_unlisten : true;
          var feature_uid = getUid(feature);
          var extent = this.indexedFeaturesExtents_[feature_uid];
          if (extent) {
              var rBush = this.rBush_;
              var nodesToRemove_1 = [];
              rBush.forEachInExtent(extent, function (node) {
                  if (feature === node.feature) {
                      nodesToRemove_1.push(node);
                  }
              });
              for (var i = nodesToRemove_1.length - 1; i >= 0; --i) {
                  rBush.remove(nodesToRemove_1[i]);
              }
          }
          if (unregister) {
              unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);
              delete this.featureChangeListenerKeys_[feature_uid];
          }
      };
      /**
       * Remove the interaction from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       */
      Snap.prototype.setMap = function (map) {
          var currentMap = this.getMap();
          var keys = this.featuresListenerKeys_;
          var features = /** @type {Array<import("../Feature.js").default>} */ (this.getFeatures_());
          if (currentMap) {
              keys.forEach(unlistenByKey);
              keys.length = 0;
              features.forEach(this.forEachFeatureRemove_.bind(this));
          }
          _super.prototype.setMap.call(this, map);
          if (map) {
              if (this.features_) {
                  keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));
              }
              else if (this.source_) {
                  keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));
              }
              features.forEach(this.forEachFeatureAdd_.bind(this));
          }
      };
      /**
       * @param {import("../pixel.js").Pixel} pixel Pixel
       * @param {import("../coordinate.js").Coordinate} pixelCoordinate Coordinate
       * @param {import("../PluggableMap.js").default} map Map.
       * @return {Result} Snap result
       */
      Snap.prototype.snapTo = function (pixel, pixelCoordinate, map) {
          var lowerLeft = map.getCoordinateFromPixel([
              pixel[0] - this.pixelTolerance_,
              pixel[1] + this.pixelTolerance_,
          ]);
          var upperRight = map.getCoordinateFromPixel([
              pixel[0] + this.pixelTolerance_,
              pixel[1] - this.pixelTolerance_,
          ]);
          var box = boundingExtent([lowerLeft, upperRight]);
          var segments = this.rBush_.getInExtent(box);
          // If snapping on vertices only, don't consider circles
          if (this.vertex_ && !this.edge_) {
              segments = segments.filter(function (segment) {
                  return segment.feature.getGeometry().getType() !== GeometryType.CIRCLE;
              });
          }
          var snapped = false;
          var vertex = null;
          var vertexPixel = null;
          if (segments.length === 0) {
              return {
                  snapped: snapped,
                  vertex: vertex,
                  vertexPixel: vertexPixel,
              };
          }
          var projection = map.getView().getProjection();
          var projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);
          var closestSegmentData;
          var minSquaredDistance = Infinity;
          for (var i = 0; i < segments.length; ++i) {
              var segmentData = segments[i];
              tempSegment$1[0] = fromUserCoordinate(segmentData.segment[0], projection);
              tempSegment$1[1] = fromUserCoordinate(segmentData.segment[1], projection);
              var delta = squaredDistanceToSegment(projectedCoordinate, tempSegment$1);
              if (delta < minSquaredDistance) {
                  closestSegmentData = segmentData;
                  minSquaredDistance = delta;
              }
          }
          var closestSegment = closestSegmentData.segment;
          if (this.vertex_ && !this.edge_) {
              var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
              var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
              var squaredDist1 = squaredDistance$1(pixel, pixel1);
              var squaredDist2 = squaredDistance$1(pixel, pixel2);
              var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
              if (dist <= this.pixelTolerance_) {
                  snapped = true;
                  vertex =
                      squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
                  vertexPixel = map.getPixelFromCoordinate(vertex);
              }
          }
          else if (this.edge_) {
              var isCircle = closestSegmentData.feature.getGeometry().getType() ===
                  GeometryType.CIRCLE;
              if (isCircle) {
                  var circleGeometry = closestSegmentData.feature.getGeometry();
                  var userProjection = getUserProjection();
                  if (userProjection) {
                      circleGeometry = circleGeometry
                          .clone()
                          .transform(userProjection, projection);
                  }
                  vertex = toUserCoordinate(closestOnCircle(projectedCoordinate, 
                  /** @type {import("../geom/Circle.js").default} */ (circleGeometry)), projection);
              }
              else {
                  tempSegment$1[0] = fromUserCoordinate(closestSegment[0], projection);
                  tempSegment$1[1] = fromUserCoordinate(closestSegment[1], projection);
                  vertex = toUserCoordinate(closestOnSegment(projectedCoordinate, tempSegment$1), projection);
              }
              vertexPixel = map.getPixelFromCoordinate(vertex);
              if (distance$1(pixel, vertexPixel) <= this.pixelTolerance_) {
                  snapped = true;
                  if (this.vertex_ && !isCircle) {
                      var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
                      var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
                      var squaredDist1 = squaredDistance$1(vertexPixel, pixel1);
                      var squaredDist2 = squaredDistance$1(vertexPixel, pixel2);
                      var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
                      if (dist <= this.pixelTolerance_) {
                          vertex =
                              squaredDist1 > squaredDist2
                                  ? closestSegment[1]
                                  : closestSegment[0];
                          vertexPixel = map.getPixelFromCoordinate(vertex);
                      }
                  }
              }
          }
          if (snapped) {
              vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];
          }
          return {
              snapped: snapped,
              vertex: vertex,
              vertexPixel: vertexPixel,
          };
      };
      /**
       * @param {import("../Feature.js").default} feature Feature
       * @private
       */
      Snap.prototype.updateFeature_ = function (feature) {
          this.removeFeature(feature, false);
          this.addFeature(feature, false);
      };
      /**
       * @param {import("../Feature.js").default} feature Feature
       * @param {import("../geom/Circle.js").default} geometry Geometry.
       * @private
       */
      Snap.prototype.writeCircleGeometry_ = function (feature, geometry) {
          var projection = this.getMap().getView().getProjection();
          var circleGeometry = geometry;
          var userProjection = getUserProjection();
          if (userProjection) {
              circleGeometry = /** @type {import("../geom/Circle.js").default} */ (circleGeometry
                  .clone()
                  .transform(userProjection, projection));
          }
          var polygon = fromCircle(circleGeometry);
          if (userProjection) {
              polygon.transform(projection, userProjection);
          }
          var coordinates = polygon.getCoordinates()[0];
          for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
              var segment = coordinates.slice(i, i + 2);
              var segmentData = {
                  feature: feature,
                  segment: segment,
              };
              this.rBush_.insert(boundingExtent(segment), segmentData);
          }
      };
      /**
       * @param {import("../Feature.js").default} feature Feature
       * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
       * @private
       */
      Snap.prototype.writeGeometryCollectionGeometry_ = function (feature, geometry) {
          var geometries = geometry.getGeometriesArray();
          for (var i = 0; i < geometries.length; ++i) {
              var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];
              if (segmentWriter) {
                  segmentWriter(feature, geometries[i]);
              }
          }
      };
      /**
       * @param {import("../Feature.js").default} feature Feature
       * @param {import("../geom/LineString.js").default} geometry Geometry.
       * @private
       */
      Snap.prototype.writeLineStringGeometry_ = function (feature, geometry) {
          var coordinates = geometry.getCoordinates();
          for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
              var segment = coordinates.slice(i, i + 2);
              var segmentData = {
                  feature: feature,
                  segment: segment,
              };
              this.rBush_.insert(boundingExtent(segment), segmentData);
          }
      };
      /**
       * @param {import("../Feature.js").default} feature Feature
       * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
       * @private
       */
      Snap.prototype.writeMultiLineStringGeometry_ = function (feature, geometry) {
          var lines = geometry.getCoordinates();
          for (var j = 0, jj = lines.length; j < jj; ++j) {
              var coordinates = lines[j];
              for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                  var segment = coordinates.slice(i, i + 2);
                  var segmentData = {
                      feature: feature,
                      segment: segment,
                  };
                  this.rBush_.insert(boundingExtent(segment), segmentData);
              }
          }
      };
      /**
       * @param {import("../Feature.js").default} feature Feature
       * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
       * @private
       */
      Snap.prototype.writeMultiPointGeometry_ = function (feature, geometry) {
          var points = geometry.getCoordinates();
          for (var i = 0, ii = points.length; i < ii; ++i) {
              var coordinates = points[i];
              var segmentData = {
                  feature: feature,
                  segment: [coordinates, coordinates],
              };
              this.rBush_.insert(geometry.getExtent(), segmentData);
          }
      };
      /**
       * @param {import("../Feature.js").default} feature Feature
       * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
       * @private
       */
      Snap.prototype.writeMultiPolygonGeometry_ = function (feature, geometry) {
          var polygons = geometry.getCoordinates();
          for (var k = 0, kk = polygons.length; k < kk; ++k) {
              var rings = polygons[k];
              for (var j = 0, jj = rings.length; j < jj; ++j) {
                  var coordinates = rings[j];
                  for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                      var segment = coordinates.slice(i, i + 2);
                      var segmentData = {
                          feature: feature,
                          segment: segment,
                      };
                      this.rBush_.insert(boundingExtent(segment), segmentData);
                  }
              }
          }
      };
      /**
       * @param {import("../Feature.js").default} feature Feature
       * @param {import("../geom/Point.js").default} geometry Geometry.
       * @private
       */
      Snap.prototype.writePointGeometry_ = function (feature, geometry) {
          var coordinates = geometry.getCoordinates();
          var segmentData = {
              feature: feature,
              segment: [coordinates, coordinates],
          };
          this.rBush_.insert(geometry.getExtent(), segmentData);
      };
      /**
       * @param {import("../Feature.js").default} feature Feature
       * @param {import("../geom/Polygon.js").default} geometry Geometry.
       * @private
       */
      Snap.prototype.writePolygonGeometry_ = function (feature, geometry) {
          var rings = geometry.getCoordinates();
          for (var j = 0, jj = rings.length; j < jj; ++j) {
              var coordinates = rings[j];
              for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                  var segment = coordinates.slice(i, i + 2);
                  var segmentData = {
                      feature: feature,
                      segment: segment,
                  };
                  this.rBush_.insert(boundingExtent(segment), segmentData);
              }
          }
      };
      return Snap;
  }(PointerInteraction));

  var __extends$1k = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @enum {string}
   */
  var TranslateEventType = {
      /**
       * Triggered upon feature translation start.
       * @event TranslateEvent#translatestart
       * @api
       */
      TRANSLATESTART: 'translatestart',
      /**
       * Triggered upon feature translation.
       * @event TranslateEvent#translating
       * @api
       */
      TRANSLATING: 'translating',
      /**
       * Triggered upon feature translation end.
       * @event TranslateEvent#translateend
       * @api
       */
      TRANSLATEEND: 'translateend',
  };
  /**
   * A function that takes an {@link module:ol/Feature} or
   * {@link module:ol/render/Feature} and an
   * {@link module:ol/layer/Layer} and returns `true` if the feature may be
   * translated or `false` otherwise.
   * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default):boolean} FilterFunction
   */
  /**
   * @typedef {Object} Options
   * @property {Collection<import("../Feature.js").default>} [features] Only features contained in this collection will be able to be translated. If
   * not specified, all features on the map will be able to be translated.
   * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default): boolean} [layers] A list of layers from which features should be
   * translated. Alternatively, a filter function can be provided. The
   * function will be called for each layer in the map and should return
   * `true` for layers that you want to be translatable. If the option is
   * absent, all visible layers will be considered translatable.
   * @property {FilterFunction} [filter] A function
   * that takes an {@link module:ol/Feature} and an
   * {@link module:ol/layer/Layer} and returns `true` if the feature may be
   * translated or `false` otherwise.
   * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   */
  /**
   * @classdesc
   * Events emitted by {@link module:ol/interaction/Translate~Translate} instances
   * are instances of this type.
   */
  var TranslateEvent = /** @class */ (function (_super) {
      __extends$1k(TranslateEvent, _super);
      /**
       * @param {TranslateEventType} type Type.
       * @param {Collection<import("../Feature.js").default>} features The features translated.
       * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
       * @param {import("../coordinate.js").Coordinate} startCoordinate The original coordinates before.translation started
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       */
      function TranslateEvent(type, features, coordinate, startCoordinate, mapBrowserEvent) {
          var _this = _super.call(this, type) || this;
          /**
           * The features being translated.
           * @type {Collection<import("../Feature.js").default>}
           * @api
           */
          _this.features = features;
          /**
           * The coordinate of the drag event.
           * @const
           * @type {import("../coordinate.js").Coordinate}
           * @api
           */
          _this.coordinate = coordinate;
          /**
           * The coordinate of the start position before translation started.
           * @const
           * @type {import("../coordinate.js").Coordinate}
           * @api
           */
          _this.startCoordinate = startCoordinate;
          /**
           * Associated {@link module:ol/MapBrowserEvent}.
           * @type {import("../MapBrowserEvent.js").default}
           * @api
           */
          _this.mapBrowserEvent = mapBrowserEvent;
          return _this;
      }
      return TranslateEvent;
  }(BaseEvent));
  /**
   * @classdesc
   * Interaction for translating (moving) features.
   *
   * @fires TranslateEvent
   * @api
   */
  var Translate = /** @class */ (function (_super) {
      __extends$1k(Translate, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function Translate(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, /** @type {import("./Pointer.js").Options} */ (options)) || this;
          /**
           * The last position we translated to.
           * @type {import("../coordinate.js").Coordinate}
           * @private
           */
          _this.lastCoordinate_ = null;
          /**
           * The start position before translation started.
           * @type {import("../coordinate.js").Coordinate}
           * @private
           */
          _this.startCoordinate_ = null;
          /**
           * @type {Collection<import("../Feature.js").default>}
           * @private
           */
          _this.features_ = options.features !== undefined ? options.features : null;
          /** @type {function(import("../layer/Layer.js").default): boolean} */
          var layerFilter;
          if (options.layers) {
              if (typeof options.layers === 'function') {
                  layerFilter = options.layers;
              }
              else {
                  var layers_1 = options.layers;
                  layerFilter = function (layer) {
                      return includes(layers_1, layer);
                  };
              }
          }
          else {
              layerFilter = TRUE;
          }
          /**
           * @private
           * @type {function(import("../layer/Layer.js").default): boolean}
           */
          _this.layerFilter_ = layerFilter;
          /**
           * @private
           * @type {FilterFunction}
           */
          _this.filter_ = options.filter ? options.filter : TRUE;
          /**
           * @private
           * @type {number}
           */
          _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
          /**
           * @type {import("../Feature.js").default}
           * @private
           */
          _this.lastFeature_ = null;
          _this.addEventListener(getChangeEventType(InteractionProperty.ACTIVE), _this.handleActiveChanged_);
          return _this;
      }
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} event Event.
       * @return {boolean} If the event was consumed.
       */
      Translate.prototype.handleDownEvent = function (event) {
          this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);
          if (!this.lastCoordinate_ && this.lastFeature_) {
              this.startCoordinate_ = event.coordinate;
              this.lastCoordinate_ = event.coordinate;
              this.handleMoveEvent(event);
              var features = this.features_ || new Collection([this.lastFeature_]);
              this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATESTART, features, event.coordinate, this.startCoordinate_, event));
              return true;
          }
          return false;
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} event Event.
       * @return {boolean} If the event was consumed.
       */
      Translate.prototype.handleUpEvent = function (event) {
          if (this.lastCoordinate_) {
              this.lastCoordinate_ = null;
              this.handleMoveEvent(event);
              var features = this.features_ || new Collection([this.lastFeature_]);
              this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATEEND, features, event.coordinate, this.startCoordinate_, event));
              // cleanup
              this.startCoordinate_ = null;
              return true;
          }
          return false;
      };
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} event Event.
       */
      Translate.prototype.handleDragEvent = function (event) {
          if (this.lastCoordinate_) {
              var newCoordinate = event.coordinate;
              var deltaX_1 = newCoordinate[0] - this.lastCoordinate_[0];
              var deltaY_1 = newCoordinate[1] - this.lastCoordinate_[1];
              var features = this.features_ || new Collection([this.lastFeature_]);
              features.forEach(function (feature) {
                  var geom = feature.getGeometry();
                  geom.translate(deltaX_1, deltaY_1);
                  feature.setGeometry(geom);
              });
              this.lastCoordinate_ = newCoordinate;
              this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATING, features, newCoordinate, this.startCoordinate_, event));
          }
      };
      /**
       * Handle pointer move events.
       * @param {import("../MapBrowserEvent.js").default} event Event.
       */
      Translate.prototype.handleMoveEvent = function (event) {
          var elem = event.map.getViewport();
          // Change the cursor to grab/grabbing if hovering any of the features managed
          // by the interaction
          if (this.featuresAtPixel_(event.pixel, event.map)) {
              elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');
              elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');
          }
          else {
              elem.classList.remove('ol-grab', 'ol-grabbing');
          }
      };
      /**
       * Tests to see if the given coordinates intersects any of our selected
       * features.
       * @param {import("../pixel.js").Pixel} pixel Pixel coordinate to test for intersection.
       * @param {import("../PluggableMap.js").default} map Map to test the intersection on.
       * @return {import("../Feature.js").default} Returns the feature found at the specified pixel
       * coordinates.
       * @private
       */
      Translate.prototype.featuresAtPixel_ = function (pixel, map) {
          return map.forEachFeatureAtPixel(pixel, function (feature, layer) {
              if (this.filter_(feature, layer)) {
                  if (!this.features_ || includes(this.features_.getArray(), feature)) {
                      return feature;
                  }
              }
          }.bind(this), {
              layerFilter: this.layerFilter_,
              hitTolerance: this.hitTolerance_,
          });
      };
      /**
       * Returns the Hit-detection tolerance.
       * @returns {number} Hit tolerance in pixels.
       * @api
       */
      Translate.prototype.getHitTolerance = function () {
          return this.hitTolerance_;
      };
      /**
       * Hit-detection tolerance. Pixels inside the radius around the given position
       * will be checked for features.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @api
       */
      Translate.prototype.setHitTolerance = function (hitTolerance) {
          this.hitTolerance_ = hitTolerance;
      };
      /**
       * Remove the interaction from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       */
      Translate.prototype.setMap = function (map) {
          var oldMap = this.getMap();
          _super.prototype.setMap.call(this, map);
          this.updateState_(oldMap);
      };
      /**
       * @private
       */
      Translate.prototype.handleActiveChanged_ = function () {
          this.updateState_(null);
      };
      /**
       * @param {import("../PluggableMap.js").default} oldMap Old map.
       * @private
       */
      Translate.prototype.updateState_ = function (oldMap) {
          var map = this.getMap();
          var active = this.getActive();
          if (!map || !active) {
              map = map || oldMap;
              if (map) {
                  var elem = map.getViewport();
                  elem.classList.remove('ol-grab', 'ol-grabbing');
              }
          }
      };
      return Translate;
  }(PointerInteraction));

  /**
   * @module ol/interaction
   */
  /**
   * @typedef {Object} DefaultsOptions
   * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
   * desired.
   * @property {boolean} [onFocusOnly=false] Interact only when the map has the
   * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
   * useful when page scroll is desired for maps that do not have the browser's
   * focus.
   * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
   * desired.
   * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
   * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
   * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
   * @property {boolean} [dragPan=true] Whether drag pan is desired.
   * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
   * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
   * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.
   * @property {number} [zoomDuration] Duration of the zoom animation in
   * milliseconds.
   */
  /**
   * Set of interactions included in maps by default. Specific interactions can be
   * excluded by setting the appropriate option to false in the constructor
   * options, but the order of the interactions is fixed.  If you want to specify
   * a different order for interactions, you will need to create your own
   * {@link module:ol/interaction/Interaction} instances and insert
   * them into a {@link module:ol/Collection} in the order you want
   * before creating your {@link module:ol/Map~Map} instance. Changing the order can
   * be of interest if the event propagation needs to be stopped at a point.
   * The default set of interactions, in sequence, is:
   * * {@link module:ol/interaction/DragRotate~DragRotate}
   * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
   * * {@link module:ol/interaction/DragPan~DragPan}
   * * {@link module:ol/interaction/PinchRotate~PinchRotate}
   * * {@link module:ol/interaction/PinchZoom~PinchZoom}
   * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
   * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
   * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
   * * {@link module:ol/interaction/DragZoom~DragZoom}
   *
   * @param {DefaultsOptions=} opt_options Defaults options.
   * @return {import("./Collection.js").default<import("./interaction/Interaction.js").default>}
   * A collection of interactions to be used with the {@link module:ol/Map~Map}
   * constructor's `interactions` option.
   * @api
   */
  function defaults$1(opt_options) {
      var options = opt_options ? opt_options : {};
      var interactions = new Collection();
      var kinetic = new Kinetic(-0.005, 0.05, 100);
      var altShiftDragRotate = options.altShiftDragRotate !== undefined
          ? options.altShiftDragRotate
          : true;
      if (altShiftDragRotate) {
          interactions.push(new DragRotate());
      }
      var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;
      if (doubleClickZoom) {
          interactions.push(new DoubleClickZoom({
              delta: options.zoomDelta,
              duration: options.zoomDuration,
          }));
      }
      var dragPan = options.dragPan !== undefined ? options.dragPan : true;
      if (dragPan) {
          interactions.push(new DragPan({
              onFocusOnly: options.onFocusOnly,
              kinetic: kinetic,
          }));
      }
      var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;
      if (pinchRotate) {
          interactions.push(new PinchRotate());
      }
      var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
      if (pinchZoom) {
          interactions.push(new PinchZoom({
              duration: options.zoomDuration,
          }));
      }
      var keyboard = options.keyboard !== undefined ? options.keyboard : true;
      if (keyboard) {
          interactions.push(new KeyboardPan());
          interactions.push(new KeyboardZoom({
              delta: options.zoomDelta,
              duration: options.zoomDuration,
          }));
      }
      var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;
      if (mouseWheelZoom) {
          interactions.push(new MouseWheelZoom({
              onFocusOnly: options.onFocusOnly,
              duration: options.zoomDuration,
          }));
      }
      var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;
      if (shiftDragZoom) {
          interactions.push(new DragZoom({
              duration: options.zoomDuration,
          }));
      }
      return interactions;
  }

  var __extends$1l = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * The map is the core component of OpenLayers. For a map to render, a view,
   * one or more layers, and a target container are needed:
   *
   *     import Map from 'ol/Map';
   *     import View from 'ol/View';
   *     import TileLayer from 'ol/layer/Tile';
   *     import OSM from 'ol/source/OSM';
   *
   *     var map = new Map({
   *       view: new View({
   *         center: [0, 0],
   *         zoom: 1
   *       }),
   *       layers: [
   *         new TileLayer({
   *           source: new OSM()
   *         })
   *       ],
   *       target: 'map'
   *     });
   *
   * The above snippet creates a map using a {@link module:ol/layer/Tile} to
   * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
   * element with the id `map`.
   *
   * The constructor places a viewport container (with CSS class name
   * `ol-viewport`) in the target element (see `getViewport()`), and then two
   * further elements within the viewport: one with CSS class name
   * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
   * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
   * option of {@link module:ol/Overlay~Overlay} for the difference). The map
   * itself is placed in a further element within the viewport.
   *
   * Layers are stored as a {@link module:ol/Collection~Collection} in
   * layerGroups. A top-level group is provided by the library. This is what is
   * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
   * options are added to this group, and `addLayer` and `removeLayer` change the
   * layer collection in the group. `getLayers` is a convenience function for
   * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~Group}
   * is a subclass of {@link module:ol/layer/Base}, so layers entered in the
   * options or added with `addLayer` can be groups, which can contain further
   * groups, and so on.
   *
   * @api
   */
  var Map$1 = /** @class */ (function (_super) {
      __extends$1l(Map, _super);
      /**
       * @param {import("./PluggableMap.js").MapOptions} options Map options.
       */
      function Map(options) {
          var _this = this;
          options = assign({}, options);
          if (!options.controls) {
              options.controls = defaults();
          }
          if (!options.interactions) {
              options.interactions = defaults$1({
                  onFocusOnly: true,
              });
          }
          _this = _super.call(this, options) || this;
          return _this;
      }
      Map.prototype.createRenderer = function () {
          return new CompositeMapRenderer(this);
      };
      return Map;
  }(PluggableMap));

  /**
   * Triggers a CustomEvent.
   *
   * @param {EventTarget} el The element or EventTarget to trigger the event upon
   * @param {string} type The event type name
   * @param {Object|null} payload=null The event data to be sent
   * @returns {boolean} The return value is false if at least one event listener called preventDefault(). Otherwise it returns true.
   * @private
   */
  let publish = (el, type, payload = null) => {
    let event;

    const detail = {
      payload,
      time: new Date()
    };

    // This check is needed to polyfill CustomEvent on IE11-
    if (typeof window.CustomEvent === 'function') {
      event = new CustomEvent(type, {
        detail,
        bubbles: true,
        cancelable: true
      });
    } else {
      event = document.createEvent('CustomEvent');
      event.initCustomEvent(type, true, true, detail);
    }

    return el.dispatchEvent(event);
  };

  /**
   * @module ol/reproj/Triangulation
   */
  /**
   * Single triangle; consists of 3 source points and 3 target points.
   * @typedef {Object} Triangle
   * @property {Array<import("../coordinate.js").Coordinate>} source
   * @property {Array<import("../coordinate.js").Coordinate>} target
   */
  /**
   * Maximum number of subdivision steps during raster reprojection triangulation.
   * Prevents high memory usage and large number of proj4 calls (for certain
   * transformations and areas). At most `2*(2^this)` triangles are created for
   * each triangulated extent (tile/image).
   * @type {number}
   */
  var MAX_SUBDIVISION = 10;
  /**
   * Maximum allowed size of triangle relative to world width. When transforming
   * corners of world extent between certain projections, the resulting
   * triangulation seems to have zero error and no subdivision is performed. If
   * the triangle width is more than this (relative to world width; 0-1),
   * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
   * @type {number}
   */
  var MAX_TRIANGLE_WIDTH = 0.25;
  /**
   * @classdesc
   * Class containing triangulation of the given target extent.
   * Used for determining source data and the reprojection itself.
   */
  var Triangulation = /** @class */ (function () {
      /**
       * @param {import("../proj/Projection.js").default} sourceProj Source projection.
       * @param {import("../proj/Projection.js").default} targetProj Target projection.
       * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
       * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
       * @param {number} errorThreshold Acceptable error (in source units).
       * @param {?number} opt_destinationResolution The (optional) resolution of the destination.
       */
      function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {
          /**
           * @type {import("../proj/Projection.js").default}
           * @private
           */
          this.sourceProj_ = sourceProj;
          /**
           * @type {import("../proj/Projection.js").default}
           * @private
           */
          this.targetProj_ = targetProj;
          /** @type {!Object<string, import("../coordinate.js").Coordinate>} */
          var transformInvCache = {};
          var transformInv = getTransform(this.targetProj_, this.sourceProj_);
          /**
           * @param {import("../coordinate.js").Coordinate} c A coordinate.
           * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
           * @private
           */
          this.transformInv_ = function (c) {
              var key = c[0] + '/' + c[1];
              if (!transformInvCache[key]) {
                  transformInvCache[key] = transformInv(c);
              }
              return transformInvCache[key];
          };
          /**
           * @type {import("../extent.js").Extent}
           * @private
           */
          this.maxSourceExtent_ = maxSourceExtent;
          /**
           * @type {number}
           * @private
           */
          this.errorThresholdSquared_ = errorThreshold * errorThreshold;
          /**
           * @type {Array<Triangle>}
           * @private
           */
          this.triangles_ = [];
          /**
           * Indicates that the triangulation crosses edge of the source projection.
           * @type {boolean}
           * @private
           */
          this.wrapsXInSource_ = false;
          /**
           * @type {boolean}
           * @private
           */
          this.canWrapXInSource_ =
              this.sourceProj_.canWrapX() &&
                  !!maxSourceExtent &&
                  !!this.sourceProj_.getExtent() &&
                  getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());
          /**
           * @type {?number}
           * @private
           */
          this.sourceWorldWidth_ = this.sourceProj_.getExtent()
              ? getWidth(this.sourceProj_.getExtent())
              : null;
          /**
           * @type {?number}
           * @private
           */
          this.targetWorldWidth_ = this.targetProj_.getExtent()
              ? getWidth(this.targetProj_.getExtent())
              : null;
          var destinationTopLeft = getTopLeft(targetExtent);
          var destinationTopRight = getTopRight(targetExtent);
          var destinationBottomRight = getBottomRight(targetExtent);
          var destinationBottomLeft = getBottomLeft(targetExtent);
          var sourceTopLeft = this.transformInv_(destinationTopLeft);
          var sourceTopRight = this.transformInv_(destinationTopRight);
          var sourceBottomRight = this.transformInv_(destinationBottomRight);
          var sourceBottomLeft = this.transformInv_(destinationBottomLeft);
          /*
           * The maxSubdivision controls how many splittings of the target area can
           * be done. The idea here is to do a linear mapping of the target areas
           * but the actual overal reprojection (can be) extremely non-linear. The
           * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256
           * tile size. However this function is also called to remap canvas rendered
           * layers which can be much larger. This calculation increases the maxSubdivision
           * value by the right factor so that each 256x256 pixel area has
           * MAX_SUBDIVISION divisions.
           */
          var maxSubdivision = MAX_SUBDIVISION +
              (opt_destinationResolution
                  ? Math.max(0, Math.ceil(log2$2(getArea(targetExtent) /
                      (opt_destinationResolution *
                          opt_destinationResolution *
                          256 *
                          256))))
                  : 0);
          this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);
          if (this.wrapsXInSource_) {
              var leftBound_1 = Infinity;
              this.triangles_.forEach(function (triangle, i, arr) {
                  leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
              });
              // Shift triangles to be as close to `leftBound` as possible
              // (if the distance is more than `worldWidth / 2` it can be closer.
              this.triangles_.forEach(function (triangle) {
                  if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) -
                      leftBound_1 >
                      this.sourceWorldWidth_ / 2) {
                      var newTriangle = [
                          [triangle.source[0][0], triangle.source[0][1]],
                          [triangle.source[1][0], triangle.source[1][1]],
                          [triangle.source[2][0], triangle.source[2][1]],
                      ];
                      if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                          newTriangle[0][0] -= this.sourceWorldWidth_;
                      }
                      if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                          newTriangle[1][0] -= this.sourceWorldWidth_;
                      }
                      if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                          newTriangle[2][0] -= this.sourceWorldWidth_;
                      }
                      // Rarely (if the extent contains both the dateline and prime meridian)
                      // the shift can in turn break some triangles.
                      // Detect this here and don't shift in such cases.
                      var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
                      var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
                      if (maxX - minX < this.sourceWorldWidth_ / 2) {
                          triangle.source = newTriangle;
                      }
                  }
              }.bind(this));
          }
          transformInvCache = {};
      }
      /**
       * Adds triangle to the triangulation.
       * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
       * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
       * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
       * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
       * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
       * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
       * @private
       */
      Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {
          this.triangles_.push({
              source: [aSrc, bSrc, cSrc],
              target: [a, b, c],
          });
      };
      /**
       * Adds quad (points in clock-wise order) to the triangulation
       * (and reprojects the vertices) if valid.
       * Performs quad subdivision if needed to increase precision.
       *
       * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
       * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
       * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
       * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
       * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
       * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
       * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
       * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
       * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
       * @private
       */
      Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
          var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
          var sourceCoverageX = this.sourceWorldWidth_
              ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_
              : null;
          var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);
          // when the quad is wrapped in the source projection
          // it covers most of the projection extent, but not fully
          var wrapsX = this.sourceProj_.canWrapX() &&
              sourceCoverageX > 0.5 &&
              sourceCoverageX < 1;
          var needsSubdivision = false;
          if (maxSubdivision > 0) {
              if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
                  var targetQuadExtent = boundingExtent([a, b, c, d]);
                  var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
                  needsSubdivision =
                      targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
              }
              if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
                  needsSubdivision =
                      sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
              }
          }
          if (!needsSubdivision && this.maxSourceExtent_) {
              if (isFinite(sourceQuadExtent[0]) &&
                  isFinite(sourceQuadExtent[1]) &&
                  isFinite(sourceQuadExtent[2]) &&
                  isFinite(sourceQuadExtent[3])) {
                  if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {
                      // whole quad outside source projection extent -> ignore
                      return;
                  }
              }
          }
          var isNotFinite = 0;
          if (!needsSubdivision) {
              if (!isFinite(aSrc[0]) ||
                  !isFinite(aSrc[1]) ||
                  !isFinite(bSrc[0]) ||
                  !isFinite(bSrc[1]) ||
                  !isFinite(cSrc[0]) ||
                  !isFinite(cSrc[1]) ||
                  !isFinite(dSrc[0]) ||
                  !isFinite(dSrc[1])) {
                  if (maxSubdivision > 0) {
                      needsSubdivision = true;
                  }
                  else {
                      // It might be the case that only 1 of the points is infinite. In this case
                      // we can draw a single triangle with the other three points
                      isNotFinite =
                          (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +
                              (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +
                              (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +
                              (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
                      if (isNotFinite != 1 &&
                          isNotFinite != 2 &&
                          isNotFinite != 4 &&
                          isNotFinite != 8) {
                          return;
                      }
                  }
              }
          }
          if (maxSubdivision > 0) {
              if (!needsSubdivision) {
                  var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
                  var centerSrc = this.transformInv_(center);
                  var dx = void 0;
                  if (wrapsX) {
                      var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) +
                          modulo(cSrc[0], sourceWorldWidth)) /
                          2;
                      dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
                  }
                  else {
                      dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
                  }
                  var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
                  var centerSrcErrorSquared = dx * dx + dy * dy;
                  needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
              }
              if (needsSubdivision) {
                  if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
                      // split horizontally (top & bottom)
                      var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
                      var bcSrc = this.transformInv_(bc);
                      var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
                      var daSrc = this.transformInv_(da);
                      this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
                      this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
                  }
                  else {
                      // split vertically (left & right)
                      var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
                      var abSrc = this.transformInv_(ab);
                      var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
                      var cdSrc = this.transformInv_(cd);
                      this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
                      this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
                  }
                  return;
              }
          }
          if (wrapsX) {
              if (!this.canWrapXInSource_) {
                  return;
              }
              this.wrapsXInSource_ = true;
          }
          // Exactly zero or one of *Src is not finite
          // The triangles must have the diagonal line as the first side
          // This is to allow easy code in reproj.s to make it straight for broken
          // browsers that can't handle diagonal clipping
          if ((isNotFinite & 0xb) == 0) {
              this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
          }
          if ((isNotFinite & 0xe) == 0) {
              this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
          }
          if (isNotFinite) {
              // Try the other two triangles
              if ((isNotFinite & 0xd) == 0) {
                  this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
              }
              if ((isNotFinite & 0x7) == 0) {
                  this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
              }
          }
      };
      /**
       * Calculates extent of the 'source' coordinates from all the triangles.
       *
       * @return {import("../extent.js").Extent} Calculated extent.
       */
      Triangulation.prototype.calculateSourceExtent = function () {
          var extent = createEmpty();
          this.triangles_.forEach(function (triangle, i, arr) {
              var src = triangle.source;
              extendCoordinate(extent, src[0]);
              extendCoordinate(extent, src[1]);
              extendCoordinate(extent, src[2]);
          });
          return extent;
      };
      /**
       * @return {Array<Triangle>} Array of the calculated triangles.
       */
      Triangulation.prototype.getTriangles = function () {
          return this.triangles_;
      };
      return Triangulation;
  }());

  /**
   * @module ol/source/common
   */
  /**
   * Context options to disable image smoothing.
   * @type {Object}
   */
  var IMAGE_SMOOTHING_DISABLED = {
      imageSmoothingEnabled: false,
      msImageSmoothingEnabled: false,
  };

  /**
   * @module ol/reproj
   */
  var brokenDiagonalRendering_;
  /**
   * This draws a small triangle into a canvas by setting the triangle as the clip region
   * and then drawing a (too large) rectangle
   *
   * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle
   * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.
   * @param {number} v1 The y-coordinate of the second point.
   * @param {number} u2 The x-coordinate of the third point.
   * @param {number} v2 The y-coordinate of the third point.
   */
  function drawTestTriangle(ctx, u1, v1, u2, v2) {
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(u1, v1);
      ctx.lineTo(u2, v2);
      ctx.closePath();
      ctx.save();
      ctx.clip();
      ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
      ctx.restore();
  }
  /**
   * Given the data from getImageData, see if the right values appear at the provided offset.
   * Returns true if either the color or transparency is off
   *
   * @param {Uint8ClampedArray} data The data returned from getImageData
   * @param {number} offset The pixel offset from the start of data.
   * @return {boolean} true if the diagonal rendering is broken
   */
  function verifyBrokenDiagonalRendering(data, offset) {
      // the values ought to be close to the rgba(210, 0, 0, 0.75)
      return (Math.abs(data[offset * 4] - 210) > 2 ||
          Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2);
  }
  /**
   * Determines if the current browser configuration can render triangular clip regions correctly.
   * This value is cached so the function is only expensive the first time called.
   * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976
   * IE also doesn't. Chrome works, and everything seems to work on OSX and Android. This function caches the
   * result. I suppose that it is conceivably possible that a browser might flip modes while the app is
   * running, but lets hope not.
   *
   * @return {boolean} true if the Diagonal Rendering is broken.
   */
  function isBrokenDiagonalRendering() {
      if (brokenDiagonalRendering_ === undefined) {
          var ctx = document.createElement('canvas').getContext('2d');
          ctx.globalCompositeOperation = 'lighter';
          ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';
          drawTestTriangle(ctx, 4, 5, 4, 0);
          drawTestTriangle(ctx, 4, 5, 0, 5);
          var data = ctx.getImageData(0, 0, 3, 3).data;
          brokenDiagonalRendering_ =
              verifyBrokenDiagonalRendering(data, 0) ||
                  verifyBrokenDiagonalRendering(data, 4) ||
                  verifyBrokenDiagonalRendering(data, 8);
      }
      return brokenDiagonalRendering_;
  }
  /**
   * Calculates ideal resolution to use from the source in order to achieve
   * pixel mapping as close as possible to 1:1 during reprojection.
   * The resolution is calculated regardless of what resolutions
   * are actually available in the dataset (TileGrid, Image, ...).
   *
   * @param {import("./proj/Projection.js").default} sourceProj Source projection.
   * @param {import("./proj/Projection.js").default} targetProj Target projection.
   * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
   * @param {number} targetResolution Target resolution.
   * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
   */
  function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
      var sourceCenter = transform(targetCenter, targetProj, sourceProj);
      // calculate the ideal resolution of the source data
      var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);
      var targetMetersPerUnit = targetProj.getMetersPerUnit();
      if (targetMetersPerUnit !== undefined) {
          sourceResolution *= targetMetersPerUnit;
      }
      var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
      if (sourceMetersPerUnit !== undefined) {
          sourceResolution /= sourceMetersPerUnit;
      }
      // Based on the projection properties, the point resolution at the specified
      // coordinates may be slightly different. We need to reverse-compensate this
      // in order to achieve optimal results.
      var sourceExtent = sourceProj.getExtent();
      if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
          var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) /
              sourceResolution;
          if (isFinite(compensationFactor) && compensationFactor > 0) {
              sourceResolution /= compensationFactor;
          }
      }
      return sourceResolution;
  }
  /**
   * Calculates ideal resolution to use from the source in order to achieve
   * pixel mapping as close as possible to 1:1 during reprojection.
   * The resolution is calculated regardless of what resolutions
   * are actually available in the dataset (TileGrid, Image, ...).
   *
   * @param {import("./proj/Projection.js").default} sourceProj Source projection.
   * @param {import("./proj/Projection.js").default} targetProj Target projection.
   * @param {import("./extent.js").Extent} targetExtent Target extent
   * @param {number} targetResolution Target resolution.
   * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
   */
  function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
      var targetCenter = getCenter(targetExtent);
      var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
      if (!isFinite(sourceResolution) || sourceResolution <= 0) {
          forEachCorner(targetExtent, function (corner) {
              sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
              return isFinite(sourceResolution) && sourceResolution > 0;
          });
      }
      return sourceResolution;
  }
  /**
   * Renders the source data into new canvas based on the triangulation.
   *
   * @param {number} width Width of the canvas.
   * @param {number} height Height of the canvas.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} sourceResolution Source resolution.
   * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
   * @param {number} targetResolution Target resolution.
   * @param {import("./extent.js").Extent} targetExtent Target extent.
   * @param {import("./reproj/Triangulation.js").default} triangulation
   * Calculated triangulation.
   * @param {Array<{extent: import("./extent.js").Extent,
   *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources
   * Array of sources.
   * @param {number} gutter Gutter of the sources.
   * @param {boolean=} opt_renderEdges Render reprojection edges.
   * @param {object=} opt_contextOptions Properties to set on the canvas context.
   * @return {HTMLCanvasElement} Canvas with reprojected data.
   */
  function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges, opt_contextOptions) {
      var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));
      assign(context, opt_contextOptions);
      if (sources.length === 0) {
          return context.canvas;
      }
      context.scale(pixelRatio, pixelRatio);
      function pixelRound(value) {
          return Math.round(value * pixelRatio) / pixelRatio;
      }
      context.globalCompositeOperation = 'lighter';
      var sourceDataExtent = createEmpty();
      sources.forEach(function (src, i, arr) {
          extend$2(sourceDataExtent, src.extent);
      });
      var canvasWidthInUnits = getWidth(sourceDataExtent);
      var canvasHeightInUnits = getHeight(sourceDataExtent);
      var stitchContext = createCanvasContext2D(Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution), Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution));
      assign(stitchContext, opt_contextOptions);
      var stitchScale = pixelRatio / sourceResolution;
      sources.forEach(function (src, i, arr) {
          var xPos = src.extent[0] - sourceDataExtent[0];
          var yPos = -(src.extent[3] - sourceDataExtent[3]);
          var srcWidth = getWidth(src.extent);
          var srcHeight = getHeight(src.extent);
          // This test should never fail -- but it does. Need to find a fix the upstream condition
          if (src.image.width > 0 && src.image.height > 0) {
              stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
          }
      });
      var targetTopLeft = getTopLeft(targetExtent);
      triangulation.getTriangles().forEach(function (triangle, i, arr) {
          /* Calculate affine transform (src -> dst)
           * Resulting matrix can be used to transform coordinate
           * from `sourceProjection` to destination pixels.
           *
           * To optimize number of context calls and increase numerical stability,
           * we also do the following operations:
           * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
           * here before solving the linear system so [ui, vi] are pixel coordinates.
           *
           * Src points: xi, yi
           * Dst points: ui, vi
           * Affine coefficients: aij
           *
           * | x0 y0 1  0  0 0 |   |a00|   |u0|
           * | x1 y1 1  0  0 0 |   |a01|   |u1|
           * | x2 y2 1  0  0 0 | x |a02| = |u2|
           * |  0  0 0 x0 y0 1 |   |a10|   |v0|
           * |  0  0 0 x1 y1 1 |   |a11|   |v1|
           * |  0  0 0 x2 y2 1 |   |a12|   |v2|
           */
          var source = triangle.source;
          var target = triangle.target;
          var x0 = source[0][0], y0 = source[0][1];
          var x1 = source[1][0], y1 = source[1][1];
          var x2 = source[2][0], y2 = source[2][1];
          // Make sure that everything is on pixel boundaries
          var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
          var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);
          var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
          var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);
          var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
          var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);
          // Shift all the source points to improve numerical stability
          // of all the subsequent calculations. The [x0, y0] is used here.
          // This is also used to simplify the linear system.
          var sourceNumericalShiftX = x0;
          var sourceNumericalShiftY = y0;
          x0 = 0;
          y0 = 0;
          x1 -= sourceNumericalShiftX;
          y1 -= sourceNumericalShiftY;
          x2 -= sourceNumericalShiftX;
          y2 -= sourceNumericalShiftY;
          var augmentedMatrix = [
              [x1, y1, 0, 0, u1 - u0],
              [x2, y2, 0, 0, u2 - u0],
              [0, 0, x1, y1, v1 - v0],
              [0, 0, x2, y2, v2 - v0],
          ];
          var affineCoefs = solveLinearSystem(augmentedMatrix);
          if (!affineCoefs) {
              return;
          }
          context.save();
          context.beginPath();
          if (isBrokenDiagonalRendering() ||
              opt_contextOptions === IMAGE_SMOOTHING_DISABLED) {
              // Make sure that all lines are horizontal or vertical
              context.moveTo(u1, v1);
              // This is the diagonal line. Do it in 4 steps
              var steps = 4;
              var ud = u0 - u1;
              var vd = v0 - v1;
              for (var step = 0; step < steps; step++) {
                  // Go horizontally
                  context.lineTo(u1 + pixelRound(((step + 1) * ud) / steps), v1 + pixelRound((step * vd) / (steps - 1)));
                  // Go vertically
                  if (step != steps - 1) {
                      context.lineTo(u1 + pixelRound(((step + 1) * ud) / steps), v1 + pixelRound(((step + 1) * vd) / (steps - 1)));
                  }
              }
              // We are almost at u0r, v0r
              context.lineTo(u2, v2);
          }
          else {
              context.moveTo(u1, v1);
              context.lineTo(u0, v0);
              context.lineTo(u2, v2);
          }
          context.clip();
          context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
          context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
          context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
          context.drawImage(stitchContext.canvas, 0, 0);
          context.restore();
      });
      if (opt_renderEdges) {
          context.save();
          context.globalCompositeOperation = 'source-over';
          context.strokeStyle = 'black';
          context.lineWidth = 1;
          triangulation.getTriangles().forEach(function (triangle, i, arr) {
              var target = triangle.target;
              var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
              var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
              var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
              var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
              var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
              var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
              context.beginPath();
              context.moveTo(u1, v1);
              context.lineTo(u0, v0);
              context.lineTo(u2, v2);
              context.closePath();
              context.stroke();
          });
          context.restore();
      }
      return context.canvas;
  }

  var __extends$1m = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {function(import("../extent.js").Extent, number, number) : import("../ImageBase.js").default} FunctionType
   */
  /**
   * @classdesc
   * Class encapsulating single reprojected image.
   * See {@link module:ol/source/Image~ImageSource}.
   */
  var ReprojImage = /** @class */ (function (_super) {
      __extends$1m(ReprojImage, _super);
      /**
       * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
       * @param {import("../proj/Projection.js").default} targetProj Target projection.
       * @param {import("../extent.js").Extent} targetExtent Target extent.
       * @param {number} targetResolution Target resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {FunctionType} getImageFunction
       *     Function returning source images (extent, resolution, pixelRatio).
       * @param {object=} opt_contextOptions Properties to set on the canvas context.
       */
      function ReprojImage(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction, opt_contextOptions) {
          var _this = this;
          var maxSourceExtent = sourceProj.getExtent();
          var maxTargetExtent = targetProj.getExtent();
          var limitedTargetExtent = maxTargetExtent
              ? getIntersection(targetExtent, maxTargetExtent)
              : targetExtent;
          var targetCenter = getCenter(limitedTargetExtent);
          var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
          var errorThresholdInPixels = ERROR_THRESHOLD;
          var triangulation = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
          var sourceExtent = triangulation.calculateSourceExtent();
          var sourceImage = getImageFunction(sourceExtent, sourceResolution, pixelRatio);
          var state = sourceImage ? ImageState.IDLE : ImageState.EMPTY;
          var sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;
          _this = _super.call(this, targetExtent, targetResolution, sourcePixelRatio, state) || this;
          /**
           * @private
           * @type {import("../proj/Projection.js").default}
           */
          _this.targetProj_ = targetProj;
          /**
           * @private
           * @type {import("../extent.js").Extent}
           */
          _this.maxSourceExtent_ = maxSourceExtent;
          /**
           * @private
           * @type {!import("./Triangulation.js").default}
           */
          _this.triangulation_ = triangulation;
          /**
           * @private
           * @type {number}
           */
          _this.targetResolution_ = targetResolution;
          /**
           * @private
           * @type {import("../extent.js").Extent}
           */
          _this.targetExtent_ = targetExtent;
          /**
           * @private
           * @type {import("../ImageBase.js").default}
           */
          _this.sourceImage_ = sourceImage;
          /**
           * @private
           * @type {number}
           */
          _this.sourcePixelRatio_ = sourcePixelRatio;
          /**
           * @private
           * @type {object}
           */
          _this.contextOptions_ = opt_contextOptions;
          /**
           * @private
           * @type {HTMLCanvasElement}
           */
          _this.canvas_ = null;
          /**
           * @private
           * @type {?import("../events.js").EventsKey}
           */
          _this.sourceListenerKey_ = null;
          return _this;
      }
      /**
       * Clean up.
       */
      ReprojImage.prototype.disposeInternal = function () {
          if (this.state == ImageState.LOADING) {
              this.unlistenSource_();
          }
          _super.prototype.disposeInternal.call(this);
      };
      /**
       * @return {HTMLCanvasElement} Image.
       */
      ReprojImage.prototype.getImage = function () {
          return this.canvas_;
      };
      /**
       * @return {import("../proj/Projection.js").default} Projection.
       */
      ReprojImage.prototype.getProjection = function () {
          return this.targetProj_;
      };
      /**
       * @private
       */
      ReprojImage.prototype.reproject_ = function () {
          var sourceState = this.sourceImage_.getState();
          if (sourceState == ImageState.LOADED) {
              var width = getWidth(this.targetExtent_) / this.targetResolution_;
              var height = getHeight(this.targetExtent_) / this.targetResolution_;
              this.canvas_ = render(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [
                  {
                      extent: this.sourceImage_.getExtent(),
                      image: this.sourceImage_.getImage(),
                  },
              ], 0, undefined, this.contextOptions_);
          }
          this.state = sourceState;
          this.changed();
      };
      /**
       * Load not yet loaded URI.
       */
      ReprojImage.prototype.load = function () {
          if (this.state == ImageState.IDLE) {
              this.state = ImageState.LOADING;
              this.changed();
              var sourceState = this.sourceImage_.getState();
              if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {
                  this.reproject_();
              }
              else {
                  this.sourceListenerKey_ = listen(this.sourceImage_, EventType.CHANGE, function (e) {
                      var sourceState = this.sourceImage_.getState();
                      if (sourceState == ImageState.LOADED ||
                          sourceState == ImageState.ERROR) {
                          this.unlistenSource_();
                          this.reproject_();
                      }
                  }, this);
                  this.sourceImage_.load();
              }
          }
      };
      /**
       * @private
       */
      ReprojImage.prototype.unlistenSource_ = function () {
          unlistenByKey(
          /** @type {!import("../events.js").EventsKey} */ (this.sourceListenerKey_));
          this.sourceListenerKey_ = null;
      };
      return ReprojImage;
  }(ImageBase));

  var __extends$1n = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @enum {string}
   */
  var ImageSourceEventType = {
      /**
       * Triggered when an image starts loading.
       * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
       * @api
       */
      IMAGELOADSTART: 'imageloadstart',
      /**
       * Triggered when an image finishes loading.
       * @event module:ol/source/Image.ImageSourceEvent#imageloadend
       * @api
       */
      IMAGELOADEND: 'imageloadend',
      /**
       * Triggered if image loading results in an error.
       * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
       * @api
       */
      IMAGELOADERROR: 'imageloaderror',
  };
  /**
   * @classdesc
   * Events emitted by {@link module:ol/source/Image~ImageSource} instances are instances of this
   * type.
   */
  var ImageSourceEvent = /** @class */ (function (_super) {
      __extends$1n(ImageSourceEvent, _super);
      /**
       * @param {string} type Type.
       * @param {import("../Image.js").default} image The image.
       */
      function ImageSourceEvent(type, image) {
          var _this = _super.call(this, type) || this;
          /**
           * The image related to the event.
           * @type {import("../Image.js").default}
           * @api
           */
          _this.image = image;
          return _this;
      }
      return ImageSourceEvent;
  }(BaseEvent));
  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions]
   * @property {boolean} [imageSmoothing=true] Enable image smoothing.
   * @property {import("../proj.js").ProjectionLike} [projection]
   * @property {Array<number>} [resolutions]
   * @property {import("./State.js").default} [state]
   */
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Base class for sources providing a single image.
   * @abstract
   * @fires module:ol/source/Image.ImageSourceEvent
   * @api
   */
  var ImageSource = /** @class */ (function (_super) {
      __extends$1n(ImageSource, _super);
      /**
       * @param {Options} options Single image source options.
       */
      function ImageSource(options) {
          var _this = _super.call(this, {
              attributions: options.attributions,
              projection: options.projection,
              state: options.state,
          }) || this;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.resolutions_ =
              options.resolutions !== undefined ? options.resolutions : null;
          /**
           * @private
           * @type {import("../reproj/Image.js").default}
           */
          _this.reprojectedImage_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.reprojectedRevision_ = 0;
          /**
           * @private
           * @type {object|undefined}
           */
          _this.contextOptions_ =
              options.imageSmoothing === false ? IMAGE_SMOOTHING_DISABLED : undefined;
          return _this;
      }
      /**
       * @return {Array<number>} Resolutions.
       */
      ImageSource.prototype.getResolutions = function () {
          return this.resolutions_;
      };
      /**
       * @return {Object|undefined} Context options.
       */
      ImageSource.prototype.getContextOptions = function () {
          return this.contextOptions_;
      };
      /**
       * @protected
       * @param {number} resolution Resolution.
       * @return {number} Resolution.
       */
      ImageSource.prototype.findNearestResolution = function (resolution) {
          if (this.resolutions_) {
              var idx = linearFindNearest(this.resolutions_, resolution, 0);
              resolution = this.resolutions_[idx];
          }
          return resolution;
      };
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {import("../ImageBase.js").default} Single image.
       */
      ImageSource.prototype.getImage = function (extent, resolution, pixelRatio, projection) {
          var sourceProjection = this.getProjection();
          if (!sourceProjection ||
              !projection ||
              equivalent(sourceProjection, projection)) {
              if (sourceProjection) {
                  projection = sourceProjection;
              }
              return this.getImageInternal(extent, resolution, pixelRatio, projection);
          }
          else {
              if (this.reprojectedImage_) {
                  if (this.reprojectedRevision_ == this.getRevision() &&
                      equivalent(this.reprojectedImage_.getProjection(), projection) &&
                      this.reprojectedImage_.getResolution() == resolution &&
                      equals$1(this.reprojectedImage_.getExtent(), extent)) {
                      return this.reprojectedImage_;
                  }
                  this.reprojectedImage_.dispose();
                  this.reprojectedImage_ = null;
              }
              this.reprojectedImage_ = new ReprojImage(sourceProjection, projection, extent, resolution, pixelRatio, function (extent, resolution, pixelRatio) {
                  return this.getImageInternal(extent, resolution, pixelRatio, sourceProjection);
              }.bind(this), this.contextOptions_);
              this.reprojectedRevision_ = this.getRevision();
              return this.reprojectedImage_;
          }
      };
      /**
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {import("../ImageBase.js").default} Single image.
       * @protected
       */
      ImageSource.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
          return abstract();
      };
      /**
       * Handle image change events.
       * @param {import("../events/Event.js").default} event Event.
       * @protected
       */
      ImageSource.prototype.handleImageChange = function (event) {
          var image = /** @type {import("../Image.js").default} */ (event.target);
          switch (image.getState()) {
              case ImageState.LOADING:
                  this.loading = true;
                  this.dispatchEvent(new ImageSourceEvent(ImageSourceEventType.IMAGELOADSTART, image));
                  break;
              case ImageState.LOADED:
                  this.loading = false;
                  this.dispatchEvent(new ImageSourceEvent(ImageSourceEventType.IMAGELOADEND, image));
                  break;
              case ImageState.ERROR:
                  this.loading = false;
                  this.dispatchEvent(new ImageSourceEvent(ImageSourceEventType.IMAGELOADERROR, image));
                  break;
              default:
              // pass
          }
      };
      return ImageSource;
  }(Source));
  /**
   * Default image load function for image sources that use import("../Image.js").Image image
   * instances.
   * @param {import("../Image.js").default} image Image.
   * @param {string} src Source.
   */
  function defaultImageLoadFunction(image, src) {
      /** @type {HTMLImageElement|HTMLVideoElement} */ (image.getImage()).src = src;
  }

  /**
   * @module ol/source/ImageStatic
   */
  var __extends$1o = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
   * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
   * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
   * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
   * @property {import("../extent.js").Extent} [imageExtent] Extent of the image in map coordinates.
   * This is the [left, bottom, right, top] map coordinates of your image.
   * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
   * @property {boolean} [imageSmoothing=true] Enable image smoothing.
   * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
   * @property {import("../size.js").Size} [imageSize] Size of the image in pixels. Usually the image size is auto-detected, so this
   * only needs to be set if auto-detection fails for some reason.
   * @property {string} url Image URL.
   */
  /**
   * @classdesc
   * A layer source for displaying a single, static image.
   * @api
   */
  var Static = /** @class */ (function (_super) {
      __extends$1o(Static, _super);
      /**
       * @param {Options} options ImageStatic options.
       */
      function Static(options) {
          var _this = this;
          var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
          var /** @type {import("../Image.js").LoadFunction} */ imageLoadFunction = options.imageLoadFunction !== undefined
              ? options.imageLoadFunction
              : defaultImageLoadFunction;
          _this = _super.call(this, {
              attributions: options.attributions,
              imageSmoothing: options.imageSmoothing,
              projection: get$3(options.projection),
          }) || this;
          /**
           * @private
           * @type {string}
           */
          _this.url_ = options.url;
          /**
           * @private
           * @type {import("../extent.js").Extent}
           */
          _this.imageExtent_ = options.imageExtent;
          /**
           * @private
           * @type {import("../Image.js").default}
           */
          _this.image_ = new ImageWrapper(_this.imageExtent_, undefined, 1, _this.url_, crossOrigin, imageLoadFunction);
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          _this.imageSize_ = options.imageSize ? options.imageSize : null;
          _this.image_.addEventListener(EventType.CHANGE, _this.handleImageChange.bind(_this));
          return _this;
      }
      /**
       * Returns the image extent
       * @return {import("../extent.js").Extent} image extent.
       * @api
       */
      Static.prototype.getImageExtent = function () {
          return this.imageExtent_;
      };
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {import("../Image.js").default} Single image.
       */
      Static.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
          if (intersects(extent, this.image_.getExtent())) {
              return this.image_;
          }
          return null;
      };
      /**
       * Return the URL used for this image source.
       * @return {string} URL.
       * @api
       */
      Static.prototype.getUrl = function () {
          return this.url_;
      };
      /**
       * @param {import("../events/Event.js").default} evt Event.
       */
      Static.prototype.handleImageChange = function (evt) {
          if (this.image_.getState() == ImageState.LOADED) {
              var imageExtent = this.image_.getExtent();
              var image = this.image_.getImage();
              var imageWidth = void 0, imageHeight = void 0;
              if (this.imageSize_) {
                  imageWidth = this.imageSize_[0];
                  imageHeight = this.imageSize_[1];
              }
              else {
                  imageWidth = image.width;
                  imageHeight = image.height;
              }
              var resolution = getHeight(imageExtent) / imageHeight;
              var targetWidth = Math.ceil(getWidth(imageExtent) / resolution);
              if (targetWidth != imageWidth) {
                  var context = createCanvasContext2D(targetWidth, imageHeight);
                  assign(context, this.getContextOptions());
                  var canvas = context.canvas;
                  context.drawImage(image, 0, 0, imageWidth, imageHeight, 0, 0, canvas.width, canvas.height);
                  this.image_.setImage(canvas);
              }
          }
          _super.prototype.handleImageChange.call(this, evt);
      };
      return Static;
  }(ImageSource));

  /**
   * @module ol/layer/TileProperty
   */
  /**
   * @enum {string}
   */
  var TileProperty = {
      PRELOAD: 'preload',
      USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',
  };

  var __extends$1p = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
   * means no preloading.
   * @property {import("../source/Tile.js").default} [source] Source for this layer.
   * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
   * this layer in its layers collection, and the layer will be rendered on top. This is useful for
   * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
   * use {@link module:ol/Map#addLayer}.
   * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
   */
  /**
   * @classdesc
   * For layer sources that provide pre-rendered, tiled images in grids that are
   * organized by zoom levels for specific resolutions.
   * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
   * property on the layer object; for example, setting `title: 'My Title'` in the
   * options means that `title` is observable, and has get/set accessors.
   *
   * @extends {Layer<import("../source/Tile.js").default>}
   * @api
   */
  var BaseTileLayer = /** @class */ (function (_super) {
      __extends$1p(BaseTileLayer, _super);
      /**
       * @param {Options=} opt_options Tile layer options.
       */
      function BaseTileLayer(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var baseOptions = assign({}, options);
          delete baseOptions.preload;
          delete baseOptions.useInterimTilesOnError;
          _this = _super.call(this, baseOptions) || this;
          _this.setPreload(options.preload !== undefined ? options.preload : 0);
          _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined
              ? options.useInterimTilesOnError
              : true);
          return _this;
      }
      /**
       * Return the level as number to which we will preload tiles up to.
       * @return {number} The level to preload tiles up to.
       * @observable
       * @api
       */
      BaseTileLayer.prototype.getPreload = function () {
          return /** @type {number} */ (this.get(TileProperty.PRELOAD));
      };
      /**
       * Set the level as number to which we will preload tiles up to.
       * @param {number} preload The level to preload tiles up to.
       * @observable
       * @api
       */
      BaseTileLayer.prototype.setPreload = function (preload) {
          this.set(TileProperty.PRELOAD, preload);
      };
      /**
       * Whether we use interim tiles on error.
       * @return {boolean} Use interim tiles on error.
       * @observable
       * @api
       */
      BaseTileLayer.prototype.getUseInterimTilesOnError = function () {
          return /** @type {boolean} */ (this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR));
      };
      /**
       * Set whether we use interim tiles on error.
       * @param {boolean} useInterimTilesOnError Use interim tiles on error.
       * @observable
       * @api
       */
      BaseTileLayer.prototype.setUseInterimTilesOnError = function (useInterimTilesOnError) {
          this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
      };
      return BaseTileLayer;
  }(Layer));

  /**
   * @module ol/TileRange
   */
  /**
   * A representation of a contiguous block of tiles.  A tile range is specified
   * by its min/max tile coordinates and is inclusive of coordinates.
   */
  var TileRange = /** @class */ (function () {
      /**
       * @param {number} minX Minimum X.
       * @param {number} maxX Maximum X.
       * @param {number} minY Minimum Y.
       * @param {number} maxY Maximum Y.
       */
      function TileRange(minX, maxX, minY, maxY) {
          /**
           * @type {number}
           */
          this.minX = minX;
          /**
           * @type {number}
           */
          this.maxX = maxX;
          /**
           * @type {number}
           */
          this.minY = minY;
          /**
           * @type {number}
           */
          this.maxY = maxY;
      }
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @return {boolean} Contains tile coordinate.
       */
      TileRange.prototype.contains = function (tileCoord) {
          return this.containsXY(tileCoord[1], tileCoord[2]);
      };
      /**
       * @param {TileRange} tileRange Tile range.
       * @return {boolean} Contains.
       */
      TileRange.prototype.containsTileRange = function (tileRange) {
          return (this.minX <= tileRange.minX &&
              tileRange.maxX <= this.maxX &&
              this.minY <= tileRange.minY &&
              tileRange.maxY <= this.maxY);
      };
      /**
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @return {boolean} Contains coordinate.
       */
      TileRange.prototype.containsXY = function (x, y) {
          return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
      };
      /**
       * @param {TileRange} tileRange Tile range.
       * @return {boolean} Equals.
       */
      TileRange.prototype.equals = function (tileRange) {
          return (this.minX == tileRange.minX &&
              this.minY == tileRange.minY &&
              this.maxX == tileRange.maxX &&
              this.maxY == tileRange.maxY);
      };
      /**
       * @param {TileRange} tileRange Tile range.
       */
      TileRange.prototype.extend = function (tileRange) {
          if (tileRange.minX < this.minX) {
              this.minX = tileRange.minX;
          }
          if (tileRange.maxX > this.maxX) {
              this.maxX = tileRange.maxX;
          }
          if (tileRange.minY < this.minY) {
              this.minY = tileRange.minY;
          }
          if (tileRange.maxY > this.maxY) {
              this.maxY = tileRange.maxY;
          }
      };
      /**
       * @return {number} Height.
       */
      TileRange.prototype.getHeight = function () {
          return this.maxY - this.minY + 1;
      };
      /**
       * @return {import("./size.js").Size} Size.
       */
      TileRange.prototype.getSize = function () {
          return [this.getWidth(), this.getHeight()];
      };
      /**
       * @return {number} Width.
       */
      TileRange.prototype.getWidth = function () {
          return this.maxX - this.minX + 1;
      };
      /**
       * @param {TileRange} tileRange Tile range.
       * @return {boolean} Intersects.
       */
      TileRange.prototype.intersects = function (tileRange) {
          return (this.minX <= tileRange.maxX &&
              this.maxX >= tileRange.minX &&
              this.minY <= tileRange.maxY &&
              this.maxY >= tileRange.minY);
      };
      return TileRange;
  }());
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   * @param {TileRange=} tileRange TileRange.
   * @return {TileRange} Tile range.
   */
  function createOrUpdate$1(minX, maxX, minY, maxY, tileRange) {
      if (tileRange !== undefined) {
          tileRange.minX = minX;
          tileRange.maxX = maxX;
          tileRange.minY = minY;
          tileRange.maxY = maxY;
          return tileRange;
      }
      else {
          return new TileRange(minX, maxX, minY, maxY);
      }
  }

  var __extends$1q = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Canvas renderer for tile layers.
   * @api
   */
  var CanvasTileLayerRenderer = /** @class */ (function (_super) {
      __extends$1q(CanvasTileLayerRenderer, _super);
      /**
       * @param {import("../../layer/Tile.js").default|import("../../layer/VectorTile.js").default} tileLayer Tile layer.
       */
      function CanvasTileLayerRenderer(tileLayer) {
          var _this = _super.call(this, tileLayer) || this;
          /**
           * Rendered extent has changed since the previous `renderFrame()` call
           * @type {boolean}
           */
          _this.extentChanged = true;
          /**
           * @private
           * @type {?import("../../extent.js").Extent}
           */
          _this.renderedExtent_ = null;
          /**
           * @protected
           * @type {number}
           */
          _this.renderedPixelRatio;
          /**
           * @protected
           * @type {import("../../proj/Projection.js").default}
           */
          _this.renderedProjection = null;
          /**
           * @protected
           * @type {number}
           */
          _this.renderedRevision;
          /**
           * @protected
           * @type {!Array<import("../../Tile.js").default>}
           */
          _this.renderedTiles = [];
          /**
           * @private
           * @type {boolean}
           */
          _this.newTiles_ = false;
          /**
           * @protected
           * @type {import("../../extent.js").Extent}
           */
          _this.tmpExtent = createEmpty();
          /**
           * @private
           * @type {import("../../TileRange.js").default}
           */
          _this.tmpTileRange_ = new TileRange(0, 0, 0, 0);
          return _this;
      }
      /**
       * @protected
       * @param {import("../../Tile.js").default} tile Tile.
       * @return {boolean} Tile is drawable.
       */
      CanvasTileLayerRenderer.prototype.isDrawableTile = function (tile) {
          var tileLayer = this.getLayer();
          var tileState = tile.getState();
          var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
          return (tileState == TileState.LOADED ||
              tileState == TileState.EMPTY ||
              (tileState == TileState.ERROR && !useInterimTilesOnError));
      };
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @return {!import("../../Tile.js").default} Tile.
       */
      CanvasTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {
          var pixelRatio = frameState.pixelRatio;
          var projection = frameState.viewState.projection;
          var tileLayer = this.getLayer();
          var tileSource = tileLayer.getSource();
          var tile = tileSource.getTile(z, x, y, pixelRatio, projection);
          if (tile.getState() == TileState.ERROR) {
              if (!tileLayer.getUseInterimTilesOnError()) {
                  // When useInterimTilesOnError is false, we consider the error tile as loaded.
                  tile.setState(TileState.LOADED);
              }
              else if (tileLayer.getPreload() > 0) {
                  // Preloaded tiles for lower resolutions might have finished loading.
                  this.newTiles_ = true;
              }
          }
          if (!this.isDrawableTile(tile)) {
              tile = tile.getInterimTile();
          }
          return tile;
      };
      /**
       * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @param {number} zoom Zoom level.
       * @param {import("../../Tile.js").default} tile Tile.
       * @return {boolean|void} If `false`, the tile will not be considered loaded.
       */
      CanvasTileLayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {
          if (this.isDrawableTile(tile)) {
              return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);
          }
          return false;
      };
      /**
       * Determine whether render should be called.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      CanvasTileLayerRenderer.prototype.prepareFrame = function (frameState) {
          return !!this.getLayer().getSource();
      };
      /**
       * Render the layer.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target that may be used to render content to.
       * @return {HTMLElement} The rendered element.
       */
      CanvasTileLayerRenderer.prototype.renderFrame = function (frameState, target) {
          var layerState = frameState.layerStatesArray[frameState.layerIndex];
          var viewState = frameState.viewState;
          var projection = viewState.projection;
          var viewResolution = viewState.resolution;
          var viewCenter = viewState.center;
          var rotation = viewState.rotation;
          var pixelRatio = frameState.pixelRatio;
          var tileLayer = this.getLayer();
          var tileSource = tileLayer.getSource();
          var sourceRevision = tileSource.getRevision();
          var tileGrid = tileSource.getTileGridForProjection(projection);
          var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
          var tileResolution = tileGrid.getResolution(z);
          var extent = frameState.extent;
          var layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);
          if (layerExtent) {
              extent = getIntersection(extent, fromUserExtent(layerState.extent, projection));
          }
          var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
          // desired dimensions of the canvas in pixels
          var width = Math.round(frameState.size[0] * tilePixelRatio);
          var height = Math.round(frameState.size[1] * tilePixelRatio);
          if (rotation) {
              var size = Math.round(Math.sqrt(width * width + height * height));
              width = size;
              height = size;
          }
          var dx = (tileResolution * width) / 2 / tilePixelRatio;
          var dy = (tileResolution * height) / 2 / tilePixelRatio;
          var canvasExtent = [
              viewCenter[0] - dx,
              viewCenter[1] - dy,
              viewCenter[0] + dx,
              viewCenter[1] + dy,
          ];
          var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
          /**
           * @type {Object<number, Object<string, import("../../Tile.js").default>>}
           */
          var tilesToDrawByZ = {};
          tilesToDrawByZ[z] = {};
          var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
          var tmpExtent = this.tmpExtent;
          var tmpTileRange = this.tmpTileRange_;
          this.newTiles_ = false;
          for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
              for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
                  var tile = this.getTile(z, x, y, frameState);
                  if (this.isDrawableTile(tile)) {
                      var uid = getUid(this);
                      if (tile.getState() == TileState.LOADED) {
                          tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
                          var inTransition = tile.inTransition(uid);
                          if (!this.newTiles_ &&
                              (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
                              this.newTiles_ = true;
                          }
                      }
                      if (tile.getAlpha(uid, frameState.time) === 1) {
                          // don't look for alt tiles if alpha is 1
                          continue;
                      }
                  }
                  var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
                  var covered = false;
                  if (childTileRange) {
                      covered = findLoadedTiles(z + 1, childTileRange);
                  }
                  if (!covered) {
                      tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);
                  }
              }
          }
          var canvasScale = tileResolution / viewResolution;
          // set forward and inverse pixel transforms
          compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / tilePixelRatio, 1 / tilePixelRatio, rotation, -width / 2, -height / 2);
          var canvasTransform = createTransformString(this.pixelTransform);
          this.useContainer(target, canvasTransform, layerState.opacity);
          var context = this.context;
          var canvas = context.canvas;
          makeInverse(this.inversePixelTransform, this.pixelTransform);
          // set scale transform for calculating tile positions on the canvas
          compose(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);
          if (canvas.width != width || canvas.height != height) {
              canvas.width = width;
              canvas.height = height;
          }
          else if (!this.containerReused) {
              context.clearRect(0, 0, width, height);
          }
          if (layerExtent) {
              this.clipUnrotated(context, frameState, layerExtent);
          }
          assign(context, tileSource.getContextOptions());
          this.preRender(context, frameState);
          this.renderedTiles.length = 0;
          /** @type {Array<number>} */
          var zs = Object.keys(tilesToDrawByZ).map(Number);
          zs.sort(numberSafeCompareFunction);
          var clips, clipZs, currentClip;
          if (layerState.opacity === 1 &&
              (!this.containerReused ||
                  tileSource.getOpaque(frameState.viewState.projection))) {
              zs = zs.reverse();
          }
          else {
              clips = [];
              clipZs = [];
          }
          for (var i = zs.length - 1; i >= 0; --i) {
              var currentZ = zs[i];
              var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
              var currentResolution = tileGrid.getResolution(currentZ);
              var currentScale = currentResolution / tileResolution;
              var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;
              var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;
              var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);
              var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
              var origin_1 = apply$1(this.tempTransform, [
                  (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /
                      tileResolution,
                  (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /
                      tileResolution,
              ]);
              var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
              var tilesToDraw = tilesToDrawByZ[currentZ];
              for (var tileCoordKey in tilesToDraw) {
                  var tile = /** @type {import("../../ImageTile.js").default} */ (tilesToDraw[tileCoordKey]);
                  var tileCoord = tile.tileCoord;
                  // Calculate integer positions and sizes so that tiles align
                  var floatX = origin_1[0] - (originTileCoord[1] - tileCoord[1]) * dx_1;
                  var nextX = Math.round(floatX + dx_1);
                  var floatY = origin_1[1] - (originTileCoord[2] - tileCoord[2]) * dy_1;
                  var nextY = Math.round(floatY + dy_1);
                  var x = Math.round(floatX);
                  var y = Math.round(floatY);
                  var w = nextX - x;
                  var h = nextY - y;
                  var transition = z === currentZ;
                  var inTransition = transition && tile.getAlpha(getUid(this), frameState.time) !== 1;
                  if (!inTransition) {
                      if (clips) {
                          // Clip mask for regions in this tile that already filled by a higher z tile
                          context.save();
                          currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
                          for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {
                              if (z !== currentZ && currentZ < clipZs[i_1]) {
                                  var clip = clips[i_1];
                                  context.beginPath();
                                  // counter-clockwise (outer ring) for current tile
                                  context.moveTo(currentClip[0], currentClip[1]);
                                  context.lineTo(currentClip[2], currentClip[3]);
                                  context.lineTo(currentClip[4], currentClip[5]);
                                  context.lineTo(currentClip[6], currentClip[7]);
                                  // clockwise (inner ring) for higher z tile
                                  context.moveTo(clip[6], clip[7]);
                                  context.lineTo(clip[4], clip[5]);
                                  context.lineTo(clip[2], clip[3]);
                                  context.lineTo(clip[0], clip[1]);
                                  context.clip();
                              }
                          }
                          clips.push(currentClip);
                          clipZs.push(currentZ);
                      }
                      else {
                          context.clearRect(x, y, w, h);
                      }
                  }
                  this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition, layerState.opacity);
                  if (clips && !inTransition) {
                      context.restore();
                  }
                  this.renderedTiles.push(tile);
                  this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
              }
          }
          this.renderedRevision = sourceRevision;
          this.renderedResolution = tileResolution;
          this.extentChanged =
              !this.renderedExtent_ || !equals$1(this.renderedExtent_, canvasExtent);
          this.renderedExtent_ = canvasExtent;
          this.renderedPixelRatio = pixelRatio;
          this.renderedProjection = projection;
          this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
          this.scheduleExpireCache(frameState, tileSource);
          this.postRender(context, frameState);
          if (layerState.extent) {
              context.restore();
          }
          if (canvasTransform !== canvas.style.transform) {
              canvas.style.transform = canvasTransform;
          }
          return this.container;
      };
      /**
       * @param {import("../../ImageTile.js").default} tile Tile.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {number} x Left of the tile.
       * @param {number} y Top of the tile.
       * @param {number} w Width of the tile.
       * @param {number} h Height of the tile.
       * @param {number} gutter Tile gutter.
       * @param {boolean} transition Apply an alpha transition.
       * @param {number} opacity Opacity.
       */
      CanvasTileLayerRenderer.prototype.drawTileImage = function (tile, frameState, x, y, w, h, gutter, transition, opacity) {
          var image = this.getTileImage(tile);
          if (!image) {
              return;
          }
          var uid = getUid(this);
          var tileAlpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
          var alpha = opacity * tileAlpha;
          var alphaChanged = alpha !== this.context.globalAlpha;
          if (alphaChanged) {
              this.context.save();
              this.context.globalAlpha = alpha;
          }
          this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);
          if (alphaChanged) {
              this.context.restore();
          }
          if (tileAlpha !== 1) {
              frameState.animate = true;
          }
          else if (transition) {
              tile.endTransition(uid);
          }
      };
      /**
       * @return {HTMLCanvasElement} Image
       */
      CanvasTileLayerRenderer.prototype.getImage = function () {
          var context = this.context;
          return context ? context.canvas : null;
      };
      /**
       * Get the image from a tile.
       * @param {import("../../ImageTile.js").default} tile Tile.
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       * @protected
       */
      CanvasTileLayerRenderer.prototype.getTileImage = function (tile) {
          return tile.getImage();
      };
      /**
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @protected
       */
      CanvasTileLayerRenderer.prototype.scheduleExpireCache = function (frameState, tileSource) {
          if (tileSource.canExpireCache()) {
              /**
               * @param {import("../../source/Tile.js").default} tileSource Tile source.
               * @param {import("../../PluggableMap.js").default} map Map.
               * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
               */
              var postRenderFunction = function (tileSource, map, frameState) {
                  var tileSourceKey = getUid(tileSource);
                  if (tileSourceKey in frameState.usedTiles) {
                      tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
                  }
              }.bind(null, tileSource);
              frameState.postRenderFunctions.push(
              /** @type {import("../../PluggableMap.js").PostRenderFunction} */ (postRenderFunction));
          }
      };
      /**
       * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @param {import('../../Tile.js').default} tile Tile.
       * @protected
       */
      CanvasTileLayerRenderer.prototype.updateUsedTiles = function (usedTiles, tileSource, tile) {
          // FIXME should we use tilesToDrawByZ instead?
          var tileSourceKey = getUid(tileSource);
          if (!(tileSourceKey in usedTiles)) {
              usedTiles[tileSourceKey] = {};
          }
          usedTiles[tileSourceKey][tile.getKey()] = true;
      };
      /**
       * Manage tile pyramid.
       * This function performs a number of functions related to the tiles at the
       * current zoom and lower zoom levels:
       * - registers idle tiles in frameState.wantedTiles so that they are not
       *   discarded by the tile queue
       * - enqueues missing tiles
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../../proj/Projection.js").default} projection Projection.
       * @param {import("../../extent.js").Extent} extent Extent.
       * @param {number} currentZ Current Z.
       * @param {number} preload Load low resolution tiles up to 'preload' levels.
       * @param {function(import("../../Tile.js").default)=} opt_tileCallback Tile callback.
       * @protected
       */
      CanvasTileLayerRenderer.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {
          var tileSourceKey = getUid(tileSource);
          if (!(tileSourceKey in frameState.wantedTiles)) {
              frameState.wantedTiles[tileSourceKey] = {};
          }
          var wantedTiles = frameState.wantedTiles[tileSourceKey];
          var tileQueue = frameState.tileQueue;
          var minZoom = tileGrid.getMinZoom();
          var tileCount = 0;
          var tile, tileRange, tileResolution, x, y, z;
          for (z = minZoom; z <= currentZ; ++z) {
              tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
              tileResolution = tileGrid.getResolution(z);
              for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
                  for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
                      if (currentZ - z <= preload) {
                          ++tileCount;
                          tile = tileSource.getTile(z, x, y, pixelRatio, projection);
                          if (tile.getState() == TileState.IDLE) {
                              wantedTiles[tile.getKey()] = true;
                              if (!tileQueue.isKeyQueued(tile.getKey())) {
                                  tileQueue.enqueue([
                                      tile,
                                      tileSourceKey,
                                      tileGrid.getTileCoordCenter(tile.tileCoord),
                                      tileResolution,
                                  ]);
                              }
                          }
                          if (opt_tileCallback !== undefined) {
                              opt_tileCallback(tile);
                          }
                      }
                      else {
                          tileSource.useTile(z, x, y, projection);
                      }
                  }
              }
          }
          tileSource.updateCacheSize(tileCount, projection);
      };
      return CanvasTileLayerRenderer;
  }(CanvasLayerRenderer));
  /**
   * @function
   * @return {import("../../layer/Tile.js").default|import("../../layer/VectorTile.js").default}
   */
  CanvasTileLayerRenderer.prototype.getLayer;

  var __extends$1r = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * For layer sources that provide pre-rendered, tiled images in grids that are
   * organized by zoom levels for specific resolutions.
   * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
   * property on the layer object; for example, setting `title: 'My Title'` in the
   * options means that `title` is observable, and has get/set accessors.
   *
   * @api
   */
  var TileLayer = /** @class */ (function (_super) {
      __extends$1r(TileLayer, _super);
      /**
       * @param {import("./BaseTile.js").Options=} opt_options Tile layer options.
       */
      function TileLayer(opt_options) {
          return _super.call(this, opt_options) || this;
      }
      /**
       * Create a renderer for this layer.
       * @return {import("../renderer/Layer.js").default} A layer renderer.
       * @protected
       */
      TileLayer.prototype.createRenderer = function () {
          return new CanvasTileLayerRenderer(this);
      };
      return TileLayer;
  }(BaseTileLayer));

  var __extends$1s = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * A function that takes an {@link module:ol/Tile} for the tile and a
   * `{string}` for the url as arguments. The default is
   * ```js
   * source.setTileLoadFunction(function(tile, src) {
   *   tile.getImage().src = src;
   * });
   * ```
   * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
   * error handling:
   *
   * ```js
   * import TileState from 'ol/TileState';
   *
   * source.setTileLoadFunction(function(tile, src) {
   *   var xhr = new XMLHttpRequest();
   *   xhr.responseType = 'blob';
   *   xhr.addEventListener('loadend', function (evt) {
   *     var data = this.response;
   *     if (data !== undefined) {
   *       tile.getImage().src = URL.createObjectURL(data);
   *     } else {
   *       tile.setState(TileState.ERROR);
   *     }
   *   });
   *   xhr.addEventListener('error', function () {
   *     tile.setState(TileState.ERROR);
   *   });
   *   xhr.open('GET', src);
   *   xhr.send();
   * });
   * ```
   *
   * @typedef {function(Tile, string): void} LoadFunction
   * @api
   */
  /**
   * {@link module:ol/source/Tile~Tile} sources use a function of this type to get
   * the url that provides a tile for a given tile coordinate.
   *
   * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
   * coordinate, a `{number}` representing the pixel ratio and a
   * {@link module:ol/proj/Projection} for the projection  as arguments
   * and returns a `{string}` representing the tile URL, or undefined if no tile
   * should be requested for the passed tile coordinate.
   *
   * @typedef {function(import("./tilecoord.js").TileCoord, number,
   *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
   * @api
   */
  /**
   * @typedef {Object} Options
   * @property {number} [transition=250] A duration for tile opacity
   * transitions in milliseconds. A duration of 0 disables the opacity transition.
   * @api
   */
  /**
   * @classdesc
   * Base class for tiles.
   *
   * @abstract
   */
  var Tile = /** @class */ (function (_super) {
      __extends$1s(Tile, _super);
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("./TileState.js").default} state State.
       * @param {Options=} opt_options Tile options.
       */
      function Tile(tileCoord, state, opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @type {import("./tilecoord.js").TileCoord}
           */
          _this.tileCoord = tileCoord;
          /**
           * @protected
           * @type {import("./TileState.js").default}
           */
          _this.state = state;
          /**
           * An "interim" tile for this tile. The interim tile may be used while this
           * one is loading, for "smooth" transitions when changing params/dimensions
           * on the source.
           * @type {Tile}
           */
          _this.interimTile = null;
          /**
           * The tile is available at the highest possible resolution. Subclasses can
           * set this to `false` initially. Tile load listeners will not be
           * unregistered before this is set to `true` and a `#changed()` is called.
           * @type {boolean}
           */
          _this.hifi = true;
          /**
           * A key assigned to the tile. This is used by the tile source to determine
           * if this tile can effectively be used, or if a new tile should be created
           * and this one be used as an interim tile for this new tile.
           * @type {string}
           */
          _this.key = '';
          /**
           * The duration for the opacity transition.
           * @type {number}
           */
          _this.transition_ =
              options.transition === undefined ? 250 : options.transition;
          /**
           * Lookup of start times for rendering transitions.  If the start time is
           * equal to -1, the transition is complete.
           * @type {Object<string, number>}
           */
          _this.transitionStarts_ = {};
          return _this;
      }
      /**
       * @protected
       */
      Tile.prototype.changed = function () {
          this.dispatchEvent(EventType.CHANGE);
      };
      /**
       * Called by the tile cache when the tile is removed from the cache due to expiry
       */
      Tile.prototype.release = function () { };
      /**
       * @return {string} Key.
       */
      Tile.prototype.getKey = function () {
          return this.key + '/' + this.tileCoord;
      };
      /**
       * Get the interim tile most suitable for rendering using the chain of interim
       * tiles. This corresponds to the  most recent tile that has been loaded, if no
       * such tile exists, the original tile is returned.
       * @return {!Tile} Best tile for rendering.
       */
      Tile.prototype.getInterimTile = function () {
          if (!this.interimTile) {
              //empty chain
              return this;
          }
          var tile = this.interimTile;
          // find the first loaded tile and return it. Since the chain is sorted in
          // decreasing order of creation time, there is no need to search the remainder
          // of the list (all those tiles correspond to older requests and will be
          // cleaned up by refreshInterimChain)
          do {
              if (tile.getState() == TileState.LOADED) {
                  // Show tile immediately instead of fading it in after loading, because
                  // the interim tile is in place already
                  this.transition_ = 0;
                  return tile;
              }
              tile = tile.interimTile;
          } while (tile);
          // we can not find a better tile
          return this;
      };
      /**
       * Goes through the chain of interim tiles and discards sections of the chain
       * that are no longer relevant.
       */
      Tile.prototype.refreshInterimChain = function () {
          if (!this.interimTile) {
              return;
          }
          var tile = this.interimTile;
          var prev = /** @type {Tile} */ (this);
          do {
              if (tile.getState() == TileState.LOADED) {
                  //we have a loaded tile, we can discard the rest of the list
                  //we would could abort any LOADING tile request
                  //older than this tile (i.e. any LOADING tile following this entry in the chain)
                  tile.interimTile = null;
                  break;
              }
              else if (tile.getState() == TileState.LOADING) {
                  //keep this LOADING tile any loaded tiles later in the chain are
                  //older than this tile, so we're still interested in the request
                  prev = tile;
              }
              else if (tile.getState() == TileState.IDLE) {
                  //the head of the list is the most current tile, we don't need
                  //to start any other requests for this chain
                  prev.interimTile = tile.interimTile;
              }
              else {
                  prev = tile;
              }
              tile = prev.interimTile;
          } while (tile);
      };
      /**
       * Get the tile coordinate for this tile.
       * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
       * @api
       */
      Tile.prototype.getTileCoord = function () {
          return this.tileCoord;
      };
      /**
       * @return {import("./TileState.js").default} State.
       */
      Tile.prototype.getState = function () {
          return this.state;
      };
      /**
       * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
       * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
       * when the tile cannot be loaded. Otherwise the tile cannot be removed from
       * the tile queue and will block other requests.
       * @param {import("./TileState.js").default} state State.
       * @api
       */
      Tile.prototype.setState = function (state) {
          if (this.state !== TileState.ERROR && this.state > state) {
              throw new Error('Tile load sequence violation');
          }
          this.state = state;
          this.changed();
      };
      /**
       * Load the image or retry if loading previously failed.
       * Loading is taken care of by the tile queue, and calling this method is
       * only needed for preloading or for reloading in case of an error.
       * @abstract
       * @api
       */
      Tile.prototype.load = function () {
          abstract();
      };
      /**
       * Get the alpha value for rendering.
       * @param {string} id An id for the renderer.
       * @param {number} time The render frame time.
       * @return {number} A number between 0 and 1.
       */
      Tile.prototype.getAlpha = function (id, time) {
          if (!this.transition_) {
              return 1;
          }
          var start = this.transitionStarts_[id];
          if (!start) {
              start = time;
              this.transitionStarts_[id] = start;
          }
          else if (start === -1) {
              return 1;
          }
          var delta = time - start + 1000 / 60; // avoid rendering at 0
          if (delta >= this.transition_) {
              return 1;
          }
          return easeIn(delta / this.transition_);
      };
      /**
       * Determine if a tile is in an alpha transition.  A tile is considered in
       * transition if tile.getAlpha() has not yet been called or has been called
       * and returned 1.
       * @param {string} id An id for the renderer.
       * @return {boolean} The tile is in transition.
       */
      Tile.prototype.inTransition = function (id) {
          if (!this.transition_) {
              return false;
          }
          return this.transitionStarts_[id] !== -1;
      };
      /**
       * Mark a transition as complete.
       * @param {string} id An id for the renderer.
       */
      Tile.prototype.endTransition = function (id) {
          if (this.transition_) {
              this.transitionStarts_[id] = -1;
          }
      };
      return Tile;
  }(Target));

  var __extends$1t = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var ImageTile = /** @class */ (function (_super) {
      __extends$1t(ImageTile, _super);
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("./TileState.js").default} state State.
       * @param {string} src Image source URI.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
       * @param {import("./Tile.js").Options=} opt_options Tile options.
       */
      function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
          var _this = _super.call(this, tileCoord, state, opt_options) || this;
          /**
           * @private
           * @type {?string}
           */
          _this.crossOrigin_ = crossOrigin;
          /**
           * Image URI
           *
           * @private
           * @type {string}
           */
          _this.src_ = src;
          /**
           * @private
           * @type {HTMLImageElement|HTMLCanvasElement}
           */
          _this.image_ = new Image();
          if (crossOrigin !== null) {
              _this.image_.crossOrigin = crossOrigin;
          }
          /**
           * @private
           * @type {?function():void}
           */
          _this.unlisten_ = null;
          /**
           * @private
           * @type {import("./Tile.js").LoadFunction}
           */
          _this.tileLoadFunction_ = tileLoadFunction;
          return _this;
      }
      /**
       * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       * @api
       */
      ImageTile.prototype.getImage = function () {
          return this.image_;
      };
      /**
       * @return {string} Key.
       */
      ImageTile.prototype.getKey = function () {
          return this.src_;
      };
      /**
       * Tracks loading or read errors.
       *
       * @private
       */
      ImageTile.prototype.handleImageError_ = function () {
          this.state = TileState.ERROR;
          this.unlistenImage_();
          this.image_ = getBlankImage();
          this.changed();
      };
      /**
       * Tracks successful image load.
       *
       * @private
       */
      ImageTile.prototype.handleImageLoad_ = function () {
          var image = /** @type {HTMLImageElement} */ (this.image_);
          if (image.naturalWidth && image.naturalHeight) {
              this.state = TileState.LOADED;
          }
          else {
              this.state = TileState.EMPTY;
          }
          this.unlistenImage_();
          this.changed();
      };
      /**
       * Load not yet loaded URI.
       * @api
       */
      ImageTile.prototype.load = function () {
          if (this.state == TileState.ERROR) {
              this.state = TileState.IDLE;
              this.image_ = new Image();
              if (this.crossOrigin_ !== null) {
                  this.image_.crossOrigin = this.crossOrigin_;
              }
          }
          if (this.state == TileState.IDLE) {
              this.state = TileState.LOADING;
              this.changed();
              this.tileLoadFunction_(this, this.src_);
              this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
          }
      };
      /**
       * Discards event handlers which listen for load completion or errors.
       *
       * @private
       */
      ImageTile.prototype.unlistenImage_ = function () {
          if (this.unlisten_) {
              this.unlisten_();
              this.unlisten_ = null;
          }
      };
      return ImageTile;
  }(Tile));
  /**
   * Get a 1-pixel blank image.
   * @return {HTMLCanvasElement} Blank image.
   */
  function getBlankImage() {
      var ctx = createCanvasContext2D(1, 1);
      ctx.fillStyle = 'rgba(0,0,0,0)';
      ctx.fillRect(0, 0, 1, 1);
      return ctx.canvas;
  }

  var __extends$1u = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {function(number, number, number, number) : import("../Tile.js").default} FunctionType
   */
  /**
   * @classdesc
   * Class encapsulating single reprojected tile.
   * See {@link module:ol/source/TileImage~TileImage}.
   *
   */
  var ReprojTile = /** @class */ (function (_super) {
      __extends$1u(ReprojTile, _super);
      /**
       * @param {import("../proj/Projection.js").default} sourceProj Source projection.
       * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
       * @param {import("../proj/Projection.js").default} targetProj Target projection.
       * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
       * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
       * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
       * @param {number} pixelRatio Pixel ratio.
       * @param {number} gutter Gutter of the source tiles.
       * @param {FunctionType} getTileFunction
       *     Function returning source tiles (z, x, y, pixelRatio).
       * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).
       * @param {boolean=} opt_renderEdges Render reprojection edges.
       * @param {object=} opt_contextOptions Properties to set on the canvas context.
       */
      function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_contextOptions) {
          var _this = _super.call(this, tileCoord, TileState.IDLE) || this;
          /**
           * @private
           * @type {boolean}
           */
          _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;
          /**
           * @private
           * @type {object}
           */
          _this.contextOptions_ = opt_contextOptions;
          /**
           * @private
           * @type {number}
           */
          _this.pixelRatio_ = pixelRatio;
          /**
           * @private
           * @type {number}
           */
          _this.gutter_ = gutter;
          /**
           * @private
           * @type {HTMLCanvasElement}
           */
          _this.canvas_ = null;
          /**
           * @private
           * @type {import("../tilegrid/TileGrid.js").default}
           */
          _this.sourceTileGrid_ = sourceTileGrid;
          /**
           * @private
           * @type {import("../tilegrid/TileGrid.js").default}
           */
          _this.targetTileGrid_ = targetTileGrid;
          /**
           * @private
           * @type {import("../tilecoord.js").TileCoord}
           */
          _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
          /**
           * @private
           * @type {!Array<import("../Tile.js").default>}
           */
          _this.sourceTiles_ = [];
          /**
           * @private
           * @type {?Array<import("../events.js").EventsKey>}
           */
          _this.sourcesListenerKeys_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.sourceZ_ = 0;
          var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);
          var maxTargetExtent = _this.targetTileGrid_.getExtent();
          var maxSourceExtent = _this.sourceTileGrid_.getExtent();
          var limitedTargetExtent = maxTargetExtent
              ? getIntersection(targetExtent, maxTargetExtent)
              : targetExtent;
          if (getArea(limitedTargetExtent) === 0) {
              // Tile is completely outside range -> EMPTY
              // TODO: is it actually correct that the source even creates the tile ?
              _this.state = TileState.EMPTY;
              return _this;
          }
          var sourceProjExtent = sourceProj.getExtent();
          if (sourceProjExtent) {
              if (!maxSourceExtent) {
                  maxSourceExtent = sourceProjExtent;
              }
              else {
                  maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
              }
          }
          var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);
          var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);
          if (!isFinite(sourceResolution) || sourceResolution <= 0) {
              // invalid sourceResolution -> EMPTY
              // probably edges of the projections when no extent is defined
              _this.state = TileState.EMPTY;
              return _this;
          }
          var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;
          /**
           * @private
           * @type {!import("./Triangulation.js").default}
           */
          _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
          if (_this.triangulation_.getTriangles().length === 0) {
              // no valid triangles -> EMPTY
              _this.state = TileState.EMPTY;
              return _this;
          }
          _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
          var sourceExtent = _this.triangulation_.calculateSourceExtent();
          if (maxSourceExtent) {
              if (sourceProj.canWrapX()) {
                  sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
                  sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
              }
              else {
                  sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
              }
          }
          if (!getArea(sourceExtent)) {
              _this.state = TileState.EMPTY;
          }
          else {
              var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);
              for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
                  for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
                      var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);
                      if (tile) {
                          _this.sourceTiles_.push(tile);
                      }
                  }
              }
              if (_this.sourceTiles_.length === 0) {
                  _this.state = TileState.EMPTY;
              }
          }
          return _this;
      }
      /**
       * Get the HTML Canvas element for this tile.
       * @return {HTMLCanvasElement} Canvas.
       */
      ReprojTile.prototype.getImage = function () {
          return this.canvas_;
      };
      /**
       * @private
       */
      ReprojTile.prototype.reproject_ = function () {
          var sources = [];
          this.sourceTiles_.forEach(function (tile, i, arr) {
              if (tile && tile.getState() == TileState.LOADED) {
                  sources.push({
                      extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
                      image: tile.getImage(),
                  });
              }
          }.bind(this));
          this.sourceTiles_.length = 0;
          if (sources.length === 0) {
              this.state = TileState.ERROR;
          }
          else {
              var z = this.wrappedTileCoord_[0];
              var size = this.targetTileGrid_.getTileSize(z);
              var width = typeof size === 'number' ? size : size[0];
              var height = typeof size === 'number' ? size : size[1];
              var targetResolution = this.targetTileGrid_.getResolution(z);
              var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
              var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
              this.canvas_ = render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.contextOptions_);
              this.state = TileState.LOADED;
          }
          this.changed();
      };
      /**
       * Load not yet loaded URI.
       */
      ReprojTile.prototype.load = function () {
          if (this.state == TileState.IDLE) {
              this.state = TileState.LOADING;
              this.changed();
              var leftToLoad_1 = 0;
              this.sourcesListenerKeys_ = [];
              this.sourceTiles_.forEach(function (tile, i, arr) {
                  var state = tile.getState();
                  if (state == TileState.IDLE || state == TileState.LOADING) {
                      leftToLoad_1++;
                      var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {
                          var state = tile.getState();
                          if (state == TileState.LOADED ||
                              state == TileState.ERROR ||
                              state == TileState.EMPTY) {
                              unlistenByKey(sourceListenKey_1);
                              leftToLoad_1--;
                              if (leftToLoad_1 === 0) {
                                  this.unlistenSources_();
                                  this.reproject_();
                              }
                          }
                      }, this);
                      this.sourcesListenerKeys_.push(sourceListenKey_1);
                  }
              }.bind(this));
              this.sourceTiles_.forEach(function (tile, i, arr) {
                  var state = tile.getState();
                  if (state == TileState.IDLE) {
                      tile.load();
                  }
              });
              if (leftToLoad_1 === 0) {
                  setTimeout(this.reproject_.bind(this), 0);
              }
          }
      };
      /**
       * @private
       */
      ReprojTile.prototype.unlistenSources_ = function () {
          this.sourcesListenerKeys_.forEach(unlistenByKey);
          this.sourcesListenerKeys_ = null;
      };
      return ReprojTile;
  }(Tile));

  /**
   * @module ol/structs/LRUCache
   */
  /**
   * @typedef {Object} Entry
   * @property {string} key_
   * @property {Object} newer
   * @property {Object} older
   * @property {*} value_
   */
  /**
   * @classdesc
   * Implements a Least-Recently-Used cache where the keys do not conflict with
   * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
   * items from the cache is the responsibility of the user.
   *
   * @fires import("../events/Event.js").default
   * @template T
   */
  var LRUCache = /** @class */ (function () {
      /**
       * @param {number=} opt_highWaterMark High water mark.
       */
      function LRUCache(opt_highWaterMark) {
          /**
           * Desired max cache size after expireCache(). If set to 0, no cache entries
           * will be pruned at all.
           * @type {number}
           */
          this.highWaterMark =
              opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;
          /**
           * @private
           * @type {number}
           */
          this.count_ = 0;
          /**
           * @private
           * @type {!Object<string, Entry>}
           */
          this.entries_ = {};
          /**
           * @private
           * @type {?Entry}
           */
          this.oldest_ = null;
          /**
           * @private
           * @type {?Entry}
           */
          this.newest_ = null;
      }
      /**
       * @return {boolean} Can expire cache.
       */
      LRUCache.prototype.canExpireCache = function () {
          return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
      };
      /**
       * FIXME empty description for jsdoc
       */
      LRUCache.prototype.clear = function () {
          this.count_ = 0;
          this.entries_ = {};
          this.oldest_ = null;
          this.newest_ = null;
      };
      /**
       * @param {string} key Key.
       * @return {boolean} Contains key.
       */
      LRUCache.prototype.containsKey = function (key) {
          return this.entries_.hasOwnProperty(key);
      };
      /**
       * @param {function(T, string, LRUCache<T>): ?} f The function
       *     to call for every entry from the oldest to the newer. This function takes
       *     3 arguments (the entry value, the entry key and the LRUCache object).
       *     The return value is ignored.
       */
      LRUCache.prototype.forEach = function (f) {
          var entry = this.oldest_;
          while (entry) {
              f(entry.value_, entry.key_, this);
              entry = entry.newer;
          }
      };
      /**
       * @param {string} key Key.
       * @param {*=} opt_options Options (reserverd for subclasses).
       * @return {T} Value.
       */
      LRUCache.prototype.get = function (key, opt_options) {
          var entry = this.entries_[key];
          assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
          if (entry === this.newest_) {
              return entry.value_;
          }
          else if (entry === this.oldest_) {
              this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);
              this.oldest_.older = null;
          }
          else {
              entry.newer.older = entry.older;
              entry.older.newer = entry.newer;
          }
          entry.newer = null;
          entry.older = this.newest_;
          this.newest_.newer = entry;
          this.newest_ = entry;
          return entry.value_;
      };
      /**
       * Remove an entry from the cache.
       * @param {string} key The entry key.
       * @return {T} The removed entry.
       */
      LRUCache.prototype.remove = function (key) {
          var entry = this.entries_[key];
          assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
          if (entry === this.newest_) {
              this.newest_ = /** @type {Entry} */ (entry.older);
              if (this.newest_) {
                  this.newest_.newer = null;
              }
          }
          else if (entry === this.oldest_) {
              this.oldest_ = /** @type {Entry} */ (entry.newer);
              if (this.oldest_) {
                  this.oldest_.older = null;
              }
          }
          else {
              entry.newer.older = entry.older;
              entry.older.newer = entry.newer;
          }
          delete this.entries_[key];
          --this.count_;
          return entry.value_;
      };
      /**
       * @return {number} Count.
       */
      LRUCache.prototype.getCount = function () {
          return this.count_;
      };
      /**
       * @return {Array<string>} Keys.
       */
      LRUCache.prototype.getKeys = function () {
          var keys = new Array(this.count_);
          var i = 0;
          var entry;
          for (entry = this.newest_; entry; entry = entry.older) {
              keys[i++] = entry.key_;
          }
          return keys;
      };
      /**
       * @return {Array<T>} Values.
       */
      LRUCache.prototype.getValues = function () {
          var values = new Array(this.count_);
          var i = 0;
          var entry;
          for (entry = this.newest_; entry; entry = entry.older) {
              values[i++] = entry.value_;
          }
          return values;
      };
      /**
       * @return {T} Last value.
       */
      LRUCache.prototype.peekLast = function () {
          return this.oldest_.value_;
      };
      /**
       * @return {string} Last key.
       */
      LRUCache.prototype.peekLastKey = function () {
          return this.oldest_.key_;
      };
      /**
       * Get the key of the newest item in the cache.  Throws if the cache is empty.
       * @return {string} The newest key.
       */
      LRUCache.prototype.peekFirstKey = function () {
          return this.newest_.key_;
      };
      /**
       * @return {T} value Value.
       */
      LRUCache.prototype.pop = function () {
          var entry = this.oldest_;
          delete this.entries_[entry.key_];
          if (entry.newer) {
              entry.newer.older = null;
          }
          this.oldest_ = /** @type {Entry} */ (entry.newer);
          if (!this.oldest_) {
              this.newest_ = null;
          }
          --this.count_;
          return entry.value_;
      };
      /**
       * @param {string} key Key.
       * @param {T} value Value.
       */
      LRUCache.prototype.replace = function (key, value) {
          this.get(key); // update `newest_`
          this.entries_[key].value_ = value;
      };
      /**
       * @param {string} key Key.
       * @param {T} value Value.
       */
      LRUCache.prototype.set = function (key, value) {
          assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already
          var entry = {
              key_: key,
              newer: null,
              older: this.newest_,
              value_: value,
          };
          if (!this.newest_) {
              this.oldest_ = entry;
          }
          else {
              this.newest_.newer = entry;
          }
          this.newest_ = entry;
          this.entries_[key] = entry;
          ++this.count_;
      };
      /**
       * Set a maximum number of entries for the cache.
       * @param {number} size Cache size.
       * @api
       */
      LRUCache.prototype.setSize = function (size) {
          this.highWaterMark = size;
      };
      return LRUCache;
  }());

  /**
   * @module ol/tilecoord
   */
  /**
   * An array of three numbers representing the location of a tile in a tile
   * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
   * @typedef {Array<number>} TileCoord
   * @api
   */
  /**
   * @param {number} z Z.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {TileCoord=} opt_tileCoord Tile coordinate.
   * @return {TileCoord} Tile coordinate.
   */
  function createOrUpdate$2(z, x, y, opt_tileCoord) {
      if (opt_tileCoord !== undefined) {
          opt_tileCoord[0] = z;
          opt_tileCoord[1] = x;
          opt_tileCoord[2] = y;
          return opt_tileCoord;
      }
      else {
          return [z, x, y];
      }
  }
  /**
   * @param {number} z Z.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {string} Key.
   */
  function getKeyZXY(z, x, y) {
      return z + '/' + x + '/' + y;
  }
  /**
   * Get the key for a tile coord.
   * @param {TileCoord} tileCoord The tile coord.
   * @return {string} Key.
   */
  function getKey$1(tileCoord) {
      return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
  }
  /**
   * Get a tile coord given a key.
   * @param {string} key The tile coord key.
   * @return {TileCoord} The tile coord.
   */
  function fromKey(key) {
      return key.split('/').map(Number);
  }
  /**
   * @param {TileCoord} tileCoord Tile coord.
   * @return {number} Hash.
   */
  function hash(tileCoord) {
      return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
  }
  /**
   * @param {TileCoord} tileCoord Tile coordinate.
   * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @return {boolean} Tile coordinate is within extent and zoom level range.
   */
  function withinExtentAndZ(tileCoord, tileGrid) {
      var z = tileCoord[0];
      var x = tileCoord[1];
      var y = tileCoord[2];
      if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
          return false;
      }
      var extent = tileGrid.getExtent();
      var tileRange;
      if (!extent) {
          tileRange = tileGrid.getFullTileRange(z);
      }
      else {
          tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
      }
      if (!tileRange) {
          return true;
      }
      else {
          return tileRange.containsXY(x, y);
      }
  }

  var __extends$1v = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var TileCache = /** @class */ (function (_super) {
      __extends$1v(TileCache, _super);
      function TileCache() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * @param {!Object<string, boolean>} usedTiles Used tiles.
       */
      TileCache.prototype.expireCache = function (usedTiles) {
          while (this.canExpireCache()) {
              var tile = this.peekLast();
              if (tile.getKey() in usedTiles) {
                  break;
              }
              else {
                  this.pop().release();
              }
          }
      };
      /**
       * Prune all tiles from the cache that don't have the same z as the newest tile.
       */
      TileCache.prototype.pruneExceptNewestZ = function () {
          if (this.getCount() === 0) {
              return;
          }
          var key = this.peekFirstKey();
          var tileCoord = fromKey(key);
          var z = tileCoord[0];
          this.forEach(function (tile) {
              if (tile.tileCoord[0] !== z) {
                  this.remove(getKey$1(tile.tileCoord));
                  tile.release();
              }
          }.bind(this));
      };
      return TileCache;
  }(LRUCache));

  /**
   * @module ol/source/TileEventType
   */
  /**
   * @enum {string}
   */
  var TileEventType = {
      /**
       * Triggered when a tile starts loading.
       * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
       * @api
       */
      TILELOADSTART: 'tileloadstart',
      /**
       * Triggered when a tile finishes loading, either when its data is loaded,
       * or when loading was aborted because the tile is no longer needed.
       * @event module:ol/source/Tile.TileSourceEvent#tileloadend
       * @api
       */
      TILELOADEND: 'tileloadend',
      /**
       * Triggered if tile loading results in an error.
       * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
       * @api
       */
      TILELOADERROR: 'tileloaderror',
  };

  /**
   * @module ol/tilegrid/TileGrid
   */
  /**
   * @private
   * @type {import("../tilecoord.js").TileCoord}
   */
  var tmpTileCoord = [0, 0, 0];
  /**
   * @typedef {Object} Options
   * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
   * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or
   * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
   * @property {number} [minZoom=0] Minimum zoom.
   * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
   * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
   * specified, `extent` or `origins` must be provided.
   * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
   * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
   * should match the length of the `resolutions` array, i.e. each resolution can have a different
   * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
   * `origin` must be provided.
   * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
   * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
   * array will have a length of `maxZoom + 1`.
   * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
   * of the grid for each zoom level. If specified the values
   * define each zoom level's extent together with the `origin` or `origins`.
   * A grid `extent` can be configured in addition, and will further limit the extent
   * for which tile requests are made by sources. If the bottom-left corner of
   * an extent is used as `origin` or `origins`, then the `y` value must be
   * negative because OpenLayers tile coordinates use the top left as the origin.
   * @property {number|import("../size.js").Size} [tileSize] Tile size.
   * Default is `[256, 256]`.
   * @property {Array<import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
   * should match the length of the `resolutions` array, i.e. each resolution can have a different
   * tile size.
   */
  /**
   * @classdesc
   * Base class for setting the grid pattern for sources accessing tiled-image
   * servers.
   * @api
   */
  var TileGrid = /** @class */ (function () {
      /**
       * @param {Options} options Tile grid options.
       */
      function TileGrid(options) {
          /**
           * @protected
           * @type {number}
           */
          this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;
          /**
           * @private
           * @type {!Array<number>}
           */
          this.resolutions_ = options.resolutions;
          assert(isSorted(this.resolutions_, function (a, b) {
              return b - a;
          }, true), 17); // `resolutions` must be sorted in descending order
          // check if we've got a consistent zoom factor and origin
          var zoomFactor;
          if (!options.origins) {
              for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
                  if (!zoomFactor) {
                      zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
                  }
                  else {
                      if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
                          zoomFactor = undefined;
                          break;
                      }
                  }
              }
          }
          /**
           * @private
           * @type {number|undefined}
           */
          this.zoomFactor_ = zoomFactor;
          /**
           * @protected
           * @type {number}
           */
          this.maxZoom = this.resolutions_.length - 1;
          /**
           * @private
           * @type {import("../coordinate.js").Coordinate}
           */
          this.origin_ = options.origin !== undefined ? options.origin : null;
          /**
           * @private
           * @type {Array<import("../coordinate.js").Coordinate>}
           */
          this.origins_ = null;
          if (options.origins !== undefined) {
              this.origins_ = options.origins;
              assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal
          }
          var extent = options.extent;
          if (extent !== undefined && !this.origin_ && !this.origins_) {
              this.origin_ = getTopLeft(extent);
          }
          assert((!this.origin_ && this.origins_) || (this.origin_ && !this.origins_), 18); // Either `origin` or `origins` must be configured, never both
          /**
           * @private
           * @type {Array<number|import("../size.js").Size>}
           */
          this.tileSizes_ = null;
          if (options.tileSizes !== undefined) {
              this.tileSizes_ = options.tileSizes;
              assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal
          }
          /**
           * @private
           * @type {number|import("../size.js").Size}
           */
          this.tileSize_ =
              options.tileSize !== undefined
                  ? options.tileSize
                  : !this.tileSizes_
                      ? DEFAULT_TILE_SIZE
                      : null;
          assert((!this.tileSize_ && this.tileSizes_) ||
              (this.tileSize_ && !this.tileSizes_), 22); // Either `tileSize` or `tileSizes` must be configured, never both
          /**
           * @private
           * @type {import("../extent.js").Extent}
           */
          this.extent_ = extent !== undefined ? extent : null;
          /**
           * @private
           * @type {Array<import("../TileRange.js").default>}
           */
          this.fullTileRanges_ = null;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          this.tmpSize_ = [0, 0];
          if (options.sizes !== undefined) {
              this.fullTileRanges_ = options.sizes.map(function (size, z) {
                  var tileRange = new TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
                  return tileRange;
              }, this);
          }
          else if (extent) {
              this.calculateTileRanges_(extent);
          }
      }
      /**
       * Call a function with each tile coordinate for a given extent and zoom level.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} zoom Integer zoom level.
       * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
       * @api
       */
      TileGrid.prototype.forEachTileCoord = function (extent, zoom, callback) {
          var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
          for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
              for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
                  callback([zoom, i, j]);
              }
          }
      };
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
       * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.
       * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
       * @return {boolean} Callback succeeded.
       */
      TileGrid.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_tileRange, opt_extent) {
          var tileRange, x, y;
          var tileCoordExtent = null;
          var z = tileCoord[0] - 1;
          if (this.zoomFactor_ === 2) {
              x = tileCoord[1];
              y = tileCoord[2];
          }
          else {
              tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
          }
          while (z >= this.minZoom) {
              if (this.zoomFactor_ === 2) {
                  x = Math.floor(x / 2);
                  y = Math.floor(y / 2);
                  tileRange = createOrUpdate$1(x, x, y, y, opt_tileRange);
              }
              else {
                  tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
              }
              if (callback(z, tileRange)) {
                  return true;
              }
              --z;
          }
          return false;
      };
      /**
       * Get the extent for this tile grid, if it was configured.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      TileGrid.prototype.getExtent = function () {
          return this.extent_;
      };
      /**
       * Get the maximum zoom level for the grid.
       * @return {number} Max zoom.
       * @api
       */
      TileGrid.prototype.getMaxZoom = function () {
          return this.maxZoom;
      };
      /**
       * Get the minimum zoom level for the grid.
       * @return {number} Min zoom.
       * @api
       */
      TileGrid.prototype.getMinZoom = function () {
          return this.minZoom;
      };
      /**
       * Get the origin for the grid at the given zoom level.
       * @param {number} z Integer zoom level.
       * @return {import("../coordinate.js").Coordinate} Origin.
       * @api
       */
      TileGrid.prototype.getOrigin = function (z) {
          if (this.origin_) {
              return this.origin_;
          }
          else {
              return this.origins_[z];
          }
      };
      /**
       * Get the resolution for the given zoom level.
       * @param {number} z Integer zoom level.
       * @return {number} Resolution.
       * @api
       */
      TileGrid.prototype.getResolution = function (z) {
          return this.resolutions_[z];
      };
      /**
       * Get the list of resolutions for the tile grid.
       * @return {Array<number>} Resolutions.
       * @api
       */
      TileGrid.prototype.getResolutions = function () {
          return this.resolutions_;
      };
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.
       * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
       * @return {import("../TileRange.js").default} Tile range.
       */
      TileGrid.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {
          if (tileCoord[0] < this.maxZoom) {
              if (this.zoomFactor_ === 2) {
                  var minX = tileCoord[1] * 2;
                  var minY = tileCoord[2] * 2;
                  return createOrUpdate$1(minX, minX + 1, minY, minY + 1, opt_tileRange);
              }
              var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
              return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
          }
          return null;
      };
      /**
       * Get the extent for a tile range.
       * @param {number} z Integer zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
       * @return {import("../extent.js").Extent} Extent.
       */
      TileGrid.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {
          var origin = this.getOrigin(z);
          var resolution = this.getResolution(z);
          var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
          var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
          var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
          var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
          var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
          return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
      };
      /**
       * Get a tile range for the given extent and integer zoom level.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} z Integer zoom level.
       * @param {import("../TileRange.js").default=} opt_tileRange Temporary tile range object.
       * @return {import("../TileRange.js").default} Tile range.
       */
      TileGrid.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {
          var tileCoord = tmpTileCoord;
          this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);
          var minX = tileCoord[1];
          var minY = tileCoord[2];
          this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);
          return createOrUpdate$1(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
      };
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @return {import("../coordinate.js").Coordinate} Tile center.
       */
      TileGrid.prototype.getTileCoordCenter = function (tileCoord) {
          var origin = this.getOrigin(tileCoord[0]);
          var resolution = this.getResolution(tileCoord[0]);
          var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
          return [
              origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
              origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,
          ];
      };
      /**
       * Get the extent of a tile coordinate.
       *
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("../extent.js").Extent=} opt_extent Temporary extent object.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      TileGrid.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {
          var origin = this.getOrigin(tileCoord[0]);
          var resolution = this.getResolution(tileCoord[0]);
          var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
          var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
          var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
          var maxX = minX + tileSize[0] * resolution;
          var maxY = minY + tileSize[1] * resolution;
          return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
      };
      /**
       * Get the tile coordinate for the given map coordinate and resolution.  This
       * method considers that coordinates that intersect tile boundaries should be
       * assigned the higher tile coordinate.
       *
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} resolution Resolution.
       * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @api
       */
      TileGrid.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {
          return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
      };
      /**
       * Note that this method should not be called for resolutions that correspond
       * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
       * @param {number} x X.
       * @param {number} y Y.
       * @param {number} resolution Resolution (for a non-integer zoom level).
       * @param {boolean} reverseIntersectionPolicy Instead of letting edge
       *     intersections go to the higher tile coordinate, let edge intersections
       *     go to the lower tile coordinate.
       * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @private
       */
      TileGrid.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
          var z = this.getZForResolution(resolution);
          var scale = resolution / this.getResolution(z);
          var origin = this.getOrigin(z);
          var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
          var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
          var adjustY = reverseIntersectionPolicy ? 0.5 : 0;
          var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
          var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);
          var tileCoordX = (scale * xFromOrigin) / tileSize[0];
          var tileCoordY = (scale * yFromOrigin) / tileSize[1];
          if (reverseIntersectionPolicy) {
              tileCoordX = Math.ceil(tileCoordX) - 1;
              tileCoordY = Math.ceil(tileCoordY) - 1;
          }
          else {
              tileCoordX = Math.floor(tileCoordX);
              tileCoordY = Math.floor(tileCoordY);
          }
          return createOrUpdate$2(z, tileCoordX, tileCoordY, opt_tileCoord);
      };
      /**
       * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
       * they should have separate implementations.  This method is for integer zoom
       * levels.  The other method should only be called for resolutions corresponding
       * to non-integer zoom levels.
       * @param {number} x Map x coordinate.
       * @param {number} y Map y coordinate.
       * @param {number} z Integer zoom level.
       * @param {boolean} reverseIntersectionPolicy Instead of letting edge
       *     intersections go to the higher tile coordinate, let edge intersections
       *     go to the lower tile coordinate.
       * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @private
       */
      TileGrid.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
          var origin = this.getOrigin(z);
          var resolution = this.getResolution(z);
          var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
          var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
          var adjustY = reverseIntersectionPolicy ? 0.5 : 0;
          var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
          var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);
          var tileCoordX = xFromOrigin / tileSize[0];
          var tileCoordY = yFromOrigin / tileSize[1];
          if (reverseIntersectionPolicy) {
              tileCoordX = Math.ceil(tileCoordX) - 1;
              tileCoordY = Math.ceil(tileCoordY) - 1;
          }
          else {
              tileCoordX = Math.floor(tileCoordX);
              tileCoordY = Math.floor(tileCoordY);
          }
          return createOrUpdate$2(z, tileCoordX, tileCoordY, opt_tileCoord);
      };
      /**
       * Get a tile coordinate given a map coordinate and zoom level.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} z Zoom level.
       * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @api
       */
      TileGrid.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {
          return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
      };
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @return {number} Tile resolution.
       */
      TileGrid.prototype.getTileCoordResolution = function (tileCoord) {
          return this.resolutions_[tileCoord[0]];
      };
      /**
       * Get the tile size for a zoom level. The type of the return value matches the
       * `tileSize` or `tileSizes` that the tile grid was configured with. To always
       * get an `import("../size.js").Size`, run the result through `import("../size.js").Size.toSize()`.
       * @param {number} z Z.
       * @return {number|import("../size.js").Size} Tile size.
       * @api
       */
      TileGrid.prototype.getTileSize = function (z) {
          if (this.tileSize_) {
              return this.tileSize_;
          }
          else {
              return this.tileSizes_[z];
          }
      };
      /**
       * @param {number} z Zoom level.
       * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
       */
      TileGrid.prototype.getFullTileRange = function (z) {
          if (!this.fullTileRanges_) {
              return null;
          }
          else {
              return this.fullTileRanges_[z];
          }
      };
      /**
       * @param {number} resolution Resolution.
       * @param {number=} opt_direction If 0, the nearest resolution will be used.
       *     If 1, the nearest lower resolution will be used. If -1, the nearest
       *     higher resolution will be used. Default is 0.
       * @return {number} Z.
       * @api
       */
      TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {
          var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);
          return clamp(z, this.minZoom, this.maxZoom);
      };
      /**
       * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
       * @private
       */
      TileGrid.prototype.calculateTileRanges_ = function (extent) {
          var length = this.resolutions_.length;
          var fullTileRanges = new Array(length);
          for (var z = this.minZoom; z < length; ++z) {
              fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
          }
          this.fullTileRanges_ = fullTileRanges;
      };
      return TileGrid;
  }());

  /**
   * @module ol/tilegrid
   */
  /**
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @return {!TileGrid} Default tile grid for the
   * passed projection.
   */
  function getForProjection(projection) {
      var tileGrid = projection.getDefaultTileGrid();
      if (!tileGrid) {
          tileGrid = createForProjection(projection);
          projection.setDefaultTileGrid(tileGrid);
      }
      return tileGrid;
  }
  /**
   * @param {TileGrid} tileGrid Tile grid.
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
   */
  function wrapX$2(tileGrid, tileCoord, projection) {
      var z = tileCoord[0];
      var center = tileGrid.getTileCoordCenter(tileCoord);
      var projectionExtent = extentFromProjection(projection);
      if (!containsCoordinate(projectionExtent, center)) {
          var worldWidth = getWidth(projectionExtent);
          var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
          center[0] += worldWidth * worldsAway;
          return tileGrid.getTileCoordForCoordAndZ(center, z);
      }
      else {
          return tileCoord;
      }
  }
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number=} opt_maxZoom Maximum zoom level (default is
   *     DEFAULT_MAX_ZOOM).
   * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
   *     DEFAULT_TILE_SIZE).
   * @param {import("./extent/Corner.js").default=} opt_corner Extent corner (default is `'top-left'`).
   * @return {!TileGrid} TileGrid instance.
   */
  function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
      var corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;
      var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);
      return new TileGrid({
          extent: extent,
          origin: getCorner(extent, corner),
          resolutions: resolutions,
          tileSize: opt_tileSize,
      });
  }
  /**
   * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number=} opt_maxZoom Maximum zoom level (default is
   *     DEFAULT_MAX_ZOOM).
   * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
   *     DEFAULT_TILE_SIZE).
   * @param {number=} opt_maxResolution Resolution at level zero.
   * @return {!Array<number>} Resolutions array.
   */
  function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {
      var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : DEFAULT_MAX_ZOOM;
      var height = getHeight(extent);
      var width = getWidth(extent);
      var tileSize = toSize(opt_tileSize !== undefined ? opt_tileSize : DEFAULT_TILE_SIZE);
      var maxResolution = opt_maxResolution > 0
          ? opt_maxResolution
          : Math.max(width / tileSize[0], height / tileSize[1]);
      var length = maxZoom + 1;
      var resolutions = new Array(length);
      for (var z = 0; z < length; ++z) {
          resolutions[z] = maxResolution / Math.pow(2, z);
      }
      return resolutions;
  }
  /**
   * @param {import("./proj.js").ProjectionLike} projection Projection.
   * @param {number=} opt_maxZoom Maximum zoom level (default is
   *     DEFAULT_MAX_ZOOM).
   * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
   *     DEFAULT_TILE_SIZE).
   * @param {import("./extent/Corner.js").default=} opt_corner Extent corner (default is `'top-left'`).
   * @return {!TileGrid} TileGrid instance.
   */
  function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
      var extent = extentFromProjection(projection);
      return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
  }
  /**
   * Generate a tile grid extent from a projection.  If the projection has an
   * extent, it is used.  If not, a global extent is assumed.
   * @param {import("./proj.js").ProjectionLike} projection Projection.
   * @return {import("./extent.js").Extent} Extent.
   */
  function extentFromProjection(projection) {
      projection = get$3(projection);
      var extent = projection.getExtent();
      if (!extent) {
          var half = (180 * METERS_PER_UNIT[Units.DEGREES]) / projection.getMetersPerUnit();
          extent = createOrUpdate(-half, -half, half, half);
      }
      return extent;
  }

  var __extends$1w = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions]
   * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
   * @property {number} [cacheSize]
   * @property {boolean} [opaque=false] Whether the layer is opaque.
   * @property {number} [tilePixelRatio]
   * @property {import("../proj.js").ProjectionLike} [projection]
   * @property {import("./State.js").default} [state]
   * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]
   * @property {boolean} [wrapX=true]
   * @property {number} [transition]
   * @property {string} [key]
   * @property {number} [zDirection=0]
   */
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Base class for sources providing images divided into a tile grid.
   * @abstract
   * @api
   */
  var TileSource = /** @class */ (function (_super) {
      __extends$1w(TileSource, _super);
      /**
       * @param {Options} options SourceTile source options.
       */
      function TileSource(options) {
          var _this = _super.call(this, {
              attributions: options.attributions,
              attributionsCollapsible: options.attributionsCollapsible,
              projection: options.projection,
              state: options.state,
              wrapX: options.wrapX,
          }) || this;
          /**
           * @private
           * @type {boolean}
           */
          _this.opaque_ = options.opaque !== undefined ? options.opaque : false;
          /**
           * @private
           * @type {number}
           */
          _this.tilePixelRatio_ =
              options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;
          /**
           * @protected
           * @type {import("../tilegrid/TileGrid.js").default}
           */
          _this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;
          var tileSize = [256, 256];
          var tileGrid = options.tileGrid;
          if (tileGrid) {
              toSize(tileGrid.getTileSize(tileGrid.getMinZoom()), tileSize);
          }
          /**
           * @protected
           * @type {import("../TileCache.js").default}
           */
          _this.tileCache = new TileCache(options.cacheSize || 0);
          /**
           * @protected
           * @type {import("../size.js").Size}
           */
          _this.tmpSize = [0, 0];
          /**
           * @private
           * @type {string}
           */
          _this.key_ = options.key || '';
          /**
           * @protected
           * @type {import("../Tile.js").Options}
           */
          _this.tileOptions = { transition: options.transition };
          /**
           * zDirection hint, read by the renderer. Indicates which resolution should be used
           * by a renderer if the views resolution does not match any resolution of the tile source.
           * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
           * will be used. If -1, the nearest higher resolution will be used.
           * @type {number}
           */
          _this.zDirection = options.zDirection ? options.zDirection : 0;
          return _this;
      }
      /**
       * @return {boolean} Can expire cache.
       */
      TileSource.prototype.canExpireCache = function () {
          return this.tileCache.canExpireCache();
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @param {!Object<string, boolean>} usedTiles Used tiles.
       */
      TileSource.prototype.expireCache = function (projection, usedTiles) {
          var tileCache = this.getTileCacheForProjection(projection);
          if (tileCache) {
              tileCache.expireCache(usedTiles);
          }
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @param {number} z Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
       *     loaded tile.  If the callback returns `false`, the tile will not be
       *     considered loaded.
       * @return {boolean} The tile range is fully covered with loaded tiles.
       */
      TileSource.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {
          var tileCache = this.getTileCacheForProjection(projection);
          if (!tileCache) {
              return false;
          }
          var covered = true;
          var tile, tileCoordKey, loaded;
          for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
              for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
                  tileCoordKey = getKeyZXY(z, x, y);
                  loaded = false;
                  if (tileCache.containsKey(tileCoordKey)) {
                      tile = /** @type {!import("../Tile.js").default} */ (tileCache.get(tileCoordKey));
                      loaded = tile.getState() === TileState.LOADED;
                      if (loaded) {
                          loaded = callback(tile) !== false;
                      }
                  }
                  if (!loaded) {
                      covered = false;
                  }
              }
          }
          return covered;
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {number} Gutter.
       */
      TileSource.prototype.getGutterForProjection = function (projection) {
          return 0;
      };
      /**
       * Return the key to be used for all tiles in the source.
       * @return {string} The key for all tiles.
       * @protected
       */
      TileSource.prototype.getKey = function () {
          return this.key_;
      };
      /**
       * Set the value to be used as the key for all tiles in the source.
       * @param {string} key The key for tiles.
       * @protected
       */
      TileSource.prototype.setKey = function (key) {
          if (this.key_ !== key) {
              this.key_ = key;
              this.changed();
          }
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {boolean} Opaque.
       */
      TileSource.prototype.getOpaque = function (projection) {
          return this.opaque_;
      };
      /**
       * @return {Array<number>} Resolutions.
       */
      TileSource.prototype.getResolutions = function () {
          return this.tileGrid.getResolutions();
      };
      /**
       * @abstract
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../Tile.js").default} Tile.
       */
      TileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {
          return abstract();
      };
      /**
       * Return the tile grid of the tile source.
       * @return {import("../tilegrid/TileGrid.js").default} Tile grid.
       * @api
       */
      TileSource.prototype.getTileGrid = function () {
          return this.tileGrid;
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
       */
      TileSource.prototype.getTileGridForProjection = function (projection) {
          if (!this.tileGrid) {
              return getForProjection(projection);
          }
          else {
              return this.tileGrid;
          }
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {import("../TileCache.js").default} Tile cache.
       * @protected
       */
      TileSource.prototype.getTileCacheForProjection = function (projection) {
          var thisProj = this.getProjection();
          if (thisProj && !equivalent(thisProj, projection)) {
              return null;
          }
          else {
              return this.tileCache;
          }
      };
      /**
       * Get the tile pixel ratio for this source. Subclasses may override this
       * method, which is meant to return a supported pixel ratio that matches the
       * provided `pixelRatio` as close as possible.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Tile pixel ratio.
       */
      TileSource.prototype.getTilePixelRatio = function (pixelRatio) {
          return this.tilePixelRatio_;
      };
      /**
       * @param {number} z Z.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {import("../size.js").Size} Tile size.
       */
      TileSource.prototype.getTilePixelSize = function (z, pixelRatio, projection) {
          var tileGrid = this.getTileGridForProjection(projection);
          var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
          var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
          if (tilePixelRatio == 1) {
              return tileSize;
          }
          else {
              return scale$3(tileSize, tilePixelRatio, this.tmpSize);
          }
      };
      /**
       * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
       * is outside the resolution and extent range of the tile grid, `null` will be
       * returned.
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("../proj/Projection.js").default=} opt_projection Projection.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
       *     null if no tile URL should be created for the passed `tileCoord`.
       */
      TileSource.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {
          var projection = opt_projection !== undefined ? opt_projection : this.getProjection();
          var tileGrid = this.getTileGridForProjection(projection);
          if (this.getWrapX() && projection.isGlobal()) {
              tileCoord = wrapX$2(tileGrid, tileCoord, projection);
          }
          return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
      };
      /**
       * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
       * @api
       */
      TileSource.prototype.clear = function () {
          this.tileCache.clear();
      };
      TileSource.prototype.refresh = function () {
          this.clear();
          _super.prototype.refresh.call(this);
      };
      /**
       * Increases the cache size if needed
       * @param {number} tileCount Minimum number of tiles needed.
       * @param {import("../proj/Projection.js").default} projection Projection.
       */
      TileSource.prototype.updateCacheSize = function (tileCount, projection) {
          var tileCache = this.getTileCacheForProjection(projection);
          if (tileCount > tileCache.highWaterMark) {
              tileCache.highWaterMark = tileCount;
          }
      };
      /**
       * Marks a tile coord as being used, without triggering a load.
       * @abstract
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {import("../proj/Projection.js").default} projection Projection.
       */
      TileSource.prototype.useTile = function (z, x, y, projection) { };
      return TileSource;
  }(Source));
  /**
   * @classdesc
   * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
   * type.
   */
  var TileSourceEvent = /** @class */ (function (_super) {
      __extends$1w(TileSourceEvent, _super);
      /**
       * @param {string} type Type.
       * @param {import("../Tile.js").default} tile The tile.
       */
      function TileSourceEvent(type, tile) {
          var _this = _super.call(this, type) || this;
          /**
           * The tile related to the event.
           * @type {import("../Tile.js").default}
           * @api
           */
          _this.tile = tile;
          return _this;
      }
      return TileSourceEvent;
  }(BaseEvent));

  /**
   * @module ol/tileurlfunction
   */
  /**
   * @param {string} template Template.
   * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @return {import("./Tile.js").UrlFunction} Tile URL function.
   */
  function createFromTemplate(template, tileGrid) {
      var zRegEx = /\{z\}/g;
      var xRegEx = /\{x\}/g;
      var yRegEx = /\{y\}/g;
      var dashYRegEx = /\{-y\}/g;
      return (
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function (tileCoord, pixelRatio, projection) {
          if (!tileCoord) {
              return undefined;
          }
          else {
              return template
                  .replace(zRegEx, tileCoord[0].toString())
                  .replace(xRegEx, tileCoord[1].toString())
                  .replace(yRegEx, tileCoord[2].toString())
                  .replace(dashYRegEx, function () {
                  var z = tileCoord[0];
                  var range = tileGrid.getFullTileRange(z);
                  assert(range, 55); // The {-y} placeholder requires a tile grid with extent
                  var y = range.getHeight() - tileCoord[2] - 1;
                  return y.toString();
              });
          }
      });
  }
  /**
   * @param {Array<string>} templates Templates.
   * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @return {import("./Tile.js").UrlFunction} Tile URL function.
   */
  function createFromTemplates(templates, tileGrid) {
      var len = templates.length;
      var tileUrlFunctions = new Array(len);
      for (var i = 0; i < len; ++i) {
          tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
      }
      return createFromTileUrlFunctions(tileUrlFunctions);
  }
  /**
   * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
   * @return {import("./Tile.js").UrlFunction} Tile URL function.
   */
  function createFromTileUrlFunctions(tileUrlFunctions) {
      if (tileUrlFunctions.length === 1) {
          return tileUrlFunctions[0];
      }
      return (
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function (tileCoord, pixelRatio, projection) {
          if (!tileCoord) {
              return undefined;
          }
          else {
              var h = hash(tileCoord);
              var index = modulo(h, tileUrlFunctions.length);
              return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
          }
      });
  }
  /**
   * @param {string} url URL.
   * @return {Array<string>} Array of urls.
   */
  function expandUrl(url) {
      var urls = [];
      var match = /\{([a-z])-([a-z])\}/.exec(url);
      if (match) {
          // char range
          var startCharCode = match[1].charCodeAt(0);
          var stopCharCode = match[2].charCodeAt(0);
          var charCode = void 0;
          for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
              urls.push(url.replace(match[0], String.fromCharCode(charCode)));
          }
          return urls;
      }
      match = /\{(\d+)-(\d+)\}/.exec(url);
      if (match) {
          // number range
          var stop_1 = parseInt(match[2], 10);
          for (var i = parseInt(match[1], 10); i <= stop_1; i++) {
              urls.push(url.replace(match[0], i.toString()));
          }
          return urls;
      }
      urls.push(url);
      return urls;
  }

  var __extends$1x = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions]
   * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
   * @property {number} [cacheSize]
   * @property {boolean} [opaque=false] Whether the layer is opaque.
   * @property {import("../proj.js").ProjectionLike} [projection]
   * @property {import("./State.js").default} [state]
   * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]
   * @property {import("../Tile.js").LoadFunction} tileLoadFunction
   * @property {number} [tilePixelRatio]
   * @property {import("../Tile.js").UrlFunction} [tileUrlFunction]
   * @property {string} [url]
   * @property {Array<string>} [urls]
   * @property {boolean} [wrapX=true]
   * @property {number} [transition]
   * @property {string} [key]
   * @property {number} [zDirection=0]
   */
  /**
   * @classdesc
   * Base class for sources providing tiles divided into a tile grid over http.
   *
   * @fires import("./Tile.js").TileSourceEvent
   */
  var UrlTile = /** @class */ (function (_super) {
      __extends$1x(UrlTile, _super);
      /**
       * @param {Options} options Image tile options.
       */
      function UrlTile(options) {
          var _this = _super.call(this, {
              attributions: options.attributions,
              cacheSize: options.cacheSize,
              opaque: options.opaque,
              projection: options.projection,
              state: options.state,
              tileGrid: options.tileGrid,
              tilePixelRatio: options.tilePixelRatio,
              wrapX: options.wrapX,
              transition: options.transition,
              key: options.key,
              attributionsCollapsible: options.attributionsCollapsible,
              zDirection: options.zDirection,
          }) || this;
          /**
           * @private
           * @type {boolean}
           */
          _this.generateTileUrlFunction_ =
              _this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;
          /**
           * @protected
           * @type {import("../Tile.js").LoadFunction}
           */
          _this.tileLoadFunction = options.tileLoadFunction;
          if (options.tileUrlFunction) {
              _this.tileUrlFunction = options.tileUrlFunction.bind(_this);
          }
          /**
           * @protected
           * @type {!Array<string>|null}
           */
          _this.urls = null;
          if (options.urls) {
              _this.setUrls(options.urls);
          }
          else if (options.url) {
              _this.setUrl(options.url);
          }
          /**
           * @private
           * @type {!Object<string, boolean>}
           */
          _this.tileLoadingKeys_ = {};
          return _this;
      }
      /**
       * Return the tile load function of the source.
       * @return {import("../Tile.js").LoadFunction} TileLoadFunction
       * @api
       */
      UrlTile.prototype.getTileLoadFunction = function () {
          return this.tileLoadFunction;
      };
      /**
       * Return the tile URL function of the source.
       * @return {import("../Tile.js").UrlFunction} TileUrlFunction
       * @api
       */
      UrlTile.prototype.getTileUrlFunction = function () {
          return this.tileUrlFunction;
      };
      /**
       * Return the URLs used for this source.
       * When a tileUrlFunction is used instead of url or urls,
       * null will be returned.
       * @return {!Array<string>|null} URLs.
       * @api
       */
      UrlTile.prototype.getUrls = function () {
          return this.urls;
      };
      /**
       * Handle tile change events.
       * @param {import("../events/Event.js").default} event Event.
       * @protected
       */
      UrlTile.prototype.handleTileChange = function (event) {
          var tile = /** @type {import("../Tile.js").default} */ (event.target);
          var uid = getUid(tile);
          var tileState = tile.getState();
          var type;
          if (tileState == TileState.LOADING) {
              this.tileLoadingKeys_[uid] = true;
              type = TileEventType.TILELOADSTART;
          }
          else if (uid in this.tileLoadingKeys_) {
              delete this.tileLoadingKeys_[uid];
              type =
                  tileState == TileState.ERROR
                      ? TileEventType.TILELOADERROR
                      : tileState == TileState.LOADED
                          ? TileEventType.TILELOADEND
                          : undefined;
          }
          if (type != undefined) {
              this.dispatchEvent(new TileSourceEvent(type, tile));
          }
      };
      /**
       * Set the tile load function of the source.
       * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
       * @api
       */
      UrlTile.prototype.setTileLoadFunction = function (tileLoadFunction) {
          this.tileCache.clear();
          this.tileLoadFunction = tileLoadFunction;
          this.changed();
      };
      /**
       * Set the tile URL function of the source.
       * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
       * @param {string=} key Optional new tile key for the source.
       * @api
       */
      UrlTile.prototype.setTileUrlFunction = function (tileUrlFunction, key) {
          this.tileUrlFunction = tileUrlFunction;
          this.tileCache.pruneExceptNewestZ();
          if (typeof key !== 'undefined') {
              this.setKey(key);
          }
          else {
              this.changed();
          }
      };
      /**
       * Set the URL to use for requests.
       * @param {string} url URL.
       * @api
       */
      UrlTile.prototype.setUrl = function (url) {
          var urls = expandUrl(url);
          this.urls = urls;
          this.setUrls(urls);
      };
      /**
       * Set the URLs to use for requests.
       * @param {Array<string>} urls URLs.
       * @api
       */
      UrlTile.prototype.setUrls = function (urls) {
          this.urls = urls;
          var key = urls.join('\n');
          if (this.generateTileUrlFunction_) {
              this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
          }
          else {
              this.setKey(key);
          }
      };
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      UrlTile.prototype.tileUrlFunction = function (tileCoord, pixelRatio, projection) {
          return undefined;
      };
      /**
       * Marks a tile coord as being used, without triggering a load.
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       */
      UrlTile.prototype.useTile = function (z, x, y) {
          var tileCoordKey = getKeyZXY(z, x, y);
          if (this.tileCache.containsKey(tileCoordKey)) {
              this.tileCache.get(tileCoordKey);
          }
      };
      return UrlTile;
  }(TileSource));

  var __extends$1y = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
   * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
   * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
   * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
   * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
   * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
   * @property {boolean} [imageSmoothing=true] Enable image smoothing.
   * @property {boolean} [opaque=false] Whether the layer is opaque.
   * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
   * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
   * Higher values can increase reprojection performance, but decrease precision.
   * @property {import("./State.js").default} [state] Source state.
   * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
   * Default is {@link module:ol/ImageTile~ImageTile}.
   * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
   * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
   * ```js
   * function(imageTile, src) {
   *   imageTile.getImage().src = src;
   * };
   * ```
   * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
   * service advertizes 256px by 256px tiles but actually sends 512px
   * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
   * should be set to `2`.
   * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
   * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
   * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
   * used instead of defining each one separately in the `urls` option.
   * @property {Array<string>} [urls] An array of URL templates.
   * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
   * request out-of-bounds tiles from the server. When set to `false`, only one
   * world will be rendered. When set to `true`, tiles will be requested for one
   * world only, but they will be wrapped horizontally to render multiple worlds.
   * @property {number} [transition] Duration of the opacity transition for rendering.
   * To disable the opacity transition, pass `transition: 0`.
   * @property {string} [key] Optional tile key for proper cache fetching
   * @property {number} [zDirection=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   */
  /**
   * @classdesc
   * Base class for sources providing images divided into a tile grid.
   *
   * @fires import("./Tile.js").TileSourceEvent
   * @api
   */
  var TileImage = /** @class */ (function (_super) {
      __extends$1y(TileImage, _super);
      /**
       * @param {!Options} options Image tile options.
       */
      function TileImage(options) {
          var _this = _super.call(this, {
              attributions: options.attributions,
              cacheSize: options.cacheSize,
              opaque: options.opaque,
              projection: options.projection,
              state: options.state,
              tileGrid: options.tileGrid,
              tileLoadFunction: options.tileLoadFunction
                  ? options.tileLoadFunction
                  : defaultTileLoadFunction,
              tilePixelRatio: options.tilePixelRatio,
              tileUrlFunction: options.tileUrlFunction,
              url: options.url,
              urls: options.urls,
              wrapX: options.wrapX,
              transition: options.transition,
              key: options.key,
              attributionsCollapsible: options.attributionsCollapsible,
              zDirection: options.zDirection,
          }) || this;
          /**
           * @protected
           * @type {?string}
           */
          _this.crossOrigin =
              options.crossOrigin !== undefined ? options.crossOrigin : null;
          /**
           * @protected
           * @type {typeof ImageTile}
           */
          _this.tileClass =
              options.tileClass !== undefined ? options.tileClass : ImageTile;
          /**
           * @protected
           * @type {!Object<string, TileCache>}
           */
          _this.tileCacheForProjection = {};
          /**
           * @protected
           * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
           */
          _this.tileGridForProjection = {};
          /**
           * @private
           * @type {number|undefined}
           */
          _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
          /**
           * @private
           * @type {object|undefined}
           */
          _this.contextOptions_ =
              options.imageSmoothing === false ? IMAGE_SMOOTHING_DISABLED : undefined;
          /**
           * @private
           * @type {boolean}
           */
          _this.renderReprojectionEdges_ = false;
          return _this;
      }
      /**
       * @return {boolean} Can expire cache.
       */
      TileImage.prototype.canExpireCache = function () {
          if (this.tileCache.canExpireCache()) {
              return true;
          }
          else {
              for (var key in this.tileCacheForProjection) {
                  if (this.tileCacheForProjection[key].canExpireCache()) {
                      return true;
                  }
              }
          }
          return false;
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @param {!Object<string, boolean>} usedTiles Used tiles.
       */
      TileImage.prototype.expireCache = function (projection, usedTiles) {
          var usedTileCache = this.getTileCacheForProjection(projection);
          this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
          for (var id in this.tileCacheForProjection) {
              var tileCache = this.tileCacheForProjection[id];
              tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
          }
      };
      /**
       * @return {Object|undefined} Context options.
       */
      TileImage.prototype.getContextOptions = function () {
          return this.contextOptions_;
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {number} Gutter.
       */
      TileImage.prototype.getGutterForProjection = function (projection) {
          if (this.getProjection() &&
              projection &&
              !equivalent(this.getProjection(), projection)) {
              return 0;
          }
          else {
              return this.getGutter();
          }
      };
      /**
       * @return {number} Gutter.
       */
      TileImage.prototype.getGutter = function () {
          return 0;
      };
      /**
       * Return the key to be used for all tiles in the source.
       * @return {string} The key for all tiles.
       * @protected
       */
      TileImage.prototype.getKey = function () {
          return (_super.prototype.getKey.call(this) +
              (this.contextOptions_ ? '\n' + JSON.stringify(this.contextOptions_) : ''));
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {boolean} Opaque.
       */
      TileImage.prototype.getOpaque = function (projection) {
          if (this.getProjection() &&
              projection &&
              !equivalent(this.getProjection(), projection)) {
              return false;
          }
          else {
              return _super.prototype.getOpaque.call(this, projection);
          }
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
       */
      TileImage.prototype.getTileGridForProjection = function (projection) {
          var thisProj = this.getProjection();
          if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
              return this.tileGrid;
          }
          else {
              var projKey = getUid(projection);
              if (!(projKey in this.tileGridForProjection)) {
                  this.tileGridForProjection[projKey] = getForProjection(projection);
              }
              return this.tileGridForProjection[projKey];
          }
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {import("../TileCache.js").default} Tile cache.
       */
      TileImage.prototype.getTileCacheForProjection = function (projection) {
          var thisProj = this.getProjection();
          if (!thisProj || equivalent(thisProj, projection)) {
              return this.tileCache;
          }
          else {
              var projKey = getUid(projection);
              if (!(projKey in this.tileCacheForProjection)) {
                  this.tileCacheForProjection[projKey] = new TileCache(this.tileCache.highWaterMark);
              }
              return this.tileCacheForProjection[projKey];
          }
      };
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @param {string} key The key set on the tile.
       * @return {!import("../Tile.js").default} Tile.
       * @private
       */
      TileImage.prototype.createTile_ = function (z, x, y, pixelRatio, projection, key) {
          var tileCoord = [z, x, y];
          var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
          var tileUrl = urlTileCoord
              ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)
              : undefined;
          var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);
          tile.key = key;
          tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));
          return tile;
      };
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../Tile.js").default} Tile.
       */
      TileImage.prototype.getTile = function (z, x, y, pixelRatio, projection) {
          var sourceProjection = this.getProjection();
          if (!sourceProjection ||
              !projection ||
              equivalent(sourceProjection, projection)) {
              return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
          }
          else {
              var cache = this.getTileCacheForProjection(projection);
              var tileCoord = [z, x, y];
              var tile = void 0;
              var tileCoordKey = getKey$1(tileCoord);
              if (cache.containsKey(tileCoordKey)) {
                  tile = cache.get(tileCoordKey);
              }
              var key = this.getKey();
              if (tile && tile.key == key) {
                  return tile;
              }
              else {
                  var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
                  var targetTileGrid = this.getTileGridForProjection(projection);
                  var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
                  var newTile = new ReprojTile(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function (z, x, y, pixelRatio) {
                      return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
                  }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.contextOptions_);
                  newTile.key = key;
                  if (tile) {
                      newTile.interimTile = tile;
                      newTile.refreshInterimChain();
                      cache.replace(tileCoordKey, newTile);
                  }
                  else {
                      cache.set(tileCoordKey, newTile);
                  }
                  return newTile;
              }
          }
      };
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {!import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../Tile.js").default} Tile.
       * @protected
       */
      TileImage.prototype.getTileInternal = function (z, x, y, pixelRatio, projection) {
          var tile = null;
          var tileCoordKey = getKeyZXY(z, x, y);
          var key = this.getKey();
          if (!this.tileCache.containsKey(tileCoordKey)) {
              tile = this.createTile_(z, x, y, pixelRatio, projection, key);
              this.tileCache.set(tileCoordKey, tile);
          }
          else {
              tile = this.tileCache.get(tileCoordKey);
              if (tile.key != key) {
                  // The source's params changed. If the tile has an interim tile and if we
                  // can use it then we use it. Otherwise we create a new tile.  In both
                  // cases we attempt to assign an interim tile to the new tile.
                  var interimTile = tile;
                  tile = this.createTile_(z, x, y, pixelRatio, projection, key);
                  //make the new tile the head of the list,
                  if (interimTile.getState() == TileState.IDLE) {
                      //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
                      tile.interimTile = interimTile.interimTile;
                  }
                  else {
                      tile.interimTile = interimTile;
                  }
                  tile.refreshInterimChain();
                  this.tileCache.replace(tileCoordKey, tile);
              }
          }
          return tile;
      };
      /**
       * Sets whether to render reprojection edges or not (usually for debugging).
       * @param {boolean} render Render the edges.
       * @api
       */
      TileImage.prototype.setRenderReprojectionEdges = function (render) {
          if (this.renderReprojectionEdges_ == render) {
              return;
          }
          this.renderReprojectionEdges_ = render;
          for (var id in this.tileCacheForProjection) {
              this.tileCacheForProjection[id].clear();
          }
          this.changed();
      };
      /**
       * Sets the tile grid to use when reprojecting the tiles to the given
       * projection instead of the default tile grid for the projection.
       *
       * This can be useful when the default tile grid cannot be created
       * (e.g. projection has no extent defined) or
       * for optimization reasons (custom tile size, resolutions, ...).
       *
       * @param {import("../proj.js").ProjectionLike} projection Projection.
       * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
       * @api
       */
      TileImage.prototype.setTileGridForProjection = function (projection, tilegrid) {
          {
              var proj = get$3(projection);
              if (proj) {
                  var projKey = getUid(proj);
                  if (!(projKey in this.tileGridForProjection)) {
                      this.tileGridForProjection[projKey] = tilegrid;
                  }
              }
          }
      };
      return TileImage;
  }(UrlTile));
  /**
   * @param {ImageTile} imageTile Image tile.
   * @param {string} src Source.
   */
  function defaultTileLoadFunction(imageTile, src) {
      /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src = src;
  }

  function _typeof$e(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$e = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof$e = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$e(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  /**
   * Converts a Uint8Array to a String.
   * @param {Uint8Array} array that should be converted
   * @param {Number} offset array offset in case only subset of array items should
                     be extracted (default: 0)
   * @param {Number} limit maximum number of array items that should be extracted
                     (defaults to length of array)
   * @returns {String}
   */
  function uint8ArrayToString(arr) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var limit = arguments.length > 2 ? arguments[2] : undefined;
    var itemLimit = limit || arr.length - offset;
    var str = "";

    for (var i = offset; i < offset + itemLimit; i++) {
      str += String.fromCharCode(arr[i]);
    }

    return str;
  }
  /**
   * Converts a String to a Uint8Array.
   * @param {String} str string that should be converted
   * @returns {Uint8Array}
   */


  function stringToUint8Array(str) {
    var arr = new Uint8Array(str.length);

    for (var i = 0, j = str.length; i < j; i++) {
      arr[i] = str.charCodeAt(i);
    }

    return arr;
  }
  /**
   * Identifies the boundary in a multipart/related message header.
   * @param {String} header message header
   * @returns {String} boundary
   */


  function identifyBoundary(header) {
    var parts = header.split("\r\n");

    for (var i = 0; i < parts.length; i++) {
      if (parts[i].substr(0, 2) === "--") {
        return parts[i];
      }
    }

    return null;
  }
  /**
   * Checks whether a given token is contained by a message at a given offset.
   * @param {Uint8Array} message message content
   * @param {Uint8Array} token substring that should be present
   * @param {Number} offset offset in message content from where search should start
   * @returns {Boolean} whether message contains token at offset
   */


  function containsToken(message, token) {
    var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    if (offset + token.length > message.length) {
      return false;
    }

    var index = offset;

    for (var i = 0; i < token.length; i++) {
      if (token[i] !== message[index]) {
        return false;
      }

      index += 1;
    }

    return true;
  }
  /**
   * Finds a given token in a message at a given offset.
   * @param {Uint8Array} message message content
   * @param {Uint8Array} token substring that should be found
   * @param {String} offset message body offset from where search should start
   * @returns {Boolean} whether message has a part at given offset or not
   */


  function findToken(message, token) {
    var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var maxSearchLength = arguments.length > 3 ? arguments[3] : undefined;
    var searchLength = message.length;

    if (maxSearchLength) {
      searchLength = Math.min(offset + maxSearchLength, message.length);
    }

    for (var i = offset; i < searchLength; i++) {
      // If the first value of the message matches
      // the first value of the token, check if
      // this is the full token.
      if (message[i] === token[0]) {
        if (containsToken(message, token, i)) {
          return i;
        }
      }
    }

    return -1;
  }
  /**
   * Create a random GUID
   *
   * @return {string}
   */


  function guid() {
    function s4() {
      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }

    return "".concat(s4() + s4(), "-").concat(s4(), "-").concat(s4(), "-").concat(s4(), "-").concat(s4()).concat(s4()).concat(s4());
  }
  /**
   * @typedef {Object} MultipartEncodedData
   * @property {ArrayBuffer} data The encoded Multipart Data
   * @property {String} boundary The boundary used to divide pieces of the encoded data
   */

  /**
   * Encode one or more DICOM datasets into a single body so it can be
   * sent using the Multipart Content-Type.
   *
   * @param {ArrayBuffer[]} datasets Array containing each file to be encoded in the
                            multipart body, passed as ArrayBuffers.
   * @param {String} [boundary] Optional string to define a boundary between each part
                                of the multipart body. If this is not specified, a random
                                GUID will be generated.
   * @return {MultipartEncodedData} The Multipart encoded data returned as an Object. This
                                    contains both the data itself, and the boundary string
                                    used to divide it.
   */


  function multipartEncode(datasets) {
    var boundary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : guid();
    var contentType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "application/dicom";
    var contentTypeString = "Content-Type: ".concat(contentType);
    var header = "\r\n--".concat(boundary, "\r\n").concat(contentTypeString, "\r\n\r\n");
    var footer = "\r\n--".concat(boundary, "--");
    var headerArray = stringToUint8Array(header);
    var footerArray = stringToUint8Array(footer);
    var headerLength = headerArray.length;
    var footerLength = footerArray.length;
    var length = 0; // Calculate the total length for the final array

    var contentArrays = datasets.map(function (datasetBuffer) {
      var contentArray = new Uint8Array(datasetBuffer);
      var contentLength = contentArray.length;
      length += headerLength + contentLength + footerLength;
      return contentArray;
    }); // Allocate the array

    var multipartArray = new Uint8Array(length); // Set the initial header

    multipartArray.set(headerArray, 0); // Write each dataset into the multipart array

    var position = 0;
    contentArrays.forEach(function (contentArray) {
      multipartArray.set(headerArray, position);
      multipartArray.set(contentArray, position + headerLength);
      position += headerLength + contentArray.length;
    });
    multipartArray.set(footerArray, position);
    return {
      data: multipartArray.buffer,
      boundary: boundary
    };
  }
  /**
   * Decode a Multipart encoded ArrayBuffer and return the components as an Array.
   *
   * @param {ArrayBuffer} response Data encoded as a 'multipart/related' message
   * @returns {Array} The content
   */


  function multipartDecode(response) {
    var message = new Uint8Array(response);
    /* Set a maximum length to search for the header boundaries, otherwise
         findToken can run for a long time
      */

    var maxSearchLength = 1000; // First look for the multipart mime header

    var separator = stringToUint8Array("\r\n\r\n");
    var headerIndex = findToken(message, separator, 0, maxSearchLength);

    if (headerIndex === -1) {
      throw new Error("Response message has no multipart mime header");
    }

    var header = uint8ArrayToString(message, 0, headerIndex);
    var boundaryString = identifyBoundary(header);

    if (!boundaryString) {
      throw new Error("Header of response message does not specify boundary");
    }

    var boundary = stringToUint8Array(boundaryString);
    var boundaryLength = boundary.length;
    var components = [];
    var offset = boundaryLength; // Loop until we cannot find any more boundaries

    var boundaryIndex;

    while (boundaryIndex !== -1) {
      // Search for the next boundary in the message, starting
      // from the current offset position
      boundaryIndex = findToken(message, boundary, offset); // If no further boundaries are found, stop here.

      if (boundaryIndex === -1) {
        break;
      }

      var headerTokenIndex = findToken(message, separator, offset, maxSearchLength);

      if (headerTokenIndex === -1) {
        throw new Error("Response message part has no mime header");
      }

      offset = headerTokenIndex + separator.length; // Extract data from response message, excluding "\r\n"

      var spacingLength = 2;
      var data = response.slice(offset, boundaryIndex - spacingLength); // Add the data to the array of results

      components.push(data); // Move the offset to the end of the current section,
      // plus the identified boundary

      offset = boundaryIndex + boundaryLength;
    }

    return components;
  }

  function isObject$1(obj) {
    return _typeof$e(obj) === "object" && obj !== null;
  }

  function isEmptyObject(obj) {
    return Object.keys(obj).length === 0 && obj.constructor === Object;
  }

  var getFirstResult = function getFirstResult(result) {
    return result[0];
  };

  var getFirstResultIfLengthGtOne = function getFirstResultIfLengthGtOne(result) {
    if (result.length > 1) {
      return result;
    }

    return result[0];
  };

  var MEDIATYPES = {
    DICOM: "application/dicom",
    DICOM_JSON: "application/dicom+json",
    OCTET_STREAM: "application/octet-stream",
    PDF: "application/pdf",
    JPEG: "image/jpeg",
    PNG: "image/png"
  };
  /**
   * Class for interacting with DICOMweb RESTful services.
   */

  var DICOMwebClient =
  /*#__PURE__*/
  function () {
    /**
     * @constructor
     * @param {Object} options (choices: "url", "username", "password", "headers")
     */
    function DICOMwebClient(options) {
      _classCallCheck(this, DICOMwebClient);

      this.baseURL = options.url;

      if (!this.baseURL) {
        console.error("no DICOMweb base url provided - calls will fail");
      }

      if ("username" in options) {
        this.username = options.username;

        if (!("password" in options)) {
          console.error("no password provided to authenticate with DICOMweb service");
        }

        this.password = options.password;
      }

      if ("qidoURLPrefix" in options) {
        console.log("use URL prefix for QIDO-RS: ".concat(options.qidoURLPrefix));
        this.qidoURL = "".concat(this.baseURL, "/").concat(options.qidoURLPrefix);
      } else {
        this.qidoURL = this.baseURL;
      }

      if ("wadoURLPrefix" in options) {
        console.log("use URL prefix for WADO-RS: ".concat(options.wadoURLPrefix));
        this.wadoURL = "".concat(this.baseURL, "/").concat(options.wadoURLPrefix);
      } else {
        this.wadoURL = this.baseURL;
      }

      if ("stowURLPrefix" in options) {
        console.log("use URL prefix for STOW-RS: ".concat(options.stowURLPrefix));
        this.stowURL = "".concat(this.baseURL, "/").concat(options.stowURLPrefix);
      } else {
        this.stowURL = this.baseURL;
      }

      this.headers = options.headers || {};
    }

    _createClass(DICOMwebClient, [{
      key: "_httpRequest",
      value: function _httpRequest(url, method, headers) {
        var _this = this;

        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        return new Promise(function (resolve, reject) {
          var request = new XMLHttpRequest();
          request.open(method, url, true);

          if ("responseType" in options) {
            request.responseType = options.responseType;
          }

          if (_typeof$e(headers) === "object") {
            Object.keys(headers).forEach(function (key) {
              request.setRequestHeader(key, headers[key]);
            });
          } // now add custom headers from the user
          // (e.g. access tokens)


          var userHeaders = _this.headers;
          Object.keys(userHeaders).forEach(function (key) {
            request.setRequestHeader(key, userHeaders[key]);
          }); // Event triggered when upload starts

          request.onloadstart = function onloadstart() {// console.log('upload started: ', url)
          }; // Event triggered when upload ends


          request.onloadend = function onloadend() {// console.log('upload finished')
          }; // Handle response message


          request.onreadystatechange = function onreadystatechange() {
            if (request.readyState === 4) {
              if (request.status === 200) {
                resolve(request.response);
              } else if (request.status === 202) {
                console.warn("some resources already existed: ", request);
                resolve(request.response);
              } else if (request.status === 204) {
                console.warn("empty response for request: ", request);
                resolve([]);
              } else {
                console.error("request failed: ", request);
                var error = new Error("request failed");
                error.request = request;
                error.response = request.response;
                error.status = request.status;
                console.error(error);
                console.error(error.response);
                reject(error);
              }
            }
          }; // Event triggered while download progresses


          if ("progressCallback" in options) {
            if (typeof options.progressCallback === "function") {
              request.onprogress = options.progressCallback;
            }
          } // request.onprogress = function (event) {
          //   const loaded = progress.loaded;
          //   let total;
          //   let percentComplete;
          //   if (progress.lengthComputable) {
          //     total = progress.total;
          //     percentComplete = Math.round((loaded / total) * 100);
          //   j
          //   // console.log('download progress: ', percentComplete, ' %');
          //   return(percentComplete);
          // };


          if ("data" in options) {
            request.send(options.data);
          } else {
            request.send();
          }
        });
      }
    }, {
      key: "_httpGet",
      value: function _httpGet(url, headers, responseType, progressCallback) {
        return this._httpRequest(url, "get", headers, {
          responseType: responseType,
          progressCallback: progressCallback
        });
      }
    }, {
      key: "_httpGetApplicationJson",
      value: function _httpGetApplicationJson(url) {
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var progressCallback = arguments.length > 2 ? arguments[2] : undefined;
        var urlWithQueryParams = url;

        if (_typeof$e(params) === "object") {
          if (!isEmptyObject(params)) {
            urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);
          }
        }

        var headers = {
          Accept: MEDIATYPES.DICOM_JSON
        };
        var responseType = "json";
        return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback);
      }
      /**
       * Performs an HTTP GET request that accepts a message with
       "application/pdf" media type.
       * @param {String} url
       * @param {Object[]} mediaTypes
       * @param {Object} params
       * @param {Function} progressCallback
       * @return {*}
       * @private
       */

    }, {
      key: "_httpGetApplicationPdf",
      value: function _httpGetApplicationPdf(url) {
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var progressCallback = arguments.length > 2 ? arguments[2] : undefined;
        var urlWithQueryParams = url;

        if (_typeof$e(params) === "object") {
          if (!isEmptyObject(params)) {
            urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);
          }
        }

        var headers = {
          Accept: MEDIATYPES.PDF
        };
        var responseType = "json";
        return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback);
      }
      /**
       * Performs an HTTP GET request that accepts a message with an image
       media type.
       *
       * @param {String} url
       * @param {Object[]} mediaTypes
       * @param {Object} params
       * @param {Function} progressCallback
       * @return {*}
       * @private
       */

    }, {
      key: "_httpGetImage",
      value: function _httpGetImage(url, mediaTypes) {
        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var progressCallback = arguments.length > 3 ? arguments[3] : undefined;
        var urlWithQueryParams = url;

        if (_typeof$e(params) === "object") {
          if (!isEmptyObject(params)) {
            urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);
          }
        }

        var supportedMediaTypes = ["image/", "image/*", "image/jpeg", "image/jp2", "image/gif", "image/png"];

        var acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);

        var headers = {
          Accept: acceptHeaderFieldValue
        };
        var responseType = "arraybuffer";
        return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback);
      }
      /**
       * Performs an HTTP GET request that accepts a message with a text
       media type.
       *
       * @param {String} url
       * @param {Object[]} mediaTypes
       * @param {Object} params
       * @param {Function} progressCallback
       * @return {*}
       * @private
       */

    }, {
      key: "_httpGetText",
      value: function _httpGetText(url, mediaTypes) {
        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var progressCallback = arguments.length > 3 ? arguments[3] : undefined;
        var urlWithQueryParams = url;

        if (_typeof$e(params) === "object") {
          if (!isEmptyObject(params)) {
            urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);
          }
        }

        var supportedMediaTypes = ["text/", "text/*", "text/html", "text/plain", "text/rtf", "text/xml"];

        var acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);

        var headers = {
          Accept: acceptHeaderFieldValue
        };
        var responseType = "arraybuffer";
        return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback);
      }
      /**
       * Performs an HTTP GET request that accepts a message with a video
       media type.
       *
       * @param {String} url
       * @param {Object[]} mediaTypes
       * @param {Object} params
       * @param {Function} progressCallback
       * @return {*}
       * @private
       */

    }, {
      key: "_httpGetVideo",
      value: function _httpGetVideo(url, mediaTypes) {
        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var progressCallback = arguments.length > 3 ? arguments[3] : undefined;
        var urlWithQueryParams = url;

        if (_typeof$e(params) === "object") {
          if (!isEmptyObject(params)) {
            urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);
          }
        }

        var supportedMediaTypes = ["video/", "video/*", "video/mpeg", "video/mp4", "video/H265"];

        var acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);

        var headers = {
          Accept: acceptHeaderFieldValue
        };
        var responseType = "arraybuffer";
        return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback);
      }
      /**
       * Asserts that a given media type is valid.
       *
       * @params {String} mediaType media type
       */

    }, {
      key: "_httpGetMultipartImage",

      /**
       * Performs an HTTP GET request that accepts a multipart message with an image media type.
       *
       * @param {String} url unique resource locator
       * @param {Object[]} mediaTypes acceptable media types and optionally the UIDs of the
       corresponding transfer syntaxes
       * @param {Array} byteRange start and end of byte range
       * @param {Object} params additional HTTP GET query parameters
       * @param {Boolean} rendered whether resource should be requested using rendered media types
       * @param {Function} progressCallback
       * @private
       * @returns {Array} content of HTTP message body parts
       */
      value: function _httpGetMultipartImage(url, mediaTypes, byteRange, params) {
        var rendered = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        var progressCallback = arguments.length > 5 ? arguments[5] : undefined;
        var headers = {};
        var supportedMediaTypes;

        if (rendered) {
          supportedMediaTypes = ["image/jpeg", "image/gif", "image/png", "image/jp2"];
        } else {
          supportedMediaTypes = {
            "1.2.840.10008.1.2.5": ["image/x-dicom-rle"],
            "1.2.840.10008.1.2.4.50": ["image/jpeg"],
            "1.2.840.10008.1.2.4.51": ["image/jpeg"],
            "1.2.840.10008.1.2.4.57": ["image/jpeg"],
            "1.2.840.10008.1.2.4.70": ["image/jpeg"],
            "1.2.840.10008.1.2.4.80": ["image/x-jls", "image/jls"],
            "1.2.840.10008.1.2.4.81": ["image/x-jls", "image/jls"],
            "1.2.840.10008.1.2.4.90": ["image/jp2"],
            "1.2.840.10008.1.2.4.91": ["image/jp2"],
            "1.2.840.10008.1.2.4.92": ["image/jpx"],
            "1.2.840.10008.1.2.4.93": ["image/jpx"]
          };

          if (byteRange) {
            headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);
          }
        }

        headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);
        return this._httpGet(url, headers, "arraybuffer", progressCallback).then(multipartDecode);
      }
      /**
       * Performs an HTTP GET request that accepts a multipart message with a video media type.
       *
       * @param {String} url unique resource locator
       * @param {Object[]} mediaTypes acceptable media types and optionally the UIDs of the
       corresponding transfer syntaxes
       * @param {Array} byteRange start and end of byte range
       * @param {Object} params additional HTTP GET query parameters
       * @param {Boolean} rendered whether resource should be requested using rendered media types
       * @param {Function} progressCallback
       * @private
       * @returns {Array} content of HTTP message body parts
       */

    }, {
      key: "_httpGetMultipartVideo",
      value: function _httpGetMultipartVideo(url, mediaTypes, byteRange, params) {
        var rendered = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        var progressCallback = arguments.length > 5 ? arguments[5] : undefined;
        var headers = {};
        var supportedMediaTypes;

        if (rendered) {
          supportedMediaTypes = ["video/", "video/*", "video/mpeg2", "video/mp4", "video/H265"];
        } else {
          supportedMediaTypes = {
            "1.2.840.10008.1.2.4.100": ["video/mpeg2"],
            "1.2.840.10008.1.2.4.101": ["video/mpeg2"],
            "1.2.840.10008.1.2.4.102": ["video/mp4"],
            "1.2.840.10008.1.2.4.103": ["video/mp4"],
            "1.2.840.10008.1.2.4.104": ["video/mp4"],
            "1.2.840.10008.1.2.4.105": ["video/mp4"],
            "1.2.840.10008.1.2.4.106": ["video/mp4"]
          };

          if (byteRange) {
            headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);
          }
        }

        headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);
        return this._httpGet(url, headers, "arraybuffer", progressCallback).then(multipartDecode);
      }
      /**
       * Performs a HTTP GET request that accepts a multipart message with "application/dicom" media type
       *
       * @param {String} url unique resource locator
       * @param {Object[]} mediaTypes acceptable media types and optionally the UIDs of the
       corresponding transfer syntaxes
       * @param {Object} params additional HTTP GET query parameters
       * @param {Function} progressCallback
       * @private
       * @returns {Array} content of HTTP message body parts
       */

    }, {
      key: "_httpGetMultipartApplicationDicom",
      value: function _httpGetMultipartApplicationDicom(url, mediaTypes, params, progressCallback) {
        var headers = {};
        var defaultMediaType = "application/dicom";
        var supportedMediaTypes = {
          "1.2.840.10008.1.2.1": [defaultMediaType],
          "1.2.840.10008.1.2.5": [defaultMediaType],
          "1.2.840.10008.1.2.4.50": [defaultMediaType],
          "1.2.840.10008.1.2.4.51": [defaultMediaType],
          "1.2.840.10008.1.2.4.57": [defaultMediaType],
          "1.2.840.10008.1.2.4.70": [defaultMediaType],
          "1.2.840.10008.1.2.4.80": [defaultMediaType],
          "1.2.840.10008.1.2.4.81": [defaultMediaType],
          "1.2.840.10008.1.2.4.90": [defaultMediaType],
          "1.2.840.10008.1.2.4.91": [defaultMediaType],
          "1.2.840.10008.1.2.4.92": [defaultMediaType],
          "1.2.840.10008.1.2.4.93": [defaultMediaType],
          "1.2.840.10008.1.2.4.100": [defaultMediaType],
          "1.2.840.10008.1.2.4.101": [defaultMediaType],
          "1.2.840.10008.1.2.4.102": [defaultMediaType],
          "1.2.840.10008.1.2.4.103": [defaultMediaType],
          "1.2.840.10008.1.2.4.104": [defaultMediaType],
          "1.2.840.10008.1.2.4.105": [defaultMediaType],
          "1.2.840.10008.1.2.4.106": [defaultMediaType]
        };
        var acceptableMediaTypes = mediaTypes;

        if (!mediaTypes) {
          acceptableMediaTypes = [{
            mediaType: defaultMediaType
          }];
        }

        headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(acceptableMediaTypes, supportedMediaTypes);
        return this._httpGet(url, headers, "arraybuffer", progressCallback).then(multipartDecode);
      }
      /**
       * Performs a HTTP GET request that accepts a multipart message with "application/octet-stream" media type
       *
       * @param {String} url unique resource locator
       * @param {Object[]} mediaTypes acceptable media types and optionally the UIDs of the
       corresponding transfer syntaxes
       * @param {Array} byteRange start and end of byte range
       * @param {Object} params additional HTTP GET query parameters
       * @param {Function} progressCallback
       * @private
       * @returns {Array} content of HTTP message body parts
       */

    }, {
      key: "_httpGetMultipartApplicationOctetStream",
      value: function _httpGetMultipartApplicationOctetStream(url, mediaTypes, byteRange, params, progressCallback) {
        var headers = {};
        var defaultMediaType = "application/octet-stream";
        var supportedMediaTypes = {
          "1.2.840.10008.1.2.1": [defaultMediaType]
        };
        var acceptableMediaTypes = mediaTypes;

        if (!mediaTypes) {
          acceptableMediaTypes = [{
            mediaType: defaultMediaType
          }];
        }

        if (byteRange) {
          headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);
        }

        headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(acceptableMediaTypes, supportedMediaTypes);
        return this._httpGet(url, headers, "arraybuffer", progressCallback).then(multipartDecode);
      }
    }, {
      key: "_httpPost",
      value: function _httpPost(url, headers, data, progressCallback) {
        return this._httpRequest(url, "post", headers, {
          data: data,
          progressCallback: progressCallback
        });
      }
    }, {
      key: "_httpPostApplicationJson",
      value: function _httpPostApplicationJson(url, data, progressCallback) {
        var headers = {
          "Content-Type": MEDIATYPES.DICOM_JSON
        };
        return this._httpPost(url, headers, data, progressCallback);
      }
      /**
       * Parses media type and extracts its type and subtype.
       *
       * @param mediaType e.g. image/jpeg
       * @private
       */

    }, {
      key: "searchForStudies",

      /**
       * Searches for DICOM studies.
       * @param {Object} options options object
       * @return {Array} study representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2)
       */
      value: function searchForStudies() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        console.log("search for studies");
        var url = "".concat(this.qidoURL, "/studies");

        if ("queryParams" in options) {
          url += DICOMwebClient._parseQueryParameters(options.queryParams);
        }

        return this._httpGetApplicationJson(url);
      }
      /**
       * Retrieves metadata for a DICOM study.
       * @param {Object} options options object
       * @returns {Array} metadata elements in DICOM JSON format for each instance
                          belonging to the study
       */

    }, {
      key: "retrieveStudyMetadata",
      value: function retrieveStudyMetadata(options) {
        if (!("studyInstanceUID" in options)) {
          throw new Error("Study Instance UID is required for retrieval of study metadata");
        }

        console.log("retrieve metadata of study ".concat(options.studyInstanceUID));
        var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/metadata");
        return this._httpGetApplicationJson(url);
      }
      /**
       * Searches for DICOM series.
       * @param {Object} options options object
       * @returns {Array} series representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2a)
       */

    }, {
      key: "searchForSeries",
      value: function searchForSeries() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var url = this.qidoURL;

        if ("studyInstanceUID" in options) {
          console.log("search series of study ".concat(options.studyInstanceUID));
          url += "/studies/".concat(options.studyInstanceUID);
        }

        url += "/series";

        if ("queryParams" in options) {
          url += DICOMwebClient._parseQueryParameters(options.queryParams);
        }

        return this._httpGetApplicationJson(url);
      }
      /**
       * Retrieves metadata for a DICOM series.
       * @param {Object} options options object
       * @returns {Array} metadata elements in DICOM JSON format for each instance
                          belonging to the series
       */

    }, {
      key: "retrieveSeriesMetadata",
      value: function retrieveSeriesMetadata(options) {
        if (!("studyInstanceUID" in options)) {
          throw new Error("Study Instance UID is required for retrieval of series metadata");
        }

        if (!("seriesInstanceUID" in options)) {
          throw new Error("Series Instance UID is required for retrieval of series metadata");
        }

        console.log("retrieve metadata of series ".concat(options.seriesInstanceUID));
        var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/series/").concat(options.seriesInstanceUID, "/metadata");
        return this._httpGetApplicationJson(url);
      }
      /**
       * Searches for DICOM instances.
       * @param {Object} options options object
       * @returns {Array} instance representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2b)
       */

    }, {
      key: "searchForInstances",
      value: function searchForInstances() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var url = this.qidoURL;

        if ("studyInstanceUID" in options) {
          url += "/studies/".concat(options.studyInstanceUID);

          if ("seriesInstanceUID" in options) {
            console.log("search for instances of series ".concat(options.seriesInstanceUID));
            url += "/series/".concat(options.seriesInstanceUID);
          } else {
            console.log("search for instances of study ".concat(options.studyInstanceUID));
          }
        } else {
          console.log("search for instances");
        }

        url += "/instances";

        if ("queryParams" in options) {
          url += DICOMwebClient._parseQueryParameters(options.queryParams);
        }

        return this._httpGetApplicationJson(url);
      }
      /** Returns a WADO-URI URL for an instance
       * @param {Object} options options object
       * @returns {String} WADO-URI URL
       */

    }, {
      key: "buildInstanceWadoURIUrl",
      value: function buildInstanceWadoURIUrl(options) {
        if (!("studyInstanceUID" in options)) {
          throw new Error("Study Instance UID is required.");
        }

        if (!("seriesInstanceUID" in options)) {
          throw new Error("Series Instance UID is required.");
        }

        if (!("sopInstanceUID" in options)) {
          throw new Error("SOP Instance UID is required.");
        }

        var contentType = options.contentType || MEDIATYPES.DICOM;
        var transferSyntax = options.transferSyntax || "*";
        var params = [];
        params.push("requestType=WADO");
        params.push("studyUID=".concat(options.studyInstanceUID));
        params.push("seriesUID=".concat(options.seriesInstanceUID));
        params.push("objectUID=".concat(options.sopInstanceUID));
        params.push("contentType=".concat(contentType));
        params.push("transferSyntax=".concat(transferSyntax));
        var paramString = params.join("&");
        return "".concat(this.wadoURL, "?").concat(paramString);
      }
      /**
       * Retrieves metadata for a DICOM instance.
       *
       * @param {Object} options object
       * @returns {Object} metadata elements in DICOM JSON format
       */

    }, {
      key: "retrieveInstanceMetadata",
      value: function retrieveInstanceMetadata(options) {
        if (!("studyInstanceUID" in options)) {
          throw new Error("Study Instance UID is required for retrieval of instance metadata");
        }

        if (!("seriesInstanceUID" in options)) {
          throw new Error("Series Instance UID is required for retrieval of instance metadata");
        }

        if (!("sopInstanceUID" in options)) {
          throw new Error("SOP Instance UID is required for retrieval of instance metadata");
        }

        console.log("retrieve metadata of instance ".concat(options.sopInstanceUID));
        var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/series/").concat(options.seriesInstanceUID, "/instances/").concat(options.sopInstanceUID, "/metadata");
        return this._httpGetApplicationJson(url);
      }
      /**
       * Retrieves frames for a DICOM instance.
       * @param {Object} options options object
       * @returns {Array} frame items as byte arrays of the pixel data element
       */

    }, {
      key: "retrieveInstanceFrames",
      value: function retrieveInstanceFrames(options) {
        if (!("studyInstanceUID" in options)) {
          throw new Error("Study Instance UID is required for retrieval of instance frames");
        }

        if (!("seriesInstanceUID" in options)) {
          throw new Error("Series Instance UID is required for retrieval of instance frames");
        }

        if (!("sopInstanceUID" in options)) {
          throw new Error("SOP Instance UID is required for retrieval of instance frames");
        }

        if (!("frameNumbers" in options)) {
          throw new Error("frame numbers are required for retrieval of instance frames");
        }

        console.log("retrieve frames ".concat(options.frameNumbers.toString(), " of instance ").concat(options.sopInstanceUID));
        var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/series/").concat(options.seriesInstanceUID, "/instances/").concat(options.sopInstanceUID, "/frames/").concat(options.frameNumbers.toString());
        var mediaTypes = options.mediaTypes;

        if (!mediaTypes) {
          return this._httpGetMultipartApplicationOctetStream(url);
        }

        var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);

        if (commonMediaType === MEDIATYPES.OCTET_STREAM) {
          return this._httpGetMultipartApplicationOctetStream(url, mediaTypes);
        } else if (commonMediaType.startsWith("image")) {
          return this._httpGetMultipartImage(url, mediaTypes);
        } else if (commonMediaType.startsWith("video")) {
          return this._httpGetMultipartVideo(url, mediaTypes);
        }

        throw new Error("Media type ".concat(commonMediaType, " is not supported for retrieval of frames."));
      }
      /**
       * Retrieves an individual, server-side rendered DICOM instance.
       *
       * @param {Object} options options object
       * @returns {Array} frame items as byte arrays of the pixel data element
       */

    }, {
      key: "retrieveInstanceRendered",
      value: function retrieveInstanceRendered(options) {
        if (!("studyInstanceUID" in options)) {
          throw new Error("Study Instance UID is required for retrieval of rendered instance");
        }

        if (!("seriesInstanceUID" in options)) {
          throw new Error("Series Instance UID is required for retrieval of rendered instance");
        }

        if (!("sopInstanceUID" in options)) {
          throw new Error("SOP Instance UID is required for retrieval of rendered instance");
        }

        var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/series/").concat(options.seriesInstanceUID, "/instances/").concat(options.sopInstanceUID, "/rendered");
        var mediaTypes = options.mediaTypes,
            params = options.params;
        var headers = {};

        if (!mediaTypes) {
          var responseType = "arraybuffer";
          return this._httpGet(url, headers, responseType);
        }

        var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);

        if (commonMediaType.startsWith("image")) {
          return this._httpGetImage(url, mediaTypes, params);
        } else if (commonMediaType.startsWith("video")) {
          return this._httpGetVideo(url, mediaTypes, params);
        } else if (commonMediaType.startsWith("text")) {
          return this._httpGetText(url, mediaTypes, params);
        } else if (commonMediaType === MEDIATYPES.PDF) {
          return this._httpGetApplicationPdf(url, params);
        }

        throw new Error("Media type ".concat(commonMediaType, " is not supported for retrieval of rendered instance."));
      }
      /**
       * Retrieves rendered frames for a DICOM instance.
       * @param {Object} options options object
       * @returns {Array} frame items as byte arrays of the pixel data element
       */

    }, {
      key: "retrieveInstanceFramesRendered",
      value: function retrieveInstanceFramesRendered(options) {
        if (!("studyInstanceUID" in options)) {
          throw new Error("Study Instance UID is required for retrieval of rendered instance frames");
        }

        if (!("seriesInstanceUID" in options)) {
          throw new Error("Series Instance UID is required for retrieval of rendered instance frames");
        }

        if (!("sopInstanceUID" in options)) {
          throw new Error("SOP Instance UID is required for retrieval of rendered instance frames");
        }

        if (!("frameNumbers" in options)) {
          throw new Error("frame numbers are required for retrieval of rendered instance frames");
        }

        console.debug("retrieve rendered frames ".concat(options.frameNumbers.toString(), " of instance ").concat(options.sopInstanceUID));
        var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/series/").concat(options.seriesInstanceUID, "/instances/").concat(options.sopInstanceUID, "/frames/").concat(options.frameNumbers.toString(), "/rendered");
        var mediaTypes = options.mediaTypes;
        var headers = {};

        if (!mediaTypes) {
          var responseType = "arraybuffer";
          return this._httpGet(url, headers, responseType);
        }

        var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);

        if (commonMediaType.startsWith("image")) {
          return this._httpGetImage(url, mediaTypes);
        } else if (commonMediaType.startsWith("video")) {
          return this._httpGetVideo(url, mediaTypes);
        }

        throw new Error("Media type ".concat(commonMediaType, " is not supported for retrieval of rendered frame."));
      }
      /**
       * Retrieves a DICOM instance.
       * @param {Object} options options object
       * @returns {ArrayBuffer} DICOM Part 10 file as Arraybuffer
       */

    }, {
      key: "retrieveInstance",
      value: function retrieveInstance(options) {
        if (!("studyInstanceUID" in options)) {
          throw new Error("Study Instance UID is required");
        }

        if (!("seriesInstanceUID" in options)) {
          throw new Error("Series Instance UID is required");
        }

        if (!("sopInstanceUID" in options)) {
          throw new Error("SOP Instance UID is required");
        }

        var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/series/").concat(options.seriesInstanceUID, "/instances/").concat(options.sopInstanceUID);
        var mediaTypes = options.mediaTypes;

        if (!mediaTypes) {
          return this._httpGetMultipartApplicationDicom(url).then(getFirstResult);
        }

        var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);

        if (commonMediaType === MEDIATYPES.DICOM) {
          return this._httpGetMultipartApplicationDicom(url, mediaTypes).then(getFirstResult);
        } else if (commonMediaType === MEDIATYPES.OCTET_STREAM) {
          return this._httpGetMultipartApplicationOctetStream(url, mediaTypes).then(getFirstResult);
        } else if (commonMediaType.startsWith("image")) {
          return this._httpGetMultipartImage(url, mediaTypes).then(getFirstResultIfLengthGtOne);
        } else if (commonMediaType.startsWith("video")) {
          return this._httpGetMultipartVideo(url, mediaTypes).then(getFirstResultIfLengthGtOne);
        }

        throw new Error("Media type ".concat(commonMediaType, " is not supported for retrieval of instance."));
      }
      /**
       * Retrieves a set of DICOM instance for a series.
       * @param {Object} options options object
       * @returns {ArrayBuffer[]} Array of DICOM Part 10 files as Arraybuffers
       */

    }, {
      key: "retrieveSeries",
      value: function retrieveSeries(options) {
        if (!("studyInstanceUID" in options)) {
          throw new Error("Study Instance UID is required");
        }

        if (!("seriesInstanceUID" in options)) {
          throw new Error("Series Instance UID is required");
        }

        var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/series/").concat(options.seriesInstanceUID);
        var mediaTypes = options.mediaTypes;

        if (!mediaTypes) {
          return this._httpGetMultipartApplicationDicom(url);
        }

        var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);

        if (commonMediaType === MEDIATYPES.DICOM) {
          return this._httpGetMultipartApplicationDicom(url, mediaTypes);
        } else if (commonMediaType === MEDIATYPES.OCTET_STREAM) {
          return this._httpGetMultipartApplicationOctetStream(url, mediaTypes);
        } else if (commonMediaType.startsWith("image")) {
          return this._httpGetMultipartImage(url, mediaTypes);
        } else if (commonMediaType.startsWith("video")) {
          return this._httpGetMultipartVideo(url, mediaTypes);
        }

        throw new Error("Media type ".concat(commonMediaType, " is not supported for retrieval of series."));
      }
      /**
       * Retrieves a set of DICOM instance for a study.
       * @param {Object} options options object
       * @returns {ArrayBuffer[]} Array of DICOM Part 10 files as Arraybuffers
       */

    }, {
      key: "retrieveStudy",
      value: function retrieveStudy(options) {
        if (!("studyInstanceUID" in options)) {
          throw new Error("Study Instance UID is required");
        }

        var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID);
        var mediaTypes = options.mediaTypes;

        if (!mediaTypes) {
          return this._httpGetMultipartApplicationDicom(url);
        }

        var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);

        if (commonMediaType === MEDIATYPES.DICOM) {
          return this._httpGetMultipartApplicationDicom(url, mediaTypes);
        } else if (commonMediaType === MEDIATYPES.OCTET_STREAM) {
          return this._httpGetMultipartApplicationOctetStream(url, mediaTypes);
        } else if (commonMediaType.startsWith("image")) {
          return this._httpGetMultipartImage(url, mediaTypes);
        } else if (commonMediaType.startsWith("video")) {
          return this._httpGetMultipartVideo(url, mediaTypes);
        }

        throw new Error("Media type ".concat(commonMediaType, " is not supported for retrieval of study."));
      }
      /**
       * Retrieves and parses BulkData from a BulkDataURI location.
       * Decodes the multipart encoded data and returns the resulting data
       * as an ArrayBuffer.
       *
       * See http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.5.5.html
       *
       * @param {Object} options options object
       * @return {Promise}
       */

    }, {
      key: "retrieveBulkData",
      value: function retrieveBulkData(options) {
        if (!("BulkDataURI" in options)) {
          throw new Error("BulkDataURI is required.");
        }

        var url = options.BulkDataURI;
        var mediaTypes = options.mediaTypes,
            byteRange = options.byteRange;

        if (!mediaTypes) {
          return this._httpGetMultipartApplicationOctetStream(url, mediaTypes, byteRange);
        }

        var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);

        if (commonMediaType === MEDIATYPES.OCTET_STREAM) {
          return this._httpGetMultipartApplicationOctetStream(url, mediaTypes, byteRange);
        } else if (commonMediaType.startsWith("image")) {
          return this._httpGetMultipartImage(url, mediaTypes, byteRange);
        }

        throw new Error("Media type ".concat(commonMediaType, " is not supported for retrieval of bulk data."));
      }
      /**
       * Stores DICOM instances.
       *
       * @param {Object} options options object
       */

    }, {
      key: "storeInstances",
      value: function storeInstances(options) {
        if (!("datasets" in options)) {
          throw new Error("datasets are required for storing");
        }

        var url = "".concat(this.stowURL, "/studies");

        if ("studyInstanceUID" in options) {
          url += "/".concat(options.studyInstanceUID);
        }

        var _multipartEncode = multipartEncode(options.datasets),
            data = _multipartEncode.data,
            boundary = _multipartEncode.boundary;

        var headers = {
          "Content-Type": "multipart/related; type=application/dicom; boundary=".concat(boundary)
        };
        return this._httpPost(url, headers, data, options.progressCallback);
      }
    }], [{
      key: "_parseQueryParameters",
      value: function _parseQueryParameters() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var queryString = "?";
        Object.keys(params).forEach(function (key, index) {
          if (index !== 0) {
            queryString += "&";
          }

          queryString += "".concat(key, "=").concat(encodeURIComponent(params[key]));
        });
        return queryString;
      }
    }, {
      key: "_assertMediaTypeIsValid",
      value: function _assertMediaTypeIsValid(mediaType) {
        if (!mediaType) {
          throw new Error("Not a valid media type: ".concat(mediaType));
        }

        var sepIndex = mediaType.indexOf("/");

        if (sepIndex === -1) {
          throw new Error("Not a valid media type: ".concat(mediaType));
        }

        var mediaTypeType = mediaType.slice(0, sepIndex);
        var types = ["application", "image", "text", "video"];

        if (!types.includes(mediaTypeType)) {
          throw new Error("Not a valid media type: ".concat(mediaType));
        }

        if (mediaType.slice(sepIndex + 1).includes("/")) {
          throw new Error("Not a valid media type: ".concat(mediaType));
        }
      }
    }, {
      key: "_parseMediaType",
      value: function _parseMediaType(mediaType) {
        DICOMwebClient._assertMediaTypeIsValid(mediaType);

        return mediaType.split("/");
      }
      /**
       * Builds an accept header field value for HTTP GET request messages.
       *
       * @param {Object[]} mediaTypes Acceptable media types
       * @param {Object[]} supportedMediaTypes Supported media types
       * @return {*}
       * @private
       */

    }, {
      key: "_buildAcceptHeaderFieldValue",
      value: function _buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes) {
        if (!Array.isArray(mediaTypes)) {
          throw new Error("Acceptable media types must be provided as an Array");
        }

        var fieldValueParts = mediaTypes.map(function (item) {
          var mediaType = item.mediaType;

          DICOMwebClient._assertMediaTypeIsValid(mediaType);

          if (!supportedMediaTypes.includes(mediaType)) {
            throw new Error("Media type ".concat(mediaType, " is not supported for requested resource"));
          }

          return mediaType;
        });
        return fieldValueParts.join(", ");
      }
      /**
         * Builds an accept header field value for HTTP GET multipart request
         messages.
         *
         * @param {Object[]} mediaTypes Acceptable media types
         * @param {Object[]} supportedMediaTypes Supported media types
         * @private
         */

    }, {
      key: "_buildMultipartAcceptHeaderFieldValue",
      value: function _buildMultipartAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes) {
        if (!Array.isArray(mediaTypes)) {
          throw new Error("Acceptable media types must be provided as an Array");
        }

        if (!Array.isArray(supportedMediaTypes) && !isObject$1(supportedMediaTypes)) {
          throw new Error("Supported media types must be provided as an Array or an Object");
        }

        var fieldValueParts = [];
        mediaTypes.forEach(function (item) {
          var transferSyntaxUID = item.transferSyntaxUID,
              mediaType = item.mediaType;

          DICOMwebClient._assertMediaTypeIsValid(mediaType);

          var fieldValue = "multipart/related; type=\"".concat(mediaType, "\"");

          if (isObject$1(supportedMediaTypes)) {
            // SupportedMediaTypes is a lookup table that maps Transfer Syntax UID
            // to one or more Media Types
            if (!Object.values(supportedMediaTypes).flat(1).includes(mediaType)) {
              if (!mediaType.endsWith("/*") || !mediaType.endsWith("/")) {
                throw new Error("Media type ".concat(mediaType, " is not supported for requested resource"));
              }
            }

            if (transferSyntaxUID) {
              if (transferSyntaxUID !== "*") {
                if (!Object.keys(supportedMediaTypes).includes(transferSyntaxUID)) {
                  throw new Error("Transfer syntax ".concat(transferSyntaxUID, " is not supported for requested resource"));
                }

                var expectedMediaTypes = supportedMediaTypes[transferSyntaxUID];

                if (!expectedMediaTypes.includes(mediaType)) {
                  var actualType = DICOMwebClient._parseMediaType(mediaType)[0];

                  expectedMediaTypes.map(function (expectedMediaType) {
                    var expectedType = DICOMwebClient._parseMediaType(expectedMediaType)[0];

                    var haveSameType = actualType === expectedType;

                    if (haveSameType && (mediaType.endsWith("/*") || mediaType.endsWith("/"))) {
                      return;
                    }

                    throw new Error("Transfer syntax ".concat(transferSyntaxUID, " is not supported for requested resource"));
                  });
                }
              }

              fieldValue += "; transfer-syntax=".concat(transferSyntaxUID);
            }
          } else if (Array.isArray(supportedMediaTypes) && !supportedMediaTypes.includes(mediaType)) {
            throw new Error("Media type ".concat(mediaType, " is not supported for requested resource"));
          }

          fieldValueParts.push(fieldValue);
        });
        return fieldValueParts.join(", ");
      }
      /**
       * Builds a range header field value for HTTP GET request messages.
       *
       * @param {Array} byteRange start and end of byte range
       * @returns {String} range header field value
       */

    }, {
      key: "_buildRangeHeaderFieldValue",
      value: function _buildRangeHeaderFieldValue() {
        var byteRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        if (byteRange.length === 1) {
          return "bytes=".concat(byteRange[0], "-");
        }

        if (byteRange.length === 2) {
          return "bytes=".concat(byteRange[0], "-").concat(byteRange[1]);
        }

        return "bytes=0-";
      }
      /**
       * Gets common type of acceptable media types and asserts that only
       one type is specified. For example, ``("image/jpeg", "image/jp2")``
       will pass, but ``("image/jpeg", "video/mpeg2")`` will raise an
       exception.
       * @param {String[]} acceptable media types and optionally the UIDs of the
       corresponding transfer syntaxes
       *
       */

    }, {
      key: "_getCommonMediaType",
      value: function _getCommonMediaType(mediaTypes) {
        if (!mediaTypes || !mediaTypes.length) {
          throw new Error("No acceptable media types provided");
        }

        var commonMediaTypes = new Set();
        mediaTypes.forEach(function (item) {
          var mediaType = item.mediaType;

          if (mediaType.startsWith("application")) {
            commonMediaTypes.add(mediaType);
          } else {
            var type = DICOMwebClient._parseMediaType(mediaType)[0];

            commonMediaTypes.add("".concat(type, "/"));
          }
        });

        if (commonMediaTypes.size === 0) {
          throw new Error("No common acceptable media type could be identified.");
        } else if (commonMediaTypes.size > 1) {
          throw new Error("Acceptable media types must have the same type.");
        }

        return Array.from(commonMediaTypes)[0];
      }
    }]);

    return DICOMwebClient;
  }();

  function findSubstring(str, before, after) {
    var beforeIndex = str.lastIndexOf(before) + before.length;

    if (beforeIndex < before.length) {
      return null;
    }

    if (after !== undefined) {
      var afterIndex = str.lastIndexOf(after);

      if (afterIndex < 0) {
        return null;
      }

      return str.substring(beforeIndex, afterIndex);
    }

    return str.substring(beforeIndex);
  }

  function getStudyInstanceUIDFromUri(uri) {
    var uid = findSubstring(uri, "studies/", "/series");

    if (!uid) {
      uid = findSubstring(uri, "studies/");
    }

    if (!uid) {
      console.debug("Study Instance UID could not be dertermined from URI \"".concat(uri, "\""));
    }

    return uid;
  }

  function getSeriesInstanceUIDFromUri(uri) {
    var uid = findSubstring(uri, "series/", "/instances");

    if (!uid) {
      uid = findSubstring(uri, "series/");
    }

    if (!uid) {
      console.debug("Series Instance UID could not be dertermined from URI \"".concat(uri, "\""));
    }

    return uid;
  }

  function getSOPInstanceUIDFromUri(uri) {
    var uid = findSubstring(uri, "/instances/", "/frames");

    if (!uid) {
      uid = findSubstring(uri, "/instances/", "/metadata");
    }

    if (!uid) {
      uid = findSubstring(uri, "/instances/");
    }

    if (!uid) {
      console.debug("SOP Instance UID could not be dertermined from URI\"".concat(uri, "\""));
    }

    return uid;
  }

  function getFrameNumbersFromUri(uri) {
    var numbers = findSubstring(uri, "/frames/", "/rendered");

    if (!numbers) {
      numbers = findSubstring(uri, "/frames/");
    }

    if (numbers === undefined) {
      console.debug("Frames Numbers could not be dertermined from URI\"".concat(uri, "\""));
    }

    return numbers.split(",");
  }
  var utils = {
    getStudyInstanceUIDFromUri: getStudyInstanceUIDFromUri,
    getSeriesInstanceUIDFromUri: getSeriesInstanceUIDFromUri,
    getSOPInstanceUIDFromUri: getSOPInstanceUIDFromUri,
    getFrameNumbersFromUri: getFrameNumbersFromUri
  };

  const Marker = {
    Arrow: "arrow",
  };

  const Markup = {
    Measurement: "measurement",
    FreeTextEvaluation: "freetext",
  };

  const FeatureEvents = {
    PROPERTY_CHANGE: "propertychange",
  };

  const MapEvents = {
    POINTER_MOVE: "pointermove",
    POINTER_UP: "pointerup",
  };

  const HTMLElementEvents = {
    MOUSE_DOWN: "mousedown",
  };

  const InteractionEvents = {
    DRAW_START: "drawstart",
    DRAW_END: "drawend",
    TRANSLATE_START: "translatestart",
    MODIFY_START: "modifystart",
  };

  const FeatureGeometryEvents = {
    CHANGE: 'change'
  };

  const RelationshipTypes = {
    HAS_OBS_CONTEXT: "HAS OBS CONTEXT",
  };

  var Enums = {
    Marker,
    Markup,
    FeatureEvents,
    FeatureGeometryEvents,
    RelationshipTypes,
    InteractionEvents,
    HTMLElementEvents,
    MapEvents
  };

  /**
   * Builds a new LineString instance with the shortest
   * distance between a given overlay and a feature.
   * 
   * @param {object} feature The feature
   * @param {object} overlay The overlay instance
   * @returns {LineString} The smallest line between the overlay and feature
   */
  const getShortestLineBetweenOverlayAndFeature = (feature, overlay) => {
    let result;
    let distanceSq = Infinity;

    let featureGeometry = feature.getGeometry();

    if (featureGeometry instanceof Circle) {
      featureGeometry = fromCircle(featureGeometry);
    }

    let geometry = featureGeometry.getLinearRing ? featureGeometry.getLinearRing(0) : featureGeometry;

    (geometry.getCoordinates() || geometry.getExtent()).forEach(coordinates => {
      const closest = overlay.getPosition();
      const distanceNew = Math.pow(closest[0] - coordinates[0], 2) + Math.pow(closest[1] - coordinates[1], 2);
      if (distanceNew < distanceSq) {
        distanceSq = distanceNew;
        result = [coordinates, closest];
      }
    });

    const coordinates = overlay.getPosition();
    const closest = geometry.getClosestPoint(coordinates);
    const distanceNew = Math.pow(closest[0] - coordinates[0], 2) + Math.pow(closest[1] - coordinates[1], 2);
    if (distanceNew < distanceSq) {
      distanceSq = distanceNew;
      result = [closest, coordinates];
    }

    return new LineString(result);
  };

  const UnitsEnum = { METERS: 'm' };
  const DEFAULT_DPI$1 = 25.4 / 0.28;

  const getUnitsSuffix = (view) => {
    const center = view.getCenter();
    const projection = view.getProjection();
    const resolution = view.getResolution();

    const pointResolutionUnits = UnitsEnum.METERS;

    let pointResolution = getPointResolution(
      projection,
      resolution,
      center,
      pointResolutionUnits
    );

    const DEFAULT_MIN_WIDTH = 65;
    const minWidth = (DEFAULT_MIN_WIDTH * (DEFAULT_DPI$1)) / DEFAULT_DPI$1;

    let nominalCount = minWidth * pointResolution;
    let suffix = '';

    if (nominalCount < 0.001) {
      suffix = 'm';
      pointResolution *= 1000000;
    } else if (nominalCount < 1) {
      suffix = 'mm';
      pointResolution *= 1000;
    } else if (nominalCount < 1000) {
      suffix = 'm';
    } else {
      suffix = 'km';
      pointResolution /= 1000;
    }

    return suffix;
  };

  const stroke = {
    color: "#3399CC",
  };

  var defaultStyles$1 = {
    stroke,
  };

  class _MarkupManager {
    constructor({
      map,
      source,
      formatters,
      onClick,
      onDrawStart,
      onDrawEnd,
      onStyle,
    } = {}) {
      this._map = map;
      this._source = source;
      this._formatters = formatters;

      this.onDrawStart = onDrawStart;
      this.onDrawEnd = onDrawEnd;
      this.onClick = onClick;
      this.onStyle = onStyle;

      this._markups = new Map();
      this._listeners = new Map();
      this._links = new Collection([], { unique: true });

      const defaultColor = defaultStyles$1.stroke.color;
      this._styleTag = document.createElement("style");
      this._styleTag.innerHTML = this._getTooltipStyles(defaultColor);

      this._linksVector = new VectorLayer({
        source: new VectorSource({ features: this._links }),
      });

      this._markupsOverlay = new Overlay({ element: this._styleTag });
      this._map.addOverlay(this._markupsOverlay);
      this._map.addLayer(this._linksVector);

      this._onDrawStart = this._onDrawStart.bind(this);
      this._onDrawEnd = this._onDrawEnd.bind(this);

      this.bindInteractionEvents(this._map.getInteractions());
    }

    /**
     * Checks whether a markup exists.
     *
     * @param {string} id The markup id
     * @return {boolean}
     */
    has(id) {
      return this._markups.has(id);
    }

    /**
     * Returns a markup
     *
     * @param {string} id The markup id
     * @return {object} The markup
     */
    get(id) {
      return this._markups.get(id);
    }

    /**
     * Removes a markup and its link
     *
     * @param {string} id The markup id
     * @return {string} The markup id
     */
    remove(id) {
      const markup = this.get(id);
      if (!markup) {
        return id;
      }

      const links = this._links.getArray();
      const link = links.find((feature) => feature.getId() === id);
      if (link) {
        this._links.remove(link);
      }

      this._map.removeOverlay(markup.overlay);
      this._markups.delete(id);

      if (this._listeners.get(id)) {
        this._listeners.delete(id);
      }

      return id;
    }

    /**
     * Creates a new markup
     *
     * @param {object} options The options
     * @param {Feature} options.feature The feature to plug the measure markup
     * @param {string} options.value The inner content of element
     * @param {boolean} options.isLinkable Create a link between feature and markup
     * @param {boolean} options.isDraggable Allow markup to be dragged
     * @param {array} offset Markup offset
     * @return {object} The markup object
     */
    create({
      feature,
      value = "",
      isLinkable = true,
      isDraggable = true,
      offset = [7, 7],
    }) {
      const id = feature.getId();
      if (!id) {
        console.warn("Failed to create markup, feature id not found");
        return;
      }

      if (this.has(id)) {
        console.warn("Markup for feature already exists", id);
        return this.get(id);
      }

      const listener = feature
        .getGeometry()
        .on(Enums.FeatureGeometryEvents.CHANGE, ({ target: geometry }) => {
          if (this.has(id)) {
            const view = this._map.getView();
            const unitsSuffix = getUnitsSuffix(view);
            const format = this._getFormatter(feature);
            const output = format(feature, unitsSuffix);
            this.update({
              feature,
              value: output,
              coordinate: geometry.getLastCoordinate(),
            });
            this.drawLink(feature);
          }
        });
      this._listeners.set(id, listener);

      const markup = { id, isLinkable, isDraggable };

      const element = document.createElement("div");
      element.id = markup.isDraggable ? "markup" : "";
      element.className = "ol-tooltip ol-tooltip-measure";
      element.innerText = value;

      markup.element = element;
      markup.overlay = new Overlay({
        className: "markup-container",
        positioning: "center-center",
        stopEvent: false,
        dragging: false,
        offset,
        element: markup.element,
      });

      const styleTooltip = (feature) => {
        const styleOptions = feature.get("styleOptions");
        if (styleOptions && styleOptions.stroke) {
          const { color } = styleOptions.stroke;
          const tooltipColor = color || defaultStyles$1.stroke.color;
          const links = this._links.getArray();
          const link = links.find((link) => link.getId() === feature.getId());
          if (link) {
            const styles = link.getStyle();
            const stroke$$1 = styles.getStroke();
            stroke$$1.setColor(tooltipColor);
            styles.setStroke(stroke$$1);
            link.setStyle(styles);
          }
          const styleTag = document.createElement("style");
          styleTag.innerHTML = this._getTooltipStyles(tooltipColor);
          this._markupsOverlay.setElement(styleTag);
        }
      };

      feature.on(
        Enums.FeatureEvents.PROPERTY_CHANGE,
        ({ key: property, target: feature }) => {
          if (property === "styleOptions") {
            styleTooltip(feature);
          }
        }
      );

      const featureCoordinate = feature.getGeometry().getLastCoordinate();
      markup.overlay.setPosition(featureCoordinate);

      let dragPan;
      let dragProperty = "dragging";
      this._map.getInteractions().forEach((interaction) => {
        if (interaction instanceof DragPan) {
          dragPan = interaction;
        }
      });

      element.addEventListener(Enums.HTMLElementEvents.MOUSE_DOWN, () => {
        const markup = this.get(id);
        if (markup) {
          dragPan.setActive(false);
          markup.overlay.set(dragProperty, true);
        }
      });

      this._map.on(Enums.MapEvents.POINTER_MOVE, (event) => {
        const markup = this.get(id);
        if (
          markup &&
          markup.overlay.get(dragProperty) === true &&
          markup.isDraggable
        ) {
          markup.overlay.setPosition(event.coordinate);
          this.drawLink(feature);
        }
      });

      this._map.on(Enums.MapEvents.POINTER_UP, () => {
        const markup = this.get(id);
        if (
          markup &&
          markup.overlay.get(dragProperty) === true &&
          markup.isDraggable
        ) {
          dragPan.setActive(true);
          markup.overlay.set(dragProperty, false);
        }
      });

      this._map.addOverlay(markup.overlay);
      this._markups.set(id, markup);

      this.drawLink(feature);

      return markup;
    }

    /**
     * Returns tooltip styles
     *
     * @param {string} color
     */
    _getTooltipStyles(color) {
      return `
      .ol-tooltip {
        color: ${color};
        white-space: nowrap;
        font-size: 14px;
      }
      .ol-tooltip-measure { opacity: 1; }
      .ol-tooltip-static { color: ${color}; }
      .ol-tooltip-measure:before,
      .ol-tooltip-static:before {
        content: '',
      }

      #markup { cursor: move; }
      .markup-container { display: block !important; }
    `;
    }

    /**
     * Checks if feature has the correct markup
     *
     * @param {Feature} feature The feature
     */
    _isValidFeature(feature) {
      return Object.values(Enums.Markup).includes(feature.get("markup"));
    }

    /**
     * Update markup content
     *
     * @param {object} markup The markup properties
     * @param {Feature} markup.feature The markup feature
     * @param {string} markup.value The markup content
     * @param {string} markup.coordinate The markup coordinate
     */
    update({ feature, value, coordinate }) {
      const id = feature.getId();

      if (!id) {
        console.warn("Failed attempt to update markup, feature with empty id");
        return;
      }

      const markup = this.get(id);
      if (!markup) {
        console.warn("No markup found for given feature");
        return;
      }

      if (value) {
        markup.element.innerText = value;
      }

      if (coordinate) {
        markup.overlay.setPosition(coordinate);
      }

      this._markups.set(id, markup);
    }

    /**
     * Get basic metadata of markup
     *
     * @param {Feature} feature The feature
     * @return {object} metadata
     */
    _getMetadata(feature) {
      const id = feature.getId();
      const markup = this.get(id);
      if (markup) {
        return {
          id: markup.id,
          value: markup.element.innerText,
          coordinate: markup.overlay.getPosition(),
        };
      }
    }

    /**
     * This event is responsible assign markup classes
     *
     * @param {object} event The event
     */
    _onDrawEnd(event) {
      this.onDrawEnd(event);
      const feature = event.feature;
      if (this._isValidFeature(feature)) {
        const featureId = feature.getId();
        const markup = this.get(featureId);
        if (markup) {
          markup.element.className = "ol-tooltip ol-tooltip-static";
          this._markups.set(featureId, markup);
        }
      }
    }

    /**
     * Returns the string format function for a given markup
     *
     * @param {object} feature The feature
     * @returns {function} format function
     */
    _getFormatter(feature) {
      const markup = feature.get("markup");
      const formatter = this._formatters[markup];
      if (!formatter) return () => "";
      return formatter;
    }

    /**
     * Wire interaction events everytime new interactions is added or updated
     *
     * @param {object[]} interactions The map interactions
     */
    bindInteractionEvents(interactions) {
      if (interactions.draw) {
        this._listeners.set(
          Enums.InteractionEvents.DRAW_START,
          interactions.draw.on(
            Enums.InteractionEvents.DRAW_START,
            this._onDrawStart
          )
        );
        this._listeners.set(
          Enums.InteractionEvents.DRAW_END,
          interactions.draw.on(Enums.InteractionEvents.DRAW_END, this._onDrawEnd)
        );
      }
    }

    /**
     * Wire interaction events everytime new interactions is added or updated
     *
     * @param {object[]} interactions The map interactions
     */
    onInteractionsChange(interactions) {
      this.bindInteractionEvents(interactions);
    }

    /**
     * Draws a link between the feature and the markup
     *
     * @param {object} feature The feature
     */
    drawLink(feature) {
      const markup = this.get(feature.getId());
      if (!markup.isLinkable) {
        return;
      }

      const line = getShortestLineBetweenOverlayAndFeature(
        feature,
        markup.overlay
      );

      const updated = this._links.getArray().some((feature) => {
        if (feature.getId() === markup.id) {
          feature.setGeometry(line);
          return true;
        }
      });

      if (!updated) {
        const feature = new Feature({ geometry: line, name: "Line" });
        feature.setId(markup.id);
        feature.setStyle(
          new Style({
            stroke: new Stroke({
              color: defaultStyles$1.stroke.color,
              lineDash: [0.3, 7],
              width: 3,
            }),
          })
        );
        this._links.push(feature);
      }
    }

    /**
     * Update the markup on drawstart
     * and caches it
     *
     * @param {object} event The drawstart event
     */
    _onDrawStart(event) {
      this.onDrawStart(event);
    }
  }

  /**
   * Format measure output
   * @param {Feature} feature feature
   * @param {string} units units
   * @return {string} The formatted measure of this feature
   */
  const format$5 = (feature, units) => {
    let output =
      Math.round((rawMeasurement(feature) / 10) * 100) / 100 + " " + units;
    return output;
  };

  /**
   * Get measurement from feature
   * @param {Feature} feature feature
   * @return {string} The formatted measure of this feature
   */
  const rawMeasurement = (feature) => {
    let value;
    let geom = feature.getGeometry();
    if (geom instanceof LineString) {
      value = getLength(geom);
      feature.set("length", value);
    } else if (geom instanceof Circle) {
      geom = fromCircle(geom);
      value = getArea$1(geom);
      feature.set("area", value);
    } else if (geom instanceof Polygon$1) {
      value = getArea$1(geom);
      feature.set("area", value);
    }
    let output = Math.round((value / 10) * 100) / 100;
    return output;
  };

  const isMeasurement = (feature) =>
    Enums.Markup.Measurement === feature.get("markup");

  const MeasurementMarkup = (api) => {
    return {
      onAdd: (feature) => {
        if (isMeasurement(feature)) {
          const view = api.map.getView();
          const unitsSuffix = getUnitsSuffix(view);
          api.markupManager.create({
            feature,
            value: format$5(feature, unitsSuffix),
          });
        }
      },
      onRemove: (feature) => {
        if (isMeasurement(feature)) {
          const featureId = feature.getId();
          api.markupManager.remove(featureId);
        }
      },
      onUpdate: (feature) => {},
      onDrawStart: ({ feature }) => {
        if (isMeasurement(feature)) {
          api.markupManager.create({ feature });
        }
      },
      onDrawEnd: ({ feature }) => {},
      isMeasurement,
      format: format$5,
    };
  };

  const getArrowStyle = (point, rotation, anchor, color) => {
    const icon = `
    <svg version="1.1" width="208px" height="208px" viewBox="0 -7.101 760.428 415.101" style="enable-background:new 0 0 408 408;" xmlns="http://www.w3.org/2000/svg">
      <g>
        <path style="fill:${encodeURIComponent(
          color
        )};" d="M 736.978 175.952 L 96.9 178.5 L 239.7 35.7 L 204 0 L 0 204 L 204 408 L 239.7 372.3 L 96.9 229.5 L 737.197 224.191 L 736.978 175.952 Z"/>
      </g>
    </svg>
  `;
    return new Style({
      geometry: new Point$1(point),
      image: new Icon({
        opacity: 1,
        src: `data:image/svg+xml;utf8,${icon}`,
        scale: 0.2,
        anchor,
        rotateWithView: true,
        rotation: -rotation,
      }),
    });
  };

  const isLocked = {};
  const bindStyleEvents = (feature) => {
    applyStyle(feature);
    if (!isLocked[feature.getId()]) {
      const onGeometryChange = () => {
        if (isArrow(feature)) {
          applyStyle(feature);
        }
      };
      feature.getGeometry().on(Enums.FeatureGeometryEvents.CHANGE, onGeometryChange);
      isLocked[feature.getId()] = true;
      feature.on(
        Enums.FeatureEvents.PROPERTY_CHANGE,
        ({ key: property, target: feature }) => {
          if (property === "styleOptions") {
            applyStyle(feature);
          }
        }
      );
    }
  };

  const applyStyle = (feature) => {
    const geometry = feature.getGeometry();
    if (geometry instanceof Point$1) {
      const anchor = [0, 0.5];
      const rotation = 120;
      const point = geometry.getCoordinates();
      const styleOptions = feature.get("styleOptions");
      const color =
        styleOptions && styleOptions.stroke && styleOptions.stroke.color
          ? styleOptions.stroke.color
          : defaultStyles$1.stroke.color;
      const arrowStyle = getArrowStyle(point, rotation, anchor, color);
      feature.setStyle(arrowStyle);
    }
  };

  const isArrow = (feature) =>
    Enums.Marker.Arrow === feature.get("marker");

  /**
   * Format arrow output
   * @param {LineString} arrow geometry
   * @return {string} The formatted output
   */
  const format$6 = (feature) => feature.get("label") || "";

  const ArrowMarker = (api) => {
    return {
      onAdd: (feature) => {
        if (isArrow(feature)) {
          bindStyleEvents(feature);
        }
      },
      onUpdate: (feature) => {},
      onRemove: (feature) => isLocked[feature.getId()] = null,
      onDrawStart: ({ feature }) => {},
      onDrawEnd: ({ feature }) => {
        if (isArrow(feature)) {
          bindStyleEvents(feature);
        }
      },
      isArrow,
      format: format$6,
    };
  };

  const isFreeText = (feature) =>
    Enums.Markup.FreeTextEvaluation === feature.get("markup");

  /**
   * Format free text output
   * @param {Feature} feature feature
   * @return {string} The formatted output
   */
  const format$7 = (feature) => feature.get("label") || "";

  const applyStyle$1 = (feature) => {
    if (hasMarker(feature)) return;
    const style = new Style({
      image: new CircleStyle({
        fill: new Fill({
          color: "rgba(255,255,255,0.0)",
        }),
        stroke: new Stroke({
          color: "rgba(255,255,255,0.0)",
          width: 0,
        }),
        radius: 5,
      }),
    });

    feature.setStyle(style);
  };

  const hasMarker = (feature) => !!feature.get("marker");

  const FreeTextMarkup = (api) => {
    return {
      onAdd: (feature) => {
        if (isFreeText(feature)) {
          const featureHasMarker = hasMarker(feature);
          api.markupManager.create({
            feature,
            value: format$7(feature),
            isLinkable: featureHasMarker,
            isDraggable: featureHasMarker,
            offset: featureHasMarker ? [7, 7] : [1, 1],
          });
          applyStyle$1(feature);
          feature.on(
            Enums.FeatureEvents.PROPERTY_CHANGE,
            ({ key: property, target: feature }) => {
              if (property === "styleOptions") {
                applyStyle$1(feature);
              }
            }
          );
        }
      },
      onRemove: (feature) => {
        if (isFreeText(feature)) {
          const featureId = feature.getId();
          api.markupManager.remove(featureId);
        }
      },
      onUpdate: (feature) => {
        if (isFreeText(feature)) {
          api.markupManager.update({ feature, value: format$7(feature) });
        }
      },
      onDrawStart: () => {},
      onDrawEnd: ({ feature }) => {
        if (isFreeText(feature)) {
          const featureHasMarker = hasMarker(feature);
          api.markupManager.create({
            feature,
            isLinkable: featureHasMarker,
            isDraggable: featureHasMarker,
            offset: featureHasMarker ? [7, 7] : [1, 1],
          });
          applyStyle$1(feature);
        }
      },
      isFreeText,
      format: format$7,
    };
  };

  const { Marker: Marker$1, Markup: Markup$1, FeatureEvents: FeatureEvents$1 } = Enums;

  class _AnnotationManager {
    constructor({ map, source, controls, getROI } = {}) {
      this.props = { map, source, controls, getROI };

      /** Markups */
      this[Markup$1.Measurement] = MeasurementMarkup(this.props);
      this[Markup$1.FreeTextEvaluation] = FreeTextMarkup(this.props);

      /** Markers */
      this[Marker$1.Arrow] = ArrowMarker(this.props);

      this.props.markupManager = new _MarkupManager({
        map,
        source,
        formatters: {
          [Marker$1.Arrow]: this[Marker$1.Arrow].format,
          [Markup$1.Measurement]: this[Markup$1.Measurement].format,
          [Markup$1.FreeTextEvaluation]: this[Markup$1.FreeTextEvaluation].format,
        },
        onDrawStart: this.onDrawStart.bind(this),
        onDrawEnd: this.onDrawEnd.bind(this),
      });
    }

    /**
     * Gets the code meaning of a given measurement or evaluation content item.
     *
     * @param {NumContentItem} contentItem The measurement or evaluation content item
     */
    getContentItemCodeMeaning(contentItem) {
      const { ConceptNameCodeSequence } = contentItem;
      return ConceptNameCodeSequence.length
        ? ConceptNameCodeSequence[0].CodeMeaning
        : ConceptNameCodeSequence.CodeMeaning;
    }

    /**
     * Add or update a ROI measurement.
     *
     * @param {Feature} feature The feature
     * @param {NumContentItem} measurement The measurement content item
     * @param {string} codeMeaning The code meaning
     */
    addOrUpdateMeasurement(feature, measurement, codeMeaning) {
      const measurements = feature.get("measurements") || [];

      const index = measurements.findIndex((measurement) => {
        const meaning = this.getContentItemCodeMeaning(measurement);
        return meaning === codeMeaning;
      });

      if (index > -1) {
        measurements[index] = measurement;
      } else {
        measurements.push(measurement);
      }

      feature.set("measurements", measurements);
    }

    /**
     * Add or update a ROI evaluation.
     *
     * @param {Feature} feature The feature
     * @param {TextContentItem} evaluation The feature
     * @param {string} codeMeaning The code meaning
     */
    addOrUpdateEvaluation(feature, evaluation, codeMeaning) {
      const evaluations = feature.get("evaluations") || [];

      const index = evaluations.findIndex((evaluation) => {
        const meaning = this.getContentItemCodeMeaning(evaluation);
        return meaning === codeMeaning;
      });

      if (index > -1) {
        evaluations[index] = evaluation;
      } else {
        evaluations.push(evaluation);
      }

      feature.set("evaluations", evaluations);
    }

    /**
     * Add or update ROI measurements and evaluations based on markup related properties.
     *
     * @param {Feature} feature The feature
     */
    _updateMeasurementsAndEvaluations(feature) {
      const view = this.props.map.getView();
      const unitsSuffix = getUnitsSuffix(view);
      const properties = feature.getProperties();

      if (properties.label) {
        const evaluation = new dcmjs.sr.valueTypes.TextContentItem({
          name: new dcmjs.sr.coding.CodedConcept({
            value: "112039",
            meaning: "Tracking Identifier",
            schemeDesignator: "DCM",
          }),
          value: properties.label,
          relationshipType: Enums.RelationshipTypes.HAS_OBS_CONTEXT,
        });
        this.addOrUpdateEvaluation(feature, evaluation, "Tracking Identifier");
      }

      if (properties.area) {
        const measurement = new dcmjs.sr.valueTypes.NumContentItem({
          name: new dcmjs.sr.coding.CodedConcept({
            value: "42798000",
            meaning: "Area",
            schemeDesignator: "DCM",
          }),
          value: properties.area,
          unit: unitsSuffix,
        });
        this.addOrUpdateMeasurement(feature, measurement, "Area");
      }

      if (properties.length) {
        const measurement = new dcmjs.sr.valueTypes.NumContentItem({
          name: new dcmjs.sr.coding.CodedConcept({
            value: "410668003",
            meaning: "Length",
            schemeDesignator: "DCM",
          }),
          value: properties.length,
          unit: unitsSuffix,
        });
        this.addOrUpdateMeasurement(feature, measurement, "Length");
      }
    }

    /**
     * Add markup properties based on ROI measurements and evaluations.
     *
     * @param {Feature} feature The feature
     */
    _addMeasurementsAndEvaluationsProperties(feature) {
      const { measurements, evaluations } = feature.getProperties();

      if (measurements && measurements.length) {
        return measurements.some((measurement) => {
          const SUPPORTED_MEASUREMENTS = ["Area", "Length"];
          let codeMeaning = this.getContentItemCodeMeaning(measurement);
          if (SUPPORTED_MEASUREMENTS.includes(codeMeaning)) {
            feature.set("markup", "measurement");
          }
        });
      }

      if (evaluations && evaluations.length) {
        return evaluations.some((evaluation) => {
          const SUPPORTED_EVALUATIONS = ["Tracking Identifier"];
          let codeMeaning = this.getContentItemCodeMeaning(evaluation);
          if (SUPPORTED_EVALUATIONS.includes(codeMeaning)) {
            feature.set("markup", "freetext");
          }
        });
      }
    }

    onInteractionsChange(interactions) {
      this.props.markupManager.onInteractionsChange(interactions);
    }

    onAdd(feature) {
      /**
       * Add properties to ROI feature before triggering
       * markup and markers callbacks to keep UI in sync with them.
       */
      this._addMeasurementsAndEvaluationsProperties(feature);

      this[Marker$1.Arrow].onAdd(feature);
      this[Markup$1.Measurement].onAdd(feature);
      this[Markup$1.FreeTextEvaluation].onAdd(feature);

      /**
       * Generate and update ROI measurements and evaluations.
       */
      this._updateMeasurementsAndEvaluations(feature);
      feature.on(FeatureEvents$1.PROPERTY_CHANGE, () =>
        this._updateMeasurementsAndEvaluations(feature)
      );
    }

    onRemove(feature) {
      this[Marker$1.Arrow].onRemove(feature);
      this[Markup$1.Measurement].onRemove(feature);
      this[Markup$1.FreeTextEvaluation].onRemove(feature);
    }

    onUpdate(feature) {
      this[Marker$1.Arrow].onUpdate(feature);
      this[Markup$1.Measurement].onUpdate(feature);
      this[Markup$1.FreeTextEvaluation].onUpdate(feature);
    }

    onDrawStart(event) {
      this[Marker$1.Arrow].onDrawStart(event);
      this[Markup$1.Measurement].onDrawStart(event);
      this[Markup$1.FreeTextEvaluation].onDrawStart(event);
    }

    onDrawEnd(event) {
      this[Marker$1.Arrow].onDrawEnd(event);
      this[Markup$1.Measurement].onDrawEnd(event);
      this[Markup$1.FreeTextEvaluation].onDrawEnd(event);
    }
  }

  function _getInteractionBindingCondition(bindings) {
    const BUTTONS = {
      left: 1,
      middle: 4,
      right: 2,
    };

    const { mouseButtons, modifierKey } = bindings;

    const _mouseButtonCondition = (event) => {
      /** No mouse button condition set. */
      if (!mouseButtons || !mouseButtons.length) {
        return true;
      }

      const button = event.pointerEvent
        ? event.pointerEvent.buttons
        : event.originalEvent.buttons;

      return mouseButtons.some((mb) => BUTTONS[mb] === button);
    };

    const _modifierKeyCondition = (event) => {
      const pointerEvent = event.pointerEvent
        ? event.pointerEvent
        : event.originalEvent;

      if (!modifierKey) {
        /**
         * No modifier key, don't pass if key pressed as other
         * tool may be using this tool.
         */
        return (
          !pointerEvent.altKey &&
          !pointerEvent.metaKey &&
          !pointerEvent.shiftKey &&
          !pointerEvent.ctrlKey
        );
      }

      switch (modifierKey) {
        case "alt":
          return pointerEvent.altKey === true || pointerEvent.metaKey === true;
        case "shift":
          return pointerEvent.shiftKey === true;
        case "ctrl":
          return pointerEvent.ctrlKey === true;
        default:
          /** Invalid modifier key set (ignore requirement as if key not pressed). */
          return (
            !pointerEvent.altKey &&
            !pointerEvent.metaKey &&
            !pointerEvent.shiftKey &&
            !pointerEvent.ctrlKey
          );
      }
    };

    return (event) => {
      return _mouseButtonCondition(event) && _modifierKeyCondition(event);
    };
  }

  /** Extracts value of Pixel Spacing attribute from metadata.
   *
   * @param {object} metadata - Metadata of a DICOM VL Whole Slide Microscopy Image instance
   * @returns {number[]} Spacing between pixel columns and rows in millimeter
   * @private
   */
  function _getPixelSpacing(metadata) {
    const functionalGroup = metadata.SharedFunctionalGroupsSequence[0];
    const pixelMeasures = functionalGroup.PixelMeasuresSequence[0];
    return pixelMeasures.PixelSpacing;
  }

  /** Determines whether image needs to be rotated relative to slide
   * coordinate system based on direction cosines.
   * We want to rotate all images such that the X axis of the slide coordinate
   * system is the vertical axis (ordinate) of the viewport and the Y axis
   * of the slide coordinate system is the horizontal axis (abscissa) of the
   * viewport. Note that this is opposite to the Openlayers coordinate system.
   * There are only planar rotations, since the total pixel matrix is
   * parallel to the slide surface. Here, we further assume that rows and
   * columns of total pixel matrix are parallel to the borders of the slide,
   * i.e. the x and y axis of the slide coordinate system.
   *
   * The row direction (left to right) of the Total Pixel Matrix
   * is defined by the first three values.
   * The three values specify how the direction changes from the last pixel
   * to the first pixel in the row along each of the three axes of the
   * slide coordinate system (x, y, z), i.e. it express in which direction one
   * is moving in the slide coordinate system when the COLUMN index changes.
   * The column direction (top to bottom) of the Total Pixel Matrix
   * is defined by the second three values.
   * The three values specify how the direction changes from the last pixel
   * to the first pixel in the column along each of the three axes of the
   * slide coordinate system (x, y, z), i.e. it express in which direction one
   * is moving in the slide coordinate system when the ROW index changes.
   *
   * @param {object} metadata - Metadata of a DICOM VL Whole Slide Microscopy Image instance
   * @returns {number} Rotation in radians
   * @private
   */
  function _getRotation(metadata) {
    // Angle with respect to the reference orientation
    const angle = computeRotation({
      orientation: metadata.ImageOrientationSlide,
    });
    // We want the slide oriented horizontally with the label on the right side
    const correction = 90 * (Math.PI / 180);
    return angle + correction;
  }

  /** Converts a vector graphic from an Openlayers Geometry into a DICOM SCOORD3D
   * representation.
   *
   * @param {object} geometry - Openlayers Geometry
   * @param {Object[]} pyramid - Metadata for resolution levels of image pyramid
   * @returns {Scoord3D} DICOM Microscopy Viewer Scoord3D
   * @private
   */
  function _geometry2Scoord3d(geometry, pyramid) {
    console.info("map coordinates from pixel matrix to slide coordinate system");
    const frameOfReferenceUID = pyramid[pyramid.length - 1].FrameOfReferenceUID;
    const type = geometry.getType();
    if (type === "Point") {
      let coordinates = geometry.getCoordinates();
      coordinates = _geometryCoordinates2scoord3dCoordinates(
        coordinates,
        pyramid
      );
      return new Point({
        coordinates,
        frameOfReferenceUID: frameOfReferenceUID,
      });
    } else if (type === "Polygon") {
      /*
       * The first linear ring of the array defines the outer-boundary (surface).
       * Each subsequent linear ring defines a hole in the surface.
       */
      let coordinates = geometry.getCoordinates()[0].map((c) => {
        return _geometryCoordinates2scoord3dCoordinates(c, pyramid);
      });
      return new Polygon({
        coordinates,
        frameOfReferenceUID: frameOfReferenceUID,
      });
    } else if (type === "LineString") {
      let coordinates = geometry.getCoordinates().map((c) => {
        const result = _geometryCoordinates2scoord3dCoordinates(c, pyramid);
        return result;
      });
      return new Polyline({
        coordinates,
        frameOfReferenceUID: frameOfReferenceUID,
      });
    } else if (type === "Circle") {
      const center = geometry.getCenter();
      const radius = geometry.getRadius();
      // Endpoints of major and  minor axis of the ellipse.
      let coordinates = [
        [center[0] - radius, center[1], 0],
        [center[0] + radius, center[1], 0],
        [center[0], center[1] - radius, 0],
        [center[0], center[1] + radius, 0],
      ];
      coordinates = coordinates.map((c) => {
        return _geometryCoordinates2scoord3dCoordinates(c, pyramid);
      });
      return new Ellipse({
        coordinates,
        frameOfReferenceUID: frameOfReferenceUID,
      });
    } else {
      // TODO: Combine multiple points into MULTIPOINT.
      console.error(`unknown geometry type "${type}"`);
    }
  }

  /** Converts a vector graphic from a DICOM SCOORD3D into an Openlayers Geometry
   * representation.
   *
   * @param {Scoord3D} scoord3d - DICOM Microscopy Viewer Scoord3D
   * @param {Object[]} pyramid - Metadata for resolution levels of image pyramid
   * @returns {object} Openlayers Geometry
   * @private
   */
  function _scoord3d2Geometry(scoord3d, pyramid) {
    console.info("map coordinates from slide coordinate system to pixel matrix");
    const type = scoord3d.graphicType;
    const data = scoord3d.graphicData;

    if (type === "POINT") {
      let coordinates = _scoord3dCoordinates2geometryCoordinates(data, pyramid);
      return new Point$1(coordinates);
    } else if (type === "POLYLINE") {
      const coordinates = data.map((d) => {
        return _scoord3dCoordinates2geometryCoordinates(d, pyramid);
      });
      return new LineString(coordinates);
    } else if (type === "POLYGON") {
      const coordinates = data.map((d) => {
        return _scoord3dCoordinates2geometryCoordinates(d, pyramid);
      });
      return new Polygon$1([coordinates]);
    } else if (type === "ELLIPSE") {
      // TODO: ensure that the ellipse represents a circle, i.e. that
      // major and minor axis form a right angle and have the same length
      const majorAxisCoordinates = data.slice(0, 2);
      const minorAxisCoordinates = data.slice(2, 4);
      // Circle is defined by two points: the center point and a point on the
      // circumference.
      const point1 = majorAxisCoordinates[0];
      const point2 = majorAxisCoordinates[1];
      let coordinates = [
        [
          (point1[0] + point2[0]) / parseFloat(2),
          (point1[1] + point2[1]) / parseFloat(2),
          0,
        ],
        point2,
      ];
      coordinates = coordinates.map((d) => {
        return _scoord3dCoordinates2geometryCoordinates(d, pyramid);
      });
      // to flat coordinates
      coordinates = [
        ...coordinates[0].slice(0, 2),
        ...coordinates[1].slice(0, 2),
      ];

      // flat coordinates in combination with opt_layout and no opt_radius are also accepted
      // and internally it calculates the Radius
      return new Circle(coordinates, null, "XY");
    } else {
      console.error(`unsupported graphic type "${type}"`);
    }
  }

  function _geometryCoordinates2scoord3dCoordinates(coordinates, pyramid) {
    return _coordinateFormatGeometry2Scoord3d(
      [coordinates[0], coordinates[1], coordinates[2]],
      pyramid
    );
  }

  function _scoord3dCoordinates2geometryCoordinates(coordinates, pyramid) {
    return _coordinateFormatScoord3d2Geometry(
      [coordinates[0], coordinates[1], coordinates[2]],
      pyramid
    );
  }

  /** Translates coordinates of Total Pixel Matrix in pixel unit into coordinates
   * in Frame of Reference (slide coordinate system) in millimeter unit.
   *
   * @param {number[]|number[][]} coordinates - Coordinates in Total Pixel Matrix
   * @param {Object[]} pyramid - Metadata for resolution levels of image pyramid
   * @returns {number[]|number[][]} Coordinates in Frame of Reference
   * @private
   */
  function _coordinateFormatGeometry2Scoord3d(coordinates, pyramid) {
    let transform = false;
    if (!Array.isArray(coordinates[0])) {
      coordinates = [coordinates];
      transform = true;
    }
    const metadata = pyramid[pyramid.length - 1];
    const origin = metadata.TotalPixelMatrixOriginSequence[0];
    const orientation = metadata.ImageOrientationSlide;
    const spacing = _getPixelSpacing(metadata);
    const offset = [
      Number(origin.XOffsetInSlideCoordinateSystem),
      Number(origin.YOffsetInSlideCoordinateSystem),
    ];

    const affine = buildTransform({
      offset,
      orientation,
      spacing,
    });
    coordinates = coordinates.map((c) => {
      const pixelCoord = [c[0], -(c[1] + 1)];
      const slideCoord = applyTransform({ coordinate: pixelCoord, affine });
      return [slideCoord[0], slideCoord[1], 0];
    });
    if (transform) {
      return coordinates[0];
    }
    return coordinates;
  }

  /** Translates coordinates of coordinates in Frame of Reference
   * (slide coordinate system) in millimeter unit into coordinates in
   * Total Pixel Matrix in pixel unit.
   *
   * @param {number[]|number[][]} coordinates - Coordinates in Frame of Reference
   * @param {Object[]} pyramid - Metadata for resolution levels of image pyramid
   * @returns {number[]|number[][]} Coordinates in Total Pixel Matrix
   * @private
   */
  function _coordinateFormatScoord3d2Geometry(coordinates, pyramid) {
    let transform = false;
    if (!Array.isArray(coordinates[0])) {
      coordinates = [coordinates];
      transform = true;
    }
    const metadata = pyramid[pyramid.length - 1];
    const orientation = metadata.ImageOrientationSlide;
    const spacing = _getPixelSpacing(metadata);
    const origin = metadata.TotalPixelMatrixOriginSequence[0];
    const offset = [
      Number(origin.XOffsetInSlideCoordinateSystem),
      Number(origin.YOffsetInSlideCoordinateSystem),
    ];

    let outOfFrame = false;
    const affine = buildInverseTransform({
      offset,
      orientation,
      spacing,
    });
    coordinates = coordinates.map((c) => {
      if (c[0] > 25 || c[1] > 76) {
        outOfFrame = true;
      }
      const slideCoord = [c[0], c[1]];
      const pixelCoord = applyInverseTransform({
        coordinate: slideCoord,
        affine,
      });
      return [pixelCoord[0], -(pixelCoord[1] + 1), 0];
    });
    if (transform) {
      return coordinates[0];
    }
    if (outOfFrame) {
      console.warning(
        "found coordinates outside slide coordinate system 25 x 76 mm"
      );
    }
    return coordinates;
  }

  /** Extracts and transforms the region of interest (ROI) from an Openlayers
   * Feature.
   *
   * @param {object} feature - Openlayers Feature
   * @param {Object[]} pyramid - Metadata for resolution levels of image pyramid
   * @param {Object} context - Context
   * @returns {ROI} Region of interest
   * @private
   */
  function _getROIFromFeature(feature, pyramid) {
    if (feature !== undefined && feature !== null) {
      const geometry = feature.getGeometry();
      const scoord3d = _geometry2Scoord3d(geometry, pyramid);
      const properties = feature.getProperties();
      // Remove geometry from properties mapping
      const geometryName = feature.getGeometryName();
      delete properties[geometryName];
      const uid = feature.getId();
      const roi = new ROI({ scoord3d, properties, uid });
      return roi;
    }
    return;
  }

  /** Map style options to OpenLayers style.
   *
   * @param {object} styleOptions - Style options
   * @param {object} styleOptions.stroke - Style options for the outline of the geometry
   * @param {number[]} styleOptions.stroke.color - RGBA color of the outline
   * @param {number} styleOptions.stroke.width - Width of the outline
   * @param {object} styleOptions.fill - Style options for body the geometry
   * @param {number[]} styleOptions.fill.color - RGBA color of the body
   * @param {object} styleOptions.image - Style options for image
   * @return {Style} OpenLayers style
   */
  function _getOpenLayersStyle(styleOptions) {
    const style = new Style();

    if ("stroke" in styleOptions) {
      const strokeOptions = {
        color: styleOptions.stroke.color,
        width: styleOptions.stroke.width,
      };
      const stroke = new Stroke(strokeOptions);
      style.setStroke(stroke);
    }

    if ("fill" in styleOptions) {
      const fillOptions = {
        color: styleOptions.fill.color,
      };
      const fill = new Fill(fillOptions);
      style.setFill(fill);
    }

    if ("image" in styleOptions) {
      const { image } = styleOptions;

      if (image.circle) {
        const options = {
          radius: image.circle.radius,
          stroke: new Stroke(image.circle.stroke),
          fill: new Fill(image.circle.fill),
        };
        const circle = new CircleStyle(options);
        style.setImage(circle);
      }

      if (image.icon) {
        const icon = new Icon(image.icon);
        style.setImage(icon);
      }
    }

    return style;
  }

  /** Updates the style of a feature.
   *
   * @param {object} styleOptions - Style options
   * @param {object} styleOptions.stroke - Style options for the outline of the geometry
   * @param {number[]} styleOptions.stroke.color - RGBA color of the outline
   * @param {number} styleOptions.stroke.width - Width of the outline
   * @param {object} styleOptions.fill - Style options for body the geometry
   * @param {number[]} styleOptions.fill.color - RGBA color of the body
   * @param {object} styleOptions.image - Style options for image
   */
  function _setFeatureStyle(feature, styleOptions) {
    if (styleOptions !== undefined) {
      const style = _getOpenLayersStyle(styleOptions);
      feature.setStyle(style);

      /**
       * styleOptions is used internally by internal styled components like markers.
       * This allows them to take priority over styling since OpenLayers swaps the styles
       * completely in case of a setStyle happens.
       */
      feature.set("styleOptions", styleOptions);
    }
  }

  const _client = Symbol("client");
  const _controls = Symbol("controls");
  const _drawingLayer = Symbol("drawingLayer");
  const _drawingSource = Symbol("drawingSource");
  const _features = Symbol("features");
  const _imageLayer = Symbol("imageLayer");
  const _interactions = Symbol("interactions");
  const _map$2 = Symbol("map");
  const _metadata = Symbol("metadata");
  const _pyramidMetadata = Symbol("pyramidMetadata");
  const _pyramidFrameMappings = Symbol("pyramidFrameMappings");
  const _pyramidBaseMetadata = Symbol("pyramidMetadataBase");
  const _segmentations = Symbol("segmentations");
  const _usewebgl = Symbol("usewebgl");
  const _annotationManager = Symbol("annotationManager");

  /** Interactive viewer for DICOM VL Whole Slide Microscopy Image instances
   * with Image Type VOLUME.
   *
   * @class
   * @memberof viewer
   */
  class VolumeImageViewer {
    /**
     * Create a viewer instance for displaying VOLUME images.
     *
     * @param {object} options
     * @param {object} options.client - A DICOMwebClient instance for interacting with an origin server over HTTP.
     * @param {Object[]} options.metadata - An array of DICOM JSON metadata objects, one for each VL Whole Slide Microscopy Image instance.
     * @param {string[]} [options.controls=[]] - Names of viewer control elements that should be included in the viewport.
     * @param {boolean} [options.retrieveRendered=true] - Whether image frames should be retrieved via DICOMweb prerendered by the server.
     * @param {boolean} [options.includeIccProfile=false] - Whether ICC Profile should be included for correction of image colors.
     * @param {boolean} [options.useWebGL=true] - Whether WebGL renderer should be used.
     */
    constructor(options) {
      if ("useWebGL" in options) {
        this[_usewebgl] = options.useWebGL;
      } else {
        this[_usewebgl] = true;
      }

      this[_client] = options.client;

      if (!("retrieveRendered" in options)) {
        options.retrieveRendered = true;
      }

      if (!("overview" in options)) {
        options.overview = {};
      }

      if (!("controls" in options)) {
        options.controls = [];
      }
      options.controls = new Set(options.controls);

      // Collection of Openlayers "VectorLayer" instances indexable by
      // DICOM Series Instance UID
      this[_segmentations] = {};

      // Collection of Openlayers "Feature" instances
      this[_features] = new Collection([], { unique: true });

      // Add unique identifier to each created "Feature" instance
      this[_features].on("add", (e) => {
        // The ID may have already been set when drawn. However, features could
        // have also been added without a draw event.
        if (e.element.getId() === undefined) {
          e.element.setId(generateUID());
        }

        this[_annotationManager].onAdd(e.element);
      });

      this[_features].on("remove", (e) => {
        this[_annotationManager].onRemove(e.element);
      });

      /*
       * To visualize images accross multiple scales, we first need to
       * determine the image pyramid structure, i.e. the size and resolution
       * images at the different pyramid levels.
       */
      this[_metadata] = [];
      options.metadata.forEach((m) => {
        const image = new VLWholeSlideMicroscopyImage({ metadata: m });
        if (image.ImageType[2] === "VOLUME") {
          this[_metadata].push(image);
        }
      });

      if (this[_metadata].length === 0) {
        throw new Error("No VOLUME image provided.");
      }

      // Sort instances and optionally concatenation parts if present.
      this[_metadata].sort((a, b) => {
        const sizeDiff = a.TotalPixelMatrixColumns - b.TotalPixelMatrixColumns;
        if (sizeDiff === 0) {
          if (a.ConcatenationFrameOffsetNumber !== undefined) {
            return (
              a.ConcatenationFrameOffsetNumber - b.ConcatenationFrameOffsetNumber
            );
          }
          return sizeDiff;
        }
        return sizeDiff;
      });

      this[_pyramidMetadata] = [];
      this[_pyramidFrameMappings] = [];
      let frameMappings = this[_metadata].map((m) => getFrameMapping(m));
      for (let i = 0; i < this[_metadata].length; i++) {
        const cols = this[_metadata][i].TotalPixelMatrixColumns;
        const rows = this[_metadata][i].TotalPixelMatrixRows;
        const numberOfFrames = this[_metadata][i].NumberOfFrames;
        /*
         * Instances may be broken down into multiple concatentation parts.
         * Therefore, we have to re-assemble instance metadata.
         */
        let alreadyExists = false;
        let index = null;
        for (let j = 0; j < this[_pyramidMetadata].length; j++) {
          if (
            this[_pyramidMetadata][j].TotalPixelMatrixColumns === cols &&
            this[_pyramidMetadata][j].TotalPixelMatrixRows === rows
          ) {
            alreadyExists = true;
            index = j;
          }
        }
        if (alreadyExists) {
          // Update with information obtained from current concatentation part.
          Object.assign(this[_pyramidFrameMappings][index], frameMappings[i]);
          this[_pyramidMetadata][index].NumberOfFrames += numberOfFrames;
          if ("PerFrameFunctionalGroupsSequence" in this[_metadata][index]) {
            this[_pyramidMetadata][index].PerFrameFunctionalGroupsSequence.push(
              ...this[_metadata][i].PerFrameFunctionalGroupsSequence
            );
          }
          if (!"SOPInstanceUIDOfConcatenationSource" in this[_metadata][i]) {
            throw new Error(
              'Attribute "SOPInstanceUIDOfConcatenationSource" is required ' +
                "for concatenation parts."
            );
          }
          const sopInstanceUID = this[_metadata][i]
            .SOPInstanceUIDOfConcatenationSource;
          this[_pyramidMetadata][index].SOPInstanceUID = sopInstanceUID;
          delete this[_pyramidMetadata][index]
            .SOPInstanceUIDOfConcatenationSource;
          delete this[_pyramidMetadata][index].ConcatenationUID;
          delete this[_pyramidMetadata][index].InConcatenationNumber;
          delete this[_pyramidMetadata][index].ConcatenationFrameOffsetNumber;
        } else {
          this[_pyramidMetadata].push(this[_metadata][i]);
          this[_pyramidFrameMappings].push(frameMappings[i]);
        }
      }

      const nLevels = this[_pyramidMetadata].length;
      if (nLevels === 0) {
        console.error("empty pyramid - no levels found");
      }

      this[_pyramidBaseMetadata] = this[_pyramidMetadata][nLevels - 1];

      /*
       * Collect relevant information from DICOM metadata for each pyramid
       * level to construct the Openlayers map.
       */
      const tileSizes = [];
      const tileGridSizes = [];
      const resolutions = [];
      const origins = [];
      const offset = [0, -1];
      const basePixelSpacing = _getPixelSpacing(this[_pyramidBaseMetadata]);
      const baseTotalPixelMatrixColumns = this[_pyramidBaseMetadata]
        .TotalPixelMatrixColumns;
      const baseTotalPixelMatrixRows = this[_pyramidBaseMetadata]
        .TotalPixelMatrixRows;
      const baseColumns = this[_pyramidBaseMetadata].Columns;
      const baseRows = this[_pyramidBaseMetadata].Rows;

      for (let j = nLevels - 1; j >= 0; j--) {
        const columns = this[_pyramidMetadata][j].Columns;
        const rows = this[_pyramidMetadata][j].Rows;
        const totalPixelMatrixColumns = this[_pyramidMetadata][j]
          .TotalPixelMatrixColumns;
        const totalPixelMatrixRows = this[_pyramidMetadata][j]
          .TotalPixelMatrixRows;
        const pixelSpacing = _getPixelSpacing(this[_pyramidMetadata][j]);
        const nColumns = Math.ceil(totalPixelMatrixColumns / columns);
        const nRows = Math.ceil(totalPixelMatrixRows / rows);
        tileSizes.push([columns, rows]);
        tileGridSizes.push([nColumns, nRows]);

        /*
         * Compute the resolution at each pyramid level, since the zoom
         * factor may not be the same between adjacent pyramid levels.
         */
        let zoomFactor = baseTotalPixelMatrixColumns / totalPixelMatrixColumns;
        resolutions.push(zoomFactor);

        /*
         * TODO: One may have to adjust the offset slightly due to the
         * difference between extent of the image at a given resolution level
         * and the actual number of tiles (frames).
         */
        origins.push(offset);
      }
      resolutions.reverse();
      tileSizes.reverse();
      tileGridSizes.reverse();
      origins.reverse();

      // Functions won't be able to access "this"
      const pyramid = this[_pyramidMetadata];
      const pyramidFrameMappings = this[_pyramidFrameMappings];

      /*
       * Define custom tile URL function to retrive frames via DICOMweb WADO-RS.
       */
      const tileUrlFunction = (tileCoord, pixelRatio, projection) => {
        /*
         * Variables x and y correspond to the X and Y axes of the slide
         * coordinate system. Since we want to view the slide horizontally
         * with the label on the right side, the x axis of the slide
         * coordinate system is the vertical axis of the viewport and the
         * y axis of the slide coordinate system the horizontal axis of the
         * viewport. Note that this is in contrast to the nomenclature used
         * by Openlayers.
         */
        const z = tileCoord[0];
        const y = tileCoord[1] + 1;
        const x = tileCoord[2] + 1;
        const index = x + "-" + y;
        const path = pyramidFrameMappings[z][index];
        if (path === undefined) {
          console.warn("tile " + index + " not found at level " + z);
          return null;
        }
        let url =
          options.client.wadoURL +
          "/studies/" +
          pyramid[z].StudyInstanceUID +
          "/series/" +
          pyramid[z].SeriesInstanceUID +
          "/instances/" +
          path;
        if (options.retrieveRendered) {
          url = url + "/rendered";
        }
        return url;
      };

      /*
       * Define custonm tile loader function, which is required because the
       * WADO-RS response message has content type "multipart/related".
       */
      const tileLoadFunction = (tile, src) => {
        if (src !== null) {
          const studyInstanceUID = utils.getStudyInstanceUIDFromUri(
            src
          );
          const seriesInstanceUID = utils.getSeriesInstanceUIDFromUri(
            src
          );
          const sopInstanceUID = utils.getSOPInstanceUIDFromUri(
            src
          );
          const frameNumbers = utils.getFrameNumbersFromUri(src);
          const img = tile.getImage();
          if (options.retrieveRendered) {
            const mediaType = "image/png";
            const retrieveOptions = {
              studyInstanceUID,
              seriesInstanceUID,
              sopInstanceUID,
              frameNumbers,
              mediaTypes: [{ mediaType }],
            };
            if (options.includeIccProfile) {
              retrieveOptions["queryParams"] = {
                iccprofile: "yes",
              };
            }
            options.client
              .retrieveInstanceFramesRendered(retrieveOptions)
              .then((renderedFrame) => {
                const blob = new Blob([renderedFrame], { type: mediaType });
                img.src = window.URL.createObjectURL(blob);
              });
          } else {
            // TODO: support "image/jp2" and "image/jls"
            const mediaType = "image/jpeg";
            const retrieveOptions = {
              studyInstanceUID,
              seriesInstanceUID,
              sopInstanceUID,
              frameNumbers,
              mediaTypes: [
                { mediaType, transferSyntaxUID: "1.2.840.10008.1.2.4.50" },
              ],
            };
            options.client
              .retrieveInstanceFrames(retrieveOptions)
              .then((rawFrames) => {
                const blob = new Blob(rawFrames, { type: mediaType });
                img.src = window.URL.createObjectURL(blob);
              });
          }
        } else {
          console.warn("could not load tile");
        }
      };

      /** Frames may extend beyond the size of the total pixel matrix.
       * The excess pixels are empty, i.e. have only a padding value.
       * We set the extent to the size of the actual image without taken
       * excess pixels into account.
       * Note that the vertical axis is flipped in the used tile source,
       * i.e. values on the axis lie in the range [-n, -1], where n is the
       * number of rows in the total pixel matrix.
       */
      const extent = [
        0, // min X
        -(baseTotalPixelMatrixRows + 1), // min Y
        baseTotalPixelMatrixColumns, // max X
        -1, // max Y
      ];

      const rotation = _getRotation(this[_pyramidBaseMetadata]);

      /*
       * Specify projection to prevent default automatic projection
       * with the default Mercator projection.
       */
      const projection = new Projection({
        code: "DICOM",
        units: "metric",
        extent: extent,
        getPointResolution: (pixelRes, point) => {
          /** DICOM Pixel Spacing has millimeter unit while the projection has
           * has meter unit.
           */
          const spacing = _getPixelSpacing(pyramid[nLevels - 1])[0] / 10 ** 3;
          return pixelRes * spacing;
        },
      });
      /*
       * TODO: Register custom projection:
       *  - http://openlayers.org/en/latest/apidoc/ol.proj.html
       *  - http://openlayers.org/en/latest/apidoc/module-ol_proj.html#~ProjectionLike
       * Direction cosines could be handled via projection rather
       * than specifying a rotation
       */

      /*
       * We need to specify the tile grid, since DICOM allows tiles to
       * have different sizes at each resolution level and a different zoom
       * factor between individual levels.
       */
      const tileGrid = new TileGrid({
        extent: extent,
        origins: origins,
        resolutions: resolutions,
        sizes: tileGridSizes,
        tileSizes: tileSizes,
      });

      /*
       * We use the existing TileImage source but customize it to retrieve
       * frames (load tiles) via DICOMweb WADO-RS.
       */
      const rasterSource = new TileImage({
        crossOrigin: "Anonymous",
        tileGrid: tileGrid,
        projection: projection,
        wrapX: false,
      });
      rasterSource.setTileUrlFunction(tileUrlFunction);
      rasterSource.setTileLoadFunction(tileLoadFunction);

      this[_imageLayer] = new TileLayer({
        extent: extent,
        source: rasterSource,
        preload: 0,
        projection: projection,
      });

      this[_drawingSource] = new VectorSource({
        tileGrid: tileGrid,
        projection: projection,
        features: this[_features],
        wrapX: false,
      });

      this[_drawingLayer] = new VectorLayer({
        extent: extent,
        source: this[_drawingSource],
        projection: projection,
        updateWhileAnimating: true,
        updateWhileInteracting: true,
      });

      const view = new View({
        center: getCenter(extent),
        extent: extent,
        projection: projection,
        resolutions: resolutions,
        rotation: rotation,
      });

      this[_interactions] = {
        draw: undefined,
        select: undefined,
        translate: undefined,
        modify: undefined,
        snap: undefined,
        dragPan: undefined,
      };

      this[_controls] = {
        scale: new ScaleLine({
          units: "metric",
          className: "",
        }),
      };

      if (options.controls.has("fullscreen")) {
        this[_controls].fullscreen = new FullScreen();
      }

      if (options.controls.has("overview")) {
        const overviewImageLayer = new TileLayer({
          extent: extent,
          source: rasterSource,
          preload: 0,
          projection: projection,
        });

        let viewOptions = { projection: projection, rotation: rotation };
        if (resolutions && !options.overview.zoom)
          viewOptions.resolutions = resolutions;
        if (options.overview.zoom) viewOptions.zoom = options.overview.zoom;
        const view = new View(viewOptions);

        this[_controls].overview = new OverviewMap({
          view,
          layers: [overviewImageLayer],
          collapsed: options.overview.hasOwnProperty("collapsed")
            ? options.overview.collapsed
            : false,
          collapsible: options.overview.hasOwnProperty("collapsible")
            ? options.overview.collapsible
            : false,
        });
      }

      /** Creates the map with the defined layers and view and renders it. */
      this[_map$2] = new Map$1({
        layers: [this[_imageLayer], this[_drawingLayer]],
        view: view,
        controls: [],
        keyboardEventTarget: document,
      });

      this[_map$2].addInteraction(new MouseWheelZoom());

      for (let control in this[_controls]) {
        this[_map$2].addControl(this[_controls][control]);
      }

      this[_map$2].getView().fit(extent);

      this[_annotationManager] = new _AnnotationManager({
        map: this[_map$2],
        source: this[_drawingSource],
        controls: this[_controls],
        getROI: this.getROI.bind(this),
      });
    }

    /** Resizes the viewer to fit the viewport. */
    resize() {
      this[_map$2].updateSize();
    }

    /** Gets the size of the viewport.
     *
     * @type {number[]}
     */
    get size() {
      return this[_map$2].getSize();
    }

    /** Renders the images in the specified viewport container.
     * @param {object} options - Rendering options.
     * @param {(string|HTMLElement)} options.container - HTML Element in which the viewer should be injected.
     */
    render(options) {
      if (!("container" in options)) {
        console.error("container must be provided for rendering images");
      }
      this[_map$2].setTarget(options.container);

      // Style scale element (overriding default Openlayers CSS "ol-scale-line")
      let scaleElement = this[_controls]["scale"].element;
      scaleElement.style.position = "absolute";
      scaleElement.style.right = ".5em";
      scaleElement.style.bottom = ".5em";
      scaleElement.style.left = "auto";
      scaleElement.style.padding = "2px";
      scaleElement.style.backgroundColor = "rgba(255,255,255,.5)";
      scaleElement.style.borderRadius = "4px";
      scaleElement.style.margin = "1px";

      let scaleInnerElement = this[_controls]["scale"].innerElement_;
      scaleInnerElement.style.color = "black";
      scaleInnerElement.style.fontWeight = "600";
      scaleInnerElement.style.fontSize = "10px";
      scaleInnerElement.style.textAlign = "center";
      scaleInnerElement.style.borderWidth = "1.5px";
      scaleInnerElement.style.borderStyle = "solid";
      scaleInnerElement.style.borderTop = "none";
      scaleInnerElement.style.borderRightColor = "black";
      scaleInnerElement.style.borderLeftColor = "black";
      scaleInnerElement.style.borderBottomColor = "black";
      scaleInnerElement.style.margin = "1px";
      scaleInnerElement.style.willChange = "contents,width";

      const container = this[_map$2].getTargetElement();

      this[_drawingSource].on(VectorEventType.ADDFEATURE, (e) => {
        publish(
          container,
          EVENTS.ROI_ADDED,
          _getROIFromFeature(e.feature, this[_pyramidMetadata])
        );
      });

      this[_drawingSource].on(VectorEventType.CHANGEFEATURE, (e) => {
        if (e.feature !== undefined || e.feature !== null) {
          const geometry = e.feature.getGeometry();
          const type = geometry.getType();
          // The first and last point of a polygon must be identical. The last point
          // is an implementation detail and is hidden from the user in the graphical
          // interface. However, we must update the last point in case the first
          // point has been modified by the user.
          if (type === "Polygon") {
            // NOTE: Polygon in GeoJSON format contains an array of geometries,
            // where the first element represents the coordinates of the outer ring
            // and the second element represents the coordinates of the inner ring
            // (in our case the inner ring should not be present).
            const layout = geometry.getLayout();
            const coordinates = geometry.getCoordinates();
            const firstPoint = coordinates[0][0];
            const lastPoint = coordinates[0][coordinates[0].length - 1];
            if (
              firstPoint[0] !== lastPoint[0] ||
              firstPoint[1] !== lastPoint[1]
            ) {
              coordinates[0][coordinates[0].length - 1] = firstPoint;
              geometry.setCoordinates(coordinates, layout);
              e.feature.setGeometry(geometry);
            }
          }
        }
        publish(
          container,
          EVENTS.ROI_MODIFIED,
          _getROIFromFeature(e.feature, this[_pyramidMetadata])
        );
      });

      this[_drawingSource].on(VectorEventType.REMOVEFEATURE, (e) => {
        publish(
          container,
          EVENTS.ROI_REMOVED,
          _getROIFromFeature(e.feature, this[_pyramidMetadata])
        );
      });
    }

    /** Activates the draw interaction for graphic annotation of regions of interest.
     * @param {object} options - Drawing options.
     * @param {string} options.geometryType - Name of the geometry type (point, circle, box, polygon, freehandPolygon, line, freehandLine)
     * @param {string} options.marker - Marker
     * @param {string} options.markup - Markup
     * @param {number} options.maxPoints - Geometry max points
     * @param {number} options.minPoints - Geometry min points
     * @param {boolean} options.vertexEnabled - Enable vertex
     * @param {object} options.styleOptions - Style options
     * @param {object} options.styleOptions.stroke - Style options for the outline of the geometry
     * @param {number[]} options.styleOptions.stroke.color - RGBA color of the outline
     * @param {number} options.styleOptions.stroke.width - Width of the outline
     * @param {object} options.styleOptions.fill - Style options for body the geometry
     * @param {number[]} options.styleOptions.fill.color - RGBA color of the body
     * @param {object} options.styleOptions.image - Style options for image
     */
    activateDrawInteraction(options = {}) {
      this.deactivateDrawInteraction();
      console.info('activate "draw" interaction');

      const geometryOptionsMapping = {
        point: {
          type: "Point",
          geometryName: "Point",
        },
        circle: {
          type: "Circle",
          geometryName: "Circle",
        },
        box: {
          type: "Circle",
          geometryName: "Box",
          geometryFunction: createRegularPolygon(4),
        },
        polygon: {
          type: "Polygon",
          geometryName: "Polygon",
          freehand: false,
        },
        freehandpolygon: {
          type: "Polygon",
          geometryName: "FreeHandPolygon",
          freehand: true,
        },
        line: {
          type: "LineString",
          geometryName: "Line",
          freehand: false,
          maxPoints: options.maxPoints,
          minPoints: options.minPoints,
        },
        freehandline: {
          type: "LineString",
          geometryName: "FreeHandLine",
          freehand: true,
        },
      };

      if (!("geometryType" in options)) {
        console.error("geometry type must be specified for drawing interaction");
      }

      if (!(options.geometryType in geometryOptionsMapping)) {
        console.error(`unsupported geometry type "${options.geometryType}"`);
      }

      const internalDrawOptions = { source: this[_drawingSource] };
      const geometryDrawOptions = geometryOptionsMapping[options.geometryType];
      const builtInDrawOptions = {
        marker: options.marker,
        markup: options.markup,
        vertexEnabled: options.vertexEnabled,
      };
      const drawOptions = Object.assign(
        internalDrawOptions,
        geometryDrawOptions,
        builtInDrawOptions
      );

      /**
       * This used to define which mouse buttons will fire the action.
       *
       * bindings: {
       *   mouseButtons can be 'left', 'right' and/or 'middle'. if absent, the action is bound to all mouse buttons.
       *   mouseButtons: ['left', 'right'],
       *   modifierKey can be 'shift', 'ctrl' or 'alt'. If not present, the action is bound to no modifier key.
       *   modifierKey: 'ctrl' // The modifier
       * },
       */
      if (options.bindings) {
        drawOptions.condition = _getInteractionBindingCondition(options.bindings);
      }

      this[_interactions].draw = new Draw(drawOptions);
      const container = this[_map$2].getTargetElement();

      this[_interactions].draw.on("drawstart", ({ feature }) => {
        _setFeatureStyle(feature, options.styleOptions);
        feature.setProperties(builtInDrawOptions, true);
        feature.setId(generateUID());
      });

      // attaching openlayers events handling
      this[_interactions].draw.on("drawend", ({ feature }) => {
        publish(
          container,
          EVENTS.ROI_DRAWN,
          _getROIFromFeature(feature, this[_pyramidMetadata])
        );
      });

      this[_map$2].addInteraction(this[_interactions].draw);

      this[_annotationManager].onInteractionsChange(this[_interactions]);
    }

    /** Deactivates draw interaction. */
    deactivateDrawInteraction() {
      console.info('deactivate "draw" interaction');
      if (this[_interactions].draw !== undefined) {
        this[_map$2].removeInteraction(this[_interactions].draw);
        this[_interactions].draw = undefined;
      }
    }

    /** Whether draw interaction is active
     *
     * @type {boolean}
     */
    get isDrawInteractionActive() {
      return this[_interactions].draw !== undefined;
    }

    /* Activates translate interaction.
     *
     * @param {Object} options - Translation options.
     */
    activateTranslateInteraction(options = {}) {
      this.deactivateTranslateInteraction();

      console.info('activate "translate" interaction');

      const translateOptions = { layers: [this[_drawingLayer]] };

      /**
       * Get conditional mouse bindings
       * See "options.binding" comment in activateDrawInteraction() definition.
       */
      if (options.bindings) {
        translateOptions.condition = _getInteractionBindingCondition(options.bindings);
      }

      this[_interactions].translate = new Translate(translateOptions);

      this[_map$2].addInteraction(this[_interactions].translate);

      this[_annotationManager].onInteractionsChange(this[_interactions]);
    }

    /** Deactivates translate interaction. */
    deactivateTranslateInteraction() {
      console.info('deactivate "translate" interaction');
      if (this[_interactions].translate) {
        this[_map$2].removeInteraction(this[_interactions].translate);
        this[_interactions].translate = undefined;
      }
    }

    /* Activates dragZoom interaction.
     *
     * @param {object} options - DragZoom options.
     */
    activateDragZoomInteraction(options = {}) {
      this.deactivateDragZoomInteraction();

      console.info('activate "dragZoom" interaction');

      const dragZoomOptions = { layers: [this[_drawingLayer]] };

      /**
       * Get conditional mouse bindings
       * See "options.binding" comment in activateDrawInteraction() definition.
       */
      if (options.bindings) {
        dragZoomOptions.condition = _getInteractionBindingCondition(options.bindings);
      }

      this[_interactions].dragZoom = new DragZoom(dragZoomOptions);

      this[_map$2].addInteraction(this[_interactions].dragZoom);

      this[_annotationManager].onInteractionsChange(this[_interactions]);
    }

    /** Deactivates dragZoom interaction. */
    deactivateDragZoomInteraction() {
      console.info('deactivate "dragZoom" interaction');
      if (this[_interactions].dragZoom) {
        this[_map$2].removeInteraction(this[_interactions].dragZoom);
        this[_interactions].dragZoom = undefined;
      }
    }

    /* Activates select interaction.
     *
     * @param {object} options - Selection options.
     */
    activateSelectInteraction(options = {}) {
      this.deactivateSelectInteraction();

      console.info('activate "select" interaction');

      const selectOptions = { layers: [this[_drawingLayer]] };

      /**
       * Get conditional mouse bindings
       * See "options.binding" comment in activateDrawInteraction() definition.
       */
      if (options.bindings) {
        selectOptions.condition = _getInteractionBindingCondition(options.bindings);
      }

      this[_interactions].select = new Select(selectOptions);

      const container = this[_map$2].getTargetElement();

      this[_interactions].select.on("select", (e) => {
        publish(
          container,
          EVENTS.ROI_SELECTED,
          _getROIFromFeature(e.selected[0], this[_pyramidMetadata])
        );
      });

      this[_map$2].addInteraction(this[_interactions].select);

      this[_annotationManager].onInteractionsChange(this[_interactions]);
    }

    /** Deactivates select interaction. */
    deactivateSelectInteraction() {
      console.info('deactivate "select" interaction');
      if (this[_interactions].select) {
        this[_map$2].removeInteraction(this[_interactions].select);
        this[_interactions].select = undefined;
      }
    }

    /** Activates dragpan interaction.
     *
     * @param {Object} options - DragPan options.
     */
    activateDragPanInteraction(options = {}) {
      this.deactivateDragPanInteraction();

      console.info('activate "drag pan" interaction');

      const dragPanOptions = {
        features: this[_features],
      };

      /**
       * Get conditional mouse bindings
       * See "options.binding" comment in activateDrawInteraction() definition.
       */
      if (options.bindings) {
        dragPanOptions.condition = _getInteractionBindingCondition(options.bindings);
      }

      this[_interactions].dragPan = new DragPan(dragPanOptions);

      this[_map$2].addInteraction(this[_interactions].dragPan);

      this[_annotationManager].onInteractionsChange(this[_interactions]);
    }

    /** Deactivate dragpan interaction. */
    deactivateDragPanInteraction() {
      console.info('deactivate "drag pan" interaction');
      if (this[_interactions].dragPan) {
        this[_map$2].removeInteraction(this[_interactions].dragPan);
        this[_interactions].dragPan = undefined;
      }
    }

    /** Activates snap interaction.
     *
     * @param {Object} options - Snap options.
     */
    activateSnapInteraction(options = {}) {
      this.deactivateSnapInteraction();
      console.info('activate "snap" interaction');
      this[_interactions].snap = new Snap({
        source: this[_drawingSource],
      });

      this[_map$2].addInteraction(this[_interactions].snap);

      this[_annotationManager].onInteractionsChange(this[_interactions]);
    }

    /** Deactivates snap interaction. */
    deactivateSnapInteraction() {
      console.info('deactivate "snap" interaction');
      if (this[_interactions].snap) {
        this[_map$2].removeInteraction(this[_interactions].snap);
        this[_interactions].snap = undefined;
      }
    }

    /** Whether select interaction is active.
     *
     * @type {boolean}
     */
    get isSelectInteractionActive() {
      return this[_interactions].select !== undefined;
    }

    /** Activates modify interaction.
     *
     * @param {object} options - Modification options.
     */
    activateModifyInteraction(options = {}) {
      this.deactivateModifyInteraction();

      console.info('activate "modify" interaction');

      const modifyOptions = {
        features: this[_features], // TODO: or source, i.e. 'drawings'???
        insertVertexCondition: ({ feature }) =>
          feature && feature.get("vertexEnabled") === true,
      };

      /**
       * Get conditional mouse bindings
       * See "options.binding" comment in activateDrawInteraction() definition.
       */
      if (options.bindings) {
        modifyOptions.condition = _getInteractionBindingCondition(options.bindings);
      }

      this[_interactions].modify = new Modify(modifyOptions);

      this[_map$2].addInteraction(this[_interactions].modify);

      this[_annotationManager].onInteractionsChange(this[_interactions]);
    }

    /** Deactivates modify interaction. */
    deactivateModifyInteraction() {
      console.info('deactivate "modify" interaction');
      if (this[_interactions].modify) {
        this[_map$2].removeInteraction(this[_interactions].modify);
        this[_interactions].modify = undefined;
      }
    }

    /** Whether modify interaction is active.
     *
     * @type {boolean}
     */
    get isModifyInteractionActive() {
      return this[_interactions].modify !== undefined;
    }

    /** Gets all annotated regions of interest.
     *
     * @returns {ROI[]} Array of regions of interest.
     */
    getAllROIs() {
      console.info("get all ROIs");
      let rois = [];
      this[_features].forEach((item) => {
        rois.push(this.getROI(item.getId()));
      });
      return rois;
    }

    /** Number of annotated regions of interest.
     *
     * @type {number}
     */
    get numberOfROIs() {
      return this[_features].getLength();
    }

    /** Gets an individual annotated regions of interest.
     *
     * @param {string} uid - Unique identifier of the region of interest
     * @returns {ROI} Regions of interest.
     */
    getROI(uid) {
      console.info(`get ROI ${uid}`);
      const feature = this[_drawingSource].getFeatureById(uid);
      return _getROIFromFeature(feature, this[_pyramidMetadata]);
    }

    /** Adds a measurement to a region of interest.
     *
     * @param {string} uid - Unique identifier of the region of interest
     * @param {Object} item - NUM content item representing a measurement
     */
    addROIMeasurement(uid, item) {
      const meaning = item.ConceptNameCodeSequence[0].CodeMeaning;
      console.info(`add measurement "${meaning}" to ROI ${uid}`);
      this[_features].forEach((feature) => {
        const id = feature.getId();
        if (id === uid) {
          const properties = feature.getProperties();
          if (!("measurements" in properties)) {
            properties["measurements"] = [item];
          } else {
            properties["measurements"].push(item);
          }
          feature.setProperties(properties, true);
        }
      });
    }

    /** Adds a qualitative evaluation to a region of interest.
     *
     * @param {string} uid - Unique identifier of the region of interest
     * @param {Object} item - CODE content item representing a qualitative evaluation
     */
    addROIEvaluation(uid, item) {
      const meaning = item.ConceptNameCodeSequence[0].CodeMeaning;
      console.info(`add qualitative evaluation "${meaning}" to ROI ${uid}`);
      this[_features].forEach((feature) => {
        const id = feature.getId();
        if (id === uid) {
          const properties = feature.getProperties();
          if (!("evaluations" in properties)) {
            properties["evaluations"] = [item];
          } else {
            properties["evaluations"].push(item);
          }
          feature.setProperties(properties, true);
        }
      });
    }

    /** Pops the most recently annotated regions of interest.
     *
     * @returns {ROI} Regions of interest.
     */
    popROI() {
      console.info("pop ROI");
      const feature = this[_features].pop();
      return _getROIFromFeature(feature, this[_pyramidMetadata]);
    }

    /** Adds a regions of interest.
     *
     * @param {ROI} item - Regions of interest.
     * @param {object} styleOptions - Style options
     * @param {object} styleOptions.stroke - Style options for the outline of the geometry
     * @param {number[]} styleOptions.stroke.color - RGBA color of the outline
     * @param {number} styleOptions.stroke.width - Width of the outline
     * @param {object} styleOptions.fill - Style options for body the geometry
     * @param {number[]} styleOptions.fill.color - RGBA color of the body
     * @param {object} styleOptions.image - Style options for image
     *
     */
    addROI(item, styleOptions) {
      console.info(`add ROI ${item.uid}`);
      const geometry = _scoord3d2Geometry(item.scoord3d, this[_pyramidMetadata]);
      const featureOptions = { geometry };

      const feature = new Feature(featureOptions);
      feature.setProperties(item.properties, true);
      feature.setId(item.uid);

      _setFeatureStyle(feature, styleOptions);

      this[_features].push(feature);
    }

    /** Update properties of regions of interest.
     *
     * @param {object} roi - ROI to be updated
     * @param {string} roi.uid - Unique identifier of the region of interest
     * @param {object} roi.properties - ROI properties
     */
    updateROI({ uid, properties }) {
      if (!uid) return;
      console.info(`update ROI ${uid}`);

      const feature = this[_drawingSource].getFeatureById(uid);
      feature.setProperties(properties);

      this[_annotationManager].onUpdate(feature);
    }

    /** Sets the style of a region of interest.
     *
     * @param {string} uid - Unique identifier of the regions of interest.
     * @param {object} styleOptions - Style options
     * @param {object} styleOptions.stroke - Style options for the outline of the geometry
     * @param {number[]} styleOptions.stroke.color - RGBA color of the outline
     * @param {number} styleOptions.stroke.width - Width of the outline
     * @param {object} styleOptions.fill - Style options for body the geometry
     * @param {number[]} styleOptions.fill.color - RGBA color of the body
     * @param {object} styleOptions.image - Style options for image
     *
     */
    setROIStyle(uid, styleOptions) {
      this[_features].forEach((feature) => {
        const id = feature.getId();
        if (id === uid) {
          _setFeatureStyle(feature, styleOptions);
        }
      });
    }

    /** Adds a new viewport overlay.
     *
     * @param {object} options Overlay options
     * @param {object} options.element The custom overlay html element
     * @param {object} options.className Class to style the OpenLayer's overlay container
     */
    addViewportOverlay({ element, className }) {
      this[_map$2].addOverlay(new Overlay({ element, className }));
    }

    /** Removes an individual regions of interest.
     *
     * @param {string} uid - Unique identifier of the region of interest
     */
    removeROI(uid) {
      console.info(`remove ROI ${uid}`);
      const feature = this[_drawingSource].getFeatureById(uid);
      this[_features].remove(feature);
    }

    /** Removes all annotated regions of interest. */
    removeAllROIs() {
      console.info("remove all ROIs");
      this[_features].clear();
    }

    /** Hides annotated regions of interest such that they are no longer
     *  visible on the viewport.
     */
    hideROIs() {
      console.info("hide ROIs");
      this[_drawingLayer].setVisible(false);
    }

    /** Shows annotated regions of interest such that they become visible
     *  on the viewport ontop of the images.
     */
    showROIs() {
      console.info("show ROIs");
      this[_drawingLayer].setVisible(true);
    }

    /** Whether annotated regions of interest are currently visible.
     *
     * @type {boolean}
     */
    get areROIsVisible() {
      return this[_drawingLayer].getVisible();
    }

    /** DICOM metadata for each VL Whole Slide Microscopy Image instance.
     *
     * @type {VLWholeSlideMicroscopyImage[]}
     */
    get imageMetadata() {
      return this[_pyramidMetadata];
    }
  }

  /** Static viewer for DICOM VL Whole Slide Microscopy Image instances
   * with Image Type other than VOLUME.
   *
   * @class
   * @private
   */
  class _NonVolumeImageViewer {
    /** Creates a viewer instance for displaying non-VOLUME images.
     *
     * @param {object} options
     * @param {object} options.client - A DICOMwebClient instance for interacting with an origin server over HTTP.
     * @param {object} options.metadata - DICOM JSON metadata object for a VL Whole Slide Microscopy Image instance.
     * @param {string} options.orientation - Orientation of the slide (vertical: label on top, or horizontal: label on right side).
     * @param {number} [options.resizeFactor=1] - To which extent image should be reduced in size (fraction).
     * @param {boolean} [options.includeIccProfile=false] - Whether ICC Profile should be included for correction of image colors.
     */
    constructor(options) {
      this[_client] = options.client;

      this[_metadata] = new VLWholeSlideMicroscopyImage({
        metadata: options.metadata,
      });

      if (this[_metadata].ImageType[2] === "VOLUME") {
        throw new Error("Viewer cannot render images of type VOLUME.");
      }

      const resizeFactor = options.resizeFactor ? options.resizeFactor : 1;
      const height = this[_metadata].TotalPixelMatrixRows * resizeFactor;
      const width = this[_metadata].TotalPixelMatrixColumns * resizeFactor;
      const extent = [
        0, // min X
        -(height + 1), // min Y
        width, // max X
        -1, // max Y
      ];

      const imageLoadFunction = (image, src) => {
        console.info("load image");
        const studyInstanceUID = utils.getStudyInstanceUIDFromUri(
          src
        );
        const seriesInstanceUID = utils.getSeriesInstanceUIDFromUri(
          src
        );
        const sopInstanceUID = utils.getSOPInstanceUIDFromUri(src);
        const mediaType = "image/png";
        const queryParams = {
          viewport: [
            this[_metadata].TotalPixelMatrixRows,
            this[_metadata].TotalPixelMatrixColumns,
          ].join(","),
        };
        // We make this optional because a) not all archives currently support
        // this query parameter and b) because ICC Profiles can be large and
        // their inclusion can result in significant overhead.
        if (options.includeIccProfile) {
          queryParams["iccprofile"] = "yes";
        }
        const retrieveOptions = {
          studyInstanceUID: this[_metadata].StudyInstanceUID,
          seriesInstanceUID: this[_metadata].SeriesInstanceUID,
          sopInstanceUID: this[_metadata].SOPInstanceUID,
          mediaTypes: [{ mediaType }],
          queryParams: queryParams,
        };
        options.client
          .retrieveInstanceRendered(retrieveOptions)
          .then((thumbnail) => {
            const blob = new Blob([thumbnail], { type: mediaType });
            image.getImage().src = window.URL.createObjectURL(blob);
          });
      };

      const projection = new Projection({
        code: "DICOM",
        units: "metric",
        extent: extent,
        getPointResolution: (pixelRes, point) => {
          /** DICOM Pixel Spacing has millimeter unit while the projection has
           * has meter unit.
           */
          const mmSpacing = _getPixelSpacing(this[_metadata])[0];
          const spacing = mmSpacing / resizeFactor / 10 ** 3;
          return pixelRes * spacing;
        },
      });

      const rasterSource = new Static({
        crossOrigin: "Anonymous",
        imageExtent: extent,
        projection: projection,
        imageLoadFunction: imageLoadFunction,
        url: "", // will be set by imageLoadFunction()
      });

      this[_imageLayer] = new ImageLayer({ source: rasterSource });

      // The default rotation is 'horizontal' with the slide label on the right
      var rotation = _getRotation(this[_metadata]);
      if (options.orientation === "vertical") {
        // Rotate counterclockwise by 90 degrees to have slide label at the top
        rotation -= 90 * (Math.PI / 180);
      }

      const view = new View({
        center: getCenter(extent),
        rotation: rotation,
        projection: projection,
      });

      // Creates the map with the defined layers and view and renders it.
      this[_map$2] = new Map$1({
        layers: [this[_imageLayer]],
        view: view,
        controls: [],
        keyboardEventTarget: document,
      });

      this[_map$2].getView().fit(extent);
    }

    /** Renders the image in the specified viewport container.
     * @param {object} options - Rendering options.
     * @param {(string|HTMLElement)} options.container - HTML Element in which the viewer should be injected.
     */
    render(options) {
      if (!("container" in options)) {
        console.error("container must be provided for rendering images");
      }
      this[_map$2].setTarget(options.container);

      this[_map$2].getInteractions().forEach((interaction) => {
        this[_map$2].removeInteraction(interaction);
      });
    }

    /** DICOM metadata for the displayed VL Whole Slide Microscopy Image instance.
     *
     * @type {VLWholeSlideMicroscopyImage}
     */
    get imageMetadata() {
      return this[_metadata];
    }

    /** Resizes the viewer to fit the viewport. */
    resize() {
      this[_map$2].updateSize();
    }

    /** Gets the size of the viewport.
     *
     * @type {number[]}
     */
    get size() {
      return this[_map$2].getSize();
    }
  }

  /** Static viewer for DICOM VL Whole Slide Microscopy Image instances
   * with Image Type OVERVIEW.
   *
   * @class
   * @memberof viewer
   */
  class OverviewImageViewer extends _NonVolumeImageViewer {
    /** Creates a viewer instance for displaying OVERVIEW images.
     *
     * @param {object} options
     * @param {object} options.client - A DICOMwebClient instance for interacting with an origin server over HTTP.
     * @param {object} options.metadata - DICOM JSON metadata object for a VL Whole Slide Microscopy Image instance.
     * @param {string} [options.orientation='horizontal'] - Orientation of the slide (vertical: label on top, or horizontal: label on right side).
     * @param {number} [options.resizeFactor=1] - To which extent image should be reduced in size (fraction).
     * @param {boolean} [options.includeIccProfile=false] - Whether ICC Profile should be included for correction of image colors.
     */
    constructor(options) {
      if (options.orientation === undefined) {
        options.orientation = "horizontal";
      }
      super(options);
    }
  }

  /** Static viewer for DICOM VL Whole Slide Microscopy Image instances
   * with Image Type LABEL.
   *
   * @class
   * @memberof viewer
   */
  class LabelImageViewer extends _NonVolumeImageViewer {
    /** Creates a viewer instance for displaying LABEL images.
     *
     * @param {object} options
     * @param {object} options.client - A DICOMwebClient instance for interacting with an origin server over HTTP.
     * @param {object} options.metadata - DICOM JSON metadata object for a VL Whole Slide Microscopy Image instance.
     * @param {string} [options.orientation='vertical'] - Orientation of the slide (vertical: label on top, or horizontal: label on right side).
     * @param {number} [options.resizeFactor=1] - To which extent image should be reduced in size (fraction).
     * @param {boolean} [options.includeIccProfile=false] - Whether ICC Profile should be included for correction of image colors.
     */
    constructor(options) {
      if (options.orientation === undefined) {
        options.orientation = "vertical";
      }
      super(options);
    }
  }

  /** Namespace for the viewer.
   *
   * @namespace api
   * @deprecated use the viewer namespace instead
   */
  const api$1 = {
    VLWholeSlideMicroscopyImageViewer: VolumeImageViewer
  };

  /** Namespace for the viewer.
   *
   * @namespace viewer
   */
  const viewer = {
    LabelImageViewer,
    OverviewImageViewer,
    VolumeImageViewer,
  };

  /** Namespace for working with DICOM Metadata.
   *
   * @namespace metadata
   */
  const metadata = {
    formatMetadata,
    VLWholeSlideMicroscopyImage,
    Comprehensive3DSR,
  };

  /** Namespace for 3-dimensional spatial coordinates (SCOORD3D).
   *
   * @namespace scoord3d
   */
  const scoord3d = {
    Point,
    Multipoint,
    Polyline,
    Polygon,
    Ellipsoid,
    Ellipse,
  };

  /** Namespace for regions of interest (ROI).
   *
   * @namespace roi
   */
  const roi = {
    ROI,
  };

  /** Namespace for viewer events.
   *
   * @namespace events
   */
  const events$1 = {
    EVENTS,
  };

  /** Namespace for various utilities.
   *
   * @namespace utils
   */
  const utils$1 = {
    applyInverseTransform,
    applyTransform,
    buildInverseTransform,
    buildTransform,
    computeRotation,
    mapSlideCoordToPixelCoord,
    mapPixelCoordToSlideCoord,
  };

  exports.api = api$1;
  exports.events = events$1;
  exports.metadata = metadata;
  exports.roi = roi;
  exports.scoord3d = scoord3d;
  exports.utils = utils$1;
  exports.viewer = viewer;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
